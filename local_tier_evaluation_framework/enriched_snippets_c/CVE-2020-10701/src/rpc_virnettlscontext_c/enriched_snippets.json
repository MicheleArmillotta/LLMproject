[
  {
    "function_name": "virNetTLSInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "1441-1454",
    "snippet": "void virNetTLSInit(void)\n{\n    const char *gnutlsdebug;\n    if ((gnutlsdebug = getenv(\"LIBVIRT_GNUTLS_DEBUG\")) != NULL) {\n        int val;\n        if (virStrToLong_i(gnutlsdebug, NULL, 10, &val) < 0)\n            val = 10;\n        gnutls_global_set_log_level(val);\n        gnutls_global_set_log_function(virNetTLSLog);\n        VIR_DEBUG(\"Enabled GNUTLS debug\");\n    }\n\n    gnutls_global_init();\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gnutls_global_init",
          "args": [],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Enabled GNUTLS debug\""
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_global_set_log_function",
          "args": [
            "virNetTLSLog"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_global_set_log_level",
          "args": [
            "val"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "gnutlsdebug",
            "NULL",
            "10",
            "&val"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"LIBVIRT_GNUTLS_DEBUG\""
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetTLSInit(void)\n{\n    const char *gnutlsdebug;\n    if ((gnutlsdebug = getenv(\"LIBVIRT_GNUTLS_DEBUG\")) != NULL) {\n        int val;\n        if (virStrToLong_i(gnutlsdebug, NULL, 10, &val) < 0)\n            val = 10;\n        gnutls_global_set_log_level(val);\n        gnutls_global_set_log_function(virNetTLSLog);\n        VIR_DEBUG(\"Enabled GNUTLS debug\");\n    }\n\n    gnutls_global_init();\n}"
  },
  {
    "function_name": "virNetTLSSessionDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "1416-1426",
    "snippet": "void virNetTLSSessionDispose(void *obj)\n{\n    virNetTLSSessionPtr sess = obj;\n\n    PROBE(RPC_TLS_SESSION_DISPOSE,\n          \"sess=%p\", sess);\n\n    VIR_FREE(sess->x509dname);\n    VIR_FREE(sess->hostname);\n    gnutls_deinit(sess->session);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetTLSContextDispose(void *obj);",
      "static void virNetTLSSessionDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gnutls_deinit",
          "args": [
            "sess->session"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sess->hostname"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sess->x509dname"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_TLS_SESSION_DISPOSE",
            "\"sess=%p\"",
            "sess"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetTLSContextDispose(void *obj);\nstatic void virNetTLSSessionDispose(void *obj);\n\nvoid virNetTLSSessionDispose(void *obj)\n{\n    virNetTLSSessionPtr sess = obj;\n\n    PROBE(RPC_TLS_SESSION_DISPOSE,\n          \"sess=%p\", sess);\n\n    VIR_FREE(sess->x509dname);\n    VIR_FREE(sess->hostname);\n    gnutls_deinit(sess->session);\n}"
  },
  {
    "function_name": "virNetTLSSessionGetX509DName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "1403-1414",
    "snippet": "const char *virNetTLSSessionGetX509DName(virNetTLSSessionPtr sess)\n{\n    const char *ret = NULL;\n\n    virObjectLock(sess);\n\n    ret = sess->x509dname;\n\n    virObjectUnlock(sess);\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nconst char *virNetTLSSessionGetX509DName(virNetTLSSessionPtr sess)\n{\n    const char *ret = NULL;\n\n    virObjectLock(sess);\n\n    ret = sess->x509dname;\n\n    virObjectUnlock(sess);\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetTLSSessionGetKeySize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "1385-1401",
    "snippet": "int virNetTLSSessionGetKeySize(virNetTLSSessionPtr sess)\n{\n    gnutls_cipher_algorithm_t cipher;\n    int ssf;\n    virObjectLock(sess);\n    cipher = gnutls_cipher_get(sess->session);\n    if (!(ssf = gnutls_cipher_get_key_size(cipher))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid cipher size for TLS session\"));\n        ssf = -1;\n        goto cleanup;\n    }\n\n cleanup:\n    virObjectUnlock(sess);\n    return ssf;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"invalid cipher size for TLS session\")"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid cipher size for TLS session\""
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_cipher_get_key_size",
          "args": [
            "cipher"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_cipher_get",
          "args": [
            "sess->session"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetTLSSessionGetKeySize(virNetTLSSessionPtr sess)\n{\n    gnutls_cipher_algorithm_t cipher;\n    int ssf;\n    virObjectLock(sess);\n    cipher = gnutls_cipher_get(sess->session);\n    if (!(ssf = gnutls_cipher_get_key_size(cipher))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid cipher size for TLS session\"));\n        ssf = -1;\n        goto cleanup;\n    }\n\n cleanup:\n    virObjectUnlock(sess);\n    return ssf;\n}"
  },
  {
    "function_name": "virNetTLSSessionGetHandshakeStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "1370-1383",
    "snippet": "virNetTLSSessionHandshakeStatus\nvirNetTLSSessionGetHandshakeStatus(virNetTLSSessionPtr sess)\n{\n    virNetTLSSessionHandshakeStatus ret;\n    virObjectLock(sess);\n    if (sess->handshakeComplete)\n        ret = VIR_NET_TLS_HANDSHAKE_COMPLETE;\n    else if (gnutls_record_get_direction(sess->session) == 0)\n        ret = VIR_NET_TLS_HANDSHAKE_RECVING;\n    else\n        ret = VIR_NET_TLS_HANDSHAKE_SENDING;\n    virObjectUnlock(sess);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_record_get_direction",
          "args": [
            "sess->session"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetTLSSessionHandshakeStatus\nvirNetTLSSessionGetHandshakeStatus(virNetTLSSessionPtr sess)\n{\n    virNetTLSSessionHandshakeStatus ret;\n    virObjectLock(sess);\n    if (sess->handshakeComplete)\n        ret = VIR_NET_TLS_HANDSHAKE_COMPLETE;\n    else if (gnutls_record_get_direction(sess->session) == 0)\n        ret = VIR_NET_TLS_HANDSHAKE_RECVING;\n    else\n        ret = VIR_NET_TLS_HANDSHAKE_SENDING;\n    virObjectUnlock(sess);\n    return ret;\n}"
  },
  {
    "function_name": "virNetTLSSessionHandshake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "1338-1368",
    "snippet": "int virNetTLSSessionHandshake(virNetTLSSessionPtr sess)\n{\n    int ret;\n    VIR_DEBUG(\"sess=%p\", sess);\n    virObjectLock(sess);\n    ret = gnutls_handshake(sess->session);\n    VIR_DEBUG(\"Ret=%d\", ret);\n    if (ret == 0) {\n        sess->handshakeComplete = true;\n        VIR_DEBUG(\"Handshake is complete\");\n        goto cleanup;\n    }\n    if (ret == GNUTLS_E_INTERRUPTED || ret == GNUTLS_E_AGAIN) {\n        ret = 1;\n        goto cleanup;\n    }\n\n#if 0\n    PROBE(CLIENT_TLS_FAIL, \"fd=%d\",\n          virNetServerClientGetFD(client));\n#endif\n\n    virReportError(VIR_ERR_AUTH_FAILED,\n                   _(\"TLS handshake failed %s\"),\n                   gnutls_strerror(ret));\n    ret = -1;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_AUTH_FAILED",
            "_(\"TLS handshake failed %s\")",
            "gnutls_strerror(ret)"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "ret"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"TLS handshake failed %s\""
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "CLIENT_TLS_FAIL",
            "\"fd=%d\"",
            "virNetServerClientGetFD(client)"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetFD",
          "args": [
            "client"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "719-727",
          "snippet": "int virNetServerClientGetFD(virNetServerClientPtr client)\n{\n    int fd = -1;\n    virObjectLock(client);\n    if (client->sock)\n        fd = virNetSocketGetFD(client->sock);\n    virObjectUnlock(client);\n    return fd;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nint virNetServerClientGetFD(virNetServerClientPtr client)\n{\n    int fd = -1;\n    virObjectLock(client);\n    if (client->sock)\n        fd = virNetSocketGetFD(client->sock);\n    virObjectUnlock(client);\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Handshake is complete\""
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Ret=%d\"",
            "ret"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_handshake",
          "args": [
            "sess->session"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"sess=%p\"",
            "sess"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetTLSSessionHandshake(virNetTLSSessionPtr sess)\n{\n    int ret;\n    VIR_DEBUG(\"sess=%p\", sess);\n    virObjectLock(sess);\n    ret = gnutls_handshake(sess->session);\n    VIR_DEBUG(\"Ret=%d\", ret);\n    if (ret == 0) {\n        sess->handshakeComplete = true;\n        VIR_DEBUG(\"Handshake is complete\");\n        goto cleanup;\n    }\n    if (ret == GNUTLS_E_INTERRUPTED || ret == GNUTLS_E_AGAIN) {\n        ret = 1;\n        goto cleanup;\n    }\n\n#if 0\n    PROBE(CLIENT_TLS_FAIL, \"fd=%d\",\n          virNetServerClientGetFD(client));\n#endif\n\n    virReportError(VIR_ERR_AUTH_FAILED,\n                   _(\"TLS handshake failed %s\"),\n                   gnutls_strerror(ret));\n    ret = -1;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}"
  },
  {
    "function_name": "virNetTLSSessionRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "1308-1336",
    "snippet": "ssize_t virNetTLSSessionRead(virNetTLSSessionPtr sess,\n                             char *buf, size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n    ret = gnutls_record_recv(sess->session, buf, len);\n\n    if (ret >= 0)\n        goto cleanup;\n\n    switch (ret) {\n    case GNUTLS_E_AGAIN:\n        errno = EAGAIN;\n        break;\n    case GNUTLS_E_INTERRUPTED:\n        errno = EINTR;\n        break;\n    default:\n        errno = EIO;\n        break;\n    }\n\n    ret = -1;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_record_recv",
          "args": [
            "sess->session",
            "buf",
            "len"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nssize_t virNetTLSSessionRead(virNetTLSSessionPtr sess,\n                             char *buf, size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n    ret = gnutls_record_recv(sess->session, buf, len);\n\n    if (ret >= 0)\n        goto cleanup;\n\n    switch (ret) {\n    case GNUTLS_E_AGAIN:\n        errno = EAGAIN;\n        break;\n    case GNUTLS_E_INTERRUPTED:\n        errno = EINTR;\n        break;\n    default:\n        errno = EIO;\n        break;\n    }\n\n    ret = -1;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}"
  },
  {
    "function_name": "virNetTLSSessionWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "1275-1306",
    "snippet": "ssize_t virNetTLSSessionWrite(virNetTLSSessionPtr sess,\n                              const char *buf, size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n    ret = gnutls_record_send(sess->session, buf, len);\n\n    if (ret >= 0)\n        goto cleanup;\n\n    switch (ret) {\n    case GNUTLS_E_AGAIN:\n        errno = EAGAIN;\n        break;\n    case GNUTLS_E_INTERRUPTED:\n        errno = EINTR;\n        break;\n    case GNUTLS_E_UNEXPECTED_PACKET_LENGTH:\n        errno = ENOMSG;\n        break;\n    default:\n        errno = EIO;\n        break;\n    }\n\n    ret = -1;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_record_send",
          "args": [
            "sess->session",
            "buf",
            "len"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nssize_t virNetTLSSessionWrite(virNetTLSSessionPtr sess,\n                              const char *buf, size_t len)\n{\n    ssize_t ret;\n\n    virObjectLock(sess);\n    ret = gnutls_record_send(sess->session, buf, len);\n\n    if (ret >= 0)\n        goto cleanup;\n\n    switch (ret) {\n    case GNUTLS_E_AGAIN:\n        errno = EAGAIN;\n        break;\n    case GNUTLS_E_INTERRUPTED:\n        errno = EINTR;\n        break;\n    case GNUTLS_E_UNEXPECTED_PACKET_LENGTH:\n        errno = ENOMSG;\n        break;\n    default:\n        errno = EIO;\n        break;\n    }\n\n    ret = -1;\n\n cleanup:\n    virObjectUnlock(sess);\n    return ret;\n}"
  },
  {
    "function_name": "virNetTLSSessionSetIOCallbacks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "1262-1272",
    "snippet": "void virNetTLSSessionSetIOCallbacks(virNetTLSSessionPtr sess,\n                                    virNetTLSSessionWriteFunc writeFunc,\n                                    virNetTLSSessionReadFunc readFunc,\n                                    void *opaque)\n{\n    virObjectLock(sess);\n    sess->writeFunc = writeFunc;\n    sess->readFunc = readFunc;\n    sess->opaque = opaque;\n    virObjectUnlock(sess);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetTLSSessionSetIOCallbacks(virNetTLSSessionPtr sess,\n                                    virNetTLSSessionWriteFunc writeFunc,\n                                    virNetTLSSessionReadFunc readFunc,\n                                    void *opaque)\n{\n    virObjectLock(sess);\n    sess->writeFunc = writeFunc;\n    sess->readFunc = readFunc;\n    sess->opaque = opaque;\n    virObjectUnlock(sess);\n}"
  },
  {
    "function_name": "virNetTLSSessionNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "1188-1259",
    "snippet": "virNetTLSSessionPtr virNetTLSSessionNew(virNetTLSContextPtr ctxt,\n                                        const char *hostname)\n{\n    virNetTLSSessionPtr sess;\n    int err;\n    const char *priority;\n\n    VIR_DEBUG(\"ctxt=%p hostname=%s isServer=%d\",\n              ctxt, NULLSTR(hostname), ctxt->isServer);\n\n    if (!(sess = virObjectLockableNew(virNetTLSSessionClass)))\n        return NULL;\n\n    sess->hostname = g_strdup(hostname);\n\n    if ((err = gnutls_init(&sess->session,\n                           ctxt->isServer ? GNUTLS_SERVER : GNUTLS_CLIENT)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Failed to initialize TLS session: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    /* avoid calling all the priority functions, since the defaults\n     * are adequate.\n     */\n    priority = ctxt->priority ? ctxt->priority : TLS_PRIORITY;\n    VIR_DEBUG(\"Setting priority string '%s'\", priority);\n    if ((err = gnutls_priority_set_direct(sess->session,\n                                          priority,\n                                          NULL)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Failed to set TLS session priority to %s: %s\"),\n                       priority, gnutls_strerror(err));\n        goto error;\n    }\n\n    if ((err = gnutls_credentials_set(sess->session,\n                                      GNUTLS_CRD_CERTIFICATE,\n                                      ctxt->x509cred)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Failed set TLS x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    /* request client certificate if any.\n     */\n    if (ctxt->isServer) {\n        gnutls_certificate_server_set_request(sess->session, GNUTLS_CERT_REQUEST);\n\n        gnutls_dh_set_prime_bits(sess->session, DH_BITS);\n    }\n\n    gnutls_transport_set_ptr(sess->session, sess);\n    gnutls_transport_set_push_function(sess->session,\n                                       virNetTLSSessionPush);\n    gnutls_transport_set_pull_function(sess->session,\n                                       virNetTLSSessionPull);\n\n    sess->isServer = ctxt->isServer;\n\n    PROBE(RPC_TLS_SESSION_NEW,\n          \"sess=%p ctxt=%p hostname=%s isServer=%d\",\n          sess, ctxt, hostname, sess->isServer);\n\n    return sess;\n\n error:\n    virObjectUnref(sess);\n    return NULL;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define DH_BITS 2048"
    ],
    "globals_used": [
      "static virClassPtr virNetTLSSessionClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sess"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_TLS_SESSION_NEW",
            "\"sess=%p ctxt=%p hostname=%s isServer=%d\"",
            "sess",
            "ctxt",
            "hostname",
            "sess->isServer"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_transport_set_pull_function",
          "args": [
            "sess->session",
            "virNetTLSSessionPull"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_transport_set_push_function",
          "args": [
            "sess->session",
            "virNetTLSSessionPush"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_transport_set_ptr",
          "args": [
            "sess->session",
            "sess"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_dh_set_prime_bits",
          "args": [
            "sess->session",
            "DH_BITS"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_server_set_request",
          "args": [
            "sess->session",
            "GNUTLS_CERT_REQUEST"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Failed set TLS x509 credentials: %s\")",
            "gnutls_strerror(err)"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "err"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed set TLS x509 credentials: %s\""
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_credentials_set",
          "args": [
            "sess->session",
            "GNUTLS_CRD_CERTIFICATE",
            "ctxt->x509cred"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Failed to set TLS session priority to %s: %s\")",
            "priority",
            "gnutls_strerror(err)"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "err"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_priority_set_direct",
          "args": [
            "sess->session",
            "priority",
            "NULL"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting priority string '%s'\"",
            "priority"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Failed to initialize TLS session: %s\")",
            "gnutls_strerror(err)"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "err"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_init",
          "args": [
            "&sess->session",
            "ctxt->isServer ? GNUTLS_SERVER : GNUTLS_CLIENT"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "virNetTLSSessionClass"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"ctxt=%p hostname=%s isServer=%d\"",
            "ctxt",
            "NULLSTR(hostname)",
            "ctxt->isServer"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "hostname"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\n#define DH_BITS 2048\n\nstatic virClassPtr virNetTLSSessionClass;\n\nvirNetTLSSessionPtr virNetTLSSessionNew(virNetTLSContextPtr ctxt,\n                                        const char *hostname)\n{\n    virNetTLSSessionPtr sess;\n    int err;\n    const char *priority;\n\n    VIR_DEBUG(\"ctxt=%p hostname=%s isServer=%d\",\n              ctxt, NULLSTR(hostname), ctxt->isServer);\n\n    if (!(sess = virObjectLockableNew(virNetTLSSessionClass)))\n        return NULL;\n\n    sess->hostname = g_strdup(hostname);\n\n    if ((err = gnutls_init(&sess->session,\n                           ctxt->isServer ? GNUTLS_SERVER : GNUTLS_CLIENT)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Failed to initialize TLS session: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    /* avoid calling all the priority functions, since the defaults\n     * are adequate.\n     */\n    priority = ctxt->priority ? ctxt->priority : TLS_PRIORITY;\n    VIR_DEBUG(\"Setting priority string '%s'\", priority);\n    if ((err = gnutls_priority_set_direct(sess->session,\n                                          priority,\n                                          NULL)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Failed to set TLS session priority to %s: %s\"),\n                       priority, gnutls_strerror(err));\n        goto error;\n    }\n\n    if ((err = gnutls_credentials_set(sess->session,\n                                      GNUTLS_CRD_CERTIFICATE,\n                                      ctxt->x509cred)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Failed set TLS x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    /* request client certificate if any.\n     */\n    if (ctxt->isServer) {\n        gnutls_certificate_server_set_request(sess->session, GNUTLS_CERT_REQUEST);\n\n        gnutls_dh_set_prime_bits(sess->session, DH_BITS);\n    }\n\n    gnutls_transport_set_ptr(sess->session, sess);\n    gnutls_transport_set_push_function(sess->session,\n                                       virNetTLSSessionPush);\n    gnutls_transport_set_pull_function(sess->session,\n                                       virNetTLSSessionPull);\n\n    sess->isServer = ctxt->isServer;\n\n    PROBE(RPC_TLS_SESSION_NEW,\n          \"sess=%p ctxt=%p hostname=%s isServer=%d\",\n          sess, ctxt, hostname, sess->isServer);\n\n    return sess;\n\n error:\n    virObjectUnref(sess);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetTLSSessionPull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "1174-1185",
    "snippet": "static ssize_t\nvirNetTLSSessionPull(void *opaque, void *buf, size_t len)\n{\n    virNetTLSSessionPtr sess = opaque;\n    if (!sess->readFunc) {\n        VIR_WARN(\"TLS session pull with missing read function\");\n        errno = EIO;\n        return -1;\n    };\n\n    return sess->readFunc(buf, len, sess->opaque);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sess->readFunc",
          "args": [
            "buf",
            "len",
            "sess->opaque"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"TLS session pull with missing read function\""
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic ssize_t\nvirNetTLSSessionPull(void *opaque, void *buf, size_t len)\n{\n    virNetTLSSessionPtr sess = opaque;\n    if (!sess->readFunc) {\n        VIR_WARN(\"TLS session pull with missing read function\");\n        errno = EIO;\n        return -1;\n    };\n\n    return sess->readFunc(buf, len, sess->opaque);\n}"
  },
  {
    "function_name": "virNetTLSSessionPush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "1160-1171",
    "snippet": "static ssize_t\nvirNetTLSSessionPush(void *opaque, const void *buf, size_t len)\n{\n    virNetTLSSessionPtr sess = opaque;\n    if (!sess->writeFunc) {\n        VIR_WARN(\"TLS session push with missing write function\");\n        errno = EIO;\n        return -1;\n    };\n\n    return sess->writeFunc(buf, len, sess->opaque);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sess->writeFunc",
          "args": [
            "buf",
            "len",
            "sess->opaque"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"TLS session push with missing write function\""
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic ssize_t\nvirNetTLSSessionPush(void *opaque, const void *buf, size_t len)\n{\n    virNetTLSSessionPtr sess = opaque;\n    if (!sess->writeFunc) {\n        VIR_WARN(\"TLS session push with missing write function\");\n        errno = EIO;\n        return -1;\n    };\n\n    return sess->writeFunc(buf, len, sess->opaque);\n}"
  },
  {
    "function_name": "virNetTLSContextDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "1147-1157",
    "snippet": "void virNetTLSContextDispose(void *obj)\n{\n    virNetTLSContextPtr ctxt = obj;\n\n    PROBE(RPC_TLS_CONTEXT_DISPOSE,\n          \"ctxt=%p\", ctxt);\n\n    VIR_FREE(ctxt->priority);\n    gnutls_dh_params_deinit(ctxt->dhParams);\n    gnutls_certificate_free_credentials(ctxt->x509cred);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetTLSContextDispose(void *obj);",
      "static void virNetTLSSessionDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gnutls_certificate_free_credentials",
          "args": [
            "ctxt->x509cred"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_dh_params_deinit",
          "args": [
            "ctxt->dhParams"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ctxt->priority"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_TLS_CONTEXT_DISPOSE",
            "\"ctxt=%p\"",
            "ctxt"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetTLSContextDispose(void *obj);\nstatic void virNetTLSSessionDispose(void *obj);\n\nvoid virNetTLSContextDispose(void *obj)\n{\n    virNetTLSContextPtr ctxt = obj;\n\n    PROBE(RPC_TLS_CONTEXT_DISPOSE,\n          \"ctxt=%p\", ctxt);\n\n    VIR_FREE(ctxt->priority);\n    gnutls_dh_params_deinit(ctxt->dhParams);\n    gnutls_certificate_free_credentials(ctxt->x509cred);\n}"
  },
  {
    "function_name": "virNetTLSContextCheckCertificate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "1120-1145",
    "snippet": "int virNetTLSContextCheckCertificate(virNetTLSContextPtr ctxt,\n                                     virNetTLSSessionPtr sess)\n{\n    int ret = -1;\n\n    virObjectLock(ctxt);\n    virObjectLock(sess);\n    if (virNetTLSContextValidCertificate(ctxt, sess) < 0) {\n        VIR_WARN(\"Certificate check failed %s\", virGetLastErrorMessage());\n        if (ctxt->requireValidCert) {\n            virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                           _(\"Failed to verify peer's certificate\"));\n            goto cleanup;\n        }\n        virResetLastError();\n        VIR_INFO(\"Ignoring bad certificate at user request\");\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(ctxt);\n    virObjectUnlock(sess);\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "sess"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Ignoring bad certificate at user request\""
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_AUTH_FAILED",
            "\"%s\"",
            "_(\"Failed to verify peer's certificate\")"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to verify peer's certificate\""
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Certificate check failed %s\"",
            "virGetLastErrorMessage()"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSContextValidCertificate",
          "args": [
            "ctxt",
            "sess"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextValidCertificate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "981-1118",
          "snippet": "static int virNetTLSContextValidCertificate(virNetTLSContextPtr ctxt,\n                                            virNetTLSSessionPtr sess)\n{\n    int ret;\n    unsigned int status;\n    const gnutls_datum_t *certs;\n    unsigned int nCerts;\n    size_t i;\n    char dname[256];\n    char *dnameptr = dname;\n    size_t dnamesize = sizeof(dname);\n\n    memset(dname, 0, dnamesize);\n\n    if ((ret = gnutls_certificate_verify_peers2(sess->session, &status)) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to verify TLS peer: %s\"),\n                       gnutls_strerror(ret));\n        goto authdeny;\n    }\n\n    if (status != 0) {\n        const char *reason = _(\"Invalid certificate\");\n\n        if (status & GNUTLS_CERT_INVALID)\n            reason = _(\"The certificate is not trusted.\");\n\n        if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n            reason = _(\"The certificate hasn't got a known issuer.\");\n\n        if (status & GNUTLS_CERT_REVOKED)\n            reason = _(\"The certificate has been revoked.\");\n\n        if (status & GNUTLS_CERT_INSECURE_ALGORITHM)\n            reason = _(\"The certificate uses an insecure algorithm\");\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Certificate failed validation: %s\"),\n                       reason);\n        goto authdeny;\n    }\n\n    if (gnutls_certificate_type_get(sess->session) != GNUTLS_CRT_X509) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Only x509 certificates are supported\"));\n        goto authdeny;\n    }\n\n    if (!(certs = gnutls_certificate_get_peers(sess->session, &nCerts))) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"The certificate has no peers\"));\n        goto authdeny;\n    }\n\n    for (i = 0; i < nCerts; i++) {\n        gnutls_x509_crt_t cert;\n\n        if (gnutls_x509_crt_init(&cert) < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                           _(\"Unable to initialize certificate\"));\n            goto authfail;\n        }\n\n        if (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                           _(\"Unable to load certificate\"));\n            gnutls_x509_crt_deinit(cert);\n            goto authfail;\n        }\n\n        if (virNetTLSContextCheckCertTimes(cert, \"[session]\",\n                                           sess->isServer, i > 0) < 0) {\n            gnutls_x509_crt_deinit(cert);\n            goto authdeny;\n        }\n\n        if (i == 0) {\n            ret = gnutls_x509_crt_get_dn(cert, dname, &dnamesize);\n            if (ret != 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Failed to get certificate %s distinguished name: %s\"),\n                               \"[session]\", gnutls_strerror(ret));\n                goto authfail;\n            }\n            sess->x509dname = g_strdup(dname);\n            VIR_DEBUG(\"Peer DN is %s\", dname);\n\n            if (virNetTLSContextCheckCertDN(cert, \"[session]\", sess->hostname, dname,\n                                            ctxt->x509dnWhitelist) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n\n            /* !sess->isServer, since on the client, we're validating the\n             * server's cert, and on the server, the client's cert\n             */\n            if (virNetTLSContextCheckCertBasicConstraints(cert, \"[session]\",\n                                                          !sess->isServer, false) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n\n            if (virNetTLSContextCheckCertKeyUsage(cert, \"[session]\",\n                                                  false) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n\n            /* !sess->isServer - as above */\n            if (virNetTLSContextCheckCertKeyPurpose(cert, \"[session]\",\n                                                    !sess->isServer) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n        }\n        gnutls_x509_crt_deinit(cert);\n    }\n\n    PROBE(RPC_TLS_CONTEXT_SESSION_ALLOW,\n          \"ctxt=%p sess=%p dname=%s\",\n          ctxt, sess, dnameptr);\n\n    return 0;\n\n authdeny:\n    PROBE(RPC_TLS_CONTEXT_SESSION_DENY,\n          \"ctxt=%p sess=%p dname=%s\",\n          ctxt, sess, dnameptr);\n\n    return -1;\n\n authfail:\n    PROBE(RPC_TLS_CONTEXT_SESSION_FAIL,\n          \"ctxt=%p sess=%p\",\n          ctxt, sess);\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextValidCertificate(virNetTLSContextPtr ctxt,\n                                            virNetTLSSessionPtr sess)\n{\n    int ret;\n    unsigned int status;\n    const gnutls_datum_t *certs;\n    unsigned int nCerts;\n    size_t i;\n    char dname[256];\n    char *dnameptr = dname;\n    size_t dnamesize = sizeof(dname);\n\n    memset(dname, 0, dnamesize);\n\n    if ((ret = gnutls_certificate_verify_peers2(sess->session, &status)) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to verify TLS peer: %s\"),\n                       gnutls_strerror(ret));\n        goto authdeny;\n    }\n\n    if (status != 0) {\n        const char *reason = _(\"Invalid certificate\");\n\n        if (status & GNUTLS_CERT_INVALID)\n            reason = _(\"The certificate is not trusted.\");\n\n        if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n            reason = _(\"The certificate hasn't got a known issuer.\");\n\n        if (status & GNUTLS_CERT_REVOKED)\n            reason = _(\"The certificate has been revoked.\");\n\n        if (status & GNUTLS_CERT_INSECURE_ALGORITHM)\n            reason = _(\"The certificate uses an insecure algorithm\");\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Certificate failed validation: %s\"),\n                       reason);\n        goto authdeny;\n    }\n\n    if (gnutls_certificate_type_get(sess->session) != GNUTLS_CRT_X509) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Only x509 certificates are supported\"));\n        goto authdeny;\n    }\n\n    if (!(certs = gnutls_certificate_get_peers(sess->session, &nCerts))) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"The certificate has no peers\"));\n        goto authdeny;\n    }\n\n    for (i = 0; i < nCerts; i++) {\n        gnutls_x509_crt_t cert;\n\n        if (gnutls_x509_crt_init(&cert) < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                           _(\"Unable to initialize certificate\"));\n            goto authfail;\n        }\n\n        if (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                           _(\"Unable to load certificate\"));\n            gnutls_x509_crt_deinit(cert);\n            goto authfail;\n        }\n\n        if (virNetTLSContextCheckCertTimes(cert, \"[session]\",\n                                           sess->isServer, i > 0) < 0) {\n            gnutls_x509_crt_deinit(cert);\n            goto authdeny;\n        }\n\n        if (i == 0) {\n            ret = gnutls_x509_crt_get_dn(cert, dname, &dnamesize);\n            if (ret != 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Failed to get certificate %s distinguished name: %s\"),\n                               \"[session]\", gnutls_strerror(ret));\n                goto authfail;\n            }\n            sess->x509dname = g_strdup(dname);\n            VIR_DEBUG(\"Peer DN is %s\", dname);\n\n            if (virNetTLSContextCheckCertDN(cert, \"[session]\", sess->hostname, dname,\n                                            ctxt->x509dnWhitelist) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n\n            /* !sess->isServer, since on the client, we're validating the\n             * server's cert, and on the server, the client's cert\n             */\n            if (virNetTLSContextCheckCertBasicConstraints(cert, \"[session]\",\n                                                          !sess->isServer, false) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n\n            if (virNetTLSContextCheckCertKeyUsage(cert, \"[session]\",\n                                                  false) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n\n            /* !sess->isServer - as above */\n            if (virNetTLSContextCheckCertKeyPurpose(cert, \"[session]\",\n                                                    !sess->isServer) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n        }\n        gnutls_x509_crt_deinit(cert);\n    }\n\n    PROBE(RPC_TLS_CONTEXT_SESSION_ALLOW,\n          \"ctxt=%p sess=%p dname=%s\",\n          ctxt, sess, dnameptr);\n\n    return 0;\n\n authdeny:\n    PROBE(RPC_TLS_CONTEXT_SESSION_DENY,\n          \"ctxt=%p sess=%p dname=%s\",\n          ctxt, sess, dnameptr);\n\n    return -1;\n\n authfail:\n    PROBE(RPC_TLS_CONTEXT_SESSION_FAIL,\n          \"ctxt=%p sess=%p\",\n          ctxt, sess);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "sess"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetTLSContextCheckCertificate(virNetTLSContextPtr ctxt,\n                                     virNetTLSSessionPtr sess)\n{\n    int ret = -1;\n\n    virObjectLock(ctxt);\n    virObjectLock(sess);\n    if (virNetTLSContextValidCertificate(ctxt, sess) < 0) {\n        VIR_WARN(\"Certificate check failed %s\", virGetLastErrorMessage());\n        if (ctxt->requireValidCert) {\n            virReportError(VIR_ERR_AUTH_FAILED, \"%s\",\n                           _(\"Failed to verify peer's certificate\"));\n            goto cleanup;\n        }\n        virResetLastError();\n        VIR_INFO(\"Ignoring bad certificate at user request\");\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(ctxt);\n    virObjectUnlock(sess);\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetTLSContextValidCertificate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "981-1118",
    "snippet": "static int virNetTLSContextValidCertificate(virNetTLSContextPtr ctxt,\n                                            virNetTLSSessionPtr sess)\n{\n    int ret;\n    unsigned int status;\n    const gnutls_datum_t *certs;\n    unsigned int nCerts;\n    size_t i;\n    char dname[256];\n    char *dnameptr = dname;\n    size_t dnamesize = sizeof(dname);\n\n    memset(dname, 0, dnamesize);\n\n    if ((ret = gnutls_certificate_verify_peers2(sess->session, &status)) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to verify TLS peer: %s\"),\n                       gnutls_strerror(ret));\n        goto authdeny;\n    }\n\n    if (status != 0) {\n        const char *reason = _(\"Invalid certificate\");\n\n        if (status & GNUTLS_CERT_INVALID)\n            reason = _(\"The certificate is not trusted.\");\n\n        if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n            reason = _(\"The certificate hasn't got a known issuer.\");\n\n        if (status & GNUTLS_CERT_REVOKED)\n            reason = _(\"The certificate has been revoked.\");\n\n        if (status & GNUTLS_CERT_INSECURE_ALGORITHM)\n            reason = _(\"The certificate uses an insecure algorithm\");\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Certificate failed validation: %s\"),\n                       reason);\n        goto authdeny;\n    }\n\n    if (gnutls_certificate_type_get(sess->session) != GNUTLS_CRT_X509) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Only x509 certificates are supported\"));\n        goto authdeny;\n    }\n\n    if (!(certs = gnutls_certificate_get_peers(sess->session, &nCerts))) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"The certificate has no peers\"));\n        goto authdeny;\n    }\n\n    for (i = 0; i < nCerts; i++) {\n        gnutls_x509_crt_t cert;\n\n        if (gnutls_x509_crt_init(&cert) < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                           _(\"Unable to initialize certificate\"));\n            goto authfail;\n        }\n\n        if (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                           _(\"Unable to load certificate\"));\n            gnutls_x509_crt_deinit(cert);\n            goto authfail;\n        }\n\n        if (virNetTLSContextCheckCertTimes(cert, \"[session]\",\n                                           sess->isServer, i > 0) < 0) {\n            gnutls_x509_crt_deinit(cert);\n            goto authdeny;\n        }\n\n        if (i == 0) {\n            ret = gnutls_x509_crt_get_dn(cert, dname, &dnamesize);\n            if (ret != 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Failed to get certificate %s distinguished name: %s\"),\n                               \"[session]\", gnutls_strerror(ret));\n                goto authfail;\n            }\n            sess->x509dname = g_strdup(dname);\n            VIR_DEBUG(\"Peer DN is %s\", dname);\n\n            if (virNetTLSContextCheckCertDN(cert, \"[session]\", sess->hostname, dname,\n                                            ctxt->x509dnWhitelist) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n\n            /* !sess->isServer, since on the client, we're validating the\n             * server's cert, and on the server, the client's cert\n             */\n            if (virNetTLSContextCheckCertBasicConstraints(cert, \"[session]\",\n                                                          !sess->isServer, false) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n\n            if (virNetTLSContextCheckCertKeyUsage(cert, \"[session]\",\n                                                  false) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n\n            /* !sess->isServer - as above */\n            if (virNetTLSContextCheckCertKeyPurpose(cert, \"[session]\",\n                                                    !sess->isServer) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n        }\n        gnutls_x509_crt_deinit(cert);\n    }\n\n    PROBE(RPC_TLS_CONTEXT_SESSION_ALLOW,\n          \"ctxt=%p sess=%p dname=%s\",\n          ctxt, sess, dnameptr);\n\n    return 0;\n\n authdeny:\n    PROBE(RPC_TLS_CONTEXT_SESSION_DENY,\n          \"ctxt=%p sess=%p dname=%s\",\n          ctxt, sess, dnameptr);\n\n    return -1;\n\n authfail:\n    PROBE(RPC_TLS_CONTEXT_SESSION_FAIL,\n          \"ctxt=%p sess=%p\",\n          ctxt, sess);\n\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_TLS_CONTEXT_SESSION_FAIL",
            "\"ctxt=%p sess=%p\"",
            "ctxt",
            "sess"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_TLS_CONTEXT_SESSION_DENY",
            "\"ctxt=%p sess=%p dname=%s\"",
            "ctxt",
            "sess",
            "dnameptr"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_TLS_CONTEXT_SESSION_ALLOW",
            "\"ctxt=%p sess=%p dname=%s\"",
            "ctxt",
            "sess",
            "dnameptr"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_deinit",
          "args": [
            "cert"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_deinit",
          "args": [
            "cert"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSContextCheckCertKeyPurpose",
          "args": [
            "cert",
            "\"[session]\"",
            "!sess->isServer"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextCheckCertKeyPurpose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "270-355",
          "snippet": "static int virNetTLSContextCheckCertKeyPurpose(gnutls_x509_crt_t cert,\n                                               const char *certFile,\n                                               bool isServer)\n{\n    int status;\n    size_t i;\n    unsigned int purposeCritical;\n    unsigned int critical;\n    char *buffer = NULL;\n    size_t size;\n    bool allowClient = false, allowServer = false;\n\n    critical = 0;\n    for (i = 0; ; i++) {\n        size = 0;\n        status = gnutls_x509_crt_get_key_purpose_oid(cert, i, buffer, &size, NULL);\n\n        if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n            VIR_DEBUG(\"No key purpose data available at slot %zu\", i);\n\n            /* If there is no data at all, then we must allow client/server to pass */\n            if (i == 0)\n                allowServer = allowClient = true;\n            break;\n        }\n        if (status != GNUTLS_E_SHORT_MEMORY_BUFFER) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key purpose %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n\n        if (VIR_ALLOC_N(buffer, size) < 0)\n            return -1;\n\n        status = gnutls_x509_crt_get_key_purpose_oid(cert, i, buffer, &size, &purposeCritical);\n        if (status < 0) {\n            VIR_FREE(buffer);\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key purpose %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n        if (purposeCritical)\n            critical = true;\n\n        VIR_DEBUG(\"Key purpose %d %s critical %u\", status, buffer, purposeCritical);\n        if (STREQ(buffer, GNUTLS_KP_TLS_WWW_SERVER)) {\n            allowServer = true;\n        } else if (STREQ(buffer, GNUTLS_KP_TLS_WWW_CLIENT)) {\n            allowClient = true;\n        } else if (STRNEQ(buffer, GNUTLS_KP_ANY)) {\n            allowServer = allowClient = true;\n        }\n\n        VIR_FREE(buffer);\n    }\n\n    if (isServer) {\n        if (!allowServer) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s purpose does not allow use for with a TLS server\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s purpose does not allow use for with a TLS server\",\n                         certFile);\n            }\n        }\n    } else {\n        if (!allowClient) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s purpose does not allow use for with a TLS client\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s purpose does not allow use for with a TLS client\",\n                         certFile);\n            }\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCertKeyPurpose(gnutls_x509_crt_t cert,\n                                               const char *certFile,\n                                               bool isServer)\n{\n    int status;\n    size_t i;\n    unsigned int purposeCritical;\n    unsigned int critical;\n    char *buffer = NULL;\n    size_t size;\n    bool allowClient = false, allowServer = false;\n\n    critical = 0;\n    for (i = 0; ; i++) {\n        size = 0;\n        status = gnutls_x509_crt_get_key_purpose_oid(cert, i, buffer, &size, NULL);\n\n        if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n            VIR_DEBUG(\"No key purpose data available at slot %zu\", i);\n\n            /* If there is no data at all, then we must allow client/server to pass */\n            if (i == 0)\n                allowServer = allowClient = true;\n            break;\n        }\n        if (status != GNUTLS_E_SHORT_MEMORY_BUFFER) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key purpose %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n\n        if (VIR_ALLOC_N(buffer, size) < 0)\n            return -1;\n\n        status = gnutls_x509_crt_get_key_purpose_oid(cert, i, buffer, &size, &purposeCritical);\n        if (status < 0) {\n            VIR_FREE(buffer);\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key purpose %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n        if (purposeCritical)\n            critical = true;\n\n        VIR_DEBUG(\"Key purpose %d %s critical %u\", status, buffer, purposeCritical);\n        if (STREQ(buffer, GNUTLS_KP_TLS_WWW_SERVER)) {\n            allowServer = true;\n        } else if (STREQ(buffer, GNUTLS_KP_TLS_WWW_CLIENT)) {\n            allowClient = true;\n        } else if (STRNEQ(buffer, GNUTLS_KP_ANY)) {\n            allowServer = allowClient = true;\n        }\n\n        VIR_FREE(buffer);\n    }\n\n    if (isServer) {\n        if (!allowServer) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s purpose does not allow use for with a TLS server\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s purpose does not allow use for with a TLS server\",\n                         certFile);\n            }\n        }\n    } else {\n        if (!allowClient) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s purpose does not allow use for with a TLS client\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s purpose does not allow use for with a TLS client\",\n                         certFile);\n            }\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_deinit",
          "args": [
            "cert"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSContextCheckCertKeyUsage",
          "args": [
            "cert",
            "\"[session]\"",
            "false"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextCheckCertKeyUsage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "206-267",
          "snippet": "static int virNetTLSContextCheckCertKeyUsage(gnutls_x509_crt_t cert,\n                                             const char *certFile,\n                                             bool isCA)\n{\n    int status;\n    unsigned int usage = 0;\n    unsigned int critical = 0;\n\n    status = gnutls_x509_crt_get_key_usage(cert, &usage, &critical);\n\n    VIR_DEBUG(\"Cert %s key usage status %d usage %d critical %u\", certFile, status, usage, critical);\n    if (status < 0) {\n        if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n            usage = isCA ? GNUTLS_KEY_KEY_CERT_SIGN :\n                GNUTLS_KEY_DIGITAL_SIGNATURE|GNUTLS_KEY_KEY_ENCIPHERMENT;\n        } else {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key usage %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n    }\n\n    if (isCA) {\n        if (!(usage & GNUTLS_KEY_KEY_CERT_SIGN)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit certificate signing\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit certificate signing\",\n                         certFile);\n            }\n        }\n    } else {\n        if (!(usage & GNUTLS_KEY_DIGITAL_SIGNATURE)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit digital signature\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit digital signature\",\n                         certFile);\n            }\n        }\n        if (!(usage & GNUTLS_KEY_KEY_ENCIPHERMENT)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit key encipherment\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit key encipherment\",\n                         certFile);\n            }\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCertKeyUsage(gnutls_x509_crt_t cert,\n                                             const char *certFile,\n                                             bool isCA)\n{\n    int status;\n    unsigned int usage = 0;\n    unsigned int critical = 0;\n\n    status = gnutls_x509_crt_get_key_usage(cert, &usage, &critical);\n\n    VIR_DEBUG(\"Cert %s key usage status %d usage %d critical %u\", certFile, status, usage, critical);\n    if (status < 0) {\n        if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n            usage = isCA ? GNUTLS_KEY_KEY_CERT_SIGN :\n                GNUTLS_KEY_DIGITAL_SIGNATURE|GNUTLS_KEY_KEY_ENCIPHERMENT;\n        } else {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key usage %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n    }\n\n    if (isCA) {\n        if (!(usage & GNUTLS_KEY_KEY_CERT_SIGN)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit certificate signing\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit certificate signing\",\n                         certFile);\n            }\n        }\n    } else {\n        if (!(usage & GNUTLS_KEY_DIGITAL_SIGNATURE)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit digital signature\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit digital signature\",\n                         certFile);\n            }\n        }\n        if (!(usage & GNUTLS_KEY_KEY_ENCIPHERMENT)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit key encipherment\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit key encipherment\",\n                         certFile);\n            }\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_deinit",
          "args": [
            "cert"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSContextCheckCertBasicConstraints",
          "args": [
            "cert",
            "\"[session]\"",
            "!sess->isServer",
            "false"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextCheckCertBasicConstraints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "163-203",
          "snippet": "static int virNetTLSContextCheckCertBasicConstraints(gnutls_x509_crt_t cert,\n                                                     const char *certFile,\n                                                     bool isServer,\n                                                     bool isCA)\n{\n    int status;\n\n    status = gnutls_x509_crt_get_basic_constraints(cert, NULL, NULL, NULL);\n    VIR_DEBUG(\"Cert %s basic constraints %d\", certFile, status);\n\n    if (status > 0) { /* It is a CA cert */\n        if (!isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, isServer ?\n                           _(\"The certificate %s basic constraints show a CA, but we need one for a server\") :\n                           _(\"The certificate %s basic constraints show a CA, but we need one for a client\"),\n                           certFile);\n            return -1;\n        }\n    } else if (status == 0) { /* It is not a CA cert */\n        if (isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"The certificate %s basic constraints do not show a CA\"),\n                           certFile);\n            return -1;\n        }\n    } else if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) { /* Missing basicConstraints */\n        if (isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"The certificate %s is missing basic constraints for a CA\"),\n                           certFile);\n            return -1;\n        }\n    } else { /* General error */\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to query certificate %s basic constraints %s\"),\n                       certFile, gnutls_strerror(status));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCertBasicConstraints(gnutls_x509_crt_t cert,\n                                                     const char *certFile,\n                                                     bool isServer,\n                                                     bool isCA)\n{\n    int status;\n\n    status = gnutls_x509_crt_get_basic_constraints(cert, NULL, NULL, NULL);\n    VIR_DEBUG(\"Cert %s basic constraints %d\", certFile, status);\n\n    if (status > 0) { /* It is a CA cert */\n        if (!isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, isServer ?\n                           _(\"The certificate %s basic constraints show a CA, but we need one for a server\") :\n                           _(\"The certificate %s basic constraints show a CA, but we need one for a client\"),\n                           certFile);\n            return -1;\n        }\n    } else if (status == 0) { /* It is not a CA cert */\n        if (isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"The certificate %s basic constraints do not show a CA\"),\n                           certFile);\n            return -1;\n        }\n    } else if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) { /* Missing basicConstraints */\n        if (isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"The certificate %s is missing basic constraints for a CA\"),\n                           certFile);\n            return -1;\n        }\n    } else { /* General error */\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to query certificate %s basic constraints %s\"),\n                       certFile, gnutls_strerror(status));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_deinit",
          "args": [
            "cert"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSContextCheckCertDN",
          "args": [
            "cert",
            "\"[session]\"",
            "sess->hostname",
            "dname",
            "ctxt->x509dnWhitelist"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextCheckCertDN",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "383-403",
          "snippet": "static int\nvirNetTLSContextCheckCertDN(gnutls_x509_crt_t cert,\n                            const char *certFile,\n                            const char *hostname,\n                            const char *dname,\n                            const char *const* whitelist)\n{\n    if (whitelist && dname &&\n        virNetTLSContextCheckCertDNWhitelist(dname, whitelist) <= 0)\n        return -1;\n\n    if (hostname &&\n        !gnutls_x509_crt_check_hostname(cert, hostname)) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Certificate %s owner does not match the hostname %s\"),\n                       certFile, hostname);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetTLSContextCheckCertDN(gnutls_x509_crt_t cert,\n                            const char *certFile,\n                            const char *hostname,\n                            const char *dname,\n                            const char *const* whitelist)\n{\n    if (whitelist && dname &&\n        virNetTLSContextCheckCertDNWhitelist(dname, whitelist) <= 0)\n        return -1;\n\n    if (hostname &&\n        !gnutls_x509_crt_check_hostname(cert, hostname)) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Certificate %s owner does not match the hostname %s\"),\n                       certFile, hostname);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Peer DN is %s\"",
            "dname"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "dname"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Failed to get certificate %s distinguished name: %s\")",
            "\"[session]\"",
            "gnutls_strerror(ret)"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "ret"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_get_dn",
          "args": [
            "cert",
            "dname",
            "&dnamesize"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_deinit",
          "args": [
            "cert"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSContextCheckCertTimes",
          "args": [
            "cert",
            "\"[session]\"",
            "sess->isServer",
            "i > 0"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextCheckCertTimes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "124-160",
          "snippet": "static int virNetTLSContextCheckCertTimes(gnutls_x509_crt_t cert,\n                                          const char *certFile,\n                                          bool isServer,\n                                          bool isCA)\n{\n    time_t now;\n\n    if ((now = time(NULL)) == ((time_t)-1)) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot get current time\"));\n        return -1;\n    }\n\n    if (gnutls_x509_crt_get_expiration_time(cert) < now) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       (isCA ?\n                        _(\"The CA certificate %s has expired\") :\n                        (isServer ?\n                         _(\"The server certificate %s has expired\") :\n                         _(\"The client certificate %s has expired\"))),\n                       certFile);\n        return -1;\n    }\n\n    if (gnutls_x509_crt_get_activation_time(cert) > now) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       (isCA ?\n                        _(\"The CA certificate %s is not yet active\") :\n                        (isServer ?\n                         _(\"The server certificate %s is not yet active\") :\n                         _(\"The client certificate %s is not yet active\"))),\n                       certFile);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCertTimes(gnutls_x509_crt_t cert,\n                                          const char *certFile,\n                                          bool isServer,\n                                          bool isCA)\n{\n    time_t now;\n\n    if ((now = time(NULL)) == ((time_t)-1)) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot get current time\"));\n        return -1;\n    }\n\n    if (gnutls_x509_crt_get_expiration_time(cert) < now) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       (isCA ?\n                        _(\"The CA certificate %s has expired\") :\n                        (isServer ?\n                         _(\"The server certificate %s has expired\") :\n                         _(\"The client certificate %s has expired\"))),\n                       certFile);\n        return -1;\n    }\n\n    if (gnutls_x509_crt_get_activation_time(cert) > now) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       (isCA ?\n                        _(\"The CA certificate %s is not yet active\") :\n                        (isServer ?\n                         _(\"The server certificate %s is not yet active\") :\n                         _(\"The client certificate %s is not yet active\"))),\n                       certFile);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_deinit",
          "args": [
            "cert"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "\"%s\"",
            "_(\"Unable to load certificate\")"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_import",
          "args": [
            "cert",
            "&certs[i]",
            "GNUTLS_X509_FMT_DER"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "\"%s\"",
            "_(\"Unable to initialize certificate\")"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_init",
          "args": [
            "&cert"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "\"%s\"",
            "_(\"The certificate has no peers\")"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_get_peers",
          "args": [
            "sess->session",
            "&nCerts"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "\"%s\"",
            "_(\"Only x509 certificates are supported\")"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_type_get",
          "args": [
            "sess->session"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Certificate failed validation: %s\")",
            "reason"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to verify TLS peer: %s\")",
            "gnutls_strerror(ret)"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "ret"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_verify_peers2",
          "args": [
            "sess->session",
            "&status"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dname",
            "0",
            "dnamesize"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextValidCertificate(virNetTLSContextPtr ctxt,\n                                            virNetTLSSessionPtr sess)\n{\n    int ret;\n    unsigned int status;\n    const gnutls_datum_t *certs;\n    unsigned int nCerts;\n    size_t i;\n    char dname[256];\n    char *dnameptr = dname;\n    size_t dnamesize = sizeof(dname);\n\n    memset(dname, 0, dnamesize);\n\n    if ((ret = gnutls_certificate_verify_peers2(sess->session, &status)) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to verify TLS peer: %s\"),\n                       gnutls_strerror(ret));\n        goto authdeny;\n    }\n\n    if (status != 0) {\n        const char *reason = _(\"Invalid certificate\");\n\n        if (status & GNUTLS_CERT_INVALID)\n            reason = _(\"The certificate is not trusted.\");\n\n        if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n            reason = _(\"The certificate hasn't got a known issuer.\");\n\n        if (status & GNUTLS_CERT_REVOKED)\n            reason = _(\"The certificate has been revoked.\");\n\n        if (status & GNUTLS_CERT_INSECURE_ALGORITHM)\n            reason = _(\"The certificate uses an insecure algorithm\");\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Certificate failed validation: %s\"),\n                       reason);\n        goto authdeny;\n    }\n\n    if (gnutls_certificate_type_get(sess->session) != GNUTLS_CRT_X509) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Only x509 certificates are supported\"));\n        goto authdeny;\n    }\n\n    if (!(certs = gnutls_certificate_get_peers(sess->session, &nCerts))) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"The certificate has no peers\"));\n        goto authdeny;\n    }\n\n    for (i = 0; i < nCerts; i++) {\n        gnutls_x509_crt_t cert;\n\n        if (gnutls_x509_crt_init(&cert) < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                           _(\"Unable to initialize certificate\"));\n            goto authfail;\n        }\n\n        if (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                           _(\"Unable to load certificate\"));\n            gnutls_x509_crt_deinit(cert);\n            goto authfail;\n        }\n\n        if (virNetTLSContextCheckCertTimes(cert, \"[session]\",\n                                           sess->isServer, i > 0) < 0) {\n            gnutls_x509_crt_deinit(cert);\n            goto authdeny;\n        }\n\n        if (i == 0) {\n            ret = gnutls_x509_crt_get_dn(cert, dname, &dnamesize);\n            if (ret != 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Failed to get certificate %s distinguished name: %s\"),\n                               \"[session]\", gnutls_strerror(ret));\n                goto authfail;\n            }\n            sess->x509dname = g_strdup(dname);\n            VIR_DEBUG(\"Peer DN is %s\", dname);\n\n            if (virNetTLSContextCheckCertDN(cert, \"[session]\", sess->hostname, dname,\n                                            ctxt->x509dnWhitelist) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n\n            /* !sess->isServer, since on the client, we're validating the\n             * server's cert, and on the server, the client's cert\n             */\n            if (virNetTLSContextCheckCertBasicConstraints(cert, \"[session]\",\n                                                          !sess->isServer, false) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n\n            if (virNetTLSContextCheckCertKeyUsage(cert, \"[session]\",\n                                                  false) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n\n            /* !sess->isServer - as above */\n            if (virNetTLSContextCheckCertKeyPurpose(cert, \"[session]\",\n                                                    !sess->isServer) < 0) {\n                gnutls_x509_crt_deinit(cert);\n                goto authdeny;\n            }\n        }\n        gnutls_x509_crt_deinit(cert);\n    }\n\n    PROBE(RPC_TLS_CONTEXT_SESSION_ALLOW,\n          \"ctxt=%p sess=%p dname=%s\",\n          ctxt, sess, dnameptr);\n\n    return 0;\n\n authdeny:\n    PROBE(RPC_TLS_CONTEXT_SESSION_DENY,\n          \"ctxt=%p sess=%p dname=%s\",\n          ctxt, sess, dnameptr);\n\n    return -1;\n\n authfail:\n    PROBE(RPC_TLS_CONTEXT_SESSION_FAIL,\n          \"ctxt=%p sess=%p\",\n          ctxt, sess);\n\n    return -1;\n}"
  },
  {
    "function_name": "virNetTLSContextNewClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "968-978",
    "snippet": "virNetTLSContextPtr virNetTLSContextNewClient(const char *cacert,\n                                              const char *cacrl,\n                                              const char *cert,\n                                              const char *key,\n                                              const char *priority,\n                                              bool sanityCheckCert,\n                                              bool requireValidCert)\n{\n    return virNetTLSContextNew(cacert, cacrl, cert, key, NULL, priority,\n                               sanityCheckCert, requireValidCert, false);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetTLSContextNew",
          "args": [
            "cacert",
            "cacrl",
            "cert",
            "key",
            "NULL",
            "priority",
            "sanityCheckCert",
            "requireValidCert",
            "false"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "674-760",
          "snippet": "static virNetTLSContextPtr virNetTLSContextNew(const char *cacert,\n                                               const char *cacrl,\n                                               const char *cert,\n                                               const char *key,\n                                               const char *const*x509dnWhitelist,\n                                               const char *priority,\n                                               bool sanityCheckCert,\n                                               bool requireValidCert,\n                                               bool isServer)\n{\n    virNetTLSContextPtr ctxt;\n    int err;\n\n    if (virNetTLSContextInitialize() < 0)\n        return NULL;\n\n    if (!(ctxt = virObjectLockableNew(virNetTLSContextClass)))\n        return NULL;\n\n    ctxt->priority = g_strdup(priority);\n\n    err = gnutls_certificate_allocate_credentials(&ctxt->x509cred);\n    if (err) {\n        /* While gnutls_certificate_credentials_t will free any\n         * partially allocated credentials struct, it does not\n         * set the returned pointer back to NULL after it is\n         * freed in an error path.\n         */\n        ctxt->x509cred = NULL;\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to allocate x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    if (sanityCheckCert &&\n        virNetTLSContextSanityCheckCredentials(isServer, cacert, cert) < 0)\n        goto error;\n\n    if (virNetTLSContextLoadCredentials(ctxt, isServer, cacert, cacrl, cert, key) < 0)\n        goto error;\n\n    /* Generate Diffie Hellman parameters - for use with DHE\n     * kx algorithms. These should be discarded and regenerated\n     * once a day, once a week or once a month. Depending on the\n     * security requirements.\n     */\n    if (isServer) {\n        err = gnutls_dh_params_init(&ctxt->dhParams);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to initialize diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n        err = gnutls_dh_params_generate2(ctxt->dhParams, DH_BITS);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to generate diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n\n        gnutls_certificate_set_dh_params(ctxt->x509cred,\n                                         ctxt->dhParams);\n    }\n\n    ctxt->requireValidCert = requireValidCert;\n    ctxt->x509dnWhitelist = x509dnWhitelist;\n    ctxt->isServer = isServer;\n\n    PROBE(RPC_TLS_CONTEXT_NEW,\n          \"ctxt=%p cacert=%s cacrl=%s cert=%s key=%s sanityCheckCert=%d requireValidCert=%d isServer=%d\",\n          ctxt, cacert, NULLSTR(cacrl), cert, key, sanityCheckCert, requireValidCert, isServer);\n\n    return ctxt;\n\n error:\n    if (isServer)\n        gnutls_dh_params_deinit(ctxt->dhParams);\n    if (ctxt->x509cred)\n        gnutls_certificate_free_credentials(ctxt->x509cred);\n    VIR_FREE(ctxt->priority);\n    VIR_FREE(ctxt);\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define DH_BITS 2048"
          ],
          "globals_used": [
            "static virClassPtr virNetTLSContextClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\n#define DH_BITS 2048\n\nstatic virClassPtr virNetTLSContextClass;\n\nstatic virNetTLSContextPtr virNetTLSContextNew(const char *cacert,\n                                               const char *cacrl,\n                                               const char *cert,\n                                               const char *key,\n                                               const char *const*x509dnWhitelist,\n                                               const char *priority,\n                                               bool sanityCheckCert,\n                                               bool requireValidCert,\n                                               bool isServer)\n{\n    virNetTLSContextPtr ctxt;\n    int err;\n\n    if (virNetTLSContextInitialize() < 0)\n        return NULL;\n\n    if (!(ctxt = virObjectLockableNew(virNetTLSContextClass)))\n        return NULL;\n\n    ctxt->priority = g_strdup(priority);\n\n    err = gnutls_certificate_allocate_credentials(&ctxt->x509cred);\n    if (err) {\n        /* While gnutls_certificate_credentials_t will free any\n         * partially allocated credentials struct, it does not\n         * set the returned pointer back to NULL after it is\n         * freed in an error path.\n         */\n        ctxt->x509cred = NULL;\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to allocate x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    if (sanityCheckCert &&\n        virNetTLSContextSanityCheckCredentials(isServer, cacert, cert) < 0)\n        goto error;\n\n    if (virNetTLSContextLoadCredentials(ctxt, isServer, cacert, cacrl, cert, key) < 0)\n        goto error;\n\n    /* Generate Diffie Hellman parameters - for use with DHE\n     * kx algorithms. These should be discarded and regenerated\n     * once a day, once a week or once a month. Depending on the\n     * security requirements.\n     */\n    if (isServer) {\n        err = gnutls_dh_params_init(&ctxt->dhParams);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to initialize diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n        err = gnutls_dh_params_generate2(ctxt->dhParams, DH_BITS);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to generate diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n\n        gnutls_certificate_set_dh_params(ctxt->x509cred,\n                                         ctxt->dhParams);\n    }\n\n    ctxt->requireValidCert = requireValidCert;\n    ctxt->x509dnWhitelist = x509dnWhitelist;\n    ctxt->isServer = isServer;\n\n    PROBE(RPC_TLS_CONTEXT_NEW,\n          \"ctxt=%p cacert=%s cacrl=%s cert=%s key=%s sanityCheckCert=%d requireValidCert=%d isServer=%d\",\n          ctxt, cacert, NULLSTR(cacrl), cert, key, sanityCheckCert, requireValidCert, isServer);\n\n    return ctxt;\n\n error:\n    if (isServer)\n        gnutls_dh_params_deinit(ctxt->dhParams);\n    if (ctxt->x509cred)\n        gnutls_certificate_free_credentials(ctxt->x509cred);\n    VIR_FREE(ctxt->priority);\n    VIR_FREE(ctxt);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetTLSContextPtr virNetTLSContextNewClient(const char *cacert,\n                                              const char *cacrl,\n                                              const char *cert,\n                                              const char *key,\n                                              const char *priority,\n                                              bool sanityCheckCert,\n                                              bool requireValidCert)\n{\n    return virNetTLSContextNew(cacert, cacrl, cert, key, NULL, priority,\n                               sanityCheckCert, requireValidCert, false);\n}"
  },
  {
    "function_name": "virNetTLSContextReloadForServer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "922-965",
    "snippet": "int virNetTLSContextReloadForServer(virNetTLSContextPtr ctxt,\n                                    bool tryUserPkiPath)\n{\n    gnutls_certificate_credentials_t x509credBak;\n    int err;\n    char *cacert = NULL;\n    char *cacrl = NULL;\n    char *cert = NULL;\n    char *key = NULL;\n\n    x509credBak = ctxt->x509cred;\n    ctxt->x509cred = NULL;\n\n    if (virNetTLSContextLocateCredentials(NULL, tryUserPkiPath, true,\n                                          &cacert, &cacrl, &cert, &key))\n        goto error;\n\n    err = gnutls_certificate_allocate_credentials(&ctxt->x509cred);\n    if (err) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to allocate x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    if (virNetTLSContextSanityCheckCredentials(true, cacert, cert))\n        goto error;\n\n    if (virNetTLSContextLoadCredentials(ctxt, true, cacert, cacrl, cert, key))\n        goto error;\n\n    gnutls_certificate_set_dh_params(ctxt->x509cred,\n                                     ctxt->dhParams);\n\n    gnutls_certificate_free_credentials(x509credBak);\n\n    return 0;\n\n error:\n    if (ctxt->x509cred)\n        gnutls_certificate_free_credentials(ctxt->x509cred);\n    ctxt->x509cred = x509credBak;\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gnutls_certificate_free_credentials",
          "args": [
            "ctxt->x509cred"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_free_credentials",
          "args": [
            "x509credBak"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_set_dh_params",
          "args": [
            "ctxt->x509cred",
            "ctxt->dhParams"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSContextLoadCredentials",
          "args": [
            "ctxt",
            "true",
            "cacert",
            "cacrl",
            "cert",
            "key"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextLoadCredentials",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "598-671",
          "snippet": "static int virNetTLSContextLoadCredentials(virNetTLSContextPtr ctxt,\n                                           bool isServer,\n                                           const char *cacert,\n                                           const char *cacrl,\n                                           const char *cert,\n                                           const char *key)\n{\n    int err;\n\n    if (cacert && cacert[0] != '\\0') {\n        if (virNetTLSContextCheckCertFile(\"CA certificate\", cacert, false) < 0)\n            return -1;\n\n        VIR_DEBUG(\"loading CA cert from %s\", cacert);\n        err = gnutls_certificate_set_x509_trust_file(ctxt->x509cred,\n                                                     cacert,\n                                                     GNUTLS_X509_FMT_PEM);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to set x509 CA certificate: %s: %s\"),\n                           cacert, gnutls_strerror(err));\n            return -1;\n        }\n    }\n\n    if (cacrl && cacrl[0] != '\\0') {\n        int rv;\n        if ((rv = virNetTLSContextCheckCertFile(\"CA revocation list\", cacrl, true)) < 0)\n            return -1;\n\n        if (rv == 0) {\n            VIR_DEBUG(\"loading CRL from %s\", cacrl);\n            err = gnutls_certificate_set_x509_crl_file(ctxt->x509cred,\n                                                       cacrl,\n                                                       GNUTLS_X509_FMT_PEM);\n            if (err < 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Unable to set x509 certificate revocation list: %s: %s\"),\n                               cacrl, gnutls_strerror(err));\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"Skipping non-existent CA CRL %s\", cacrl);\n        }\n    }\n\n    if (cert && cert[0] != '\\0' && key && key[0] != '\\0') {\n        int rv;\n        if ((rv = virNetTLSContextCheckCertFile(\"certificate\", cert, !isServer)) < 0)\n            return -1;\n        if (rv == 0 &&\n            (rv = virNetTLSContextCheckCertFile(\"private key\", key, !isServer)) < 0)\n            return -1;\n\n        if (rv == 0) {\n            VIR_DEBUG(\"loading cert and key from %s and %s\", cert, key);\n            err =\n                gnutls_certificate_set_x509_key_file(ctxt->x509cred,\n                                                     cert, key,\n                                                     GNUTLS_X509_FMT_PEM);\n            if (err < 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Unable to set x509 key and certificate: %s, %s: %s\"),\n                               key, cert, gnutls_strerror(err));\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"Skipping non-existent cert %s key %s on client\",\n                      cert, key);\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextLoadCredentials(virNetTLSContextPtr ctxt,\n                                           bool isServer,\n                                           const char *cacert,\n                                           const char *cacrl,\n                                           const char *cert,\n                                           const char *key)\n{\n    int err;\n\n    if (cacert && cacert[0] != '\\0') {\n        if (virNetTLSContextCheckCertFile(\"CA certificate\", cacert, false) < 0)\n            return -1;\n\n        VIR_DEBUG(\"loading CA cert from %s\", cacert);\n        err = gnutls_certificate_set_x509_trust_file(ctxt->x509cred,\n                                                     cacert,\n                                                     GNUTLS_X509_FMT_PEM);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to set x509 CA certificate: %s: %s\"),\n                           cacert, gnutls_strerror(err));\n            return -1;\n        }\n    }\n\n    if (cacrl && cacrl[0] != '\\0') {\n        int rv;\n        if ((rv = virNetTLSContextCheckCertFile(\"CA revocation list\", cacrl, true)) < 0)\n            return -1;\n\n        if (rv == 0) {\n            VIR_DEBUG(\"loading CRL from %s\", cacrl);\n            err = gnutls_certificate_set_x509_crl_file(ctxt->x509cred,\n                                                       cacrl,\n                                                       GNUTLS_X509_FMT_PEM);\n            if (err < 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Unable to set x509 certificate revocation list: %s: %s\"),\n                               cacrl, gnutls_strerror(err));\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"Skipping non-existent CA CRL %s\", cacrl);\n        }\n    }\n\n    if (cert && cert[0] != '\\0' && key && key[0] != '\\0') {\n        int rv;\n        if ((rv = virNetTLSContextCheckCertFile(\"certificate\", cert, !isServer)) < 0)\n            return -1;\n        if (rv == 0 &&\n            (rv = virNetTLSContextCheckCertFile(\"private key\", key, !isServer)) < 0)\n            return -1;\n\n        if (rv == 0) {\n            VIR_DEBUG(\"loading cert and key from %s and %s\", cert, key);\n            err =\n                gnutls_certificate_set_x509_key_file(ctxt->x509cred,\n                                                     cert, key,\n                                                     GNUTLS_X509_FMT_PEM);\n            if (err < 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Unable to set x509 key and certificate: %s, %s: %s\"),\n                               key, cert, gnutls_strerror(err));\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"Skipping non-existent cert %s key %s on client\",\n                      cert, key);\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSContextSanityCheckCredentials",
          "args": [
            "true",
            "cacert",
            "cert"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextSanityCheckCredentials",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "555-595",
          "snippet": "static int virNetTLSContextSanityCheckCredentials(bool isServer,\n                                                  const char *cacertFile,\n                                                  const char *certFile)\n{\n    gnutls_x509_crt_t cert = NULL;\n    gnutls_x509_crt_t cacerts[MAX_CERTS];\n    size_t ncacerts = 0;\n    size_t i;\n    int ret = -1;\n\n    memset(cacerts, 0, sizeof(cacerts));\n    if ((access(certFile, R_OK) == 0) &&\n        !(cert = virNetTLSContextLoadCertFromFile(certFile, isServer)))\n        goto cleanup;\n    if ((access(cacertFile, R_OK) == 0) &&\n        virNetTLSContextLoadCACertListFromFile(cacertFile, cacerts,\n                                               MAX_CERTS, &ncacerts) < 0)\n        goto cleanup;\n\n    if (cert &&\n        virNetTLSContextCheckCert(cert, certFile, isServer, false) < 0)\n        goto cleanup;\n\n    for (i = 0; i < ncacerts; i++) {\n        if (virNetTLSContextCheckCert(cacerts[i], cacertFile, isServer, true) < 0)\n            goto cleanup;\n    }\n\n    if (cert && ncacerts &&\n        virNetTLSContextCheckCertPair(cert, certFile, cacerts, ncacerts, cacertFile, isServer) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (cert)\n        gnutls_x509_crt_deinit(cert);\n    for (i = 0; i < ncacerts; i++)\n        gnutls_x509_crt_deinit(cacerts[i]);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_CERTS 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\n#define MAX_CERTS 16\n\nstatic int virNetTLSContextSanityCheckCredentials(bool isServer,\n                                                  const char *cacertFile,\n                                                  const char *certFile)\n{\n    gnutls_x509_crt_t cert = NULL;\n    gnutls_x509_crt_t cacerts[MAX_CERTS];\n    size_t ncacerts = 0;\n    size_t i;\n    int ret = -1;\n\n    memset(cacerts, 0, sizeof(cacerts));\n    if ((access(certFile, R_OK) == 0) &&\n        !(cert = virNetTLSContextLoadCertFromFile(certFile, isServer)))\n        goto cleanup;\n    if ((access(cacertFile, R_OK) == 0) &&\n        virNetTLSContextLoadCACertListFromFile(cacertFile, cacerts,\n                                               MAX_CERTS, &ncacerts) < 0)\n        goto cleanup;\n\n    if (cert &&\n        virNetTLSContextCheckCert(cert, certFile, isServer, false) < 0)\n        goto cleanup;\n\n    for (i = 0; i < ncacerts; i++) {\n        if (virNetTLSContextCheckCert(cacerts[i], cacertFile, isServer, true) < 0)\n            goto cleanup;\n    }\n\n    if (cert && ncacerts &&\n        virNetTLSContextCheckCertPair(cert, certFile, cacerts, ncacerts, cacertFile, isServer) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (cert)\n        gnutls_x509_crt_deinit(cert);\n    for (i = 0; i < ncacerts; i++)\n        gnutls_x509_crt_deinit(cacerts[i]);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to allocate x509 credentials: %s\")",
            "gnutls_strerror(err)"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "err"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to allocate x509 credentials: %s\""
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_allocate_credentials",
          "args": [
            "&ctxt->x509cred"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSContextLocateCredentials",
          "args": [
            "NULL",
            "tryUserPkiPath",
            "true",
            "&cacert",
            "&cacrl",
            "&cert",
            "&key"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextLocateCredentials",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "763-856",
          "snippet": "static int virNetTLSContextLocateCredentials(const char *pkipath,\n                                             bool tryUserPkiPath,\n                                             bool isServer,\n                                             char **cacert,\n                                             char **cacrl,\n                                             char **cert,\n                                             char **key)\n{\n    char *userdir = NULL;\n    char *user_pki_path = NULL;\n\n    *cacert = NULL;\n    *cacrl = NULL;\n    *key = NULL;\n    *cert = NULL;\n\n    VIR_DEBUG(\"pkipath=%s isServer=%d tryUserPkiPath=%d\",\n              pkipath, isServer, tryUserPkiPath);\n\n    /* Explicit path, then use that no matter whether the\n     * files actually exist there\n     */\n    if (pkipath) {\n        VIR_DEBUG(\"Told to use TLS credentials in %s\", pkipath);\n        *cacert = g_strdup_printf(\"%s/%s\", pkipath, \"cacert.pem\");\n        *cacrl = g_strdup_printf(\"%s/%s\", pkipath, \"cacrl.pem\");\n        *key = g_strdup_printf(\"%s/%s\", pkipath,\n                               isServer ? \"serverkey.pem\" : \"clientkey.pem\");\n\n        *cert = g_strdup_printf(\"%s/%s\", pkipath,\n                                isServer ? \"servercert.pem\" : \"clientcert.pem\");\n    } else if (tryUserPkiPath) {\n        /* Check to see if $HOME/.pki contains at least one of the\n         * files and if so, use that\n         */\n        userdir = virGetUserDirectory();\n\n        user_pki_path = g_strdup_printf(\"%s/.pki/libvirt\", userdir);\n\n        VIR_DEBUG(\"Trying to find TLS user credentials in %s\", user_pki_path);\n\n        *cacert = g_strdup_printf(\"%s/%s\", user_pki_path, \"cacert.pem\");\n\n        *cacrl = g_strdup_printf(\"%s/%s\", user_pki_path, \"cacrl.pem\");\n\n        *key = g_strdup_printf(\"%s/%s\", user_pki_path,\n                               isServer ? \"serverkey.pem\" : \"clientkey.pem\");\n\n        *cert = g_strdup_printf(\"%s/%s\", user_pki_path,\n                                isServer ? \"servercert.pem\" : \"clientcert.pem\");\n\n        /*\n         * If some of the files can't be found, fallback\n         * to the global location for them\n         */\n        if (!virFileExists(*cacert))\n            VIR_FREE(*cacert);\n        if (!virFileExists(*cacrl))\n            VIR_FREE(*cacrl);\n\n        /* Check these as a pair, since it they are\n         * mutually dependent\n         */\n        if (!virFileExists(*key) || !virFileExists(*cert)) {\n            VIR_FREE(*key);\n            VIR_FREE(*cert);\n        }\n    }\n\n    /* No explicit path, or user path didn't exist, so\n     * fallback to global defaults\n     */\n    if (!*cacert) {\n        VIR_DEBUG(\"Using default TLS CA certificate path\");\n        *cacert = g_strdup(LIBVIRT_CACERT);\n    }\n\n    if (!*cacrl) {\n        VIR_DEBUG(\"Using default TLS CA revocation list path\");\n        *cacrl = g_strdup(LIBVIRT_CACRL);\n    }\n\n    if (!*key && !*cert) {\n        VIR_DEBUG(\"Using default TLS key/certificate path\");\n        *key = g_strdup(isServer ? LIBVIRT_SERVERKEY : LIBVIRT_CLIENTKEY);\n\n        *cert = g_strdup(isServer ? LIBVIRT_SERVERCERT : LIBVIRT_CLIENTCERT);\n    }\n\n    VIR_FREE(user_pki_path);\n    VIR_FREE(userdir);\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBVIRT_SERVERCERT LIBVIRT_PKI_DIR \"/libvirt/servercert.pem\"",
            "#define LIBVIRT_SERVERKEY LIBVIRT_PKI_DIR \"/libvirt/private/serverkey.pem\"",
            "#define LIBVIRT_CLIENTCERT LIBVIRT_PKI_DIR \"/libvirt/clientcert.pem\"",
            "#define LIBVIRT_CLIENTKEY LIBVIRT_PKI_DIR \"/libvirt/private/clientkey.pem\"",
            "#define LIBVIRT_CACRL LIBVIRT_PKI_DIR \"/CA/cacrl.pem\"",
            "#define LIBVIRT_CACERT LIBVIRT_PKI_DIR \"/CA/cacert.pem\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\n#define LIBVIRT_SERVERCERT LIBVIRT_PKI_DIR \"/libvirt/servercert.pem\"\n#define LIBVIRT_SERVERKEY LIBVIRT_PKI_DIR \"/libvirt/private/serverkey.pem\"\n#define LIBVIRT_CLIENTCERT LIBVIRT_PKI_DIR \"/libvirt/clientcert.pem\"\n#define LIBVIRT_CLIENTKEY LIBVIRT_PKI_DIR \"/libvirt/private/clientkey.pem\"\n#define LIBVIRT_CACRL LIBVIRT_PKI_DIR \"/CA/cacrl.pem\"\n#define LIBVIRT_CACERT LIBVIRT_PKI_DIR \"/CA/cacert.pem\"\n\nstatic int virNetTLSContextLocateCredentials(const char *pkipath,\n                                             bool tryUserPkiPath,\n                                             bool isServer,\n                                             char **cacert,\n                                             char **cacrl,\n                                             char **cert,\n                                             char **key)\n{\n    char *userdir = NULL;\n    char *user_pki_path = NULL;\n\n    *cacert = NULL;\n    *cacrl = NULL;\n    *key = NULL;\n    *cert = NULL;\n\n    VIR_DEBUG(\"pkipath=%s isServer=%d tryUserPkiPath=%d\",\n              pkipath, isServer, tryUserPkiPath);\n\n    /* Explicit path, then use that no matter whether the\n     * files actually exist there\n     */\n    if (pkipath) {\n        VIR_DEBUG(\"Told to use TLS credentials in %s\", pkipath);\n        *cacert = g_strdup_printf(\"%s/%s\", pkipath, \"cacert.pem\");\n        *cacrl = g_strdup_printf(\"%s/%s\", pkipath, \"cacrl.pem\");\n        *key = g_strdup_printf(\"%s/%s\", pkipath,\n                               isServer ? \"serverkey.pem\" : \"clientkey.pem\");\n\n        *cert = g_strdup_printf(\"%s/%s\", pkipath,\n                                isServer ? \"servercert.pem\" : \"clientcert.pem\");\n    } else if (tryUserPkiPath) {\n        /* Check to see if $HOME/.pki contains at least one of the\n         * files and if so, use that\n         */\n        userdir = virGetUserDirectory();\n\n        user_pki_path = g_strdup_printf(\"%s/.pki/libvirt\", userdir);\n\n        VIR_DEBUG(\"Trying to find TLS user credentials in %s\", user_pki_path);\n\n        *cacert = g_strdup_printf(\"%s/%s\", user_pki_path, \"cacert.pem\");\n\n        *cacrl = g_strdup_printf(\"%s/%s\", user_pki_path, \"cacrl.pem\");\n\n        *key = g_strdup_printf(\"%s/%s\", user_pki_path,\n                               isServer ? \"serverkey.pem\" : \"clientkey.pem\");\n\n        *cert = g_strdup_printf(\"%s/%s\", user_pki_path,\n                                isServer ? \"servercert.pem\" : \"clientcert.pem\");\n\n        /*\n         * If some of the files can't be found, fallback\n         * to the global location for them\n         */\n        if (!virFileExists(*cacert))\n            VIR_FREE(*cacert);\n        if (!virFileExists(*cacrl))\n            VIR_FREE(*cacrl);\n\n        /* Check these as a pair, since it they are\n         * mutually dependent\n         */\n        if (!virFileExists(*key) || !virFileExists(*cert)) {\n            VIR_FREE(*key);\n            VIR_FREE(*cert);\n        }\n    }\n\n    /* No explicit path, or user path didn't exist, so\n     * fallback to global defaults\n     */\n    if (!*cacert) {\n        VIR_DEBUG(\"Using default TLS CA certificate path\");\n        *cacert = g_strdup(LIBVIRT_CACERT);\n    }\n\n    if (!*cacrl) {\n        VIR_DEBUG(\"Using default TLS CA revocation list path\");\n        *cacrl = g_strdup(LIBVIRT_CACRL);\n    }\n\n    if (!*key && !*cert) {\n        VIR_DEBUG(\"Using default TLS key/certificate path\");\n        *key = g_strdup(isServer ? LIBVIRT_SERVERKEY : LIBVIRT_CLIENTKEY);\n\n        *cert = g_strdup(isServer ? LIBVIRT_SERVERCERT : LIBVIRT_CLIENTCERT);\n    }\n\n    VIR_FREE(user_pki_path);\n    VIR_FREE(userdir);\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetTLSContextReloadForServer(virNetTLSContextPtr ctxt,\n                                    bool tryUserPkiPath)\n{\n    gnutls_certificate_credentials_t x509credBak;\n    int err;\n    char *cacert = NULL;\n    char *cacrl = NULL;\n    char *cert = NULL;\n    char *key = NULL;\n\n    x509credBak = ctxt->x509cred;\n    ctxt->x509cred = NULL;\n\n    if (virNetTLSContextLocateCredentials(NULL, tryUserPkiPath, true,\n                                          &cacert, &cacrl, &cert, &key))\n        goto error;\n\n    err = gnutls_certificate_allocate_credentials(&ctxt->x509cred);\n    if (err) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to allocate x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    if (virNetTLSContextSanityCheckCredentials(true, cacert, cert))\n        goto error;\n\n    if (virNetTLSContextLoadCredentials(ctxt, true, cacert, cacrl, cert, key))\n        goto error;\n\n    gnutls_certificate_set_dh_params(ctxt->x509cred,\n                                     ctxt->dhParams);\n\n    gnutls_certificate_free_credentials(x509credBak);\n\n    return 0;\n\n error:\n    if (ctxt->x509cred)\n        gnutls_certificate_free_credentials(ctxt->x509cred);\n    ctxt->x509cred = x509credBak;\n    return -1;\n}"
  },
  {
    "function_name": "virNetTLSContextNewServer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "908-919",
    "snippet": "virNetTLSContextPtr virNetTLSContextNewServer(const char *cacert,\n                                              const char *cacrl,\n                                              const char *cert,\n                                              const char *key,\n                                              const char *const*x509dnWhitelist,\n                                              const char *priority,\n                                              bool sanityCheckCert,\n                                              bool requireValidCert)\n{\n    return virNetTLSContextNew(cacert, cacrl, cert, key, x509dnWhitelist, priority,\n                               sanityCheckCert, requireValidCert, true);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetTLSContextNew",
          "args": [
            "cacert",
            "cacrl",
            "cert",
            "key",
            "x509dnWhitelist",
            "priority",
            "sanityCheckCert",
            "requireValidCert",
            "true"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "674-760",
          "snippet": "static virNetTLSContextPtr virNetTLSContextNew(const char *cacert,\n                                               const char *cacrl,\n                                               const char *cert,\n                                               const char *key,\n                                               const char *const*x509dnWhitelist,\n                                               const char *priority,\n                                               bool sanityCheckCert,\n                                               bool requireValidCert,\n                                               bool isServer)\n{\n    virNetTLSContextPtr ctxt;\n    int err;\n\n    if (virNetTLSContextInitialize() < 0)\n        return NULL;\n\n    if (!(ctxt = virObjectLockableNew(virNetTLSContextClass)))\n        return NULL;\n\n    ctxt->priority = g_strdup(priority);\n\n    err = gnutls_certificate_allocate_credentials(&ctxt->x509cred);\n    if (err) {\n        /* While gnutls_certificate_credentials_t will free any\n         * partially allocated credentials struct, it does not\n         * set the returned pointer back to NULL after it is\n         * freed in an error path.\n         */\n        ctxt->x509cred = NULL;\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to allocate x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    if (sanityCheckCert &&\n        virNetTLSContextSanityCheckCredentials(isServer, cacert, cert) < 0)\n        goto error;\n\n    if (virNetTLSContextLoadCredentials(ctxt, isServer, cacert, cacrl, cert, key) < 0)\n        goto error;\n\n    /* Generate Diffie Hellman parameters - for use with DHE\n     * kx algorithms. These should be discarded and regenerated\n     * once a day, once a week or once a month. Depending on the\n     * security requirements.\n     */\n    if (isServer) {\n        err = gnutls_dh_params_init(&ctxt->dhParams);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to initialize diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n        err = gnutls_dh_params_generate2(ctxt->dhParams, DH_BITS);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to generate diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n\n        gnutls_certificate_set_dh_params(ctxt->x509cred,\n                                         ctxt->dhParams);\n    }\n\n    ctxt->requireValidCert = requireValidCert;\n    ctxt->x509dnWhitelist = x509dnWhitelist;\n    ctxt->isServer = isServer;\n\n    PROBE(RPC_TLS_CONTEXT_NEW,\n          \"ctxt=%p cacert=%s cacrl=%s cert=%s key=%s sanityCheckCert=%d requireValidCert=%d isServer=%d\",\n          ctxt, cacert, NULLSTR(cacrl), cert, key, sanityCheckCert, requireValidCert, isServer);\n\n    return ctxt;\n\n error:\n    if (isServer)\n        gnutls_dh_params_deinit(ctxt->dhParams);\n    if (ctxt->x509cred)\n        gnutls_certificate_free_credentials(ctxt->x509cred);\n    VIR_FREE(ctxt->priority);\n    VIR_FREE(ctxt);\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define DH_BITS 2048"
          ],
          "globals_used": [
            "static virClassPtr virNetTLSContextClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\n#define DH_BITS 2048\n\nstatic virClassPtr virNetTLSContextClass;\n\nstatic virNetTLSContextPtr virNetTLSContextNew(const char *cacert,\n                                               const char *cacrl,\n                                               const char *cert,\n                                               const char *key,\n                                               const char *const*x509dnWhitelist,\n                                               const char *priority,\n                                               bool sanityCheckCert,\n                                               bool requireValidCert,\n                                               bool isServer)\n{\n    virNetTLSContextPtr ctxt;\n    int err;\n\n    if (virNetTLSContextInitialize() < 0)\n        return NULL;\n\n    if (!(ctxt = virObjectLockableNew(virNetTLSContextClass)))\n        return NULL;\n\n    ctxt->priority = g_strdup(priority);\n\n    err = gnutls_certificate_allocate_credentials(&ctxt->x509cred);\n    if (err) {\n        /* While gnutls_certificate_credentials_t will free any\n         * partially allocated credentials struct, it does not\n         * set the returned pointer back to NULL after it is\n         * freed in an error path.\n         */\n        ctxt->x509cred = NULL;\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to allocate x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    if (sanityCheckCert &&\n        virNetTLSContextSanityCheckCredentials(isServer, cacert, cert) < 0)\n        goto error;\n\n    if (virNetTLSContextLoadCredentials(ctxt, isServer, cacert, cacrl, cert, key) < 0)\n        goto error;\n\n    /* Generate Diffie Hellman parameters - for use with DHE\n     * kx algorithms. These should be discarded and regenerated\n     * once a day, once a week or once a month. Depending on the\n     * security requirements.\n     */\n    if (isServer) {\n        err = gnutls_dh_params_init(&ctxt->dhParams);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to initialize diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n        err = gnutls_dh_params_generate2(ctxt->dhParams, DH_BITS);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to generate diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n\n        gnutls_certificate_set_dh_params(ctxt->x509cred,\n                                         ctxt->dhParams);\n    }\n\n    ctxt->requireValidCert = requireValidCert;\n    ctxt->x509dnWhitelist = x509dnWhitelist;\n    ctxt->isServer = isServer;\n\n    PROBE(RPC_TLS_CONTEXT_NEW,\n          \"ctxt=%p cacert=%s cacrl=%s cert=%s key=%s sanityCheckCert=%d requireValidCert=%d isServer=%d\",\n          ctxt, cacert, NULLSTR(cacrl), cert, key, sanityCheckCert, requireValidCert, isServer);\n\n    return ctxt;\n\n error:\n    if (isServer)\n        gnutls_dh_params_deinit(ctxt->dhParams);\n    if (ctxt->x509cred)\n        gnutls_certificate_free_credentials(ctxt->x509cred);\n    VIR_FREE(ctxt->priority);\n    VIR_FREE(ctxt);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetTLSContextPtr virNetTLSContextNewServer(const char *cacert,\n                                              const char *cacrl,\n                                              const char *cert,\n                                              const char *key,\n                                              const char *const*x509dnWhitelist,\n                                              const char *priority,\n                                              bool sanityCheckCert,\n                                              bool requireValidCert)\n{\n    return virNetTLSContextNew(cacert, cacrl, cert, key, x509dnWhitelist, priority,\n                               sanityCheckCert, requireValidCert, true);\n}"
  },
  {
    "function_name": "virNetTLSContextNewClientPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "897-905",
    "snippet": "virNetTLSContextPtr virNetTLSContextNewClientPath(const char *pkipath,\n                                                  bool tryUserPkiPath,\n                                                  const char *priority,\n                                                  bool sanityCheckCert,\n                                                  bool requireValidCert)\n{\n    return virNetTLSContextNewPath(pkipath, tryUserPkiPath, NULL, priority,\n                                   sanityCheckCert, requireValidCert, false);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetTLSContextNewPath",
          "args": [
            "pkipath",
            "tryUserPkiPath",
            "NULL",
            "priority",
            "sanityCheckCert",
            "requireValidCert",
            "false"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextNewPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "859-884",
          "snippet": "static virNetTLSContextPtr virNetTLSContextNewPath(const char *pkipath,\n                                                   bool tryUserPkiPath,\n                                                   const char *const*x509dnWhitelist,\n                                                   const char *priority,\n                                                   bool sanityCheckCert,\n                                                   bool requireValidCert,\n                                                   bool isServer)\n{\n    char *cacert = NULL, *cacrl = NULL, *key = NULL, *cert = NULL;\n    virNetTLSContextPtr ctxt = NULL;\n\n    if (virNetTLSContextLocateCredentials(pkipath, tryUserPkiPath, isServer,\n                                          &cacert, &cacrl, &cert, &key) < 0)\n        return NULL;\n\n    ctxt = virNetTLSContextNew(cacert, cacrl, cert, key,\n                               x509dnWhitelist, priority, sanityCheckCert,\n                               requireValidCert, isServer);\n\n    VIR_FREE(cacert);\n    VIR_FREE(cacrl);\n    VIR_FREE(key);\n    VIR_FREE(cert);\n\n    return ctxt;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetTLSContextPtr virNetTLSContextNewPath(const char *pkipath,\n                                                   bool tryUserPkiPath,\n                                                   const char *const*x509dnWhitelist,\n                                                   const char *priority,\n                                                   bool sanityCheckCert,\n                                                   bool requireValidCert,\n                                                   bool isServer)\n{\n    char *cacert = NULL, *cacrl = NULL, *key = NULL, *cert = NULL;\n    virNetTLSContextPtr ctxt = NULL;\n\n    if (virNetTLSContextLocateCredentials(pkipath, tryUserPkiPath, isServer,\n                                          &cacert, &cacrl, &cert, &key) < 0)\n        return NULL;\n\n    ctxt = virNetTLSContextNew(cacert, cacrl, cert, key,\n                               x509dnWhitelist, priority, sanityCheckCert,\n                               requireValidCert, isServer);\n\n    VIR_FREE(cacert);\n    VIR_FREE(cacrl);\n    VIR_FREE(key);\n    VIR_FREE(cert);\n\n    return ctxt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetTLSContextPtr virNetTLSContextNewClientPath(const char *pkipath,\n                                                  bool tryUserPkiPath,\n                                                  const char *priority,\n                                                  bool sanityCheckCert,\n                                                  bool requireValidCert)\n{\n    return virNetTLSContextNewPath(pkipath, tryUserPkiPath, NULL, priority,\n                                   sanityCheckCert, requireValidCert, false);\n}"
  },
  {
    "function_name": "virNetTLSContextNewServerPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "886-895",
    "snippet": "virNetTLSContextPtr virNetTLSContextNewServerPath(const char *pkipath,\n                                                  bool tryUserPkiPath,\n                                                  const char *const*x509dnWhitelist,\n                                                  const char *priority,\n                                                  bool sanityCheckCert,\n                                                  bool requireValidCert)\n{\n    return virNetTLSContextNewPath(pkipath, tryUserPkiPath, x509dnWhitelist, priority,\n                                   sanityCheckCert, requireValidCert, true);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetTLSContextNewPath",
          "args": [
            "pkipath",
            "tryUserPkiPath",
            "x509dnWhitelist",
            "priority",
            "sanityCheckCert",
            "requireValidCert",
            "true"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextNewPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "859-884",
          "snippet": "static virNetTLSContextPtr virNetTLSContextNewPath(const char *pkipath,\n                                                   bool tryUserPkiPath,\n                                                   const char *const*x509dnWhitelist,\n                                                   const char *priority,\n                                                   bool sanityCheckCert,\n                                                   bool requireValidCert,\n                                                   bool isServer)\n{\n    char *cacert = NULL, *cacrl = NULL, *key = NULL, *cert = NULL;\n    virNetTLSContextPtr ctxt = NULL;\n\n    if (virNetTLSContextLocateCredentials(pkipath, tryUserPkiPath, isServer,\n                                          &cacert, &cacrl, &cert, &key) < 0)\n        return NULL;\n\n    ctxt = virNetTLSContextNew(cacert, cacrl, cert, key,\n                               x509dnWhitelist, priority, sanityCheckCert,\n                               requireValidCert, isServer);\n\n    VIR_FREE(cacert);\n    VIR_FREE(cacrl);\n    VIR_FREE(key);\n    VIR_FREE(cert);\n\n    return ctxt;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetTLSContextPtr virNetTLSContextNewPath(const char *pkipath,\n                                                   bool tryUserPkiPath,\n                                                   const char *const*x509dnWhitelist,\n                                                   const char *priority,\n                                                   bool sanityCheckCert,\n                                                   bool requireValidCert,\n                                                   bool isServer)\n{\n    char *cacert = NULL, *cacrl = NULL, *key = NULL, *cert = NULL;\n    virNetTLSContextPtr ctxt = NULL;\n\n    if (virNetTLSContextLocateCredentials(pkipath, tryUserPkiPath, isServer,\n                                          &cacert, &cacrl, &cert, &key) < 0)\n        return NULL;\n\n    ctxt = virNetTLSContextNew(cacert, cacrl, cert, key,\n                               x509dnWhitelist, priority, sanityCheckCert,\n                               requireValidCert, isServer);\n\n    VIR_FREE(cacert);\n    VIR_FREE(cacrl);\n    VIR_FREE(key);\n    VIR_FREE(cert);\n\n    return ctxt;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetTLSContextPtr virNetTLSContextNewServerPath(const char *pkipath,\n                                                  bool tryUserPkiPath,\n                                                  const char *const*x509dnWhitelist,\n                                                  const char *priority,\n                                                  bool sanityCheckCert,\n                                                  bool requireValidCert)\n{\n    return virNetTLSContextNewPath(pkipath, tryUserPkiPath, x509dnWhitelist, priority,\n                                   sanityCheckCert, requireValidCert, true);\n}"
  },
  {
    "function_name": "virNetTLSContextNewPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "859-884",
    "snippet": "static virNetTLSContextPtr virNetTLSContextNewPath(const char *pkipath,\n                                                   bool tryUserPkiPath,\n                                                   const char *const*x509dnWhitelist,\n                                                   const char *priority,\n                                                   bool sanityCheckCert,\n                                                   bool requireValidCert,\n                                                   bool isServer)\n{\n    char *cacert = NULL, *cacrl = NULL, *key = NULL, *cert = NULL;\n    virNetTLSContextPtr ctxt = NULL;\n\n    if (virNetTLSContextLocateCredentials(pkipath, tryUserPkiPath, isServer,\n                                          &cacert, &cacrl, &cert, &key) < 0)\n        return NULL;\n\n    ctxt = virNetTLSContextNew(cacert, cacrl, cert, key,\n                               x509dnWhitelist, priority, sanityCheckCert,\n                               requireValidCert, isServer);\n\n    VIR_FREE(cacert);\n    VIR_FREE(cacrl);\n    VIR_FREE(key);\n    VIR_FREE(cert);\n\n    return ctxt;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cert"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "key"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cacrl"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cacert"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSContextNew",
          "args": [
            "cacert",
            "cacrl",
            "cert",
            "key",
            "x509dnWhitelist",
            "priority",
            "sanityCheckCert",
            "requireValidCert",
            "isServer"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "674-760",
          "snippet": "static virNetTLSContextPtr virNetTLSContextNew(const char *cacert,\n                                               const char *cacrl,\n                                               const char *cert,\n                                               const char *key,\n                                               const char *const*x509dnWhitelist,\n                                               const char *priority,\n                                               bool sanityCheckCert,\n                                               bool requireValidCert,\n                                               bool isServer)\n{\n    virNetTLSContextPtr ctxt;\n    int err;\n\n    if (virNetTLSContextInitialize() < 0)\n        return NULL;\n\n    if (!(ctxt = virObjectLockableNew(virNetTLSContextClass)))\n        return NULL;\n\n    ctxt->priority = g_strdup(priority);\n\n    err = gnutls_certificate_allocate_credentials(&ctxt->x509cred);\n    if (err) {\n        /* While gnutls_certificate_credentials_t will free any\n         * partially allocated credentials struct, it does not\n         * set the returned pointer back to NULL after it is\n         * freed in an error path.\n         */\n        ctxt->x509cred = NULL;\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to allocate x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    if (sanityCheckCert &&\n        virNetTLSContextSanityCheckCredentials(isServer, cacert, cert) < 0)\n        goto error;\n\n    if (virNetTLSContextLoadCredentials(ctxt, isServer, cacert, cacrl, cert, key) < 0)\n        goto error;\n\n    /* Generate Diffie Hellman parameters - for use with DHE\n     * kx algorithms. These should be discarded and regenerated\n     * once a day, once a week or once a month. Depending on the\n     * security requirements.\n     */\n    if (isServer) {\n        err = gnutls_dh_params_init(&ctxt->dhParams);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to initialize diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n        err = gnutls_dh_params_generate2(ctxt->dhParams, DH_BITS);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to generate diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n\n        gnutls_certificate_set_dh_params(ctxt->x509cred,\n                                         ctxt->dhParams);\n    }\n\n    ctxt->requireValidCert = requireValidCert;\n    ctxt->x509dnWhitelist = x509dnWhitelist;\n    ctxt->isServer = isServer;\n\n    PROBE(RPC_TLS_CONTEXT_NEW,\n          \"ctxt=%p cacert=%s cacrl=%s cert=%s key=%s sanityCheckCert=%d requireValidCert=%d isServer=%d\",\n          ctxt, cacert, NULLSTR(cacrl), cert, key, sanityCheckCert, requireValidCert, isServer);\n\n    return ctxt;\n\n error:\n    if (isServer)\n        gnutls_dh_params_deinit(ctxt->dhParams);\n    if (ctxt->x509cred)\n        gnutls_certificate_free_credentials(ctxt->x509cred);\n    VIR_FREE(ctxt->priority);\n    VIR_FREE(ctxt);\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define DH_BITS 2048"
          ],
          "globals_used": [
            "static virClassPtr virNetTLSContextClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\n#define DH_BITS 2048\n\nstatic virClassPtr virNetTLSContextClass;\n\nstatic virNetTLSContextPtr virNetTLSContextNew(const char *cacert,\n                                               const char *cacrl,\n                                               const char *cert,\n                                               const char *key,\n                                               const char *const*x509dnWhitelist,\n                                               const char *priority,\n                                               bool sanityCheckCert,\n                                               bool requireValidCert,\n                                               bool isServer)\n{\n    virNetTLSContextPtr ctxt;\n    int err;\n\n    if (virNetTLSContextInitialize() < 0)\n        return NULL;\n\n    if (!(ctxt = virObjectLockableNew(virNetTLSContextClass)))\n        return NULL;\n\n    ctxt->priority = g_strdup(priority);\n\n    err = gnutls_certificate_allocate_credentials(&ctxt->x509cred);\n    if (err) {\n        /* While gnutls_certificate_credentials_t will free any\n         * partially allocated credentials struct, it does not\n         * set the returned pointer back to NULL after it is\n         * freed in an error path.\n         */\n        ctxt->x509cred = NULL;\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to allocate x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    if (sanityCheckCert &&\n        virNetTLSContextSanityCheckCredentials(isServer, cacert, cert) < 0)\n        goto error;\n\n    if (virNetTLSContextLoadCredentials(ctxt, isServer, cacert, cacrl, cert, key) < 0)\n        goto error;\n\n    /* Generate Diffie Hellman parameters - for use with DHE\n     * kx algorithms. These should be discarded and regenerated\n     * once a day, once a week or once a month. Depending on the\n     * security requirements.\n     */\n    if (isServer) {\n        err = gnutls_dh_params_init(&ctxt->dhParams);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to initialize diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n        err = gnutls_dh_params_generate2(ctxt->dhParams, DH_BITS);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to generate diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n\n        gnutls_certificate_set_dh_params(ctxt->x509cred,\n                                         ctxt->dhParams);\n    }\n\n    ctxt->requireValidCert = requireValidCert;\n    ctxt->x509dnWhitelist = x509dnWhitelist;\n    ctxt->isServer = isServer;\n\n    PROBE(RPC_TLS_CONTEXT_NEW,\n          \"ctxt=%p cacert=%s cacrl=%s cert=%s key=%s sanityCheckCert=%d requireValidCert=%d isServer=%d\",\n          ctxt, cacert, NULLSTR(cacrl), cert, key, sanityCheckCert, requireValidCert, isServer);\n\n    return ctxt;\n\n error:\n    if (isServer)\n        gnutls_dh_params_deinit(ctxt->dhParams);\n    if (ctxt->x509cred)\n        gnutls_certificate_free_credentials(ctxt->x509cred);\n    VIR_FREE(ctxt->priority);\n    VIR_FREE(ctxt);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSContextLocateCredentials",
          "args": [
            "pkipath",
            "tryUserPkiPath",
            "isServer",
            "&cacert",
            "&cacrl",
            "&cert",
            "&key"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextLocateCredentials",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "763-856",
          "snippet": "static int virNetTLSContextLocateCredentials(const char *pkipath,\n                                             bool tryUserPkiPath,\n                                             bool isServer,\n                                             char **cacert,\n                                             char **cacrl,\n                                             char **cert,\n                                             char **key)\n{\n    char *userdir = NULL;\n    char *user_pki_path = NULL;\n\n    *cacert = NULL;\n    *cacrl = NULL;\n    *key = NULL;\n    *cert = NULL;\n\n    VIR_DEBUG(\"pkipath=%s isServer=%d tryUserPkiPath=%d\",\n              pkipath, isServer, tryUserPkiPath);\n\n    /* Explicit path, then use that no matter whether the\n     * files actually exist there\n     */\n    if (pkipath) {\n        VIR_DEBUG(\"Told to use TLS credentials in %s\", pkipath);\n        *cacert = g_strdup_printf(\"%s/%s\", pkipath, \"cacert.pem\");\n        *cacrl = g_strdup_printf(\"%s/%s\", pkipath, \"cacrl.pem\");\n        *key = g_strdup_printf(\"%s/%s\", pkipath,\n                               isServer ? \"serverkey.pem\" : \"clientkey.pem\");\n\n        *cert = g_strdup_printf(\"%s/%s\", pkipath,\n                                isServer ? \"servercert.pem\" : \"clientcert.pem\");\n    } else if (tryUserPkiPath) {\n        /* Check to see if $HOME/.pki contains at least one of the\n         * files and if so, use that\n         */\n        userdir = virGetUserDirectory();\n\n        user_pki_path = g_strdup_printf(\"%s/.pki/libvirt\", userdir);\n\n        VIR_DEBUG(\"Trying to find TLS user credentials in %s\", user_pki_path);\n\n        *cacert = g_strdup_printf(\"%s/%s\", user_pki_path, \"cacert.pem\");\n\n        *cacrl = g_strdup_printf(\"%s/%s\", user_pki_path, \"cacrl.pem\");\n\n        *key = g_strdup_printf(\"%s/%s\", user_pki_path,\n                               isServer ? \"serverkey.pem\" : \"clientkey.pem\");\n\n        *cert = g_strdup_printf(\"%s/%s\", user_pki_path,\n                                isServer ? \"servercert.pem\" : \"clientcert.pem\");\n\n        /*\n         * If some of the files can't be found, fallback\n         * to the global location for them\n         */\n        if (!virFileExists(*cacert))\n            VIR_FREE(*cacert);\n        if (!virFileExists(*cacrl))\n            VIR_FREE(*cacrl);\n\n        /* Check these as a pair, since it they are\n         * mutually dependent\n         */\n        if (!virFileExists(*key) || !virFileExists(*cert)) {\n            VIR_FREE(*key);\n            VIR_FREE(*cert);\n        }\n    }\n\n    /* No explicit path, or user path didn't exist, so\n     * fallback to global defaults\n     */\n    if (!*cacert) {\n        VIR_DEBUG(\"Using default TLS CA certificate path\");\n        *cacert = g_strdup(LIBVIRT_CACERT);\n    }\n\n    if (!*cacrl) {\n        VIR_DEBUG(\"Using default TLS CA revocation list path\");\n        *cacrl = g_strdup(LIBVIRT_CACRL);\n    }\n\n    if (!*key && !*cert) {\n        VIR_DEBUG(\"Using default TLS key/certificate path\");\n        *key = g_strdup(isServer ? LIBVIRT_SERVERKEY : LIBVIRT_CLIENTKEY);\n\n        *cert = g_strdup(isServer ? LIBVIRT_SERVERCERT : LIBVIRT_CLIENTCERT);\n    }\n\n    VIR_FREE(user_pki_path);\n    VIR_FREE(userdir);\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBVIRT_SERVERCERT LIBVIRT_PKI_DIR \"/libvirt/servercert.pem\"",
            "#define LIBVIRT_SERVERKEY LIBVIRT_PKI_DIR \"/libvirt/private/serverkey.pem\"",
            "#define LIBVIRT_CLIENTCERT LIBVIRT_PKI_DIR \"/libvirt/clientcert.pem\"",
            "#define LIBVIRT_CLIENTKEY LIBVIRT_PKI_DIR \"/libvirt/private/clientkey.pem\"",
            "#define LIBVIRT_CACRL LIBVIRT_PKI_DIR \"/CA/cacrl.pem\"",
            "#define LIBVIRT_CACERT LIBVIRT_PKI_DIR \"/CA/cacert.pem\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\n#define LIBVIRT_SERVERCERT LIBVIRT_PKI_DIR \"/libvirt/servercert.pem\"\n#define LIBVIRT_SERVERKEY LIBVIRT_PKI_DIR \"/libvirt/private/serverkey.pem\"\n#define LIBVIRT_CLIENTCERT LIBVIRT_PKI_DIR \"/libvirt/clientcert.pem\"\n#define LIBVIRT_CLIENTKEY LIBVIRT_PKI_DIR \"/libvirt/private/clientkey.pem\"\n#define LIBVIRT_CACRL LIBVIRT_PKI_DIR \"/CA/cacrl.pem\"\n#define LIBVIRT_CACERT LIBVIRT_PKI_DIR \"/CA/cacert.pem\"\n\nstatic int virNetTLSContextLocateCredentials(const char *pkipath,\n                                             bool tryUserPkiPath,\n                                             bool isServer,\n                                             char **cacert,\n                                             char **cacrl,\n                                             char **cert,\n                                             char **key)\n{\n    char *userdir = NULL;\n    char *user_pki_path = NULL;\n\n    *cacert = NULL;\n    *cacrl = NULL;\n    *key = NULL;\n    *cert = NULL;\n\n    VIR_DEBUG(\"pkipath=%s isServer=%d tryUserPkiPath=%d\",\n              pkipath, isServer, tryUserPkiPath);\n\n    /* Explicit path, then use that no matter whether the\n     * files actually exist there\n     */\n    if (pkipath) {\n        VIR_DEBUG(\"Told to use TLS credentials in %s\", pkipath);\n        *cacert = g_strdup_printf(\"%s/%s\", pkipath, \"cacert.pem\");\n        *cacrl = g_strdup_printf(\"%s/%s\", pkipath, \"cacrl.pem\");\n        *key = g_strdup_printf(\"%s/%s\", pkipath,\n                               isServer ? \"serverkey.pem\" : \"clientkey.pem\");\n\n        *cert = g_strdup_printf(\"%s/%s\", pkipath,\n                                isServer ? \"servercert.pem\" : \"clientcert.pem\");\n    } else if (tryUserPkiPath) {\n        /* Check to see if $HOME/.pki contains at least one of the\n         * files and if so, use that\n         */\n        userdir = virGetUserDirectory();\n\n        user_pki_path = g_strdup_printf(\"%s/.pki/libvirt\", userdir);\n\n        VIR_DEBUG(\"Trying to find TLS user credentials in %s\", user_pki_path);\n\n        *cacert = g_strdup_printf(\"%s/%s\", user_pki_path, \"cacert.pem\");\n\n        *cacrl = g_strdup_printf(\"%s/%s\", user_pki_path, \"cacrl.pem\");\n\n        *key = g_strdup_printf(\"%s/%s\", user_pki_path,\n                               isServer ? \"serverkey.pem\" : \"clientkey.pem\");\n\n        *cert = g_strdup_printf(\"%s/%s\", user_pki_path,\n                                isServer ? \"servercert.pem\" : \"clientcert.pem\");\n\n        /*\n         * If some of the files can't be found, fallback\n         * to the global location for them\n         */\n        if (!virFileExists(*cacert))\n            VIR_FREE(*cacert);\n        if (!virFileExists(*cacrl))\n            VIR_FREE(*cacrl);\n\n        /* Check these as a pair, since it they are\n         * mutually dependent\n         */\n        if (!virFileExists(*key) || !virFileExists(*cert)) {\n            VIR_FREE(*key);\n            VIR_FREE(*cert);\n        }\n    }\n\n    /* No explicit path, or user path didn't exist, so\n     * fallback to global defaults\n     */\n    if (!*cacert) {\n        VIR_DEBUG(\"Using default TLS CA certificate path\");\n        *cacert = g_strdup(LIBVIRT_CACERT);\n    }\n\n    if (!*cacrl) {\n        VIR_DEBUG(\"Using default TLS CA revocation list path\");\n        *cacrl = g_strdup(LIBVIRT_CACRL);\n    }\n\n    if (!*key && !*cert) {\n        VIR_DEBUG(\"Using default TLS key/certificate path\");\n        *key = g_strdup(isServer ? LIBVIRT_SERVERKEY : LIBVIRT_CLIENTKEY);\n\n        *cert = g_strdup(isServer ? LIBVIRT_SERVERCERT : LIBVIRT_CLIENTCERT);\n    }\n\n    VIR_FREE(user_pki_path);\n    VIR_FREE(userdir);\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetTLSContextPtr virNetTLSContextNewPath(const char *pkipath,\n                                                   bool tryUserPkiPath,\n                                                   const char *const*x509dnWhitelist,\n                                                   const char *priority,\n                                                   bool sanityCheckCert,\n                                                   bool requireValidCert,\n                                                   bool isServer)\n{\n    char *cacert = NULL, *cacrl = NULL, *key = NULL, *cert = NULL;\n    virNetTLSContextPtr ctxt = NULL;\n\n    if (virNetTLSContextLocateCredentials(pkipath, tryUserPkiPath, isServer,\n                                          &cacert, &cacrl, &cert, &key) < 0)\n        return NULL;\n\n    ctxt = virNetTLSContextNew(cacert, cacrl, cert, key,\n                               x509dnWhitelist, priority, sanityCheckCert,\n                               requireValidCert, isServer);\n\n    VIR_FREE(cacert);\n    VIR_FREE(cacrl);\n    VIR_FREE(key);\n    VIR_FREE(cert);\n\n    return ctxt;\n}"
  },
  {
    "function_name": "virNetTLSContextLocateCredentials",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "763-856",
    "snippet": "static int virNetTLSContextLocateCredentials(const char *pkipath,\n                                             bool tryUserPkiPath,\n                                             bool isServer,\n                                             char **cacert,\n                                             char **cacrl,\n                                             char **cert,\n                                             char **key)\n{\n    char *userdir = NULL;\n    char *user_pki_path = NULL;\n\n    *cacert = NULL;\n    *cacrl = NULL;\n    *key = NULL;\n    *cert = NULL;\n\n    VIR_DEBUG(\"pkipath=%s isServer=%d tryUserPkiPath=%d\",\n              pkipath, isServer, tryUserPkiPath);\n\n    /* Explicit path, then use that no matter whether the\n     * files actually exist there\n     */\n    if (pkipath) {\n        VIR_DEBUG(\"Told to use TLS credentials in %s\", pkipath);\n        *cacert = g_strdup_printf(\"%s/%s\", pkipath, \"cacert.pem\");\n        *cacrl = g_strdup_printf(\"%s/%s\", pkipath, \"cacrl.pem\");\n        *key = g_strdup_printf(\"%s/%s\", pkipath,\n                               isServer ? \"serverkey.pem\" : \"clientkey.pem\");\n\n        *cert = g_strdup_printf(\"%s/%s\", pkipath,\n                                isServer ? \"servercert.pem\" : \"clientcert.pem\");\n    } else if (tryUserPkiPath) {\n        /* Check to see if $HOME/.pki contains at least one of the\n         * files and if so, use that\n         */\n        userdir = virGetUserDirectory();\n\n        user_pki_path = g_strdup_printf(\"%s/.pki/libvirt\", userdir);\n\n        VIR_DEBUG(\"Trying to find TLS user credentials in %s\", user_pki_path);\n\n        *cacert = g_strdup_printf(\"%s/%s\", user_pki_path, \"cacert.pem\");\n\n        *cacrl = g_strdup_printf(\"%s/%s\", user_pki_path, \"cacrl.pem\");\n\n        *key = g_strdup_printf(\"%s/%s\", user_pki_path,\n                               isServer ? \"serverkey.pem\" : \"clientkey.pem\");\n\n        *cert = g_strdup_printf(\"%s/%s\", user_pki_path,\n                                isServer ? \"servercert.pem\" : \"clientcert.pem\");\n\n        /*\n         * If some of the files can't be found, fallback\n         * to the global location for them\n         */\n        if (!virFileExists(*cacert))\n            VIR_FREE(*cacert);\n        if (!virFileExists(*cacrl))\n            VIR_FREE(*cacrl);\n\n        /* Check these as a pair, since it they are\n         * mutually dependent\n         */\n        if (!virFileExists(*key) || !virFileExists(*cert)) {\n            VIR_FREE(*key);\n            VIR_FREE(*cert);\n        }\n    }\n\n    /* No explicit path, or user path didn't exist, so\n     * fallback to global defaults\n     */\n    if (!*cacert) {\n        VIR_DEBUG(\"Using default TLS CA certificate path\");\n        *cacert = g_strdup(LIBVIRT_CACERT);\n    }\n\n    if (!*cacrl) {\n        VIR_DEBUG(\"Using default TLS CA revocation list path\");\n        *cacrl = g_strdup(LIBVIRT_CACRL);\n    }\n\n    if (!*key && !*cert) {\n        VIR_DEBUG(\"Using default TLS key/certificate path\");\n        *key = g_strdup(isServer ? LIBVIRT_SERVERKEY : LIBVIRT_CLIENTKEY);\n\n        *cert = g_strdup(isServer ? LIBVIRT_SERVERCERT : LIBVIRT_CLIENTCERT);\n    }\n\n    VIR_FREE(user_pki_path);\n    VIR_FREE(userdir);\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define LIBVIRT_SERVERCERT LIBVIRT_PKI_DIR \"/libvirt/servercert.pem\"",
      "#define LIBVIRT_SERVERKEY LIBVIRT_PKI_DIR \"/libvirt/private/serverkey.pem\"",
      "#define LIBVIRT_CLIENTCERT LIBVIRT_PKI_DIR \"/libvirt/clientcert.pem\"",
      "#define LIBVIRT_CLIENTKEY LIBVIRT_PKI_DIR \"/libvirt/private/clientkey.pem\"",
      "#define LIBVIRT_CACRL LIBVIRT_PKI_DIR \"/CA/cacrl.pem\"",
      "#define LIBVIRT_CACERT LIBVIRT_PKI_DIR \"/CA/cacert.pem\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "userdir"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "user_pki_path"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "isServer ? LIBVIRT_SERVERCERT : LIBVIRT_CLIENTCERT"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Using default TLS key/certificate path\""
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Using default TLS CA revocation list path\""
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Using default TLS CA certificate path\""
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*cert"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*key"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "*cert"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*cacrl"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*cacert"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Trying to find TLS user credentials in %s\"",
            "user_pki_path"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetUserDirectory",
          "args": [],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "567-571",
          "snippet": "char *\nvirGetUserDirectory(void)\n{\n    return g_strdup(g_get_home_dir());\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirGetUserDirectory(void)\n{\n    return g_strdup(g_get_home_dir());\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Told to use TLS credentials in %s\"",
            "pkipath"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"pkipath=%s isServer=%d tryUserPkiPath=%d\"",
            "pkipath",
            "isServer",
            "tryUserPkiPath"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\n#define LIBVIRT_SERVERCERT LIBVIRT_PKI_DIR \"/libvirt/servercert.pem\"\n#define LIBVIRT_SERVERKEY LIBVIRT_PKI_DIR \"/libvirt/private/serverkey.pem\"\n#define LIBVIRT_CLIENTCERT LIBVIRT_PKI_DIR \"/libvirt/clientcert.pem\"\n#define LIBVIRT_CLIENTKEY LIBVIRT_PKI_DIR \"/libvirt/private/clientkey.pem\"\n#define LIBVIRT_CACRL LIBVIRT_PKI_DIR \"/CA/cacrl.pem\"\n#define LIBVIRT_CACERT LIBVIRT_PKI_DIR \"/CA/cacert.pem\"\n\nstatic int virNetTLSContextLocateCredentials(const char *pkipath,\n                                             bool tryUserPkiPath,\n                                             bool isServer,\n                                             char **cacert,\n                                             char **cacrl,\n                                             char **cert,\n                                             char **key)\n{\n    char *userdir = NULL;\n    char *user_pki_path = NULL;\n\n    *cacert = NULL;\n    *cacrl = NULL;\n    *key = NULL;\n    *cert = NULL;\n\n    VIR_DEBUG(\"pkipath=%s isServer=%d tryUserPkiPath=%d\",\n              pkipath, isServer, tryUserPkiPath);\n\n    /* Explicit path, then use that no matter whether the\n     * files actually exist there\n     */\n    if (pkipath) {\n        VIR_DEBUG(\"Told to use TLS credentials in %s\", pkipath);\n        *cacert = g_strdup_printf(\"%s/%s\", pkipath, \"cacert.pem\");\n        *cacrl = g_strdup_printf(\"%s/%s\", pkipath, \"cacrl.pem\");\n        *key = g_strdup_printf(\"%s/%s\", pkipath,\n                               isServer ? \"serverkey.pem\" : \"clientkey.pem\");\n\n        *cert = g_strdup_printf(\"%s/%s\", pkipath,\n                                isServer ? \"servercert.pem\" : \"clientcert.pem\");\n    } else if (tryUserPkiPath) {\n        /* Check to see if $HOME/.pki contains at least one of the\n         * files and if so, use that\n         */\n        userdir = virGetUserDirectory();\n\n        user_pki_path = g_strdup_printf(\"%s/.pki/libvirt\", userdir);\n\n        VIR_DEBUG(\"Trying to find TLS user credentials in %s\", user_pki_path);\n\n        *cacert = g_strdup_printf(\"%s/%s\", user_pki_path, \"cacert.pem\");\n\n        *cacrl = g_strdup_printf(\"%s/%s\", user_pki_path, \"cacrl.pem\");\n\n        *key = g_strdup_printf(\"%s/%s\", user_pki_path,\n                               isServer ? \"serverkey.pem\" : \"clientkey.pem\");\n\n        *cert = g_strdup_printf(\"%s/%s\", user_pki_path,\n                                isServer ? \"servercert.pem\" : \"clientcert.pem\");\n\n        /*\n         * If some of the files can't be found, fallback\n         * to the global location for them\n         */\n        if (!virFileExists(*cacert))\n            VIR_FREE(*cacert);\n        if (!virFileExists(*cacrl))\n            VIR_FREE(*cacrl);\n\n        /* Check these as a pair, since it they are\n         * mutually dependent\n         */\n        if (!virFileExists(*key) || !virFileExists(*cert)) {\n            VIR_FREE(*key);\n            VIR_FREE(*cert);\n        }\n    }\n\n    /* No explicit path, or user path didn't exist, so\n     * fallback to global defaults\n     */\n    if (!*cacert) {\n        VIR_DEBUG(\"Using default TLS CA certificate path\");\n        *cacert = g_strdup(LIBVIRT_CACERT);\n    }\n\n    if (!*cacrl) {\n        VIR_DEBUG(\"Using default TLS CA revocation list path\");\n        *cacrl = g_strdup(LIBVIRT_CACRL);\n    }\n\n    if (!*key && !*cert) {\n        VIR_DEBUG(\"Using default TLS key/certificate path\");\n        *key = g_strdup(isServer ? LIBVIRT_SERVERKEY : LIBVIRT_CLIENTKEY);\n\n        *cert = g_strdup(isServer ? LIBVIRT_SERVERCERT : LIBVIRT_CLIENTCERT);\n    }\n\n    VIR_FREE(user_pki_path);\n    VIR_FREE(userdir);\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetTLSContextNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "674-760",
    "snippet": "static virNetTLSContextPtr virNetTLSContextNew(const char *cacert,\n                                               const char *cacrl,\n                                               const char *cert,\n                                               const char *key,\n                                               const char *const*x509dnWhitelist,\n                                               const char *priority,\n                                               bool sanityCheckCert,\n                                               bool requireValidCert,\n                                               bool isServer)\n{\n    virNetTLSContextPtr ctxt;\n    int err;\n\n    if (virNetTLSContextInitialize() < 0)\n        return NULL;\n\n    if (!(ctxt = virObjectLockableNew(virNetTLSContextClass)))\n        return NULL;\n\n    ctxt->priority = g_strdup(priority);\n\n    err = gnutls_certificate_allocate_credentials(&ctxt->x509cred);\n    if (err) {\n        /* While gnutls_certificate_credentials_t will free any\n         * partially allocated credentials struct, it does not\n         * set the returned pointer back to NULL after it is\n         * freed in an error path.\n         */\n        ctxt->x509cred = NULL;\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to allocate x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    if (sanityCheckCert &&\n        virNetTLSContextSanityCheckCredentials(isServer, cacert, cert) < 0)\n        goto error;\n\n    if (virNetTLSContextLoadCredentials(ctxt, isServer, cacert, cacrl, cert, key) < 0)\n        goto error;\n\n    /* Generate Diffie Hellman parameters - for use with DHE\n     * kx algorithms. These should be discarded and regenerated\n     * once a day, once a week or once a month. Depending on the\n     * security requirements.\n     */\n    if (isServer) {\n        err = gnutls_dh_params_init(&ctxt->dhParams);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to initialize diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n        err = gnutls_dh_params_generate2(ctxt->dhParams, DH_BITS);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to generate diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n\n        gnutls_certificate_set_dh_params(ctxt->x509cred,\n                                         ctxt->dhParams);\n    }\n\n    ctxt->requireValidCert = requireValidCert;\n    ctxt->x509dnWhitelist = x509dnWhitelist;\n    ctxt->isServer = isServer;\n\n    PROBE(RPC_TLS_CONTEXT_NEW,\n          \"ctxt=%p cacert=%s cacrl=%s cert=%s key=%s sanityCheckCert=%d requireValidCert=%d isServer=%d\",\n          ctxt, cacert, NULLSTR(cacrl), cert, key, sanityCheckCert, requireValidCert, isServer);\n\n    return ctxt;\n\n error:\n    if (isServer)\n        gnutls_dh_params_deinit(ctxt->dhParams);\n    if (ctxt->x509cred)\n        gnutls_certificate_free_credentials(ctxt->x509cred);\n    VIR_FREE(ctxt->priority);\n    VIR_FREE(ctxt);\n    return NULL;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define DH_BITS 2048"
    ],
    "globals_used": [
      "static virClassPtr virNetTLSContextClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ctxt"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ctxt->priority"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_free_credentials",
          "args": [
            "ctxt->x509cred"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_dh_params_deinit",
          "args": [
            "ctxt->dhParams"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "RPC_TLS_CONTEXT_NEW",
            "\"ctxt=%p cacert=%s cacrl=%s cert=%s key=%s sanityCheckCert=%d requireValidCert=%d isServer=%d\"",
            "ctxt",
            "cacert",
            "NULLSTR(cacrl)",
            "cert",
            "key",
            "sanityCheckCert",
            "requireValidCert",
            "isServer"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cacrl"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_set_dh_params",
          "args": [
            "ctxt->x509cred",
            "ctxt->dhParams"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to generate diffie-hellman parameters: %s\")",
            "gnutls_strerror(err)"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "err"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to generate diffie-hellman parameters: %s\""
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_dh_params_generate2",
          "args": [
            "ctxt->dhParams",
            "DH_BITS"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to initialize diffie-hellman parameters: %s\")",
            "gnutls_strerror(err)"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "err"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_dh_params_init",
          "args": [
            "&ctxt->dhParams"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSContextLoadCredentials",
          "args": [
            "ctxt",
            "isServer",
            "cacert",
            "cacrl",
            "cert",
            "key"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextLoadCredentials",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "598-671",
          "snippet": "static int virNetTLSContextLoadCredentials(virNetTLSContextPtr ctxt,\n                                           bool isServer,\n                                           const char *cacert,\n                                           const char *cacrl,\n                                           const char *cert,\n                                           const char *key)\n{\n    int err;\n\n    if (cacert && cacert[0] != '\\0') {\n        if (virNetTLSContextCheckCertFile(\"CA certificate\", cacert, false) < 0)\n            return -1;\n\n        VIR_DEBUG(\"loading CA cert from %s\", cacert);\n        err = gnutls_certificate_set_x509_trust_file(ctxt->x509cred,\n                                                     cacert,\n                                                     GNUTLS_X509_FMT_PEM);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to set x509 CA certificate: %s: %s\"),\n                           cacert, gnutls_strerror(err));\n            return -1;\n        }\n    }\n\n    if (cacrl && cacrl[0] != '\\0') {\n        int rv;\n        if ((rv = virNetTLSContextCheckCertFile(\"CA revocation list\", cacrl, true)) < 0)\n            return -1;\n\n        if (rv == 0) {\n            VIR_DEBUG(\"loading CRL from %s\", cacrl);\n            err = gnutls_certificate_set_x509_crl_file(ctxt->x509cred,\n                                                       cacrl,\n                                                       GNUTLS_X509_FMT_PEM);\n            if (err < 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Unable to set x509 certificate revocation list: %s: %s\"),\n                               cacrl, gnutls_strerror(err));\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"Skipping non-existent CA CRL %s\", cacrl);\n        }\n    }\n\n    if (cert && cert[0] != '\\0' && key && key[0] != '\\0') {\n        int rv;\n        if ((rv = virNetTLSContextCheckCertFile(\"certificate\", cert, !isServer)) < 0)\n            return -1;\n        if (rv == 0 &&\n            (rv = virNetTLSContextCheckCertFile(\"private key\", key, !isServer)) < 0)\n            return -1;\n\n        if (rv == 0) {\n            VIR_DEBUG(\"loading cert and key from %s and %s\", cert, key);\n            err =\n                gnutls_certificate_set_x509_key_file(ctxt->x509cred,\n                                                     cert, key,\n                                                     GNUTLS_X509_FMT_PEM);\n            if (err < 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Unable to set x509 key and certificate: %s, %s: %s\"),\n                               key, cert, gnutls_strerror(err));\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"Skipping non-existent cert %s key %s on client\",\n                      cert, key);\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextLoadCredentials(virNetTLSContextPtr ctxt,\n                                           bool isServer,\n                                           const char *cacert,\n                                           const char *cacrl,\n                                           const char *cert,\n                                           const char *key)\n{\n    int err;\n\n    if (cacert && cacert[0] != '\\0') {\n        if (virNetTLSContextCheckCertFile(\"CA certificate\", cacert, false) < 0)\n            return -1;\n\n        VIR_DEBUG(\"loading CA cert from %s\", cacert);\n        err = gnutls_certificate_set_x509_trust_file(ctxt->x509cred,\n                                                     cacert,\n                                                     GNUTLS_X509_FMT_PEM);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to set x509 CA certificate: %s: %s\"),\n                           cacert, gnutls_strerror(err));\n            return -1;\n        }\n    }\n\n    if (cacrl && cacrl[0] != '\\0') {\n        int rv;\n        if ((rv = virNetTLSContextCheckCertFile(\"CA revocation list\", cacrl, true)) < 0)\n            return -1;\n\n        if (rv == 0) {\n            VIR_DEBUG(\"loading CRL from %s\", cacrl);\n            err = gnutls_certificate_set_x509_crl_file(ctxt->x509cred,\n                                                       cacrl,\n                                                       GNUTLS_X509_FMT_PEM);\n            if (err < 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Unable to set x509 certificate revocation list: %s: %s\"),\n                               cacrl, gnutls_strerror(err));\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"Skipping non-existent CA CRL %s\", cacrl);\n        }\n    }\n\n    if (cert && cert[0] != '\\0' && key && key[0] != '\\0') {\n        int rv;\n        if ((rv = virNetTLSContextCheckCertFile(\"certificate\", cert, !isServer)) < 0)\n            return -1;\n        if (rv == 0 &&\n            (rv = virNetTLSContextCheckCertFile(\"private key\", key, !isServer)) < 0)\n            return -1;\n\n        if (rv == 0) {\n            VIR_DEBUG(\"loading cert and key from %s and %s\", cert, key);\n            err =\n                gnutls_certificate_set_x509_key_file(ctxt->x509cred,\n                                                     cert, key,\n                                                     GNUTLS_X509_FMT_PEM);\n            if (err < 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Unable to set x509 key and certificate: %s, %s: %s\"),\n                               key, cert, gnutls_strerror(err));\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"Skipping non-existent cert %s key %s on client\",\n                      cert, key);\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSContextSanityCheckCredentials",
          "args": [
            "isServer",
            "cacert",
            "cert"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextSanityCheckCredentials",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "555-595",
          "snippet": "static int virNetTLSContextSanityCheckCredentials(bool isServer,\n                                                  const char *cacertFile,\n                                                  const char *certFile)\n{\n    gnutls_x509_crt_t cert = NULL;\n    gnutls_x509_crt_t cacerts[MAX_CERTS];\n    size_t ncacerts = 0;\n    size_t i;\n    int ret = -1;\n\n    memset(cacerts, 0, sizeof(cacerts));\n    if ((access(certFile, R_OK) == 0) &&\n        !(cert = virNetTLSContextLoadCertFromFile(certFile, isServer)))\n        goto cleanup;\n    if ((access(cacertFile, R_OK) == 0) &&\n        virNetTLSContextLoadCACertListFromFile(cacertFile, cacerts,\n                                               MAX_CERTS, &ncacerts) < 0)\n        goto cleanup;\n\n    if (cert &&\n        virNetTLSContextCheckCert(cert, certFile, isServer, false) < 0)\n        goto cleanup;\n\n    for (i = 0; i < ncacerts; i++) {\n        if (virNetTLSContextCheckCert(cacerts[i], cacertFile, isServer, true) < 0)\n            goto cleanup;\n    }\n\n    if (cert && ncacerts &&\n        virNetTLSContextCheckCertPair(cert, certFile, cacerts, ncacerts, cacertFile, isServer) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (cert)\n        gnutls_x509_crt_deinit(cert);\n    for (i = 0; i < ncacerts; i++)\n        gnutls_x509_crt_deinit(cacerts[i]);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_CERTS 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\n#define MAX_CERTS 16\n\nstatic int virNetTLSContextSanityCheckCredentials(bool isServer,\n                                                  const char *cacertFile,\n                                                  const char *certFile)\n{\n    gnutls_x509_crt_t cert = NULL;\n    gnutls_x509_crt_t cacerts[MAX_CERTS];\n    size_t ncacerts = 0;\n    size_t i;\n    int ret = -1;\n\n    memset(cacerts, 0, sizeof(cacerts));\n    if ((access(certFile, R_OK) == 0) &&\n        !(cert = virNetTLSContextLoadCertFromFile(certFile, isServer)))\n        goto cleanup;\n    if ((access(cacertFile, R_OK) == 0) &&\n        virNetTLSContextLoadCACertListFromFile(cacertFile, cacerts,\n                                               MAX_CERTS, &ncacerts) < 0)\n        goto cleanup;\n\n    if (cert &&\n        virNetTLSContextCheckCert(cert, certFile, isServer, false) < 0)\n        goto cleanup;\n\n    for (i = 0; i < ncacerts; i++) {\n        if (virNetTLSContextCheckCert(cacerts[i], cacertFile, isServer, true) < 0)\n            goto cleanup;\n    }\n\n    if (cert && ncacerts &&\n        virNetTLSContextCheckCertPair(cert, certFile, cacerts, ncacerts, cacertFile, isServer) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (cert)\n        gnutls_x509_crt_deinit(cert);\n    for (i = 0; i < ncacerts; i++)\n        gnutls_x509_crt_deinit(cacerts[i]);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to allocate x509 credentials: %s\")",
            "gnutls_strerror(err)"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "err"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_allocate_credentials",
          "args": [
            "&ctxt->x509cred"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "virNetTLSContextClass"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSContextInitialize",
          "args": [],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\n#define DH_BITS 2048\n\nstatic virClassPtr virNetTLSContextClass;\n\nstatic virNetTLSContextPtr virNetTLSContextNew(const char *cacert,\n                                               const char *cacrl,\n                                               const char *cert,\n                                               const char *key,\n                                               const char *const*x509dnWhitelist,\n                                               const char *priority,\n                                               bool sanityCheckCert,\n                                               bool requireValidCert,\n                                               bool isServer)\n{\n    virNetTLSContextPtr ctxt;\n    int err;\n\n    if (virNetTLSContextInitialize() < 0)\n        return NULL;\n\n    if (!(ctxt = virObjectLockableNew(virNetTLSContextClass)))\n        return NULL;\n\n    ctxt->priority = g_strdup(priority);\n\n    err = gnutls_certificate_allocate_credentials(&ctxt->x509cred);\n    if (err) {\n        /* While gnutls_certificate_credentials_t will free any\n         * partially allocated credentials struct, it does not\n         * set the returned pointer back to NULL after it is\n         * freed in an error path.\n         */\n        ctxt->x509cred = NULL;\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to allocate x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    if (sanityCheckCert &&\n        virNetTLSContextSanityCheckCredentials(isServer, cacert, cert) < 0)\n        goto error;\n\n    if (virNetTLSContextLoadCredentials(ctxt, isServer, cacert, cacrl, cert, key) < 0)\n        goto error;\n\n    /* Generate Diffie Hellman parameters - for use with DHE\n     * kx algorithms. These should be discarded and regenerated\n     * once a day, once a week or once a month. Depending on the\n     * security requirements.\n     */\n    if (isServer) {\n        err = gnutls_dh_params_init(&ctxt->dhParams);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to initialize diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n        err = gnutls_dh_params_generate2(ctxt->dhParams, DH_BITS);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to generate diffie-hellman parameters: %s\"),\n                           gnutls_strerror(err));\n            goto error;\n        }\n\n        gnutls_certificate_set_dh_params(ctxt->x509cred,\n                                         ctxt->dhParams);\n    }\n\n    ctxt->requireValidCert = requireValidCert;\n    ctxt->x509dnWhitelist = x509dnWhitelist;\n    ctxt->isServer = isServer;\n\n    PROBE(RPC_TLS_CONTEXT_NEW,\n          \"ctxt=%p cacert=%s cacrl=%s cert=%s key=%s sanityCheckCert=%d requireValidCert=%d isServer=%d\",\n          ctxt, cacert, NULLSTR(cacrl), cert, key, sanityCheckCert, requireValidCert, isServer);\n\n    return ctxt;\n\n error:\n    if (isServer)\n        gnutls_dh_params_deinit(ctxt->dhParams);\n    if (ctxt->x509cred)\n        gnutls_certificate_free_credentials(ctxt->x509cred);\n    VIR_FREE(ctxt->priority);\n    VIR_FREE(ctxt);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetTLSContextLoadCredentials",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "598-671",
    "snippet": "static int virNetTLSContextLoadCredentials(virNetTLSContextPtr ctxt,\n                                           bool isServer,\n                                           const char *cacert,\n                                           const char *cacrl,\n                                           const char *cert,\n                                           const char *key)\n{\n    int err;\n\n    if (cacert && cacert[0] != '\\0') {\n        if (virNetTLSContextCheckCertFile(\"CA certificate\", cacert, false) < 0)\n            return -1;\n\n        VIR_DEBUG(\"loading CA cert from %s\", cacert);\n        err = gnutls_certificate_set_x509_trust_file(ctxt->x509cred,\n                                                     cacert,\n                                                     GNUTLS_X509_FMT_PEM);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to set x509 CA certificate: %s: %s\"),\n                           cacert, gnutls_strerror(err));\n            return -1;\n        }\n    }\n\n    if (cacrl && cacrl[0] != '\\0') {\n        int rv;\n        if ((rv = virNetTLSContextCheckCertFile(\"CA revocation list\", cacrl, true)) < 0)\n            return -1;\n\n        if (rv == 0) {\n            VIR_DEBUG(\"loading CRL from %s\", cacrl);\n            err = gnutls_certificate_set_x509_crl_file(ctxt->x509cred,\n                                                       cacrl,\n                                                       GNUTLS_X509_FMT_PEM);\n            if (err < 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Unable to set x509 certificate revocation list: %s: %s\"),\n                               cacrl, gnutls_strerror(err));\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"Skipping non-existent CA CRL %s\", cacrl);\n        }\n    }\n\n    if (cert && cert[0] != '\\0' && key && key[0] != '\\0') {\n        int rv;\n        if ((rv = virNetTLSContextCheckCertFile(\"certificate\", cert, !isServer)) < 0)\n            return -1;\n        if (rv == 0 &&\n            (rv = virNetTLSContextCheckCertFile(\"private key\", key, !isServer)) < 0)\n            return -1;\n\n        if (rv == 0) {\n            VIR_DEBUG(\"loading cert and key from %s and %s\", cert, key);\n            err =\n                gnutls_certificate_set_x509_key_file(ctxt->x509cred,\n                                                     cert, key,\n                                                     GNUTLS_X509_FMT_PEM);\n            if (err < 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Unable to set x509 key and certificate: %s, %s: %s\"),\n                               key, cert, gnutls_strerror(err));\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"Skipping non-existent cert %s key %s on client\",\n                      cert, key);\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skipping non-existent cert %s key %s on client\"",
            "cert",
            "key"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to set x509 key and certificate: %s, %s: %s\")",
            "key",
            "cert",
            "gnutls_strerror(err)"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "err"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to set x509 key and certificate: %s, %s: %s\""
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_set_x509_key_file",
          "args": [
            "ctxt->x509cred",
            "cert",
            "key",
            "GNUTLS_X509_FMT_PEM"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"loading cert and key from %s and %s\"",
            "cert",
            "key"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSContextCheckCertFile",
          "args": [
            "\"private key\"",
            "key",
            "!isServer"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextCheckCertFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "101-114",
          "snippet": "static int\nvirNetTLSContextCheckCertFile(const char *type, const char *file, bool allowMissing)\n{\n    if (!virFileExists(file)) {\n        if (allowMissing)\n            return 1;\n\n        virReportSystemError(errno,\n                             _(\"Cannot read %s '%s'\"),\n                             type, file);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetTLSContextCheckCertFile(const char *type, const char *file, bool allowMissing)\n{\n    if (!virFileExists(file)) {\n        if (allowMissing)\n            return 1;\n\n        virReportSystemError(errno,\n                             _(\"Cannot read %s '%s'\"),\n                             type, file);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skipping non-existent CA CRL %s\"",
            "cacrl"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to set x509 certificate revocation list: %s: %s\")",
            "cacrl",
            "gnutls_strerror(err)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "err"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_set_x509_crl_file",
          "args": [
            "ctxt->x509cred",
            "cacrl",
            "GNUTLS_X509_FMT_PEM"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"loading CRL from %s\"",
            "cacrl"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to set x509 CA certificate: %s: %s\")",
            "cacert",
            "gnutls_strerror(err)"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "err"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_certificate_set_x509_trust_file",
          "args": [
            "ctxt->x509cred",
            "cacert",
            "GNUTLS_X509_FMT_PEM"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"loading CA cert from %s\"",
            "cacert"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextLoadCredentials(virNetTLSContextPtr ctxt,\n                                           bool isServer,\n                                           const char *cacert,\n                                           const char *cacrl,\n                                           const char *cert,\n                                           const char *key)\n{\n    int err;\n\n    if (cacert && cacert[0] != '\\0') {\n        if (virNetTLSContextCheckCertFile(\"CA certificate\", cacert, false) < 0)\n            return -1;\n\n        VIR_DEBUG(\"loading CA cert from %s\", cacert);\n        err = gnutls_certificate_set_x509_trust_file(ctxt->x509cred,\n                                                     cacert,\n                                                     GNUTLS_X509_FMT_PEM);\n        if (err < 0) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to set x509 CA certificate: %s: %s\"),\n                           cacert, gnutls_strerror(err));\n            return -1;\n        }\n    }\n\n    if (cacrl && cacrl[0] != '\\0') {\n        int rv;\n        if ((rv = virNetTLSContextCheckCertFile(\"CA revocation list\", cacrl, true)) < 0)\n            return -1;\n\n        if (rv == 0) {\n            VIR_DEBUG(\"loading CRL from %s\", cacrl);\n            err = gnutls_certificate_set_x509_crl_file(ctxt->x509cred,\n                                                       cacrl,\n                                                       GNUTLS_X509_FMT_PEM);\n            if (err < 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Unable to set x509 certificate revocation list: %s: %s\"),\n                               cacrl, gnutls_strerror(err));\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"Skipping non-existent CA CRL %s\", cacrl);\n        }\n    }\n\n    if (cert && cert[0] != '\\0' && key && key[0] != '\\0') {\n        int rv;\n        if ((rv = virNetTLSContextCheckCertFile(\"certificate\", cert, !isServer)) < 0)\n            return -1;\n        if (rv == 0 &&\n            (rv = virNetTLSContextCheckCertFile(\"private key\", key, !isServer)) < 0)\n            return -1;\n\n        if (rv == 0) {\n            VIR_DEBUG(\"loading cert and key from %s and %s\", cert, key);\n            err =\n                gnutls_certificate_set_x509_key_file(ctxt->x509cred,\n                                                     cert, key,\n                                                     GNUTLS_X509_FMT_PEM);\n            if (err < 0) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Unable to set x509 key and certificate: %s, %s: %s\"),\n                               key, cert, gnutls_strerror(err));\n                return -1;\n            }\n        } else {\n            VIR_DEBUG(\"Skipping non-existent cert %s key %s on client\",\n                      cert, key);\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetTLSContextSanityCheckCredentials",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "555-595",
    "snippet": "static int virNetTLSContextSanityCheckCredentials(bool isServer,\n                                                  const char *cacertFile,\n                                                  const char *certFile)\n{\n    gnutls_x509_crt_t cert = NULL;\n    gnutls_x509_crt_t cacerts[MAX_CERTS];\n    size_t ncacerts = 0;\n    size_t i;\n    int ret = -1;\n\n    memset(cacerts, 0, sizeof(cacerts));\n    if ((access(certFile, R_OK) == 0) &&\n        !(cert = virNetTLSContextLoadCertFromFile(certFile, isServer)))\n        goto cleanup;\n    if ((access(cacertFile, R_OK) == 0) &&\n        virNetTLSContextLoadCACertListFromFile(cacertFile, cacerts,\n                                               MAX_CERTS, &ncacerts) < 0)\n        goto cleanup;\n\n    if (cert &&\n        virNetTLSContextCheckCert(cert, certFile, isServer, false) < 0)\n        goto cleanup;\n\n    for (i = 0; i < ncacerts; i++) {\n        if (virNetTLSContextCheckCert(cacerts[i], cacertFile, isServer, true) < 0)\n            goto cleanup;\n    }\n\n    if (cert && ncacerts &&\n        virNetTLSContextCheckCertPair(cert, certFile, cacerts, ncacerts, cacertFile, isServer) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (cert)\n        gnutls_x509_crt_deinit(cert);\n    for (i = 0; i < ncacerts; i++)\n        gnutls_x509_crt_deinit(cacerts[i]);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define MAX_CERTS 16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gnutls_x509_crt_deinit",
          "args": [
            "cacerts[i]"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_deinit",
          "args": [
            "cert"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSContextCheckCertPair",
          "args": [
            "cert",
            "certFile",
            "cacerts",
            "ncacerts",
            "cacertFile",
            "isServer"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextCheckCertPair",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "432-474",
          "snippet": "static int virNetTLSContextCheckCertPair(gnutls_x509_crt_t cert,\n                                         const char *certFile,\n                                         gnutls_x509_crt_t *cacerts,\n                                         size_t ncacerts,\n                                         const char *cacertFile,\n                                         bool isServer)\n{\n    unsigned int status;\n\n    if (gnutls_x509_crt_list_verify(&cert, 1,\n                                    cacerts, ncacerts,\n                                    NULL, 0,\n                                    0, &status) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, isServer ?\n                       _(\"Unable to verify server certificate %s against CA certificate %s\") :\n                       _(\"Unable to verify client certificate %s against CA certificate %s\"),\n                       certFile, cacertFile);\n        return -1;\n    }\n\n    if (status != 0) {\n        const char *reason = _(\"Invalid certificate\");\n\n        if (status & GNUTLS_CERT_INVALID)\n            reason = _(\"The certificate is not trusted.\");\n\n        if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n            reason = _(\"The certificate hasn't got a known issuer.\");\n\n        if (status & GNUTLS_CERT_REVOKED)\n            reason = _(\"The certificate has been revoked.\");\n\n        if (status & GNUTLS_CERT_INSECURE_ALGORITHM)\n            reason = _(\"The certificate uses an insecure algorithm\");\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Our own certificate %s failed validation against %s: %s\"),\n                       certFile, cacertFile, reason);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCertPair(gnutls_x509_crt_t cert,\n                                         const char *certFile,\n                                         gnutls_x509_crt_t *cacerts,\n                                         size_t ncacerts,\n                                         const char *cacertFile,\n                                         bool isServer)\n{\n    unsigned int status;\n\n    if (gnutls_x509_crt_list_verify(&cert, 1,\n                                    cacerts, ncacerts,\n                                    NULL, 0,\n                                    0, &status) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, isServer ?\n                       _(\"Unable to verify server certificate %s against CA certificate %s\") :\n                       _(\"Unable to verify client certificate %s against CA certificate %s\"),\n                       certFile, cacertFile);\n        return -1;\n    }\n\n    if (status != 0) {\n        const char *reason = _(\"Invalid certificate\");\n\n        if (status & GNUTLS_CERT_INVALID)\n            reason = _(\"The certificate is not trusted.\");\n\n        if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n            reason = _(\"The certificate hasn't got a known issuer.\");\n\n        if (status & GNUTLS_CERT_REVOKED)\n            reason = _(\"The certificate has been revoked.\");\n\n        if (status & GNUTLS_CERT_INSECURE_ALGORITHM)\n            reason = _(\"The certificate uses an insecure algorithm\");\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Our own certificate %s failed validation against %s: %s\"),\n                       certFile, cacertFile, reason);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSContextCheckCert",
          "args": [
            "cacerts[i]",
            "cacertFile",
            "isServer",
            "true"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextCheckCert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "406-429",
          "snippet": "static int virNetTLSContextCheckCert(gnutls_x509_crt_t cert,\n                                     const char *certFile,\n                                     bool isServer,\n                                     bool isCA)\n{\n    if (virNetTLSContextCheckCertTimes(cert, certFile,\n                                       isServer, isCA) < 0)\n        return -1;\n\n    if (virNetTLSContextCheckCertBasicConstraints(cert, certFile,\n                                                  isServer, isCA) < 0)\n        return -1;\n\n    if (virNetTLSContextCheckCertKeyUsage(cert, certFile,\n                                          isCA) < 0)\n        return -1;\n\n    if (!isCA &&\n        virNetTLSContextCheckCertKeyPurpose(cert, certFile,\n                                            isServer) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCert(gnutls_x509_crt_t cert,\n                                     const char *certFile,\n                                     bool isServer,\n                                     bool isCA)\n{\n    if (virNetTLSContextCheckCertTimes(cert, certFile,\n                                       isServer, isCA) < 0)\n        return -1;\n\n    if (virNetTLSContextCheckCertBasicConstraints(cert, certFile,\n                                                  isServer, isCA) < 0)\n        return -1;\n\n    if (virNetTLSContextCheckCertKeyUsage(cert, certFile,\n                                          isCA) < 0)\n        return -1;\n\n    if (!isCA &&\n        virNetTLSContextCheckCertKeyPurpose(cert, certFile,\n                                            isServer) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSContextLoadCACertListFromFile",
          "args": [
            "cacertFile",
            "cacerts",
            "MAX_CERTS",
            "&ncacerts"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextLoadCACertListFromFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "520-551",
          "snippet": "static int virNetTLSContextLoadCACertListFromFile(const char *certFile,\n                                                  gnutls_x509_crt_t *certs,\n                                                  unsigned int certMax,\n                                                  size_t *ncerts)\n{\n    gnutls_datum_t data;\n    char *buf = NULL;\n    int ret = -1;\n\n    *ncerts = 0;\n    VIR_DEBUG(\"certFile %s\", certFile);\n\n    if (virFileReadAll(certFile, (1<<16), &buf) < 0)\n        goto cleanup;\n\n    data.data = (unsigned char *)buf;\n    data.size = strlen(buf);\n\n    if (gnutls_x509_crt_list_import(certs, &certMax, &data, GNUTLS_X509_FMT_PEM, 0) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to import CA certificate list %s\"),\n                       certFile);\n        goto cleanup;\n    }\n    *ncerts = certMax;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(buf);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextLoadCACertListFromFile(const char *certFile,\n                                                  gnutls_x509_crt_t *certs,\n                                                  unsigned int certMax,\n                                                  size_t *ncerts)\n{\n    gnutls_datum_t data;\n    char *buf = NULL;\n    int ret = -1;\n\n    *ncerts = 0;\n    VIR_DEBUG(\"certFile %s\", certFile);\n\n    if (virFileReadAll(certFile, (1<<16), &buf) < 0)\n        goto cleanup;\n\n    data.data = (unsigned char *)buf;\n    data.size = strlen(buf);\n\n    if (gnutls_x509_crt_list_import(certs, &certMax, &data, GNUTLS_X509_FMT_PEM, 0) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to import CA certificate list %s\"),\n                       certFile);\n        goto cleanup;\n    }\n    *ncerts = certMax;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(buf);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "cacertFile",
            "R_OK"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSContextLoadCertFromFile",
          "args": [
            "certFile",
            "isServer"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextLoadCertFromFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "477-517",
          "snippet": "static gnutls_x509_crt_t virNetTLSContextLoadCertFromFile(const char *certFile,\n                                                          bool isServer)\n{\n    gnutls_datum_t data;\n    gnutls_x509_crt_t cert = NULL;\n    char *buf = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"isServer %d certFile %s\",\n              isServer, certFile);\n\n    if (gnutls_x509_crt_init(&cert) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Unable to initialize certificate\"));\n        goto cleanup;\n    }\n\n    if (virFileReadAll(certFile, (1<<16), &buf) < 0)\n        goto cleanup;\n\n    data.data = (unsigned char *)buf;\n    data.size = strlen(buf);\n\n    if (gnutls_x509_crt_import(cert, &data, GNUTLS_X509_FMT_PEM) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, isServer ?\n                       _(\"Unable to import server certificate %s\") :\n                       _(\"Unable to import client certificate %s\"),\n                       certFile);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret != 0) {\n        gnutls_x509_crt_deinit(cert);\n        cert = NULL;\n    }\n    VIR_FREE(buf);\n    return cert;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic gnutls_x509_crt_t virNetTLSContextLoadCertFromFile(const char *certFile,\n                                                          bool isServer)\n{\n    gnutls_datum_t data;\n    gnutls_x509_crt_t cert = NULL;\n    char *buf = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"isServer %d certFile %s\",\n              isServer, certFile);\n\n    if (gnutls_x509_crt_init(&cert) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Unable to initialize certificate\"));\n        goto cleanup;\n    }\n\n    if (virFileReadAll(certFile, (1<<16), &buf) < 0)\n        goto cleanup;\n\n    data.data = (unsigned char *)buf;\n    data.size = strlen(buf);\n\n    if (gnutls_x509_crt_import(cert, &data, GNUTLS_X509_FMT_PEM) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, isServer ?\n                       _(\"Unable to import server certificate %s\") :\n                       _(\"Unable to import client certificate %s\"),\n                       certFile);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret != 0) {\n        gnutls_x509_crt_deinit(cert);\n        cert = NULL;\n    }\n    VIR_FREE(buf);\n    return cert;\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "certFile",
            "R_OK"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cacerts",
            "0",
            "sizeof(cacerts)"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\n#define MAX_CERTS 16\n\nstatic int virNetTLSContextSanityCheckCredentials(bool isServer,\n                                                  const char *cacertFile,\n                                                  const char *certFile)\n{\n    gnutls_x509_crt_t cert = NULL;\n    gnutls_x509_crt_t cacerts[MAX_CERTS];\n    size_t ncacerts = 0;\n    size_t i;\n    int ret = -1;\n\n    memset(cacerts, 0, sizeof(cacerts));\n    if ((access(certFile, R_OK) == 0) &&\n        !(cert = virNetTLSContextLoadCertFromFile(certFile, isServer)))\n        goto cleanup;\n    if ((access(cacertFile, R_OK) == 0) &&\n        virNetTLSContextLoadCACertListFromFile(cacertFile, cacerts,\n                                               MAX_CERTS, &ncacerts) < 0)\n        goto cleanup;\n\n    if (cert &&\n        virNetTLSContextCheckCert(cert, certFile, isServer, false) < 0)\n        goto cleanup;\n\n    for (i = 0; i < ncacerts; i++) {\n        if (virNetTLSContextCheckCert(cacerts[i], cacertFile, isServer, true) < 0)\n            goto cleanup;\n    }\n\n    if (cert && ncacerts &&\n        virNetTLSContextCheckCertPair(cert, certFile, cacerts, ncacerts, cacertFile, isServer) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (cert)\n        gnutls_x509_crt_deinit(cert);\n    for (i = 0; i < ncacerts; i++)\n        gnutls_x509_crt_deinit(cacerts[i]);\n    return ret;\n}"
  },
  {
    "function_name": "virNetTLSContextLoadCACertListFromFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "520-551",
    "snippet": "static int virNetTLSContextLoadCACertListFromFile(const char *certFile,\n                                                  gnutls_x509_crt_t *certs,\n                                                  unsigned int certMax,\n                                                  size_t *ncerts)\n{\n    gnutls_datum_t data;\n    char *buf = NULL;\n    int ret = -1;\n\n    *ncerts = 0;\n    VIR_DEBUG(\"certFile %s\", certFile);\n\n    if (virFileReadAll(certFile, (1<<16), &buf) < 0)\n        goto cleanup;\n\n    data.data = (unsigned char *)buf;\n    data.size = strlen(buf);\n\n    if (gnutls_x509_crt_list_import(certs, &certMax, &data, GNUTLS_X509_FMT_PEM, 0) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to import CA certificate list %s\"),\n                       certFile);\n        goto cleanup;\n    }\n    *ncerts = certMax;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(buf);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buf"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to import CA certificate list %s\")",
            "certFile"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to import CA certificate list %s\""
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_list_import",
          "args": [
            "certs",
            "&certMax",
            "&data",
            "GNUTLS_X509_FMT_PEM",
            "0"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "certFile",
            "(1<<16)",
            "&buf"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"certFile %s\"",
            "certFile"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextLoadCACertListFromFile(const char *certFile,\n                                                  gnutls_x509_crt_t *certs,\n                                                  unsigned int certMax,\n                                                  size_t *ncerts)\n{\n    gnutls_datum_t data;\n    char *buf = NULL;\n    int ret = -1;\n\n    *ncerts = 0;\n    VIR_DEBUG(\"certFile %s\", certFile);\n\n    if (virFileReadAll(certFile, (1<<16), &buf) < 0)\n        goto cleanup;\n\n    data.data = (unsigned char *)buf;\n    data.size = strlen(buf);\n\n    if (gnutls_x509_crt_list_import(certs, &certMax, &data, GNUTLS_X509_FMT_PEM, 0) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to import CA certificate list %s\"),\n                       certFile);\n        goto cleanup;\n    }\n    *ncerts = certMax;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(buf);\n    return ret;\n}"
  },
  {
    "function_name": "virNetTLSContextLoadCertFromFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "477-517",
    "snippet": "static gnutls_x509_crt_t virNetTLSContextLoadCertFromFile(const char *certFile,\n                                                          bool isServer)\n{\n    gnutls_datum_t data;\n    gnutls_x509_crt_t cert = NULL;\n    char *buf = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"isServer %d certFile %s\",\n              isServer, certFile);\n\n    if (gnutls_x509_crt_init(&cert) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Unable to initialize certificate\"));\n        goto cleanup;\n    }\n\n    if (virFileReadAll(certFile, (1<<16), &buf) < 0)\n        goto cleanup;\n\n    data.data = (unsigned char *)buf;\n    data.size = strlen(buf);\n\n    if (gnutls_x509_crt_import(cert, &data, GNUTLS_X509_FMT_PEM) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, isServer ?\n                       _(\"Unable to import server certificate %s\") :\n                       _(\"Unable to import client certificate %s\"),\n                       certFile);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret != 0) {\n        gnutls_x509_crt_deinit(cert);\n        cert = NULL;\n    }\n    VIR_FREE(buf);\n    return cert;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buf"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_deinit",
          "args": [
            "cert"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "isServer ?\n                       _(\"Unable to import server certificate %s\") :\n                       _(\"Unable to import client certificate %s\")",
            "certFile"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to import client certificate %s\""
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_import",
          "args": [
            "cert",
            "&data",
            "GNUTLS_X509_FMT_PEM"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "certFile",
            "(1<<16)",
            "&buf"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "\"%s\"",
            "_(\"Unable to initialize certificate\")"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_init",
          "args": [
            "&cert"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"isServer %d certFile %s\"",
            "isServer",
            "certFile"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic gnutls_x509_crt_t virNetTLSContextLoadCertFromFile(const char *certFile,\n                                                          bool isServer)\n{\n    gnutls_datum_t data;\n    gnutls_x509_crt_t cert = NULL;\n    char *buf = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"isServer %d certFile %s\",\n              isServer, certFile);\n\n    if (gnutls_x509_crt_init(&cert) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                       _(\"Unable to initialize certificate\"));\n        goto cleanup;\n    }\n\n    if (virFileReadAll(certFile, (1<<16), &buf) < 0)\n        goto cleanup;\n\n    data.data = (unsigned char *)buf;\n    data.size = strlen(buf);\n\n    if (gnutls_x509_crt_import(cert, &data, GNUTLS_X509_FMT_PEM) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, isServer ?\n                       _(\"Unable to import server certificate %s\") :\n                       _(\"Unable to import client certificate %s\"),\n                       certFile);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret != 0) {\n        gnutls_x509_crt_deinit(cert);\n        cert = NULL;\n    }\n    VIR_FREE(buf);\n    return cert;\n}"
  },
  {
    "function_name": "virNetTLSContextCheckCertPair",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "432-474",
    "snippet": "static int virNetTLSContextCheckCertPair(gnutls_x509_crt_t cert,\n                                         const char *certFile,\n                                         gnutls_x509_crt_t *cacerts,\n                                         size_t ncacerts,\n                                         const char *cacertFile,\n                                         bool isServer)\n{\n    unsigned int status;\n\n    if (gnutls_x509_crt_list_verify(&cert, 1,\n                                    cacerts, ncacerts,\n                                    NULL, 0,\n                                    0, &status) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, isServer ?\n                       _(\"Unable to verify server certificate %s against CA certificate %s\") :\n                       _(\"Unable to verify client certificate %s against CA certificate %s\"),\n                       certFile, cacertFile);\n        return -1;\n    }\n\n    if (status != 0) {\n        const char *reason = _(\"Invalid certificate\");\n\n        if (status & GNUTLS_CERT_INVALID)\n            reason = _(\"The certificate is not trusted.\");\n\n        if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n            reason = _(\"The certificate hasn't got a known issuer.\");\n\n        if (status & GNUTLS_CERT_REVOKED)\n            reason = _(\"The certificate has been revoked.\");\n\n        if (status & GNUTLS_CERT_INSECURE_ALGORITHM)\n            reason = _(\"The certificate uses an insecure algorithm\");\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Our own certificate %s failed validation against %s: %s\"),\n                       certFile, cacertFile, reason);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Our own certificate %s failed validation against %s: %s\")",
            "certFile",
            "cacertFile",
            "reason"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Our own certificate %s failed validation against %s: %s\""
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "isServer ?\n                       _(\"Unable to verify server certificate %s against CA certificate %s\") :\n                       _(\"Unable to verify client certificate %s against CA certificate %s\")",
            "certFile",
            "cacertFile"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_list_verify",
          "args": [
            "&cert",
            "1",
            "cacerts",
            "ncacerts",
            "NULL",
            "0",
            "0",
            "&status"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCertPair(gnutls_x509_crt_t cert,\n                                         const char *certFile,\n                                         gnutls_x509_crt_t *cacerts,\n                                         size_t ncacerts,\n                                         const char *cacertFile,\n                                         bool isServer)\n{\n    unsigned int status;\n\n    if (gnutls_x509_crt_list_verify(&cert, 1,\n                                    cacerts, ncacerts,\n                                    NULL, 0,\n                                    0, &status) < 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR, isServer ?\n                       _(\"Unable to verify server certificate %s against CA certificate %s\") :\n                       _(\"Unable to verify client certificate %s against CA certificate %s\"),\n                       certFile, cacertFile);\n        return -1;\n    }\n\n    if (status != 0) {\n        const char *reason = _(\"Invalid certificate\");\n\n        if (status & GNUTLS_CERT_INVALID)\n            reason = _(\"The certificate is not trusted.\");\n\n        if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n            reason = _(\"The certificate hasn't got a known issuer.\");\n\n        if (status & GNUTLS_CERT_REVOKED)\n            reason = _(\"The certificate has been revoked.\");\n\n        if (status & GNUTLS_CERT_INSECURE_ALGORITHM)\n            reason = _(\"The certificate uses an insecure algorithm\");\n\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Our own certificate %s failed validation against %s: %s\"),\n                       certFile, cacertFile, reason);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetTLSContextCheckCert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "406-429",
    "snippet": "static int virNetTLSContextCheckCert(gnutls_x509_crt_t cert,\n                                     const char *certFile,\n                                     bool isServer,\n                                     bool isCA)\n{\n    if (virNetTLSContextCheckCertTimes(cert, certFile,\n                                       isServer, isCA) < 0)\n        return -1;\n\n    if (virNetTLSContextCheckCertBasicConstraints(cert, certFile,\n                                                  isServer, isCA) < 0)\n        return -1;\n\n    if (virNetTLSContextCheckCertKeyUsage(cert, certFile,\n                                          isCA) < 0)\n        return -1;\n\n    if (!isCA &&\n        virNetTLSContextCheckCertKeyPurpose(cert, certFile,\n                                            isServer) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetTLSContextCheckCertKeyPurpose",
          "args": [
            "cert",
            "certFile",
            "isServer"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextCheckCertKeyPurpose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "270-355",
          "snippet": "static int virNetTLSContextCheckCertKeyPurpose(gnutls_x509_crt_t cert,\n                                               const char *certFile,\n                                               bool isServer)\n{\n    int status;\n    size_t i;\n    unsigned int purposeCritical;\n    unsigned int critical;\n    char *buffer = NULL;\n    size_t size;\n    bool allowClient = false, allowServer = false;\n\n    critical = 0;\n    for (i = 0; ; i++) {\n        size = 0;\n        status = gnutls_x509_crt_get_key_purpose_oid(cert, i, buffer, &size, NULL);\n\n        if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n            VIR_DEBUG(\"No key purpose data available at slot %zu\", i);\n\n            /* If there is no data at all, then we must allow client/server to pass */\n            if (i == 0)\n                allowServer = allowClient = true;\n            break;\n        }\n        if (status != GNUTLS_E_SHORT_MEMORY_BUFFER) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key purpose %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n\n        if (VIR_ALLOC_N(buffer, size) < 0)\n            return -1;\n\n        status = gnutls_x509_crt_get_key_purpose_oid(cert, i, buffer, &size, &purposeCritical);\n        if (status < 0) {\n            VIR_FREE(buffer);\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key purpose %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n        if (purposeCritical)\n            critical = true;\n\n        VIR_DEBUG(\"Key purpose %d %s critical %u\", status, buffer, purposeCritical);\n        if (STREQ(buffer, GNUTLS_KP_TLS_WWW_SERVER)) {\n            allowServer = true;\n        } else if (STREQ(buffer, GNUTLS_KP_TLS_WWW_CLIENT)) {\n            allowClient = true;\n        } else if (STRNEQ(buffer, GNUTLS_KP_ANY)) {\n            allowServer = allowClient = true;\n        }\n\n        VIR_FREE(buffer);\n    }\n\n    if (isServer) {\n        if (!allowServer) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s purpose does not allow use for with a TLS server\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s purpose does not allow use for with a TLS server\",\n                         certFile);\n            }\n        }\n    } else {\n        if (!allowClient) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s purpose does not allow use for with a TLS client\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s purpose does not allow use for with a TLS client\",\n                         certFile);\n            }\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCertKeyPurpose(gnutls_x509_crt_t cert,\n                                               const char *certFile,\n                                               bool isServer)\n{\n    int status;\n    size_t i;\n    unsigned int purposeCritical;\n    unsigned int critical;\n    char *buffer = NULL;\n    size_t size;\n    bool allowClient = false, allowServer = false;\n\n    critical = 0;\n    for (i = 0; ; i++) {\n        size = 0;\n        status = gnutls_x509_crt_get_key_purpose_oid(cert, i, buffer, &size, NULL);\n\n        if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n            VIR_DEBUG(\"No key purpose data available at slot %zu\", i);\n\n            /* If there is no data at all, then we must allow client/server to pass */\n            if (i == 0)\n                allowServer = allowClient = true;\n            break;\n        }\n        if (status != GNUTLS_E_SHORT_MEMORY_BUFFER) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key purpose %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n\n        if (VIR_ALLOC_N(buffer, size) < 0)\n            return -1;\n\n        status = gnutls_x509_crt_get_key_purpose_oid(cert, i, buffer, &size, &purposeCritical);\n        if (status < 0) {\n            VIR_FREE(buffer);\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key purpose %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n        if (purposeCritical)\n            critical = true;\n\n        VIR_DEBUG(\"Key purpose %d %s critical %u\", status, buffer, purposeCritical);\n        if (STREQ(buffer, GNUTLS_KP_TLS_WWW_SERVER)) {\n            allowServer = true;\n        } else if (STREQ(buffer, GNUTLS_KP_TLS_WWW_CLIENT)) {\n            allowClient = true;\n        } else if (STRNEQ(buffer, GNUTLS_KP_ANY)) {\n            allowServer = allowClient = true;\n        }\n\n        VIR_FREE(buffer);\n    }\n\n    if (isServer) {\n        if (!allowServer) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s purpose does not allow use for with a TLS server\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s purpose does not allow use for with a TLS server\",\n                         certFile);\n            }\n        }\n    } else {\n        if (!allowClient) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s purpose does not allow use for with a TLS client\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s purpose does not allow use for with a TLS client\",\n                         certFile);\n            }\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSContextCheckCertKeyUsage",
          "args": [
            "cert",
            "certFile",
            "isCA"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextCheckCertKeyUsage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "206-267",
          "snippet": "static int virNetTLSContextCheckCertKeyUsage(gnutls_x509_crt_t cert,\n                                             const char *certFile,\n                                             bool isCA)\n{\n    int status;\n    unsigned int usage = 0;\n    unsigned int critical = 0;\n\n    status = gnutls_x509_crt_get_key_usage(cert, &usage, &critical);\n\n    VIR_DEBUG(\"Cert %s key usage status %d usage %d critical %u\", certFile, status, usage, critical);\n    if (status < 0) {\n        if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n            usage = isCA ? GNUTLS_KEY_KEY_CERT_SIGN :\n                GNUTLS_KEY_DIGITAL_SIGNATURE|GNUTLS_KEY_KEY_ENCIPHERMENT;\n        } else {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key usage %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n    }\n\n    if (isCA) {\n        if (!(usage & GNUTLS_KEY_KEY_CERT_SIGN)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit certificate signing\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit certificate signing\",\n                         certFile);\n            }\n        }\n    } else {\n        if (!(usage & GNUTLS_KEY_DIGITAL_SIGNATURE)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit digital signature\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit digital signature\",\n                         certFile);\n            }\n        }\n        if (!(usage & GNUTLS_KEY_KEY_ENCIPHERMENT)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit key encipherment\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit key encipherment\",\n                         certFile);\n            }\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCertKeyUsage(gnutls_x509_crt_t cert,\n                                             const char *certFile,\n                                             bool isCA)\n{\n    int status;\n    unsigned int usage = 0;\n    unsigned int critical = 0;\n\n    status = gnutls_x509_crt_get_key_usage(cert, &usage, &critical);\n\n    VIR_DEBUG(\"Cert %s key usage status %d usage %d critical %u\", certFile, status, usage, critical);\n    if (status < 0) {\n        if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n            usage = isCA ? GNUTLS_KEY_KEY_CERT_SIGN :\n                GNUTLS_KEY_DIGITAL_SIGNATURE|GNUTLS_KEY_KEY_ENCIPHERMENT;\n        } else {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key usage %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n    }\n\n    if (isCA) {\n        if (!(usage & GNUTLS_KEY_KEY_CERT_SIGN)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit certificate signing\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit certificate signing\",\n                         certFile);\n            }\n        }\n    } else {\n        if (!(usage & GNUTLS_KEY_DIGITAL_SIGNATURE)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit digital signature\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit digital signature\",\n                         certFile);\n            }\n        }\n        if (!(usage & GNUTLS_KEY_KEY_ENCIPHERMENT)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit key encipherment\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit key encipherment\",\n                         certFile);\n            }\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSContextCheckCertBasicConstraints",
          "args": [
            "cert",
            "certFile",
            "isServer",
            "isCA"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextCheckCertBasicConstraints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "163-203",
          "snippet": "static int virNetTLSContextCheckCertBasicConstraints(gnutls_x509_crt_t cert,\n                                                     const char *certFile,\n                                                     bool isServer,\n                                                     bool isCA)\n{\n    int status;\n\n    status = gnutls_x509_crt_get_basic_constraints(cert, NULL, NULL, NULL);\n    VIR_DEBUG(\"Cert %s basic constraints %d\", certFile, status);\n\n    if (status > 0) { /* It is a CA cert */\n        if (!isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, isServer ?\n                           _(\"The certificate %s basic constraints show a CA, but we need one for a server\") :\n                           _(\"The certificate %s basic constraints show a CA, but we need one for a client\"),\n                           certFile);\n            return -1;\n        }\n    } else if (status == 0) { /* It is not a CA cert */\n        if (isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"The certificate %s basic constraints do not show a CA\"),\n                           certFile);\n            return -1;\n        }\n    } else if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) { /* Missing basicConstraints */\n        if (isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"The certificate %s is missing basic constraints for a CA\"),\n                           certFile);\n            return -1;\n        }\n    } else { /* General error */\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to query certificate %s basic constraints %s\"),\n                       certFile, gnutls_strerror(status));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCertBasicConstraints(gnutls_x509_crt_t cert,\n                                                     const char *certFile,\n                                                     bool isServer,\n                                                     bool isCA)\n{\n    int status;\n\n    status = gnutls_x509_crt_get_basic_constraints(cert, NULL, NULL, NULL);\n    VIR_DEBUG(\"Cert %s basic constraints %d\", certFile, status);\n\n    if (status > 0) { /* It is a CA cert */\n        if (!isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, isServer ?\n                           _(\"The certificate %s basic constraints show a CA, but we need one for a server\") :\n                           _(\"The certificate %s basic constraints show a CA, but we need one for a client\"),\n                           certFile);\n            return -1;\n        }\n    } else if (status == 0) { /* It is not a CA cert */\n        if (isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"The certificate %s basic constraints do not show a CA\"),\n                           certFile);\n            return -1;\n        }\n    } else if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) { /* Missing basicConstraints */\n        if (isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"The certificate %s is missing basic constraints for a CA\"),\n                           certFile);\n            return -1;\n        }\n    } else { /* General error */\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to query certificate %s basic constraints %s\"),\n                       certFile, gnutls_strerror(status));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetTLSContextCheckCertTimes",
          "args": [
            "cert",
            "certFile",
            "isServer",
            "isCA"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextCheckCertTimes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "124-160",
          "snippet": "static int virNetTLSContextCheckCertTimes(gnutls_x509_crt_t cert,\n                                          const char *certFile,\n                                          bool isServer,\n                                          bool isCA)\n{\n    time_t now;\n\n    if ((now = time(NULL)) == ((time_t)-1)) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot get current time\"));\n        return -1;\n    }\n\n    if (gnutls_x509_crt_get_expiration_time(cert) < now) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       (isCA ?\n                        _(\"The CA certificate %s has expired\") :\n                        (isServer ?\n                         _(\"The server certificate %s has expired\") :\n                         _(\"The client certificate %s has expired\"))),\n                       certFile);\n        return -1;\n    }\n\n    if (gnutls_x509_crt_get_activation_time(cert) > now) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       (isCA ?\n                        _(\"The CA certificate %s is not yet active\") :\n                        (isServer ?\n                         _(\"The server certificate %s is not yet active\") :\n                         _(\"The client certificate %s is not yet active\"))),\n                       certFile);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCertTimes(gnutls_x509_crt_t cert,\n                                          const char *certFile,\n                                          bool isServer,\n                                          bool isCA)\n{\n    time_t now;\n\n    if ((now = time(NULL)) == ((time_t)-1)) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot get current time\"));\n        return -1;\n    }\n\n    if (gnutls_x509_crt_get_expiration_time(cert) < now) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       (isCA ?\n                        _(\"The CA certificate %s has expired\") :\n                        (isServer ?\n                         _(\"The server certificate %s has expired\") :\n                         _(\"The client certificate %s has expired\"))),\n                       certFile);\n        return -1;\n    }\n\n    if (gnutls_x509_crt_get_activation_time(cert) > now) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       (isCA ?\n                        _(\"The CA certificate %s is not yet active\") :\n                        (isServer ?\n                         _(\"The server certificate %s is not yet active\") :\n                         _(\"The client certificate %s is not yet active\"))),\n                       certFile);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCert(gnutls_x509_crt_t cert,\n                                     const char *certFile,\n                                     bool isServer,\n                                     bool isCA)\n{\n    if (virNetTLSContextCheckCertTimes(cert, certFile,\n                                       isServer, isCA) < 0)\n        return -1;\n\n    if (virNetTLSContextCheckCertBasicConstraints(cert, certFile,\n                                                  isServer, isCA) < 0)\n        return -1;\n\n    if (virNetTLSContextCheckCertKeyUsage(cert, certFile,\n                                          isCA) < 0)\n        return -1;\n\n    if (!isCA &&\n        virNetTLSContextCheckCertKeyPurpose(cert, certFile,\n                                            isServer) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetTLSContextCheckCertDN",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "383-403",
    "snippet": "static int\nvirNetTLSContextCheckCertDN(gnutls_x509_crt_t cert,\n                            const char *certFile,\n                            const char *hostname,\n                            const char *dname,\n                            const char *const* whitelist)\n{\n    if (whitelist && dname &&\n        virNetTLSContextCheckCertDNWhitelist(dname, whitelist) <= 0)\n        return -1;\n\n    if (hostname &&\n        !gnutls_x509_crt_check_hostname(cert, hostname)) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Certificate %s owner does not match the hostname %s\"),\n                       certFile, hostname);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "_(\"Certificate %s owner does not match the hostname %s\")",
            "certFile",
            "hostname"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Certificate %s owner does not match the hostname %s\""
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_check_hostname",
          "args": [
            "cert",
            "hostname"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSContextCheckCertDNWhitelist",
          "args": [
            "dname",
            "whitelist"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextCheckCertDNWhitelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "358-380",
          "snippet": "static int\nvirNetTLSContextCheckCertDNWhitelist(const char *dname,\n                                     const char *const*wildcards)\n{\n    while (*wildcards) {\n        if (g_pattern_match_simple(*wildcards, dname))\n            return 1;\n\n        wildcards++;\n    }\n\n    /* Log the client's DN for debugging */\n    VIR_DEBUG(\"Failed whitelist check for client DN '%s'\", dname);\n\n    /* This is the most common error: make it informative. */\n    virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                   _(\"Client's Distinguished Name is not on the list \"\n                     \"of allowed clients (tls_allowed_dn_list).  Use \"\n                     \"'certtool -i --infile clientcert.pem' to view the \"\n                     \"Distinguished Name field in the client certificate, \"\n                     \"or run this daemon with --verbose option.\"));\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetTLSContextCheckCertDNWhitelist(const char *dname,\n                                     const char *const*wildcards)\n{\n    while (*wildcards) {\n        if (g_pattern_match_simple(*wildcards, dname))\n            return 1;\n\n        wildcards++;\n    }\n\n    /* Log the client's DN for debugging */\n    VIR_DEBUG(\"Failed whitelist check for client DN '%s'\", dname);\n\n    /* This is the most common error: make it informative. */\n    virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                   _(\"Client's Distinguished Name is not on the list \"\n                     \"of allowed clients (tls_allowed_dn_list).  Use \"\n                     \"'certtool -i --infile clientcert.pem' to view the \"\n                     \"Distinguished Name field in the client certificate, \"\n                     \"or run this daemon with --verbose option.\"));\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetTLSContextCheckCertDN(gnutls_x509_crt_t cert,\n                            const char *certFile,\n                            const char *hostname,\n                            const char *dname,\n                            const char *const* whitelist)\n{\n    if (whitelist && dname &&\n        virNetTLSContextCheckCertDNWhitelist(dname, whitelist) <= 0)\n        return -1;\n\n    if (hostname &&\n        !gnutls_x509_crt_check_hostname(cert, hostname)) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Certificate %s owner does not match the hostname %s\"),\n                       certFile, hostname);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetTLSContextCheckCertDNWhitelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "358-380",
    "snippet": "static int\nvirNetTLSContextCheckCertDNWhitelist(const char *dname,\n                                     const char *const*wildcards)\n{\n    while (*wildcards) {\n        if (g_pattern_match_simple(*wildcards, dname))\n            return 1;\n\n        wildcards++;\n    }\n\n    /* Log the client's DN for debugging */\n    VIR_DEBUG(\"Failed whitelist check for client DN '%s'\", dname);\n\n    /* This is the most common error: make it informative. */\n    virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                   _(\"Client's Distinguished Name is not on the list \"\n                     \"of allowed clients (tls_allowed_dn_list).  Use \"\n                     \"'certtool -i --infile clientcert.pem' to view the \"\n                     \"Distinguished Name field in the client certificate, \"\n                     \"or run this daemon with --verbose option.\"));\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "\"%s\"",
            "_(\"Client's Distinguished Name is not on the list \"\n                     \"of allowed clients (tls_allowed_dn_list).  Use \"\n                     \"'certtool -i --infile clientcert.pem' to view the \"\n                     \"Distinguished Name field in the client certificate, \"\n                     \"or run this daemon with --verbose option.\")"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Client's Distinguished Name is not on the list \"\n                     \"of allowed clients (tls_allowed_dn_list).  Use \"\n                     \"'certtool -i --infile clientcert.pem' to view the \"\n                     \"Distinguished Name field in the client certificate, \"\n                     \"or run this daemon with --verbose option.\""
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed whitelist check for client DN '%s'\"",
            "dname"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_pattern_match_simple",
          "args": [
            "*wildcards",
            "dname"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetTLSContextCheckCertDNWhitelist(const char *dname,\n                                     const char *const*wildcards)\n{\n    while (*wildcards) {\n        if (g_pattern_match_simple(*wildcards, dname))\n            return 1;\n\n        wildcards++;\n    }\n\n    /* Log the client's DN for debugging */\n    VIR_DEBUG(\"Failed whitelist check for client DN '%s'\", dname);\n\n    /* This is the most common error: make it informative. */\n    virReportError(VIR_ERR_SYSTEM_ERROR, \"%s\",\n                   _(\"Client's Distinguished Name is not on the list \"\n                     \"of allowed clients (tls_allowed_dn_list).  Use \"\n                     \"'certtool -i --infile clientcert.pem' to view the \"\n                     \"Distinguished Name field in the client certificate, \"\n                     \"or run this daemon with --verbose option.\"));\n    return 0;\n}"
  },
  {
    "function_name": "virNetTLSContextCheckCertKeyPurpose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "270-355",
    "snippet": "static int virNetTLSContextCheckCertKeyPurpose(gnutls_x509_crt_t cert,\n                                               const char *certFile,\n                                               bool isServer)\n{\n    int status;\n    size_t i;\n    unsigned int purposeCritical;\n    unsigned int critical;\n    char *buffer = NULL;\n    size_t size;\n    bool allowClient = false, allowServer = false;\n\n    critical = 0;\n    for (i = 0; ; i++) {\n        size = 0;\n        status = gnutls_x509_crt_get_key_purpose_oid(cert, i, buffer, &size, NULL);\n\n        if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n            VIR_DEBUG(\"No key purpose data available at slot %zu\", i);\n\n            /* If there is no data at all, then we must allow client/server to pass */\n            if (i == 0)\n                allowServer = allowClient = true;\n            break;\n        }\n        if (status != GNUTLS_E_SHORT_MEMORY_BUFFER) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key purpose %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n\n        if (VIR_ALLOC_N(buffer, size) < 0)\n            return -1;\n\n        status = gnutls_x509_crt_get_key_purpose_oid(cert, i, buffer, &size, &purposeCritical);\n        if (status < 0) {\n            VIR_FREE(buffer);\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key purpose %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n        if (purposeCritical)\n            critical = true;\n\n        VIR_DEBUG(\"Key purpose %d %s critical %u\", status, buffer, purposeCritical);\n        if (STREQ(buffer, GNUTLS_KP_TLS_WWW_SERVER)) {\n            allowServer = true;\n        } else if (STREQ(buffer, GNUTLS_KP_TLS_WWW_CLIENT)) {\n            allowClient = true;\n        } else if (STRNEQ(buffer, GNUTLS_KP_ANY)) {\n            allowServer = allowClient = true;\n        }\n\n        VIR_FREE(buffer);\n    }\n\n    if (isServer) {\n        if (!allowServer) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s purpose does not allow use for with a TLS server\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s purpose does not allow use for with a TLS server\",\n                         certFile);\n            }\n        }\n    } else {\n        if (!allowClient) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s purpose does not allow use for with a TLS client\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s purpose does not allow use for with a TLS client\",\n                         certFile);\n            }\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Certificate %s purpose does not allow use for with a TLS client\"",
            "certFile"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Certificate %s purpose does not allow use for with a TLS client\")",
            "certFile"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Certificate %s purpose does not allow use for with a TLS client\""
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Certificate %s purpose does not allow use for with a TLS server\"",
            "certFile"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Certificate %s purpose does not allow use for with a TLS server\")",
            "certFile"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buffer"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "buffer",
            "GNUTLS_KP_ANY"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "buffer",
            "GNUTLS_KP_TLS_WWW_CLIENT"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "buffer",
            "GNUTLS_KP_TLS_WWW_SERVER"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Key purpose %d %s critical %u\"",
            "status",
            "buffer",
            "purposeCritical"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to query certificate %s key purpose %s\")",
            "certFile",
            "gnutls_strerror(status)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "status"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buffer"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_get_key_purpose_oid",
          "args": [
            "cert",
            "i",
            "buffer",
            "&size",
            "&purposeCritical"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "buffer",
            "size"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to query certificate %s key purpose %s\")",
            "certFile",
            "gnutls_strerror(status)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "status"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"No key purpose data available at slot %zu\"",
            "i"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_get_key_purpose_oid",
          "args": [
            "cert",
            "i",
            "buffer",
            "&size",
            "NULL"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCertKeyPurpose(gnutls_x509_crt_t cert,\n                                               const char *certFile,\n                                               bool isServer)\n{\n    int status;\n    size_t i;\n    unsigned int purposeCritical;\n    unsigned int critical;\n    char *buffer = NULL;\n    size_t size;\n    bool allowClient = false, allowServer = false;\n\n    critical = 0;\n    for (i = 0; ; i++) {\n        size = 0;\n        status = gnutls_x509_crt_get_key_purpose_oid(cert, i, buffer, &size, NULL);\n\n        if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n            VIR_DEBUG(\"No key purpose data available at slot %zu\", i);\n\n            /* If there is no data at all, then we must allow client/server to pass */\n            if (i == 0)\n                allowServer = allowClient = true;\n            break;\n        }\n        if (status != GNUTLS_E_SHORT_MEMORY_BUFFER) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key purpose %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n\n        if (VIR_ALLOC_N(buffer, size) < 0)\n            return -1;\n\n        status = gnutls_x509_crt_get_key_purpose_oid(cert, i, buffer, &size, &purposeCritical);\n        if (status < 0) {\n            VIR_FREE(buffer);\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key purpose %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n        if (purposeCritical)\n            critical = true;\n\n        VIR_DEBUG(\"Key purpose %d %s critical %u\", status, buffer, purposeCritical);\n        if (STREQ(buffer, GNUTLS_KP_TLS_WWW_SERVER)) {\n            allowServer = true;\n        } else if (STREQ(buffer, GNUTLS_KP_TLS_WWW_CLIENT)) {\n            allowClient = true;\n        } else if (STRNEQ(buffer, GNUTLS_KP_ANY)) {\n            allowServer = allowClient = true;\n        }\n\n        VIR_FREE(buffer);\n    }\n\n    if (isServer) {\n        if (!allowServer) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s purpose does not allow use for with a TLS server\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s purpose does not allow use for with a TLS server\",\n                         certFile);\n            }\n        }\n    } else {\n        if (!allowClient) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s purpose does not allow use for with a TLS client\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s purpose does not allow use for with a TLS client\",\n                         certFile);\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetTLSContextCheckCertKeyUsage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "206-267",
    "snippet": "static int virNetTLSContextCheckCertKeyUsage(gnutls_x509_crt_t cert,\n                                             const char *certFile,\n                                             bool isCA)\n{\n    int status;\n    unsigned int usage = 0;\n    unsigned int critical = 0;\n\n    status = gnutls_x509_crt_get_key_usage(cert, &usage, &critical);\n\n    VIR_DEBUG(\"Cert %s key usage status %d usage %d critical %u\", certFile, status, usage, critical);\n    if (status < 0) {\n        if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n            usage = isCA ? GNUTLS_KEY_KEY_CERT_SIGN :\n                GNUTLS_KEY_DIGITAL_SIGNATURE|GNUTLS_KEY_KEY_ENCIPHERMENT;\n        } else {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key usage %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n    }\n\n    if (isCA) {\n        if (!(usage & GNUTLS_KEY_KEY_CERT_SIGN)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit certificate signing\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit certificate signing\",\n                         certFile);\n            }\n        }\n    } else {\n        if (!(usage & GNUTLS_KEY_DIGITAL_SIGNATURE)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit digital signature\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit digital signature\",\n                         certFile);\n            }\n        }\n        if (!(usage & GNUTLS_KEY_KEY_ENCIPHERMENT)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit key encipherment\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit key encipherment\",\n                         certFile);\n            }\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Certificate %s usage does not permit key encipherment\"",
            "certFile"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Certificate %s usage does not permit key encipherment\")",
            "certFile"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Certificate %s usage does not permit key encipherment\""
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Certificate %s usage does not permit digital signature\"",
            "certFile"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Certificate %s usage does not permit digital signature\")",
            "certFile"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Certificate %s usage does not permit certificate signing\"",
            "certFile"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Certificate %s usage does not permit certificate signing\")",
            "certFile"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to query certificate %s key usage %s\")",
            "certFile",
            "gnutls_strerror(status)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "status"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Cert %s key usage status %d usage %d critical %u\"",
            "certFile",
            "status",
            "usage",
            "critical"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_get_key_usage",
          "args": [
            "cert",
            "&usage",
            "&critical"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCertKeyUsage(gnutls_x509_crt_t cert,\n                                             const char *certFile,\n                                             bool isCA)\n{\n    int status;\n    unsigned int usage = 0;\n    unsigned int critical = 0;\n\n    status = gnutls_x509_crt_get_key_usage(cert, &usage, &critical);\n\n    VIR_DEBUG(\"Cert %s key usage status %d usage %d critical %u\", certFile, status, usage, critical);\n    if (status < 0) {\n        if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) {\n            usage = isCA ? GNUTLS_KEY_KEY_CERT_SIGN :\n                GNUTLS_KEY_DIGITAL_SIGNATURE|GNUTLS_KEY_KEY_ENCIPHERMENT;\n        } else {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Unable to query certificate %s key usage %s\"),\n                           certFile, gnutls_strerror(status));\n            return -1;\n        }\n    }\n\n    if (isCA) {\n        if (!(usage & GNUTLS_KEY_KEY_CERT_SIGN)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit certificate signing\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit certificate signing\",\n                         certFile);\n            }\n        }\n    } else {\n        if (!(usage & GNUTLS_KEY_DIGITAL_SIGNATURE)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit digital signature\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit digital signature\",\n                         certFile);\n            }\n        }\n        if (!(usage & GNUTLS_KEY_KEY_ENCIPHERMENT)) {\n            if (critical) {\n                virReportError(VIR_ERR_SYSTEM_ERROR,\n                               _(\"Certificate %s usage does not permit key encipherment\"),\n                               certFile);\n                return -1;\n            } else {\n                VIR_WARN(\"Certificate %s usage does not permit key encipherment\",\n                         certFile);\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetTLSContextCheckCertBasicConstraints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "163-203",
    "snippet": "static int virNetTLSContextCheckCertBasicConstraints(gnutls_x509_crt_t cert,\n                                                     const char *certFile,\n                                                     bool isServer,\n                                                     bool isCA)\n{\n    int status;\n\n    status = gnutls_x509_crt_get_basic_constraints(cert, NULL, NULL, NULL);\n    VIR_DEBUG(\"Cert %s basic constraints %d\", certFile, status);\n\n    if (status > 0) { /* It is a CA cert */\n        if (!isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, isServer ?\n                           _(\"The certificate %s basic constraints show a CA, but we need one for a server\") :\n                           _(\"The certificate %s basic constraints show a CA, but we need one for a client\"),\n                           certFile);\n            return -1;\n        }\n    } else if (status == 0) { /* It is not a CA cert */\n        if (isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"The certificate %s basic constraints do not show a CA\"),\n                           certFile);\n            return -1;\n        }\n    } else if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) { /* Missing basicConstraints */\n        if (isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"The certificate %s is missing basic constraints for a CA\"),\n                           certFile);\n            return -1;\n        }\n    } else { /* General error */\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to query certificate %s basic constraints %s\"),\n                       certFile, gnutls_strerror(status));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Unable to query certificate %s basic constraints %s\")",
            "certFile",
            "gnutls_strerror(status)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_strerror",
          "args": [
            "status"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to query certificate %s basic constraints %s\""
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"The certificate %s is missing basic constraints for a CA\")",
            "certFile"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"The certificate %s basic constraints do not show a CA\")",
            "certFile"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "isServer ?\n                           _(\"The certificate %s basic constraints show a CA, but we need one for a server\") :\n                           _(\"The certificate %s basic constraints show a CA, but we need one for a client\")",
            "certFile"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Cert %s basic constraints %d\"",
            "certFile",
            "status"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_get_basic_constraints",
          "args": [
            "cert",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCertBasicConstraints(gnutls_x509_crt_t cert,\n                                                     const char *certFile,\n                                                     bool isServer,\n                                                     bool isCA)\n{\n    int status;\n\n    status = gnutls_x509_crt_get_basic_constraints(cert, NULL, NULL, NULL);\n    VIR_DEBUG(\"Cert %s basic constraints %d\", certFile, status);\n\n    if (status > 0) { /* It is a CA cert */\n        if (!isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR, isServer ?\n                           _(\"The certificate %s basic constraints show a CA, but we need one for a server\") :\n                           _(\"The certificate %s basic constraints show a CA, but we need one for a client\"),\n                           certFile);\n            return -1;\n        }\n    } else if (status == 0) { /* It is not a CA cert */\n        if (isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"The certificate %s basic constraints do not show a CA\"),\n                           certFile);\n            return -1;\n        }\n    } else if (status == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE) { /* Missing basicConstraints */\n        if (isCA) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"The certificate %s is missing basic constraints for a CA\"),\n                           certFile);\n            return -1;\n        }\n    } else { /* General error */\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to query certificate %s basic constraints %s\"),\n                       certFile, gnutls_strerror(status));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetTLSContextCheckCertTimes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "124-160",
    "snippet": "static int virNetTLSContextCheckCertTimes(gnutls_x509_crt_t cert,\n                                          const char *certFile,\n                                          bool isServer,\n                                          bool isCA)\n{\n    time_t now;\n\n    if ((now = time(NULL)) == ((time_t)-1)) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot get current time\"));\n        return -1;\n    }\n\n    if (gnutls_x509_crt_get_expiration_time(cert) < now) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       (isCA ?\n                        _(\"The CA certificate %s has expired\") :\n                        (isServer ?\n                         _(\"The server certificate %s has expired\") :\n                         _(\"The client certificate %s has expired\"))),\n                       certFile);\n        return -1;\n    }\n\n    if (gnutls_x509_crt_get_activation_time(cert) > now) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       (isCA ?\n                        _(\"The CA certificate %s is not yet active\") :\n                        (isServer ?\n                         _(\"The server certificate %s is not yet active\") :\n                         _(\"The client certificate %s is not yet active\"))),\n                       certFile);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "(isCA ?\n                        _(\"The CA certificate %s is not yet active\") :\n                        (isServer ?\n                         _(\"The server certificate %s is not yet active\") :\n                         _(\"The client certificate %s is not yet active\")))",
            "certFile"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"The client certificate %s is not yet active\""
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_get_activation_time",
          "args": [
            "cert"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "(isCA ?\n                        _(\"The CA certificate %s has expired\") :\n                        (isServer ?\n                         _(\"The server certificate %s has expired\") :\n                         _(\"The client certificate %s has expired\")))",
            "certFile"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gnutls_x509_crt_get_expiration_time",
          "args": [
            "cert"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot get current time\")"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobCleanStorageSourceRuntime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "636-647",
          "snippet": "static void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextCheckCertTimes(gnutls_x509_crt_t cert,\n                                          const char *certFile,\n                                          bool isServer,\n                                          bool isCA)\n{\n    time_t now;\n\n    if ((now = time(NULL)) == ((time_t)-1)) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot get current time\"));\n        return -1;\n    }\n\n    if (gnutls_x509_crt_get_expiration_time(cert) < now) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       (isCA ?\n                        _(\"The CA certificate %s has expired\") :\n                        (isServer ?\n                         _(\"The server certificate %s has expired\") :\n                         _(\"The client certificate %s has expired\"))),\n                       certFile);\n        return -1;\n    }\n\n    if (gnutls_x509_crt_get_activation_time(cert) > now) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       (isCA ?\n                        _(\"The CA certificate %s is not yet active\") :\n                        (isServer ?\n                         _(\"The server certificate %s is not yet active\") :\n                         _(\"The client certificate %s is not yet active\"))),\n                       certFile);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetTLSLog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "117-121",
    "snippet": "static void virNetTLSLog(int level G_GNUC_UNUSED,\n                         const char *str G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"%d %s\", level, str);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%d %s\"",
            "level",
            "str"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void virNetTLSLog(int level G_GNUC_UNUSED,\n                         const char *str G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"%d %s\", level, str);\n}"
  },
  {
    "function_name": "virNetTLSContextCheckCertFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "101-114",
    "snippet": "static int\nvirNetTLSContextCheckCertFile(const char *type, const char *file, bool allowMissing)\n{\n    if (!virFileExists(file)) {\n        if (allowMissing)\n            return 1;\n\n        virReportSystemError(errno,\n                             _(\"Cannot read %s '%s'\"),\n                             type, file);\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot read %s '%s'\")",
            "type",
            "file"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot read %s '%s'\""
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "file"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetTLSContextCheckCertFile(const char *type, const char *file, bool allowMissing)\n{\n    if (!virFileExists(file)) {\n        if (allowMissing)\n            return 1;\n\n        virReportSystemError(errno,\n                             _(\"Cannot read %s '%s'\"),\n                             type, file);\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virNetTLSContextOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
    "lines": "87-96",
    "snippet": "static int virNetTLSContextOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetTLSContext, virClassForObjectLockable()))\n        return -1;\n\n    if (!VIR_CLASS_NEW(virNetTLSSession, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virthread.h\"",
      "#include \"virprobe.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virnettlscontext.h\"",
      "#include <gnutls/x509.h>",
      "#include <gnutls/crypto.h>",
      "#include <gnutls/gnutls.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virNetTLSSession",
            "virClassForObjectLockable()"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virNetTLSContext",
            "virClassForObjectLockable()"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetTLSContextOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetTLSContext, virClassForObjectLockable()))\n        return -1;\n\n    if (!VIR_CLASS_NEW(virNetTLSSession, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}"
  }
]