[
  {
    "function_name": "virNetlinkGetErrorCode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1378-1384",
    "snippet": "int\nvirNetlinkGetErrorCode(struct nlmsghdr *resp G_GNUC_UNUSED,\n                       unsigned int recvbuflen G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -EINVAL;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkGetErrorCode(struct nlmsghdr *resp G_GNUC_UNUSED,\n                       unsigned int recvbuflen G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -EINVAL;\n}"
  },
  {
    "function_name": "virNetlinkEventRemoveClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1369-1375",
    "snippet": "int virNetlinkEventRemoveClient(int watch G_GNUC_UNUSED,\n                                const virMacAddr *macaddr G_GNUC_UNUSED,\n                                unsigned int protocol G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkEventRemoveClient(int watch G_GNUC_UNUSED,\n                                const virMacAddr *macaddr G_GNUC_UNUSED,\n                                unsigned int protocol G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virNetlinkEventAddClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1356-1364",
    "snippet": "int virNetlinkEventAddClient(virNetlinkEventHandleCallback handleCB G_GNUC_UNUSED,\n                             virNetlinkEventRemoveCallback removeCB G_GNUC_UNUSED,\n                             void *opaque G_GNUC_UNUSED,\n                             const virMacAddr *macaddr G_GNUC_UNUSED,\n                             unsigned int protocol G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkEventAddClient(virNetlinkEventHandleCallback handleCB G_GNUC_UNUSED,\n                             virNetlinkEventRemoveCallback removeCB G_GNUC_UNUSED,\n                             void *opaque G_GNUC_UNUSED,\n                             const virMacAddr *macaddr G_GNUC_UNUSED,\n                             unsigned int protocol G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virNetlinkEventServiceLocalPid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1346-1350",
    "snippet": "int virNetlinkEventServiceLocalPid(unsigned int protocol G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkEventServiceLocalPid(unsigned int protocol G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virNetlinkEventServiceIsRunning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1340-1344",
    "snippet": "bool virNetlinkEventServiceIsRunning(unsigned int protocol G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nbool virNetlinkEventServiceIsRunning(unsigned int protocol G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return 0;\n}"
  },
  {
    "function_name": "virNetlinkEventServiceStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1329-1334",
    "snippet": "int virNetlinkEventServiceStart(unsigned int protocol G_GNUC_UNUSED,\n                                unsigned int groups G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"%s\", _(unsupported));\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkEventServiceStart(unsigned int protocol G_GNUC_UNUSED,\n                                unsigned int groups G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"%s\", _(unsupported));\n    return 0;\n}"
  },
  {
    "function_name": "virNetlinkEventServiceStopAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1319-1323",
    "snippet": "int virNetlinkEventServiceStopAll(void)\n{\n    VIR_DEBUG(\"%s\", _(unsupported));\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkEventServiceStopAll(void)\n{\n    VIR_DEBUG(\"%s\", _(unsupported));\n    return 0;\n}"
  },
  {
    "function_name": "virNetlinkEventServiceStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1309-1313",
    "snippet": "int virNetlinkEventServiceStop(unsigned int protocol G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"%s\", _(unsupported));\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkEventServiceStop(unsigned int protocol G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"%s\", _(unsupported));\n    return 0;\n}"
  },
  {
    "function_name": "virNetlinkGetNeighbor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1295-1302",
    "snippet": "int\nvirNetlinkGetNeighbor(void **nlData G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkGetNeighbor(void **nlData G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virNetlinkNewLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1284-1292",
    "snippet": "int\nvirNetlinkNewLink(const char *ifname G_GNUC_UNUSED,\n                  const char *type G_GNUC_UNUSED,\n                  virNetlinkNewLinkDataPtr extra_args G_GNUC_UNUSED,\n                  int *error G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkNewLink(const char *ifname G_GNUC_UNUSED,\n                  const char *type G_GNUC_UNUSED,\n                  virNetlinkNewLinkDataPtr extra_args G_GNUC_UNUSED,\n                  int *error G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virNetlinkDelLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1275-1281",
    "snippet": "int\nvirNetlinkDelLink(const char *ifname G_GNUC_UNUSED,\n                  virNetlinkDelLinkFallback fallback G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkDelLink(const char *ifname G_GNUC_UNUSED,\n                  virNetlinkDelLinkFallback fallback G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virNetlinkDumpLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1261-1272",
    "snippet": "int\nvirNetlinkDumpLink(const char *ifname G_GNUC_UNUSED,\n                   int ifindex G_GNUC_UNUSED,\n                   void **nlData G_GNUC_UNUSED,\n                   struct nlattr **tb G_GNUC_UNUSED,\n                   uint32_t src_pid G_GNUC_UNUSED,\n                   uint32_t dst_pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to dump link info on this platform\"));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"Unable to dump link info on this platform\")"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to dump link info on this platform\""
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkDumpLink(const char *ifname G_GNUC_UNUSED,\n                   int ifindex G_GNUC_UNUSED,\n                   void **nlData G_GNUC_UNUSED,\n                   struct nlattr **tb G_GNUC_UNUSED,\n                   uint32_t src_pid G_GNUC_UNUSED,\n                   uint32_t dst_pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to dump link info on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNetlinkDumpCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1248-1259",
    "snippet": "int\nvirNetlinkDumpCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      virNetlinkDumpCallback callback G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED,\n                      void *opaque G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkDumpCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      virNetlinkDumpCallback callback G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED,\n                      void *opaque G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virNetlinkCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1236-1246",
    "snippet": "int virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virNetlinkShutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1230-1234",
    "snippet": "void\nvirNetlinkShutdown(void)\n{\n    return;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetlinkShutdown(void)\n{\n    return;\n}"
  },
  {
    "function_name": "virNetlinkStartup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1224-1228",
    "snippet": "int\nvirNetlinkStartup(void)\n{\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkStartup(void)\n{\n    return 0;\n}"
  },
  {
    "function_name": "virNetlinkEventRemoveClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1172-1214",
    "snippet": "int\nvirNetlinkEventRemoveClient(int watch, const virMacAddr *macaddr,\n                            unsigned int protocol)\n{\n    size_t i;\n    int ret = -1;\n    virNetlinkEventSrvPrivatePtr srv = NULL;\n\n    if (protocol >= MAX_LINKS)\n        return -EINVAL;\n\n    srv = server[protocol];\n\n    VIR_DEBUG(\"removing client watch=%d, mac=%p.\", watch, macaddr);\n\n    if (watch <= 0 && !macaddr) {\n        VIR_WARN(\"Ignoring invalid netlink client id: %d\", watch);\n        return -1;\n    }\n\n    virNetlinkEventServerLock(srv);\n\n    for (i = 0; i < srv->handlesCount; i++) {\n        if (srv->handles[i].deleted != VIR_NETLINK_HANDLE_VALID)\n            continue;\n\n        if ((watch && srv->handles[i].watch == watch) ||\n            (!watch &&\n             virMacAddrCmp(macaddr, &srv->handles[i].macaddr) == 0)) {\n\n            VIR_DEBUG(\"removed client: %d by %s.\",\n                      srv->handles[i].watch, watch ? \"index\" : \"mac\");\n            virNetlinkEventRemoveClientPrimitive(i, protocol);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"no client found to remove.\");\n\n cleanup:\n    virNetlinkEventServerUnlock(srv);\n    return ret;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetlinkEventServerUnlock",
          "args": [
            "srv"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventServerUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "797-801",
          "snippet": "static void\nvirNetlinkEventServerUnlock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetlinkEventServerUnlock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"no client found to remove.\""
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkEventRemoveClientPrimitive",
          "args": [
            "i",
            "protocol"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventRemoveClientPrimitive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "817-832",
          "snippet": "static int\nvirNetlinkEventRemoveClientPrimitive(size_t i, unsigned int protocol)\n{\n    if (protocol >= MAX_LINKS)\n        return -EINVAL;\n\n    virNetlinkEventRemoveCallback removeCB = server[protocol]->handles[i].removeCB;\n\n    if (removeCB) {\n        (removeCB)(server[protocol]->handles[i].watch,\n                   &server[protocol]->handles[i].macaddr,\n                   server[protocol]->handles[i].opaque);\n    }\n    server[protocol]->handles[i].deleted = VIR_NETLINK_HANDLE_DELETED;\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetlinkEventRemoveClientPrimitive(size_t i, unsigned int protocol)\n{\n    if (protocol >= MAX_LINKS)\n        return -EINVAL;\n\n    virNetlinkEventRemoveCallback removeCB = server[protocol]->handles[i].removeCB;\n\n    if (removeCB) {\n        (removeCB)(server[protocol]->handles[i].watch,\n                   &server[protocol]->handles[i].macaddr,\n                   server[protocol]->handles[i].opaque);\n    }\n    server[protocol]->handles[i].deleted = VIR_NETLINK_HANDLE_DELETED;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"removed client: %d by %s.\"",
            "srv->handles[i].watch",
            "watch ? \"index\" : \"mac\""
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrCmp",
          "args": [
            "macaddr",
            "&srv->handles[i].macaddr"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrCmpRaw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "86-91",
          "snippet": "int\nvirMacAddrCmpRaw(const virMacAddr *mac1,\n                 const unsigned char mac2[VIR_MAC_BUFLEN])\n{\n    return memcmp(mac1->addr, mac2, VIR_MAC_BUFLEN);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint\nvirMacAddrCmpRaw(const virMacAddr *mac1,\n                 const unsigned char mac2[VIR_MAC_BUFLEN])\n{\n    return memcmp(mac1->addr, mac2, VIR_MAC_BUFLEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkEventServerLock",
          "args": [
            "srv"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventServerLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "791-795",
          "snippet": "static void\nvirNetlinkEventServerLock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetlinkEventServerLock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Ignoring invalid netlink client id: %d\"",
            "watch"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"removing client watch=%d, mac=%p.\"",
            "watch",
            "macaddr"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkEventRemoveClient(int watch, const virMacAddr *macaddr,\n                            unsigned int protocol)\n{\n    size_t i;\n    int ret = -1;\n    virNetlinkEventSrvPrivatePtr srv = NULL;\n\n    if (protocol >= MAX_LINKS)\n        return -EINVAL;\n\n    srv = server[protocol];\n\n    VIR_DEBUG(\"removing client watch=%d, mac=%p.\", watch, macaddr);\n\n    if (watch <= 0 && !macaddr) {\n        VIR_WARN(\"Ignoring invalid netlink client id: %d\", watch);\n        return -1;\n    }\n\n    virNetlinkEventServerLock(srv);\n\n    for (i = 0; i < srv->handlesCount; i++) {\n        if (srv->handles[i].deleted != VIR_NETLINK_HANDLE_VALID)\n            continue;\n\n        if ((watch && srv->handles[i].watch == watch) ||\n            (!watch &&\n             virMacAddrCmp(macaddr, &srv->handles[i].macaddr) == 0)) {\n\n            VIR_DEBUG(\"removed client: %d by %s.\",\n                      srv->handles[i].watch, watch ? \"index\" : \"mac\");\n            virNetlinkEventRemoveClientPrimitive(i, protocol);\n            ret = 0;\n            goto cleanup;\n        }\n    }\n    VIR_DEBUG(\"no client found to remove.\");\n\n cleanup:\n    virNetlinkEventServerUnlock(srv);\n    return ret;\n}"
  },
  {
    "function_name": "virNetlinkEventAddClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "1096-1157",
    "snippet": "int\nvirNetlinkEventAddClient(virNetlinkEventHandleCallback handleCB,\n                         virNetlinkEventRemoveCallback removeCB,\n                         void *opaque, const virMacAddr *macaddr,\n                         unsigned int protocol)\n{\n    size_t i;\n    int r, ret = -1;\n    virNetlinkEventSrvPrivatePtr srv = NULL;\n\n    if (protocol >= MAX_LINKS)\n        return -EINVAL;\n\n    srv = server[protocol];\n\n    if (handleCB == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Invalid NULL callback provided\"));\n        return -1;\n    }\n\n    virNetlinkEventServerLock(srv);\n\n    VIR_DEBUG(\"adding client: %d.\", nextWatch);\n\n    r = 0;\n    /* first try to re-use deleted free slots */\n    for (i = 0; i < srv->handlesCount; i++) {\n        if (srv->handles[i].deleted == VIR_NETLINK_HANDLE_DELETED) {\n            r = i;\n            goto addentry;\n        }\n    }\n    /* Resize the eventLoop array if needed */\n    if (srv->handlesCount == srv->handlesAlloc) {\n        VIR_DEBUG(\"Used %zu handle slots, adding at least %d more\",\n                  srv->handlesAlloc, NETLINK_EVENT_ALLOC_EXTENT);\n        if (VIR_RESIZE_N(srv->handles, srv->handlesAlloc,\n                         srv->handlesCount, NETLINK_EVENT_ALLOC_EXTENT) < 0)\n            goto error;\n    }\n    r = srv->handlesCount++;\n\n addentry:\n    srv->handles[r].watch    = nextWatch;\n    srv->handles[r].handleCB = handleCB;\n    srv->handles[r].removeCB = removeCB;\n    srv->handles[r].opaque   = opaque;\n    srv->handles[r].deleted  = VIR_NETLINK_HANDLE_VALID;\n    if (macaddr)\n        virMacAddrSet(&srv->handles[r].macaddr, macaddr);\n    else\n        virMacAddrSetRaw(&srv->handles[r].macaddr,\n                         (unsigned char[VIR_MAC_BUFLEN]){0, 0, 0, 0, 0, 0});\n\n    VIR_DEBUG(\"added client to loop slot: %d. with macaddr ptr=%p\", r, macaddr);\n\n    ret = nextWatch++;\n error:\n    virNetlinkEventServerUnlock(srv);\n    return ret;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetlinkEventServerUnlock",
          "args": [
            "srv"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventServerUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "797-801",
          "snippet": "static void\nvirNetlinkEventServerUnlock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetlinkEventServerUnlock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"added client to loop slot: %d. with macaddr ptr=%p\"",
            "r",
            "macaddr"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrSetRaw",
          "args": [
            "&srv->handles[r].macaddr",
            "(unsigned char[VIR_MAC_BUFLEN]){0, 0, 0, 0, 0, 0}"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrSetRaw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "113-117",
          "snippet": "void\nvirMacAddrSetRaw(virMacAddrPtr dst, const unsigned char src[VIR_MAC_BUFLEN])\n{\n    memcpy(dst->addr, src, VIR_MAC_BUFLEN);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nvoid\nvirMacAddrSetRaw(virMacAddrPtr dst, const unsigned char src[VIR_MAC_BUFLEN])\n{\n    memcpy(dst->addr, src, VIR_MAC_BUFLEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "srv->handles",
            "srv->handlesAlloc",
            "srv->handlesCount",
            "NETLINK_EVENT_ALLOC_EXTENT"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Used %zu handle slots, adding at least %d more\"",
            "srv->handlesAlloc",
            "NETLINK_EVENT_ALLOC_EXTENT"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"adding client: %d.\"",
            "nextWatch"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkEventServerLock",
          "args": [
            "srv"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventServerLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "791-795",
          "snippet": "static void\nvirNetlinkEventServerLock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetlinkEventServerLock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid NULL callback provided\")"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid NULL callback provided\""
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkEventAddClient(virNetlinkEventHandleCallback handleCB,\n                         virNetlinkEventRemoveCallback removeCB,\n                         void *opaque, const virMacAddr *macaddr,\n                         unsigned int protocol)\n{\n    size_t i;\n    int r, ret = -1;\n    virNetlinkEventSrvPrivatePtr srv = NULL;\n\n    if (protocol >= MAX_LINKS)\n        return -EINVAL;\n\n    srv = server[protocol];\n\n    if (handleCB == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Invalid NULL callback provided\"));\n        return -1;\n    }\n\n    virNetlinkEventServerLock(srv);\n\n    VIR_DEBUG(\"adding client: %d.\", nextWatch);\n\n    r = 0;\n    /* first try to re-use deleted free slots */\n    for (i = 0; i < srv->handlesCount; i++) {\n        if (srv->handles[i].deleted == VIR_NETLINK_HANDLE_DELETED) {\n            r = i;\n            goto addentry;\n        }\n    }\n    /* Resize the eventLoop array if needed */\n    if (srv->handlesCount == srv->handlesAlloc) {\n        VIR_DEBUG(\"Used %zu handle slots, adding at least %d more\",\n                  srv->handlesAlloc, NETLINK_EVENT_ALLOC_EXTENT);\n        if (VIR_RESIZE_N(srv->handles, srv->handlesAlloc,\n                         srv->handlesCount, NETLINK_EVENT_ALLOC_EXTENT) < 0)\n            goto error;\n    }\n    r = srv->handlesCount++;\n\n addentry:\n    srv->handles[r].watch    = nextWatch;\n    srv->handles[r].handleCB = handleCB;\n    srv->handles[r].removeCB = removeCB;\n    srv->handles[r].opaque   = opaque;\n    srv->handles[r].deleted  = VIR_NETLINK_HANDLE_VALID;\n    if (macaddr)\n        virMacAddrSet(&srv->handles[r].macaddr, macaddr);\n    else\n        virMacAddrSetRaw(&srv->handles[r].macaddr,\n                         (unsigned char[VIR_MAC_BUFLEN]){0, 0, 0, 0, 0, 0});\n\n    VIR_DEBUG(\"added client to loop slot: %d. with macaddr ptr=%p\", r, macaddr);\n\n    ret = nextWatch++;\n error:\n    virNetlinkEventServerUnlock(srv);\n    return ret;\n}"
  },
  {
    "function_name": "virNetlinkEventServiceStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "999-1077",
    "snippet": "int\nvirNetlinkEventServiceStart(unsigned int protocol, unsigned int groups)\n{\n    virNetlinkEventSrvPrivatePtr srv;\n    int fd;\n    int ret = -1;\n\n    if (protocol >= MAX_LINKS) {\n        virReportSystemError(EINVAL,\n                             _(\"invalid protocol argument: %d\"), protocol);\n        return -EINVAL;\n    }\n\n    if (server[protocol])\n        return 0;\n\n    VIR_INFO(\"starting netlink event service with protocol %d\", protocol);\n\n    if (VIR_ALLOC(srv) < 0)\n        return -1;\n\n    if (virMutexInit(&srv->lock) < 0) {\n        VIR_FREE(srv);\n        return -1;\n    }\n\n    virNetlinkEventServerLock(srv);\n\n    /* Allocate a new socket and get fd */\n    if (!(srv->netlinknh = virNetlinkCreateSocket(protocol)))\n        goto error_locked;\n\n    fd = nl_socket_get_fd(srv->netlinknh);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot get netlink socket fd\"));\n        goto error_server;\n    }\n\n    if (groups && nl_socket_add_membership(srv->netlinknh, groups) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot add netlink membership\"));\n        goto error_server;\n    }\n\n    if (nl_socket_set_nonblocking(srv->netlinknh)) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot set netlink socket nonblocking\"));\n        goto error_server;\n    }\n\n    if ((srv->eventwatch = virEventAddHandle(fd,\n                                             VIR_EVENT_HANDLE_READABLE,\n                                             virNetlinkEventCallback,\n                                             srv, NULL)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to add netlink event handle watch\"));\n        goto error_server;\n    }\n\n    srv->netlinkfd = fd;\n    VIR_DEBUG(\"netlink event listener on fd: %i running\", fd);\n\n    ret = 0;\n    server[protocol] = srv;\n\n error_server:\n    if (ret < 0) {\n        nl_close(srv->netlinknh);\n        virNetlinkFree(srv->netlinknh);\n    }\n error_locked:\n    virNetlinkEventServerUnlock(srv);\n    if (ret < 0) {\n        virMutexDestroy(&srv->lock);\n        VIR_FREE(srv);\n    }\n    return ret;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "srv"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&srv->lock"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkEventServerUnlock",
          "args": [
            "srv"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventServerUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "797-801",
          "snippet": "static void\nvirNetlinkEventServerUnlock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetlinkEventServerUnlock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkFree",
          "args": [
            "srv->netlinknh"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_close",
          "args": [
            "srv->netlinknh"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"netlink event listener on fd: %i running\"",
            "fd"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to add netlink event handle watch\")"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to add netlink event handle watch\""
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virEventAddHandle",
          "args": [
            "fd",
            "VIR_EVENT_HANDLE_READABLE",
            "virNetlinkEventCallback",
            "srv",
            "NULL"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "virEventAddHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "73-84",
          "snippet": "int\nvirEventAddHandle(int fd,\n                  int events,\n                  virEventHandleCallback cb,\n                  void *opaque,\n                  virFreeCallback ff)\n{\n    if (!addHandleImpl)\n        return -1;\n\n    return addHandleImpl(fd, events, cb, opaque, ff);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventAddHandleFunc addHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventAddHandleFunc addHandleImpl;\n\nint\nvirEventAddHandle(int fd,\n                  int events,\n                  virEventHandleCallback cb,\n                  void *opaque,\n                  virFreeCallback ff)\n{\n    if (!addHandleImpl)\n        return -1;\n\n    return addHandleImpl(fd, events, cb, opaque, ff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot set netlink socket nonblocking\")"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_socket_set_nonblocking",
          "args": [
            "srv->netlinknh"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot add netlink membership\")"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_socket_add_membership",
          "args": [
            "srv->netlinknh",
            "groups"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot get netlink socket fd\")"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_socket_get_fd",
          "args": [
            "srv->netlinknh"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkCreateSocket",
          "args": [
            "protocol"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkCreateSocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "161-194",
          "snippet": "static virNetlinkHandle *\nvirNetlinkCreateSocket(int protocol)\n{\n    virNetlinkHandle *nlhandle = NULL;\n\n    if (!(nlhandle = virNetlinkAlloc())) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot allocate nlhandle for netlink\"));\n        goto error;\n    }\n    if (nl_connect(nlhandle, protocol) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot connect to netlink socket \"\n                               \"with protocol %d\"), protocol);\n        goto error;\n    }\n\n    if (virNetlinkSetBufferSize(nlhandle, 131702, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot set netlink socket buffer \"\n                               \"size to 128k\"));\n        goto error;\n    }\n    nl_socket_enable_msg_peek(nlhandle);\n\n    return nlhandle;\n\n error:\n    if (nlhandle) {\n        nl_close(nlhandle);\n        virNetlinkFree(nlhandle);\n    }\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetlinkHandle *\nvirNetlinkCreateSocket(int protocol)\n{\n    virNetlinkHandle *nlhandle = NULL;\n\n    if (!(nlhandle = virNetlinkAlloc())) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot allocate nlhandle for netlink\"));\n        goto error;\n    }\n    if (nl_connect(nlhandle, protocol) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot connect to netlink socket \"\n                               \"with protocol %d\"), protocol);\n        goto error;\n    }\n\n    if (virNetlinkSetBufferSize(nlhandle, 131702, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot set netlink socket buffer \"\n                               \"size to 128k\"));\n        goto error;\n    }\n    nl_socket_enable_msg_peek(nlhandle);\n\n    return nlhandle;\n\n error:\n    if (nlhandle) {\n        nl_close(nlhandle);\n        virNetlinkFree(nlhandle);\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkEventServerLock",
          "args": [
            "srv"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventServerLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "791-795",
          "snippet": "static void\nvirNetlinkEventServerLock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetlinkEventServerLock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "srv"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexInit",
          "args": [
            "&srv->lock"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "srv"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"starting netlink event service with protocol %d\"",
            "protocol"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EINVAL",
            "_(\"invalid protocol argument: %d\")",
            "protocol"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkEventServiceStart(unsigned int protocol, unsigned int groups)\n{\n    virNetlinkEventSrvPrivatePtr srv;\n    int fd;\n    int ret = -1;\n\n    if (protocol >= MAX_LINKS) {\n        virReportSystemError(EINVAL,\n                             _(\"invalid protocol argument: %d\"), protocol);\n        return -EINVAL;\n    }\n\n    if (server[protocol])\n        return 0;\n\n    VIR_INFO(\"starting netlink event service with protocol %d\", protocol);\n\n    if (VIR_ALLOC(srv) < 0)\n        return -1;\n\n    if (virMutexInit(&srv->lock) < 0) {\n        VIR_FREE(srv);\n        return -1;\n    }\n\n    virNetlinkEventServerLock(srv);\n\n    /* Allocate a new socket and get fd */\n    if (!(srv->netlinknh = virNetlinkCreateSocket(protocol)))\n        goto error_locked;\n\n    fd = nl_socket_get_fd(srv->netlinknh);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot get netlink socket fd\"));\n        goto error_server;\n    }\n\n    if (groups && nl_socket_add_membership(srv->netlinknh, groups) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot add netlink membership\"));\n        goto error_server;\n    }\n\n    if (nl_socket_set_nonblocking(srv->netlinknh)) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot set netlink socket nonblocking\"));\n        goto error_server;\n    }\n\n    if ((srv->eventwatch = virEventAddHandle(fd,\n                                             VIR_EVENT_HANDLE_READABLE,\n                                             virNetlinkEventCallback,\n                                             srv, NULL)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to add netlink event handle watch\"));\n        goto error_server;\n    }\n\n    srv->netlinkfd = fd;\n    VIR_DEBUG(\"netlink event listener on fd: %i running\", fd);\n\n    ret = 0;\n    server[protocol] = srv;\n\n error_server:\n    if (ret < 0) {\n        nl_close(srv->netlinknh);\n        virNetlinkFree(srv->netlinknh);\n    }\n error_locked:\n    virNetlinkEventServerUnlock(srv);\n    if (ret < 0) {\n        virMutexDestroy(&srv->lock);\n        VIR_FREE(srv);\n    }\n    return ret;\n}"
  },
  {
    "function_name": "virNetlinkEventServiceLocalPid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "974-985",
    "snippet": "int virNetlinkEventServiceLocalPid(unsigned int protocol)\n{\n    if (protocol >= MAX_LINKS)\n        return -EINVAL;\n\n    if (!(server[protocol] && server[protocol]->netlinknh)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"netlink event service not running\"));\n        return -1;\n    }\n    return (int)nl_socket_get_local_port(server[protocol]->netlinknh);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nl_socket_get_local_port",
          "args": [
            "server[protocol]->netlinknh"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"netlink event service not running\")"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"netlink event service not running\""
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkEventServiceLocalPid(unsigned int protocol)\n{\n    if (protocol >= MAX_LINKS)\n        return -EINVAL;\n\n    if (!(server[protocol] && server[protocol]->netlinknh)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"netlink event service not running\"));\n        return -1;\n    }\n    return (int)nl_socket_get_local_port(server[protocol]->netlinknh);\n}"
  },
  {
    "function_name": "virNetlinkEventServiceIsRunning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "953-963",
    "snippet": "bool\nvirNetlinkEventServiceIsRunning(unsigned int protocol)\n{\n    if (protocol >= MAX_LINKS) {\n        virReportSystemError(EINVAL,\n                             _(\"invalid protocol argument: %d\"), protocol);\n        return false;\n    }\n\n    return server[protocol] != NULL;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EINVAL",
            "_(\"invalid protocol argument: %d\")",
            "protocol"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid protocol argument: %d\""
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirNetlinkEventServiceIsRunning(unsigned int protocol)\n{\n    if (protocol >= MAX_LINKS) {\n        virReportSystemError(EINVAL,\n                             _(\"invalid protocol argument: %d\"), protocol);\n        return false;\n    }\n\n    return server[protocol] != NULL;\n}"
  },
  {
    "function_name": "virNetlinkEventServiceStopAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "931-942",
    "snippet": "int\nvirNetlinkEventServiceStopAll(void)\n{\n    size_t i;\n\n    VIR_INFO(\"stopping all netlink event services\");\n\n    for (i = 0; i < MAX_LINKS; i++)\n        virNetlinkEventServiceStop(i);\n\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetlinkEventServiceStop",
          "args": [
            "i"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventServiceStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1309-1313",
          "snippet": "int virNetlinkEventServiceStop(unsigned int protocol G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"%s\", _(unsupported));\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkEventServiceStop(unsigned int protocol G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"%s\", _(unsupported));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"stopping all netlink event services\""
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkEventServiceStopAll(void)\n{\n    size_t i;\n\n    VIR_INFO(\"stopping all netlink event services\");\n\n    for (i = 0; i < MAX_LINKS; i++)\n        virNetlinkEventServiceStop(i);\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetlinkEventServiceStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "890-922",
    "snippet": "int\nvirNetlinkEventServiceStop(unsigned int protocol)\n{\n    if (protocol >= MAX_LINKS)\n        return -EINVAL;\n\n    virNetlinkEventSrvPrivatePtr srv = server[protocol];\n    size_t i;\n\n    VIR_INFO(\"stopping netlink event service\");\n\n    if (!server[protocol])\n        return 0;\n\n    virNetlinkEventServerLock(srv);\n    nl_close(srv->netlinknh);\n    virNetlinkFree(srv->netlinknh);\n    virEventRemoveHandle(srv->eventwatch);\n\n    /* free any remaining clients on the list */\n    for (i = 0; i < srv->handlesCount; i++) {\n        if (srv->handles[i].deleted == VIR_NETLINK_HANDLE_VALID)\n            virNetlinkEventRemoveClientPrimitive(i, protocol);\n    }\n\n    server[protocol] = NULL;\n    VIR_FREE(srv->handles);\n    virNetlinkEventServerUnlock(srv);\n\n    virMutexDestroy(&srv->lock);\n    VIR_FREE(srv);\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "srv"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&srv->lock"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkEventServerUnlock",
          "args": [
            "srv"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventServerUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "797-801",
          "snippet": "static void\nvirNetlinkEventServerUnlock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetlinkEventServerUnlock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "srv->handles"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkEventRemoveClientPrimitive",
          "args": [
            "i",
            "protocol"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventRemoveClientPrimitive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "817-832",
          "snippet": "static int\nvirNetlinkEventRemoveClientPrimitive(size_t i, unsigned int protocol)\n{\n    if (protocol >= MAX_LINKS)\n        return -EINVAL;\n\n    virNetlinkEventRemoveCallback removeCB = server[protocol]->handles[i].removeCB;\n\n    if (removeCB) {\n        (removeCB)(server[protocol]->handles[i].watch,\n                   &server[protocol]->handles[i].macaddr,\n                   server[protocol]->handles[i].opaque);\n    }\n    server[protocol]->handles[i].deleted = VIR_NETLINK_HANDLE_DELETED;\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetlinkEventRemoveClientPrimitive(size_t i, unsigned int protocol)\n{\n    if (protocol >= MAX_LINKS)\n        return -EINVAL;\n\n    virNetlinkEventRemoveCallback removeCB = server[protocol]->handles[i].removeCB;\n\n    if (removeCB) {\n        (removeCB)(server[protocol]->handles[i].watch,\n                   &server[protocol]->handles[i].macaddr,\n                   server[protocol]->handles[i].opaque);\n    }\n    server[protocol]->handles[i].deleted = VIR_NETLINK_HANDLE_DELETED;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virEventRemoveHandle",
          "args": [
            "srv->eventwatch"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "virEventRemoveHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "116-123",
          "snippet": "int\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventRemoveHandleFunc removeHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventRemoveHandleFunc removeHandleImpl;\n\nint\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkFree",
          "args": [
            "srv->netlinknh"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_close",
          "args": [
            "srv->netlinknh"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkEventServerLock",
          "args": [
            "srv"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventServerLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "791-795",
          "snippet": "static void\nvirNetlinkEventServerLock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetlinkEventServerLock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"stopping netlink event service\""
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkEventServiceStop(unsigned int protocol)\n{\n    if (protocol >= MAX_LINKS)\n        return -EINVAL;\n\n    virNetlinkEventSrvPrivatePtr srv = server[protocol];\n    size_t i;\n\n    VIR_INFO(\"stopping netlink event service\");\n\n    if (!server[protocol])\n        return 0;\n\n    virNetlinkEventServerLock(srv);\n    nl_close(srv->netlinknh);\n    virNetlinkFree(srv->netlinknh);\n    virEventRemoveHandle(srv->eventwatch);\n\n    /* free any remaining clients on the list */\n    for (i = 0; i < srv->handlesCount; i++) {\n        if (srv->handles[i].deleted == VIR_NETLINK_HANDLE_VALID)\n            virNetlinkEventRemoveClientPrimitive(i, protocol);\n    }\n\n    server[protocol] = NULL;\n    VIR_FREE(srv->handles);\n    virNetlinkEventServerUnlock(srv);\n\n    virMutexDestroy(&srv->lock);\n    VIR_FREE(srv);\n    return 0;\n}"
  },
  {
    "function_name": "virNetlinkEventCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "834-878",
    "snippet": "static void\nvirNetlinkEventCallback(int watch,\n                        int fd G_GNUC_UNUSED,\n                        int events G_GNUC_UNUSED,\n                        void *opaque)\n{\n    virNetlinkEventSrvPrivatePtr srv = opaque;\n    struct sockaddr_nl peer;\n    struct ucred *creds = NULL;\n    size_t i;\n    int length;\n    bool handled = false;\n    g_autofree struct nlmsghdr *msg = NULL;\n\n    length = nl_recv(srv->netlinknh, &peer,\n                     (unsigned char **)&msg, &creds);\n\n    if (length == 0)\n        return;\n    if (length < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"nl_recv returned with error\"));\n        return;\n    }\n\n    virNetlinkEventServerLock(srv);\n\n    VIR_DEBUG(\"dispatching to max %d clients, called from event watch %d\",\n              (int)srv->handlesCount, watch);\n\n    for (i = 0; i < srv->handlesCount; i++) {\n        if (srv->handles[i].deleted != VIR_NETLINK_HANDLE_VALID)\n            continue;\n\n        VIR_DEBUG(\"dispatching client %zu.\", i);\n\n        (srv->handles[i].handleCB)(msg, length, &peer, &handled,\n                                   srv->handles[i].opaque);\n    }\n\n    if (!handled)\n        VIR_DEBUG(\"event not handled.\");\n\n    virNetlinkEventServerUnlock(srv);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetlinkEventServerUnlock",
          "args": [
            "srv"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventServerUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "797-801",
          "snippet": "static void\nvirNetlinkEventServerUnlock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetlinkEventServerUnlock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"event not handled.\""
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "msg",
            "length",
            "&peer",
            "&handled",
            "srv->handles[i].opaque"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"dispatching client %zu.\"",
            "i"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"dispatching to max %d clients, called from event watch %d\"",
            "(int)srv->handlesCount",
            "watch"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkEventServerLock",
          "args": [
            "srv"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventServerLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "791-795",
          "snippet": "static void\nvirNetlinkEventServerLock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetlinkEventServerLock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"nl_recv returned with error\")"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"nl_recv returned with error\""
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nl_recv",
          "args": [
            "srv->netlinknh",
            "&peer",
            "(unsigned char **)&msg",
            "&creds"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetlinkEventCallback(int watch,\n                        int fd G_GNUC_UNUSED,\n                        int events G_GNUC_UNUSED,\n                        void *opaque)\n{\n    virNetlinkEventSrvPrivatePtr srv = opaque;\n    struct sockaddr_nl peer;\n    struct ucred *creds = NULL;\n    size_t i;\n    int length;\n    bool handled = false;\n    g_autofree struct nlmsghdr *msg = NULL;\n\n    length = nl_recv(srv->netlinknh, &peer,\n                     (unsigned char **)&msg, &creds);\n\n    if (length == 0)\n        return;\n    if (length < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"nl_recv returned with error\"));\n        return;\n    }\n\n    virNetlinkEventServerLock(srv);\n\n    VIR_DEBUG(\"dispatching to max %d clients, called from event watch %d\",\n              (int)srv->handlesCount, watch);\n\n    for (i = 0; i < srv->handlesCount; i++) {\n        if (srv->handles[i].deleted != VIR_NETLINK_HANDLE_VALID)\n            continue;\n\n        VIR_DEBUG(\"dispatching client %zu.\", i);\n\n        (srv->handles[i].handleCB)(msg, length, &peer, &handled,\n                                   srv->handles[i].opaque);\n    }\n\n    if (!handled)\n        VIR_DEBUG(\"event not handled.\");\n\n    virNetlinkEventServerUnlock(srv);\n}"
  },
  {
    "function_name": "virNetlinkEventRemoveClientPrimitive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "817-832",
    "snippet": "static int\nvirNetlinkEventRemoveClientPrimitive(size_t i, unsigned int protocol)\n{\n    if (protocol >= MAX_LINKS)\n        return -EINVAL;\n\n    virNetlinkEventRemoveCallback removeCB = server[protocol]->handles[i].removeCB;\n\n    if (removeCB) {\n        (removeCB)(server[protocol]->handles[i].watch,\n                   &server[protocol]->handles[i].macaddr,\n                   server[protocol]->handles[i].opaque);\n    }\n    server[protocol]->handles[i].deleted = VIR_NETLINK_HANDLE_DELETED;\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "server[protocol]->handles[i].watch",
            "&server[protocol]->handles[i].macaddr",
            "server[protocol]->handles[i].opaque"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirNetlinkEventRemoveClientPrimitive(size_t i, unsigned int protocol)\n{\n    if (protocol >= MAX_LINKS)\n        return -EINVAL;\n\n    virNetlinkEventRemoveCallback removeCB = server[protocol]->handles[i].removeCB;\n\n    if (removeCB) {\n        (removeCB)(server[protocol]->handles[i].watch,\n                   &server[protocol]->handles[i].macaddr,\n                   server[protocol]->handles[i].opaque);\n    }\n    server[protocol]->handles[i].deleted = VIR_NETLINK_HANDLE_DELETED;\n    return 0;\n}"
  },
  {
    "function_name": "virNetlinkEventServerUnlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "797-801",
    "snippet": "static void\nvirNetlinkEventServerUnlock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&driver->lock"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetlinkEventServerUnlock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexUnlock(&driver->lock);\n}"
  },
  {
    "function_name": "virNetlinkEventServerLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "791-795",
    "snippet": "static void\nvirNetlinkEventServerLock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&driver->lock"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirNetlinkEventServerLock(virNetlinkEventSrvPrivatePtr driver)\n{\n    virMutexLock(&driver->lock);\n}"
  },
  {
    "function_name": "virNetlinkGetErrorCode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "749-788",
    "snippet": "int\nvirNetlinkGetErrorCode(struct nlmsghdr *resp, unsigned int recvbuflen)\n{\n    struct nlmsgerr *err;\n    int result = 0;\n\n    if (recvbuflen < NLMSG_LENGTH(0) || resp == NULL)\n        goto malformed_resp;\n\n    switch (resp->nlmsg_type) {\n    case NLMSG_ERROR:\n        err = (struct nlmsgerr *)NLMSG_DATA(resp);\n        if (resp->nlmsg_len < NLMSG_LENGTH(sizeof(*err)))\n            goto malformed_resp;\n\n        switch (err->error) {\n        case 0: /* ACK */\n            break;\n\n        default:\n            result = err->error;\n        }\n        break;\n\n    case NLMSG_DONE:\n        break;\n\n    default:\n        /* We allow multipart messages. */\n        if (!(resp->nlmsg_flags & NLM_F_MULTI))\n            goto malformed_resp;\n    }\n\n    return result;\n\n malformed_resp:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"malformed netlink response message\"));\n    return -EINVAL;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed netlink response message\")"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed netlink response message\""
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(*err)"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "resp"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "0"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkGetErrorCode(struct nlmsghdr *resp, unsigned int recvbuflen)\n{\n    struct nlmsgerr *err;\n    int result = 0;\n\n    if (recvbuflen < NLMSG_LENGTH(0) || resp == NULL)\n        goto malformed_resp;\n\n    switch (resp->nlmsg_type) {\n    case NLMSG_ERROR:\n        err = (struct nlmsgerr *)NLMSG_DATA(resp);\n        if (resp->nlmsg_len < NLMSG_LENGTH(sizeof(*err)))\n            goto malformed_resp;\n\n        switch (err->error) {\n        case 0: /* ACK */\n            break;\n\n        default:\n            result = err->error;\n        }\n        break;\n\n    case NLMSG_DONE:\n        break;\n\n    default:\n        /* We allow multipart messages. */\n        if (!(resp->nlmsg_flags & NLM_F_MULTI))\n            goto malformed_resp;\n    }\n\n    return result;\n\n malformed_resp:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"malformed netlink response message\"));\n    return -EINVAL;\n}"
  },
  {
    "function_name": "virNetlinkGetNeighbor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "687-747",
    "snippet": "int\nvirNetlinkGetNeighbor(void **nlData, uint32_t src_pid, uint32_t dst_pid)\n{\n    struct nlmsgerr *err;\n    struct ndmsg ndinfo = {\n        .ndm_family = AF_UNSPEC,\n    };\n    unsigned int recvbuflen;\n    g_autoptr(virNetlinkMsg) nl_msg = NULL;\n    g_autofree struct nlmsghdr *resp = NULL;\n\n    nl_msg = nlmsg_alloc_simple(RTM_GETNEIGH, NLM_F_DUMP | NLM_F_REQUEST);\n    if (!nl_msg) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if (nlmsg_append(nl_msg, &ndinfo, sizeof(ndinfo), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n\n    if (virNetlinkCommand(nl_msg, &resp, &recvbuflen,\n                          src_pid, dst_pid, NETLINK_ROUTE, 0) < 0)\n        return -1;\n\n    if (recvbuflen < NLMSG_LENGTH(0) || resp == NULL)\n        goto malformed_resp;\n\n    switch (resp->nlmsg_type) {\n    case NLMSG_ERROR:\n        err = (struct nlmsgerr *)NLMSG_DATA(resp);\n        if (resp->nlmsg_len < NLMSG_LENGTH(sizeof(*err)))\n            goto malformed_resp;\n\n        if (err->error) {\n            virReportSystemError(-err->error,\n                                 \"%s\", _(\"error dumping\"));\n            return -1;\n        }\n        break;\n\n    case RTM_NEWNEIGH:\n        break;\n\n    default:\n        goto malformed_resp;\n    }\n\n    *nlData = g_steal_pointer(&resp);\n    return recvbuflen;\n\n malformed_resp:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"malformed netlink response message\"));\n    return -1;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"allocated netlink buffer is too small\")"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"allocated netlink buffer is too small\""
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed netlink response message\")"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&resp"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-err->error",
            "\"%s\"",
            "_(\"error dumping\")"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(*err)"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "resp"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "0"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkCommand",
          "args": [
            "nl_msg",
            "&resp",
            "&recvbuflen",
            "src_pid",
            "dst_pid",
            "NETLINK_ROUTE",
            "0"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1236-1246",
          "snippet": "int virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_append",
          "args": [
            "nl_msg",
            "&ndinfo",
            "sizeof(ndinfo)",
            "NLMSG_ALIGNTO"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_simple",
          "args": [
            "RTM_GETNEIGH",
            "NLM_F_DUMP | NLM_F_REQUEST"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkGetNeighbor(void **nlData, uint32_t src_pid, uint32_t dst_pid)\n{\n    struct nlmsgerr *err;\n    struct ndmsg ndinfo = {\n        .ndm_family = AF_UNSPEC,\n    };\n    unsigned int recvbuflen;\n    g_autoptr(virNetlinkMsg) nl_msg = NULL;\n    g_autofree struct nlmsghdr *resp = NULL;\n\n    nl_msg = nlmsg_alloc_simple(RTM_GETNEIGH, NLM_F_DUMP | NLM_F_REQUEST);\n    if (!nl_msg) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if (nlmsg_append(nl_msg, &ndinfo, sizeof(ndinfo), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n\n    if (virNetlinkCommand(nl_msg, &resp, &recvbuflen,\n                          src_pid, dst_pid, NETLINK_ROUTE, 0) < 0)\n        return -1;\n\n    if (recvbuflen < NLMSG_LENGTH(0) || resp == NULL)\n        goto malformed_resp;\n\n    switch (resp->nlmsg_type) {\n    case NLMSG_ERROR:\n        err = (struct nlmsgerr *)NLMSG_DATA(resp);\n        if (resp->nlmsg_len < NLMSG_LENGTH(sizeof(*err)))\n            goto malformed_resp;\n\n        if (err->error) {\n            virReportSystemError(-err->error,\n                                 \"%s\", _(\"error dumping\"));\n            return -1;\n        }\n        break;\n\n    case RTM_NEWNEIGH:\n        break;\n\n    default:\n        goto malformed_resp;\n    }\n\n    *nlData = g_steal_pointer(&resp);\n    return recvbuflen;\n\n malformed_resp:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"malformed netlink response message\"));\n    return -1;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNetlinkDelLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "605-670",
    "snippet": "int\nvirNetlinkDelLink(const char *ifname, virNetlinkDelLinkFallback fallback)\n{\n    struct nlmsgerr *err;\n    struct ifinfomsg ifinfo = { .ifi_family = AF_UNSPEC };\n    unsigned int recvbuflen;\n    g_autoptr(virNetlinkMsg) nl_msg = NULL;\n    g_autofree struct nlmsghdr *resp = NULL;\n\n    nl_msg = nlmsg_alloc_simple(RTM_DELLINK,\n                                NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL);\n    if (!nl_msg) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if (nlmsg_append(nl_msg,  &ifinfo, sizeof(ifinfo), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (nla_put(nl_msg, IFLA_IFNAME, strlen(ifname)+1, ifname) < 0)\n        goto buffer_too_small;\n\n    if (virNetlinkCommand(nl_msg, &resp, &recvbuflen, 0, 0,\n                          NETLINK_ROUTE, 0) < 0) {\n        return -1;\n    }\n\n    if (recvbuflen < NLMSG_LENGTH(0) || resp == NULL)\n        goto malformed_resp;\n\n    switch (resp->nlmsg_type) {\n    case NLMSG_ERROR:\n        err = (struct nlmsgerr *)NLMSG_DATA(resp);\n        if (resp->nlmsg_len < NLMSG_LENGTH(sizeof(*err)))\n            goto malformed_resp;\n\n        if (-err->error == EOPNOTSUPP && fallback)\n            return fallback(ifname);\n\n        if (err->error) {\n            virReportSystemError(-err->error,\n                                 _(\"error destroying network device %s\"),\n                                 ifname);\n            return -1;\n        }\n        break;\n\n    case NLMSG_DONE:\n        break;\n\n    default:\n        goto malformed_resp;\n    }\n\n    return 0;\n\n malformed_resp:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"malformed netlink response message\"));\n    return -1;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"allocated netlink buffer is too small\")"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"allocated netlink buffer is too small\""
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed netlink response message\")"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-err->error",
            "_(\"error destroying network device %s\")",
            "ifname"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fallback",
          "args": [
            "ifname"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(*err)"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "resp"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "0"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkCommand",
          "args": [
            "nl_msg",
            "&resp",
            "&recvbuflen",
            "0",
            "0",
            "NETLINK_ROUTE",
            "0"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1236-1246",
          "snippet": "int virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nl_msg",
            "IFLA_IFNAME",
            "strlen(ifname)+1",
            "ifname"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ifname"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_append",
          "args": [
            "nl_msg",
            "&ifinfo",
            "sizeof(ifinfo)",
            "NLMSG_ALIGNTO"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_simple",
          "args": [
            "RTM_DELLINK",
            "NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkDelLink(const char *ifname, virNetlinkDelLinkFallback fallback)\n{\n    struct nlmsgerr *err;\n    struct ifinfomsg ifinfo = { .ifi_family = AF_UNSPEC };\n    unsigned int recvbuflen;\n    g_autoptr(virNetlinkMsg) nl_msg = NULL;\n    g_autofree struct nlmsghdr *resp = NULL;\n\n    nl_msg = nlmsg_alloc_simple(RTM_DELLINK,\n                                NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL);\n    if (!nl_msg) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if (nlmsg_append(nl_msg,  &ifinfo, sizeof(ifinfo), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (nla_put(nl_msg, IFLA_IFNAME, strlen(ifname)+1, ifname) < 0)\n        goto buffer_too_small;\n\n    if (virNetlinkCommand(nl_msg, &resp, &recvbuflen, 0, 0,\n                          NETLINK_ROUTE, 0) < 0) {\n        return -1;\n    }\n\n    if (recvbuflen < NLMSG_LENGTH(0) || resp == NULL)\n        goto malformed_resp;\n\n    switch (resp->nlmsg_type) {\n    case NLMSG_ERROR:\n        err = (struct nlmsgerr *)NLMSG_DATA(resp);\n        if (resp->nlmsg_len < NLMSG_LENGTH(sizeof(*err)))\n            goto malformed_resp;\n\n        if (-err->error == EOPNOTSUPP && fallback)\n            return fallback(ifname);\n\n        if (err->error) {\n            virReportSystemError(-err->error,\n                                 _(\"error destroying network device %s\"),\n                                 ifname);\n            return -1;\n        }\n        break;\n\n    case NLMSG_DONE:\n        break;\n\n    default:\n        goto malformed_resp;\n    }\n\n    return 0;\n\n malformed_resp:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"malformed netlink response message\"));\n    return -1;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNetlinkNewLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "489-587",
    "snippet": "int\nvirNetlinkNewLink(const char *ifname,\n                  const char *type,\n                  virNetlinkNewLinkDataPtr extra_args,\n                  int *error)\n{\n    struct nlmsgerr *err;\n    struct nlattr *linkinfo = NULL;\n    struct nlattr *infodata = NULL;\n    unsigned int buflen;\n    struct ifinfomsg ifinfo = { .ifi_family = AF_UNSPEC };\n    g_autoptr(virNetlinkMsg) nl_msg = NULL;\n    g_autofree struct nlmsghdr *resp = NULL;\n\n    *error = 0;\n\n    VIR_DEBUG(\"Creating %s interface '%s'\", type, ifname);\n\n    if (!ifname || !type) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"both interface name and type must not be NULL\"));\n        return -1;\n    }\n\n    nl_msg = nlmsg_alloc_simple(RTM_NEWLINK,\n                                NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL);\n    if (!nl_msg) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if (nlmsg_append(nl_msg,  &ifinfo, sizeof(ifinfo), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    NETLINK_MSG_PUT(nl_msg, IFLA_IFNAME, (strlen(ifname) + 1), ifname);\n\n    NETLINK_MSG_NEST_START(nl_msg, linkinfo, IFLA_LINKINFO);\n    NETLINK_MSG_PUT(nl_msg, IFLA_INFO_KIND, (strlen(type) + 1), type);\n\n    if ((STREQ(type, \"macvtap\") || STREQ(type, \"macvlan\")) &&\n        extra_args &&\n        extra_args->macvlan_mode &&\n        *extra_args->macvlan_mode > 0) {\n        NETLINK_MSG_NEST_START(nl_msg, infodata, IFLA_INFO_DATA);\n        NETLINK_MSG_PUT(nl_msg, IFLA_MACVLAN_MODE,\n                        sizeof(uint32_t), extra_args->macvlan_mode);\n        NETLINK_MSG_NEST_END(nl_msg, infodata);\n    }\n\n    NETLINK_MSG_NEST_END(nl_msg, linkinfo);\n\n    if (extra_args) {\n        if (extra_args->ifindex) {\n            NETLINK_MSG_PUT(nl_msg, IFLA_LINK,\n                        sizeof(uint32_t), extra_args->ifindex);\n        }\n        if (extra_args->mac) {\n            NETLINK_MSG_PUT(nl_msg, IFLA_ADDRESS,\n                            VIR_MAC_BUFLEN, extra_args->mac);\n        }\n    }\n\n    if (virNetlinkCommand(nl_msg, &resp, &buflen, 0, 0, NETLINK_ROUTE, 0) < 0)\n        return -1;\n\n    if (buflen < NLMSG_LENGTH(0) || resp == NULL)\n        goto malformed_resp;\n\n    switch (resp->nlmsg_type) {\n    case NLMSG_ERROR:\n        err = (struct nlmsgerr *)NLMSG_DATA(resp);\n        if (resp->nlmsg_len < NLMSG_LENGTH(sizeof(*err)))\n            goto malformed_resp;\n\n        if (err->error < 0) {\n            *error = err->error;\n            return -1;\n        }\n        break;\n\n    case NLMSG_DONE:\n        break;\n\n    default:\n        goto malformed_resp;\n    }\n\n    return 0;\n\n malformed_resp:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"malformed netlink response message\"));\n    return -1;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"allocated netlink buffer is too small\")"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"allocated netlink buffer is too small\""
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed netlink response message\")"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(*err)"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "resp"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "0"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkCommand",
          "args": [
            "nl_msg",
            "&resp",
            "&buflen",
            "0",
            "0",
            "NETLINK_ROUTE",
            "0"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1236-1246",
          "snippet": "int virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NETLINK_MSG_PUT",
          "args": [
            "nl_msg",
            "IFLA_ADDRESS",
            "VIR_MAC_BUFLEN",
            "extra_args->mac"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_MSG_PUT",
          "args": [
            "nl_msg",
            "IFLA_LINK",
            "sizeof(uint32_t)",
            "extra_args->ifindex"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_MSG_NEST_END",
          "args": [
            "nl_msg",
            "linkinfo"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_MSG_NEST_END",
          "args": [
            "nl_msg",
            "infodata"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_MSG_PUT",
          "args": [
            "nl_msg",
            "IFLA_MACVLAN_MODE",
            "sizeof(uint32_t)",
            "extra_args->macvlan_mode"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_MSG_NEST_START",
          "args": [
            "nl_msg",
            "infodata",
            "IFLA_INFO_DATA"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"macvlan\""
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "\"macvtap\""
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_MSG_PUT",
          "args": [
            "nl_msg",
            "IFLA_INFO_KIND",
            "(strlen(type) + 1)",
            "type"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "type"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_MSG_NEST_START",
          "args": [
            "nl_msg",
            "linkinfo",
            "IFLA_LINKINFO"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NETLINK_MSG_PUT",
          "args": [
            "nl_msg",
            "IFLA_IFNAME",
            "(strlen(ifname) + 1)",
            "ifname"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ifname"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_append",
          "args": [
            "nl_msg",
            "&ifinfo",
            "sizeof(ifinfo)",
            "NLMSG_ALIGNTO"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_simple",
          "args": [
            "RTM_NEWLINK",
            "NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"both interface name and type must not be NULL\")"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Creating %s interface '%s'\"",
            "type",
            "ifname"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkNewLink(const char *ifname,\n                  const char *type,\n                  virNetlinkNewLinkDataPtr extra_args,\n                  int *error)\n{\n    struct nlmsgerr *err;\n    struct nlattr *linkinfo = NULL;\n    struct nlattr *infodata = NULL;\n    unsigned int buflen;\n    struct ifinfomsg ifinfo = { .ifi_family = AF_UNSPEC };\n    g_autoptr(virNetlinkMsg) nl_msg = NULL;\n    g_autofree struct nlmsghdr *resp = NULL;\n\n    *error = 0;\n\n    VIR_DEBUG(\"Creating %s interface '%s'\", type, ifname);\n\n    if (!ifname || !type) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"both interface name and type must not be NULL\"));\n        return -1;\n    }\n\n    nl_msg = nlmsg_alloc_simple(RTM_NEWLINK,\n                                NLM_F_REQUEST | NLM_F_CREATE | NLM_F_EXCL);\n    if (!nl_msg) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if (nlmsg_append(nl_msg,  &ifinfo, sizeof(ifinfo), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    NETLINK_MSG_PUT(nl_msg, IFLA_IFNAME, (strlen(ifname) + 1), ifname);\n\n    NETLINK_MSG_NEST_START(nl_msg, linkinfo, IFLA_LINKINFO);\n    NETLINK_MSG_PUT(nl_msg, IFLA_INFO_KIND, (strlen(type) + 1), type);\n\n    if ((STREQ(type, \"macvtap\") || STREQ(type, \"macvlan\")) &&\n        extra_args &&\n        extra_args->macvlan_mode &&\n        *extra_args->macvlan_mode > 0) {\n        NETLINK_MSG_NEST_START(nl_msg, infodata, IFLA_INFO_DATA);\n        NETLINK_MSG_PUT(nl_msg, IFLA_MACVLAN_MODE,\n                        sizeof(uint32_t), extra_args->macvlan_mode);\n        NETLINK_MSG_NEST_END(nl_msg, infodata);\n    }\n\n    NETLINK_MSG_NEST_END(nl_msg, linkinfo);\n\n    if (extra_args) {\n        if (extra_args->ifindex) {\n            NETLINK_MSG_PUT(nl_msg, IFLA_LINK,\n                        sizeof(uint32_t), extra_args->ifindex);\n        }\n        if (extra_args->mac) {\n            NETLINK_MSG_PUT(nl_msg, IFLA_ADDRESS,\n                            VIR_MAC_BUFLEN, extra_args->mac);\n        }\n    }\n\n    if (virNetlinkCommand(nl_msg, &resp, &buflen, 0, 0, NETLINK_ROUTE, 0) < 0)\n        return -1;\n\n    if (buflen < NLMSG_LENGTH(0) || resp == NULL)\n        goto malformed_resp;\n\n    switch (resp->nlmsg_type) {\n    case NLMSG_ERROR:\n        err = (struct nlmsgerr *)NLMSG_DATA(resp);\n        if (resp->nlmsg_len < NLMSG_LENGTH(sizeof(*err)))\n            goto malformed_resp;\n\n        if (err->error < 0) {\n            *error = err->error;\n            return -1;\n        }\n        break;\n\n    case NLMSG_DONE:\n        break;\n\n    default:\n        goto malformed_resp;\n    }\n\n    return 0;\n\n malformed_resp:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"malformed netlink response message\"));\n    return -1;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNetlinkDumpLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "377-471",
    "snippet": "int\nvirNetlinkDumpLink(const char *ifname, int ifindex,\n                   void **nlData, struct nlattr **tb,\n                   uint32_t src_pid, uint32_t dst_pid)\n{\n    int rc = -1;\n    struct nlmsgerr *err;\n    struct ifinfomsg ifinfo = {\n        .ifi_family = AF_UNSPEC,\n        .ifi_index  = ifindex\n    };\n    unsigned int recvbuflen;\n    g_autoptr(virNetlinkMsg) nl_msg = NULL;\n    g_autofree struct nlmsghdr *resp = NULL;\n\n    if (ifname && ifindex <= 0 && virNetDevGetIndex(ifname, &ifindex) < 0)\n        return -1;\n\n    ifinfo.ifi_index = ifindex;\n\n    nl_msg = nlmsg_alloc_simple(RTM_GETLINK, NLM_F_REQUEST);\n    if (!nl_msg) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if (nlmsg_append(nl_msg,  &ifinfo, sizeof(ifinfo), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (ifname) {\n        if (nla_put(nl_msg, IFLA_IFNAME, strlen(ifname)+1, ifname) < 0)\n            goto buffer_too_small;\n    }\n\n# ifdef RTEXT_FILTER_VF\n    /* if this filter exists in the kernel's netlink implementation,\n     * we need to set it, otherwise the response message will not\n     * contain the IFLA_VFINFO_LIST that we're looking for.\n     */\n    {\n        uint32_t ifla_ext_mask = RTEXT_FILTER_VF;\n\n        if (nla_put(nl_msg, IFLA_EXT_MASK,\n                    sizeof(ifla_ext_mask), &ifla_ext_mask) < 0) {\n            goto buffer_too_small;\n        }\n    }\n# endif\n\n    if (virNetlinkCommand(nl_msg, &resp, &recvbuflen,\n                          src_pid, dst_pid, NETLINK_ROUTE, 0) < 0)\n        return -1;\n\n    if (recvbuflen < NLMSG_LENGTH(0) || resp == NULL)\n        goto malformed_resp;\n\n    switch (resp->nlmsg_type) {\n    case NLMSG_ERROR:\n        err = (struct nlmsgerr *)NLMSG_DATA(resp);\n        if (resp->nlmsg_len < NLMSG_LENGTH(sizeof(*err)))\n            goto malformed_resp;\n\n        if (err->error) {\n            virReportSystemError(-err->error,\n                                 _(\"error dumping %s (%d) interface\"),\n                                 ifname, ifindex);\n            return -1;\n        }\n        break;\n\n    case GENL_ID_CTRL:\n    case NLMSG_DONE:\n        rc = nlmsg_parse(resp, sizeof(struct ifinfomsg),\n                         tb, IFLA_MAX, NULL);\n        if (rc < 0)\n            goto malformed_resp;\n        break;\n\n    default:\n        goto malformed_resp;\n    }\n\n    *nlData = g_steal_pointer(&resp);\n    return 0;\n\n malformed_resp:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"malformed netlink response message\"));\n    return rc;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    return rc;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"allocated netlink buffer is too small\")"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"allocated netlink buffer is too small\""
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed netlink response message\")"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&resp"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_parse",
          "args": [
            "resp",
            "sizeof(struct ifinfomsg)",
            "tb",
            "IFLA_MAX",
            "NULL"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-err->error",
            "_(\"error dumping %s (%d) interface\")",
            "ifname",
            "ifindex"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(*err)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "resp"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "0"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkCommand",
          "args": [
            "nl_msg",
            "&resp",
            "&recvbuflen",
            "src_pid",
            "dst_pid",
            "NETLINK_ROUTE",
            "0"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1236-1246",
          "snippet": "int virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nl_msg",
            "IFLA_EXT_MASK",
            "sizeof(ifla_ext_mask)",
            "&ifla_ext_mask"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nl_msg",
            "IFLA_IFNAME",
            "strlen(ifname)+1",
            "ifname"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ifname"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_append",
          "args": [
            "nl_msg",
            "&ifinfo",
            "sizeof(ifinfo)",
            "NLMSG_ALIGNTO"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_simple",
          "args": [
            "RTM_GETLINK",
            "NLM_F_REQUEST"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevGetIndex",
          "args": [
            "ifname",
            "&ifindex"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "893-899",
          "snippet": "int virNetDevGetIndex(const char *ifname G_GNUC_UNUSED,\n                      int *ifindex G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get interface index on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint virNetDevGetIndex(const char *ifname G_GNUC_UNUSED,\n                      int *ifindex G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get interface index on this platform\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkDumpLink(const char *ifname, int ifindex,\n                   void **nlData, struct nlattr **tb,\n                   uint32_t src_pid, uint32_t dst_pid)\n{\n    int rc = -1;\n    struct nlmsgerr *err;\n    struct ifinfomsg ifinfo = {\n        .ifi_family = AF_UNSPEC,\n        .ifi_index  = ifindex\n    };\n    unsigned int recvbuflen;\n    g_autoptr(virNetlinkMsg) nl_msg = NULL;\n    g_autofree struct nlmsghdr *resp = NULL;\n\n    if (ifname && ifindex <= 0 && virNetDevGetIndex(ifname, &ifindex) < 0)\n        return -1;\n\n    ifinfo.ifi_index = ifindex;\n\n    nl_msg = nlmsg_alloc_simple(RTM_GETLINK, NLM_F_REQUEST);\n    if (!nl_msg) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if (nlmsg_append(nl_msg,  &ifinfo, sizeof(ifinfo), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (ifname) {\n        if (nla_put(nl_msg, IFLA_IFNAME, strlen(ifname)+1, ifname) < 0)\n            goto buffer_too_small;\n    }\n\n# ifdef RTEXT_FILTER_VF\n    /* if this filter exists in the kernel's netlink implementation,\n     * we need to set it, otherwise the response message will not\n     * contain the IFLA_VFINFO_LIST that we're looking for.\n     */\n    {\n        uint32_t ifla_ext_mask = RTEXT_FILTER_VF;\n\n        if (nla_put(nl_msg, IFLA_EXT_MASK,\n                    sizeof(ifla_ext_mask), &ifla_ext_mask) < 0) {\n            goto buffer_too_small;\n        }\n    }\n# endif\n\n    if (virNetlinkCommand(nl_msg, &resp, &recvbuflen,\n                          src_pid, dst_pid, NETLINK_ROUTE, 0) < 0)\n        return -1;\n\n    if (recvbuflen < NLMSG_LENGTH(0) || resp == NULL)\n        goto malformed_resp;\n\n    switch (resp->nlmsg_type) {\n    case NLMSG_ERROR:\n        err = (struct nlmsgerr *)NLMSG_DATA(resp);\n        if (resp->nlmsg_len < NLMSG_LENGTH(sizeof(*err)))\n            goto malformed_resp;\n\n        if (err->error) {\n            virReportSystemError(-err->error,\n                                 _(\"error dumping %s (%d) interface\"),\n                                 ifname, ifindex);\n            return -1;\n        }\n        break;\n\n    case GENL_ID_CTRL:\n    case NLMSG_DONE:\n        rc = nlmsg_parse(resp, sizeof(struct ifinfomsg),\n                         tb, IFLA_MAX, NULL);\n        if (rc < 0)\n            goto malformed_resp;\n        break;\n\n    default:\n        goto malformed_resp;\n    }\n\n    *nlData = g_steal_pointer(&resp);\n    return 0;\n\n malformed_resp:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"malformed netlink response message\"));\n    return rc;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    return rc;\n}"
  },
  {
    "function_name": "virNetlinkDumpCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "315-356",
    "snippet": "int\nvirNetlinkDumpCommand(struct nl_msg *nl_msg,\n                      virNetlinkDumpCallback callback,\n                      uint32_t src_pid, uint32_t dst_pid,\n                      unsigned int protocol, unsigned int groups,\n                      void *opaque)\n{\n    bool end = false;\n    int len = 0;\n    struct nlmsghdr *msg = NULL;\n\n    struct sockaddr_nl nladdr = {\n            .nl_family = AF_NETLINK,\n            .nl_pid    = dst_pid,\n            .nl_groups = 0,\n    };\n    g_autoptr(virNetlinkHandle) nlhandle = NULL;\n\n    if (!(nlhandle = virNetlinkSendRequest(nl_msg, src_pid, nladdr,\n                                           protocol, groups)))\n        return -1;\n\n    while (!end) {\n        g_autofree struct nlmsghdr *resp = NULL;\n\n        len = nl_recv(nlhandle, &nladdr, (unsigned char **)&resp, NULL);\n        VIR_WARNINGS_NO_CAST_ALIGN\n        for (msg = resp; NLMSG_OK(msg, len); msg = NLMSG_NEXT(msg, len)) {\n            VIR_WARNINGS_RESET\n            if (msg->nlmsg_type == NLMSG_DONE)\n                end = true;\n\n            if (virNetlinkGetErrorCode(msg, len) < 0)\n                return -1;\n\n            if (callback(msg, opaque) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "callback",
          "args": [
            "msg",
            "opaque"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkGetErrorCode",
          "args": [
            "msg",
            "len"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkGetErrorCode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1378-1384",
          "snippet": "int\nvirNetlinkGetErrorCode(struct nlmsghdr *resp G_GNUC_UNUSED,\n                       unsigned int recvbuflen G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -EINVAL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkGetErrorCode(struct nlmsghdr *resp G_GNUC_UNUSED,\n                       unsigned int recvbuflen G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NLMSG_NEXT",
          "args": [
            "msg",
            "len"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_OK",
          "args": [
            "msg",
            "len"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_recv",
          "args": [
            "nlhandle",
            "&nladdr",
            "(unsigned char **)&resp",
            "NULL"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkSendRequest",
          "args": [
            "nl_msg",
            "src_pid",
            "nladdr",
            "protocol",
            "groups"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkSendRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "196-261",
          "snippet": "static virNetlinkHandle *\nvirNetlinkSendRequest(struct nl_msg *nl_msg, uint32_t src_pid,\n                      struct sockaddr_nl nladdr,\n                      unsigned int protocol, unsigned int groups)\n{\n    ssize_t nbytes;\n    int fd;\n    int n;\n    virNetlinkHandle *nlhandle = NULL;\n    struct pollfd fds[1];\n    struct nlmsghdr *nlmsg = nlmsg_hdr(nl_msg);\n\n    if (protocol >= MAX_LINKS) {\n        virReportSystemError(EINVAL,\n                             _(\"invalid protocol argument: %d\"), protocol);\n        goto error;\n    }\n\n    if (!(nlhandle = virNetlinkCreateSocket(protocol)))\n        goto error;\n\n    fd = nl_socket_get_fd(nlhandle);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot get netlink socket fd\"));\n        goto error;\n    }\n\n    if (groups && nl_socket_add_membership(nlhandle, groups) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot add netlink membership\"));\n        goto error;\n    }\n\n    nlmsg_set_dst(nl_msg, &nladdr);\n\n    nlmsg->nlmsg_pid = src_pid ? src_pid : getpid();\n\n    nbytes = nl_send_auto_complete(nlhandle, nl_msg);\n    if (nbytes < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot send to netlink socket\"));\n        goto error;\n    }\n\n    memset(fds, 0, sizeof(fds));\n\n    fds[0].fd = fd;\n    fds[0].events = POLLIN;\n\n    n = poll(fds, G_N_ELEMENTS(fds), NETLINK_ACK_TIMEOUT_S);\n    if (n <= 0) {\n        if (n < 0)\n            virReportSystemError(errno, \"%s\",\n                                 _(\"error in poll call\"));\n        if (n == 0)\n            virReportSystemError(ETIMEDOUT, \"%s\",\n                                 _(\"no valid netlink response was received\"));\n    }\n\n    return nlhandle;\n\n error:\n    virNetlinkFree(nlhandle);\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define NETLINK_ACK_TIMEOUT_S  (2*1000)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\n#define NETLINK_ACK_TIMEOUT_S  (2*1000)\n\nstatic virNetlinkHandle *\nvirNetlinkSendRequest(struct nl_msg *nl_msg, uint32_t src_pid,\n                      struct sockaddr_nl nladdr,\n                      unsigned int protocol, unsigned int groups)\n{\n    ssize_t nbytes;\n    int fd;\n    int n;\n    virNetlinkHandle *nlhandle = NULL;\n    struct pollfd fds[1];\n    struct nlmsghdr *nlmsg = nlmsg_hdr(nl_msg);\n\n    if (protocol >= MAX_LINKS) {\n        virReportSystemError(EINVAL,\n                             _(\"invalid protocol argument: %d\"), protocol);\n        goto error;\n    }\n\n    if (!(nlhandle = virNetlinkCreateSocket(protocol)))\n        goto error;\n\n    fd = nl_socket_get_fd(nlhandle);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot get netlink socket fd\"));\n        goto error;\n    }\n\n    if (groups && nl_socket_add_membership(nlhandle, groups) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot add netlink membership\"));\n        goto error;\n    }\n\n    nlmsg_set_dst(nl_msg, &nladdr);\n\n    nlmsg->nlmsg_pid = src_pid ? src_pid : getpid();\n\n    nbytes = nl_send_auto_complete(nlhandle, nl_msg);\n    if (nbytes < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot send to netlink socket\"));\n        goto error;\n    }\n\n    memset(fds, 0, sizeof(fds));\n\n    fds[0].fd = fd;\n    fds[0].events = POLLIN;\n\n    n = poll(fds, G_N_ELEMENTS(fds), NETLINK_ACK_TIMEOUT_S);\n    if (n <= 0) {\n        if (n < 0)\n            virReportSystemError(errno, \"%s\",\n                                 _(\"error in poll call\"));\n        if (n == 0)\n            virReportSystemError(ETIMEDOUT, \"%s\",\n                                 _(\"no valid netlink response was received\"));\n    }\n\n    return nlhandle;\n\n error:\n    virNetlinkFree(nlhandle);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkDumpCommand(struct nl_msg *nl_msg,\n                      virNetlinkDumpCallback callback,\n                      uint32_t src_pid, uint32_t dst_pid,\n                      unsigned int protocol, unsigned int groups,\n                      void *opaque)\n{\n    bool end = false;\n    int len = 0;\n    struct nlmsghdr *msg = NULL;\n\n    struct sockaddr_nl nladdr = {\n            .nl_family = AF_NETLINK,\n            .nl_pid    = dst_pid,\n            .nl_groups = 0,\n    };\n    g_autoptr(virNetlinkHandle) nlhandle = NULL;\n\n    if (!(nlhandle = virNetlinkSendRequest(nl_msg, src_pid, nladdr,\n                                           protocol, groups)))\n        return -1;\n\n    while (!end) {\n        g_autofree struct nlmsghdr *resp = NULL;\n\n        len = nl_recv(nlhandle, &nladdr, (unsigned char **)&resp, NULL);\n        VIR_WARNINGS_NO_CAST_ALIGN\n        for (msg = resp; NLMSG_OK(msg, len); msg = NLMSG_NEXT(msg, len)) {\n            VIR_WARNINGS_RESET\n            if (msg->nlmsg_type == NLMSG_DONE)\n                end = true;\n\n            if (virNetlinkGetErrorCode(msg, len) < 0)\n                return -1;\n\n            if (callback(msg, opaque) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetlinkCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "278-313",
    "snippet": "int virNetlinkCommand(struct nl_msg *nl_msg,\n                      struct nlmsghdr **resp, unsigned int *respbuflen,\n                      uint32_t src_pid, uint32_t dst_pid,\n                      unsigned int protocol, unsigned int groups)\n{\n    struct sockaddr_nl nladdr = {\n            .nl_family = AF_NETLINK,\n            .nl_pid    = dst_pid,\n            .nl_groups = 0,\n    };\n    struct pollfd fds[1];\n    g_autofree struct nlmsghdr *temp_resp = NULL;\n    g_autoptr(virNetlinkHandle) nlhandle = NULL;\n    int len = 0;\n\n    memset(fds, 0, sizeof(fds));\n\n    if (!(nlhandle = virNetlinkSendRequest(nl_msg, src_pid, nladdr,\n                                           protocol, groups)))\n        return -1;\n\n    len = nl_recv(nlhandle, &nladdr, (unsigned char **)&temp_resp, NULL);\n    if (len == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"nl_recv failed - returned 0 bytes\"));\n        return -1;\n    }\n    if (len < 0) {\n        virReportSystemError(errno, \"%s\", _(\"nl_recv failed\"));\n        return -1;\n    }\n\n    *resp = g_steal_pointer(&temp_resp);\n    *respbuflen = len;\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&temp_resp"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"nl_recv failed\")"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"nl_recv failed\""
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"nl_recv failed - returned 0 bytes\")"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_recv",
          "args": [
            "nlhandle",
            "&nladdr",
            "(unsigned char **)&temp_resp",
            "NULL"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkSendRequest",
          "args": [
            "nl_msg",
            "src_pid",
            "nladdr",
            "protocol",
            "groups"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkSendRequest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "196-261",
          "snippet": "static virNetlinkHandle *\nvirNetlinkSendRequest(struct nl_msg *nl_msg, uint32_t src_pid,\n                      struct sockaddr_nl nladdr,\n                      unsigned int protocol, unsigned int groups)\n{\n    ssize_t nbytes;\n    int fd;\n    int n;\n    virNetlinkHandle *nlhandle = NULL;\n    struct pollfd fds[1];\n    struct nlmsghdr *nlmsg = nlmsg_hdr(nl_msg);\n\n    if (protocol >= MAX_LINKS) {\n        virReportSystemError(EINVAL,\n                             _(\"invalid protocol argument: %d\"), protocol);\n        goto error;\n    }\n\n    if (!(nlhandle = virNetlinkCreateSocket(protocol)))\n        goto error;\n\n    fd = nl_socket_get_fd(nlhandle);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot get netlink socket fd\"));\n        goto error;\n    }\n\n    if (groups && nl_socket_add_membership(nlhandle, groups) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot add netlink membership\"));\n        goto error;\n    }\n\n    nlmsg_set_dst(nl_msg, &nladdr);\n\n    nlmsg->nlmsg_pid = src_pid ? src_pid : getpid();\n\n    nbytes = nl_send_auto_complete(nlhandle, nl_msg);\n    if (nbytes < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot send to netlink socket\"));\n        goto error;\n    }\n\n    memset(fds, 0, sizeof(fds));\n\n    fds[0].fd = fd;\n    fds[0].events = POLLIN;\n\n    n = poll(fds, G_N_ELEMENTS(fds), NETLINK_ACK_TIMEOUT_S);\n    if (n <= 0) {\n        if (n < 0)\n            virReportSystemError(errno, \"%s\",\n                                 _(\"error in poll call\"));\n        if (n == 0)\n            virReportSystemError(ETIMEDOUT, \"%s\",\n                                 _(\"no valid netlink response was received\"));\n    }\n\n    return nlhandle;\n\n error:\n    virNetlinkFree(nlhandle);\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define NETLINK_ACK_TIMEOUT_S  (2*1000)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\n#define NETLINK_ACK_TIMEOUT_S  (2*1000)\n\nstatic virNetlinkHandle *\nvirNetlinkSendRequest(struct nl_msg *nl_msg, uint32_t src_pid,\n                      struct sockaddr_nl nladdr,\n                      unsigned int protocol, unsigned int groups)\n{\n    ssize_t nbytes;\n    int fd;\n    int n;\n    virNetlinkHandle *nlhandle = NULL;\n    struct pollfd fds[1];\n    struct nlmsghdr *nlmsg = nlmsg_hdr(nl_msg);\n\n    if (protocol >= MAX_LINKS) {\n        virReportSystemError(EINVAL,\n                             _(\"invalid protocol argument: %d\"), protocol);\n        goto error;\n    }\n\n    if (!(nlhandle = virNetlinkCreateSocket(protocol)))\n        goto error;\n\n    fd = nl_socket_get_fd(nlhandle);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot get netlink socket fd\"));\n        goto error;\n    }\n\n    if (groups && nl_socket_add_membership(nlhandle, groups) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot add netlink membership\"));\n        goto error;\n    }\n\n    nlmsg_set_dst(nl_msg, &nladdr);\n\n    nlmsg->nlmsg_pid = src_pid ? src_pid : getpid();\n\n    nbytes = nl_send_auto_complete(nlhandle, nl_msg);\n    if (nbytes < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot send to netlink socket\"));\n        goto error;\n    }\n\n    memset(fds, 0, sizeof(fds));\n\n    fds[0].fd = fd;\n    fds[0].events = POLLIN;\n\n    n = poll(fds, G_N_ELEMENTS(fds), NETLINK_ACK_TIMEOUT_S);\n    if (n <= 0) {\n        if (n < 0)\n            virReportSystemError(errno, \"%s\",\n                                 _(\"error in poll call\"));\n        if (n == 0)\n            virReportSystemError(ETIMEDOUT, \"%s\",\n                                 _(\"no valid netlink response was received\"));\n    }\n\n    return nlhandle;\n\n error:\n    virNetlinkFree(nlhandle);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fds",
            "0",
            "sizeof(fds)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkCommand(struct nl_msg *nl_msg,\n                      struct nlmsghdr **resp, unsigned int *respbuflen,\n                      uint32_t src_pid, uint32_t dst_pid,\n                      unsigned int protocol, unsigned int groups)\n{\n    struct sockaddr_nl nladdr = {\n            .nl_family = AF_NETLINK,\n            .nl_pid    = dst_pid,\n            .nl_groups = 0,\n    };\n    struct pollfd fds[1];\n    g_autofree struct nlmsghdr *temp_resp = NULL;\n    g_autoptr(virNetlinkHandle) nlhandle = NULL;\n    int len = 0;\n\n    memset(fds, 0, sizeof(fds));\n\n    if (!(nlhandle = virNetlinkSendRequest(nl_msg, src_pid, nladdr,\n                                           protocol, groups)))\n        return -1;\n\n    len = nl_recv(nlhandle, &nladdr, (unsigned char **)&temp_resp, NULL);\n    if (len == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"nl_recv failed - returned 0 bytes\"));\n        return -1;\n    }\n    if (len < 0) {\n        virReportSystemError(errno, \"%s\", _(\"nl_recv failed\"));\n        return -1;\n    }\n\n    *resp = g_steal_pointer(&temp_resp);\n    *respbuflen = len;\n    return 0;\n}"
  },
  {
    "function_name": "virNetlinkSendRequest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "196-261",
    "snippet": "static virNetlinkHandle *\nvirNetlinkSendRequest(struct nl_msg *nl_msg, uint32_t src_pid,\n                      struct sockaddr_nl nladdr,\n                      unsigned int protocol, unsigned int groups)\n{\n    ssize_t nbytes;\n    int fd;\n    int n;\n    virNetlinkHandle *nlhandle = NULL;\n    struct pollfd fds[1];\n    struct nlmsghdr *nlmsg = nlmsg_hdr(nl_msg);\n\n    if (protocol >= MAX_LINKS) {\n        virReportSystemError(EINVAL,\n                             _(\"invalid protocol argument: %d\"), protocol);\n        goto error;\n    }\n\n    if (!(nlhandle = virNetlinkCreateSocket(protocol)))\n        goto error;\n\n    fd = nl_socket_get_fd(nlhandle);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot get netlink socket fd\"));\n        goto error;\n    }\n\n    if (groups && nl_socket_add_membership(nlhandle, groups) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot add netlink membership\"));\n        goto error;\n    }\n\n    nlmsg_set_dst(nl_msg, &nladdr);\n\n    nlmsg->nlmsg_pid = src_pid ? src_pid : getpid();\n\n    nbytes = nl_send_auto_complete(nlhandle, nl_msg);\n    if (nbytes < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot send to netlink socket\"));\n        goto error;\n    }\n\n    memset(fds, 0, sizeof(fds));\n\n    fds[0].fd = fd;\n    fds[0].events = POLLIN;\n\n    n = poll(fds, G_N_ELEMENTS(fds), NETLINK_ACK_TIMEOUT_S);\n    if (n <= 0) {\n        if (n < 0)\n            virReportSystemError(errno, \"%s\",\n                                 _(\"error in poll call\"));\n        if (n == 0)\n            virReportSystemError(ETIMEDOUT, \"%s\",\n                                 _(\"no valid netlink response was received\"));\n    }\n\n    return nlhandle;\n\n error:\n    virNetlinkFree(nlhandle);\n    return NULL;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define NETLINK_ACK_TIMEOUT_S  (2*1000)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetlinkFree",
          "args": [
            "nlhandle"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ETIMEDOUT",
            "\"%s\"",
            "_(\"no valid netlink response was received\")"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no valid netlink response was received\""
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"error in poll call\")"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "fds",
            "G_N_ELEMENTS(fds)",
            "NETLINK_ACK_TIMEOUT_S"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "fds"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fds",
            "0",
            "sizeof(fds)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot send to netlink socket\")"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_send_auto_complete",
          "args": [
            "nlhandle",
            "nl_msg"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_set_dst",
          "args": [
            "nl_msg",
            "&nladdr"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot add netlink membership\")"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_socket_add_membership",
          "args": [
            "nlhandle",
            "groups"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot get netlink socket fd\")"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_socket_get_fd",
          "args": [
            "nlhandle"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkCreateSocket",
          "args": [
            "protocol"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkCreateSocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "161-194",
          "snippet": "static virNetlinkHandle *\nvirNetlinkCreateSocket(int protocol)\n{\n    virNetlinkHandle *nlhandle = NULL;\n\n    if (!(nlhandle = virNetlinkAlloc())) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot allocate nlhandle for netlink\"));\n        goto error;\n    }\n    if (nl_connect(nlhandle, protocol) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot connect to netlink socket \"\n                               \"with protocol %d\"), protocol);\n        goto error;\n    }\n\n    if (virNetlinkSetBufferSize(nlhandle, 131702, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot set netlink socket buffer \"\n                               \"size to 128k\"));\n        goto error;\n    }\n    nl_socket_enable_msg_peek(nlhandle);\n\n    return nlhandle;\n\n error:\n    if (nlhandle) {\n        nl_close(nlhandle);\n        virNetlinkFree(nlhandle);\n    }\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetlinkHandle *\nvirNetlinkCreateSocket(int protocol)\n{\n    virNetlinkHandle *nlhandle = NULL;\n\n    if (!(nlhandle = virNetlinkAlloc())) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot allocate nlhandle for netlink\"));\n        goto error;\n    }\n    if (nl_connect(nlhandle, protocol) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot connect to netlink socket \"\n                               \"with protocol %d\"), protocol);\n        goto error;\n    }\n\n    if (virNetlinkSetBufferSize(nlhandle, 131702, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot set netlink socket buffer \"\n                               \"size to 128k\"));\n        goto error;\n    }\n    nl_socket_enable_msg_peek(nlhandle);\n\n    return nlhandle;\n\n error:\n    if (nlhandle) {\n        nl_close(nlhandle);\n        virNetlinkFree(nlhandle);\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EINVAL",
            "_(\"invalid protocol argument: %d\")",
            "protocol"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_hdr",
          "args": [
            "nl_msg"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\n#define NETLINK_ACK_TIMEOUT_S  (2*1000)\n\nstatic virNetlinkHandle *\nvirNetlinkSendRequest(struct nl_msg *nl_msg, uint32_t src_pid,\n                      struct sockaddr_nl nladdr,\n                      unsigned int protocol, unsigned int groups)\n{\n    ssize_t nbytes;\n    int fd;\n    int n;\n    virNetlinkHandle *nlhandle = NULL;\n    struct pollfd fds[1];\n    struct nlmsghdr *nlmsg = nlmsg_hdr(nl_msg);\n\n    if (protocol >= MAX_LINKS) {\n        virReportSystemError(EINVAL,\n                             _(\"invalid protocol argument: %d\"), protocol);\n        goto error;\n    }\n\n    if (!(nlhandle = virNetlinkCreateSocket(protocol)))\n        goto error;\n\n    fd = nl_socket_get_fd(nlhandle);\n    if (fd < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot get netlink socket fd\"));\n        goto error;\n    }\n\n    if (groups && nl_socket_add_membership(nlhandle, groups) < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot add netlink membership\"));\n        goto error;\n    }\n\n    nlmsg_set_dst(nl_msg, &nladdr);\n\n    nlmsg->nlmsg_pid = src_pid ? src_pid : getpid();\n\n    nbytes = nl_send_auto_complete(nlhandle, nl_msg);\n    if (nbytes < 0) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot send to netlink socket\"));\n        goto error;\n    }\n\n    memset(fds, 0, sizeof(fds));\n\n    fds[0].fd = fd;\n    fds[0].events = POLLIN;\n\n    n = poll(fds, G_N_ELEMENTS(fds), NETLINK_ACK_TIMEOUT_S);\n    if (n <= 0) {\n        if (n < 0)\n            virReportSystemError(errno, \"%s\",\n                                 _(\"error in poll call\"));\n        if (n == 0)\n            virReportSystemError(ETIMEDOUT, \"%s\",\n                                 _(\"no valid netlink response was received\"));\n    }\n\n    return nlhandle;\n\n error:\n    virNetlinkFree(nlhandle);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetlinkCreateSocket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "161-194",
    "snippet": "static virNetlinkHandle *\nvirNetlinkCreateSocket(int protocol)\n{\n    virNetlinkHandle *nlhandle = NULL;\n\n    if (!(nlhandle = virNetlinkAlloc())) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot allocate nlhandle for netlink\"));\n        goto error;\n    }\n    if (nl_connect(nlhandle, protocol) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot connect to netlink socket \"\n                               \"with protocol %d\"), protocol);\n        goto error;\n    }\n\n    if (virNetlinkSetBufferSize(nlhandle, 131702, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot set netlink socket buffer \"\n                               \"size to 128k\"));\n        goto error;\n    }\n    nl_socket_enable_msg_peek(nlhandle);\n\n    return nlhandle;\n\n error:\n    if (nlhandle) {\n        nl_close(nlhandle);\n        virNetlinkFree(nlhandle);\n    }\n    return NULL;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetlinkFree",
          "args": [
            "nlhandle"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_close",
          "args": [
            "nlhandle"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_socket_enable_msg_peek",
          "args": [
            "nlhandle"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot set netlink socket buffer \"\n                               \"size to 128k\")"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot set netlink socket buffer \"\n                               \"size to 128k\""
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkSetBufferSize",
          "args": [
            "nlhandle",
            "131702",
            "0"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot connect to netlink socket \"\n                               \"with protocol %d\")",
            "protocol"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nl_connect",
          "args": [
            "nlhandle",
            "protocol"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot allocate nlhandle for netlink\")"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkAlloc",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virNetlinkHandle *\nvirNetlinkCreateSocket(int protocol)\n{\n    virNetlinkHandle *nlhandle = NULL;\n\n    if (!(nlhandle = virNetlinkAlloc())) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot allocate nlhandle for netlink\"));\n        goto error;\n    }\n    if (nl_connect(nlhandle, protocol) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot connect to netlink socket \"\n                               \"with protocol %d\"), protocol);\n        goto error;\n    }\n\n    if (virNetlinkSetBufferSize(nlhandle, 131702, 0) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot set netlink socket buffer \"\n                               \"size to 128k\"));\n        goto error;\n    }\n    nl_socket_enable_msg_peek(nlhandle);\n\n    return nlhandle;\n\n error:\n    if (nlhandle) {\n        nl_close(nlhandle);\n        virNetlinkFree(nlhandle);\n    }\n    return NULL;\n}"
  },
  {
    "function_name": "virNetlinkShutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "139-146",
    "snippet": "void\nvirNetlinkShutdown(void)\n{\n    if (placeholder_nlhandle) {\n        virNetlinkFree(placeholder_nlhandle);\n        placeholder_nlhandle = NULL;\n    }\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetlinkFree",
          "args": [
            "placeholder_nlhandle"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetlinkShutdown(void)\n{\n    if (placeholder_nlhandle) {\n        virNetlinkFree(placeholder_nlhandle);\n        placeholder_nlhandle = NULL;\n    }\n}"
  },
  {
    "function_name": "virNetlinkStartup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
    "lines": "118-131",
    "snippet": "int\nvirNetlinkStartup(void)\n{\n    if (placeholder_nlhandle)\n        return 0;\n    VIR_DEBUG(\"Running global netlink initialization\");\n    placeholder_nlhandle = virNetlinkAlloc();\n    if (!placeholder_nlhandle) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot allocate placeholder nlhandle for netlink\"));\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virmacaddr.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virnetlink.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot allocate placeholder nlhandle for netlink\")"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot allocate placeholder nlhandle for netlink\""
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkAlloc",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Running global netlink initialization\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkStartup(void)\n{\n    if (placeholder_nlhandle)\n        return 0;\n    VIR_DEBUG(\"Running global netlink initialization\");\n    placeholder_nlhandle = virNetlinkAlloc();\n    if (!placeholder_nlhandle) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot allocate placeholder nlhandle for netlink\"));\n        return -1;\n    }\n    return 0;\n}"
  }
]