[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_shim.c",
    "lines": "87-330",
    "snippet": "int main(int argc, char **argv)\n{\n    GThread *eventLoopThread = NULL;\n    virConnectPtr conn = NULL;\n    virConnectPtr sconn = NULL;\n    g_autofree char *xml = NULL;\n    g_autofree char *uri = NULL;\n    g_autofree char *suri = NULL;\n    char *root = NULL;\n    bool tmproot = false;\n    int ret = 1;\n    g_autoptr(GError) error = NULL;\n    g_auto(GStrv) secrets = NULL;\n    gboolean verbose = false;\n    gboolean debug = false;\n    GStrv tmpsecrets;\n    GOptionContext *ctx;\n    GOptionEntry entries[] = {\n        { \"secret\", 's', 0, G_OPTION_ARG_STRING_ARRAY, &secrets, \"Load secret file\", \"SECRET-XML-FILE,SECRET-VALUE-FILE\" },\n        { \"root\", 'r', 0, G_OPTION_ARG_STRING, &root, \"Root directory\", \"DIR\" },\n        { \"debug\", 'd', 0, G_OPTION_ARG_NONE, &debug, \"Debug output\", NULL },\n        { \"verbose\", 'v', 0, G_OPTION_ARG_NONE, &verbose, \"Verbose output\", NULL },\n        { 0 }\n    };\n    int quitfd[2] = {-1, -1};\n    long long start = g_get_monotonic_time();\n\n#define deltams() ((long long)g_get_monotonic_time() - start)\n\n    ctx = g_option_context_new(\"- run a standalone QEMU process\");\n    g_option_context_add_main_entries(ctx, entries, PACKAGE);\n    if (!g_option_context_parse(ctx, &argc, &argv, &error)) {\n        g_printerr(\"%s: option parsing failed: %s\\n\",\n                   argv[0], error->message);\n        return 1;\n    }\n\n    if (argc != 2) {\n        g_autofree char *help = g_option_context_get_help(ctx, TRUE, NULL);\n        g_printerr(\"%s\", help);\n        return 1;\n    }\n\n    if (verbose)\n        g_printerr(\"%s: %lld: initializing libvirt\\n\",\n                   argv[0], deltams());\n\n    if (virInitialize() < 0) {\n        g_printerr(\"%s: cannot initialize libvirt\\n\", argv[0]);\n        return 1;\n    }\n    if (virGettextInitialize() < 0) {\n        g_printerr(\"%s: cannot initialize libvirt translations\\n\", argv[0]);\n        return 1;\n    }\n\n    virSetErrorFunc(NULL, qemuShimQuench);\n\n    if (verbose)\n        g_printerr(\"%s: %lld: initializing signal handlers\\n\",\n                   argv[0], deltams());\n\n    signal(SIGTERM, qemuShimSigShutdown);\n    signal(SIGINT, qemuShimSigShutdown);\n    signal(SIGQUIT, qemuShimSigShutdown);\n    signal(SIGHUP, qemuShimSigShutdown);\n    signal(SIGPIPE, SIG_IGN);\n\n    if (root == NULL) {\n        if (!(root = g_dir_make_tmp(\"virt-qemu-run-XXXXXX\", &error))) {\n            g_printerr(\"%s: cannot create temporary dir: %s\\n\",\n                       argv[0], error->message);\n            return 1;\n        }\n        tmproot = true;\n\n        if (chmod(root, 0755) < 0) {\n            g_printerr(\"%s: cannot chown temporary dir: %s\\n\",\n                       argv[0], g_strerror(errno));\n            goto cleanup;\n        }\n    }\n\n    virFileActivateDirOverrideForProg(argv[0]);\n\n    if (verbose)\n        g_printerr(\"%s: %lld: preparing event loop thread\\n\",\n                   argv[0], deltams());\n    virEventRegisterDefaultImpl();\n\n    if (pipe(quitfd) < 0) {\n        g_printerr(\"%s: cannot create event loop pipe: %s\",\n                   argv[0], g_strerror(errno));\n        goto cleanup;\n    }\n\n    if (virEventAddHandle(quitfd[0], VIR_EVENT_HANDLE_READABLE, qemuShimEventLoopStop, NULL, NULL) < 0) {\n        VIR_FORCE_CLOSE(quitfd[0]);\n        VIR_FORCE_CLOSE(quitfd[1]);\n        quitfd[0] = quitfd[1] = -1;\n        g_printerr(\"%s: cannot register event loop handle: %s\",\n                   argv[0], virGetLastErrorMessage());\n        goto cleanup;\n    }\n    eventQuitFD = quitfd[1];\n\n    eventLoopThread = g_thread_new(\"event-loop\", qemuShimEventLoop, NULL);\n\n    if (secrets && *secrets) {\n        suri = g_strdup_printf(\"secret:///embed?root=%s\", root);\n\n        if (verbose)\n            g_printerr(\"%s: %lld: opening %s\\n\",\n                       argv[0], deltams(), suri);\n\n        sconn = virConnectOpen(suri);\n        if (!sconn) {\n            g_printerr(\"%s: cannot open %s: %s\\n\",\n                       argv[0], suri, virGetLastErrorMessage());\n            goto cleanup;\n        }\n\n        tmpsecrets = secrets;\n        while (tmpsecrets && *tmpsecrets) {\n            g_auto(GStrv) bits = g_strsplit(*tmpsecrets, \",\", 2);\n            g_autofree char *sxml = NULL;\n            g_autofree char *value = NULL;\n            virSecretPtr sec;\n            size_t nvalue;\n\n            if (!bits || bits[0] == NULL || bits[1] == NULL) {\n                g_printerr(\"%s: expected a pair of filenames for --secret argument\\n\",\n                    argv[0]);\n                goto cleanup;\n            }\n\n            if (verbose)\n                g_printerr(\"%s: %lld: loading secret %s and %s\\n\",\n                           argv[0], deltams(), bits[0], bits[1]);\n\n            if (!g_file_get_contents(bits[0], &sxml, NULL, &error)) {\n                g_printerr(\"%s: cannot read secret XML %s: %s\\n\",\n                           argv[0], bits[0], error->message);\n                goto cleanup;\n            }\n\n            if (!g_file_get_contents(bits[1], &value, &nvalue, &error)) {\n                g_printerr(\"%s: cannot read secret value %s: %s\\n\",\n                           argv[0], bits[1], error->message);\n                goto cleanup;\n            }\n\n            if (!(sec = virSecretDefineXML(sconn, sxml, 0))) {\n                g_printerr(\"%s: cannot define secret %s: %s\\n\",\n                           argv[0], bits[0], virGetLastErrorMessage());\n                goto cleanup;\n            }\n\n            if (virSecretSetValue(sec, (unsigned char *)value, nvalue, 0) < 0) {\n                virSecretFree(sec);\n                g_printerr(\"%s: cannot set value for secret %s: %s\\n\",\n                argv[0], bits[0], virGetLastErrorMessage());\n                goto cleanup;\n            }\n            virSecretFree(sec);\n\n            tmpsecrets++;\n        }\n    }\n\n    uri = g_strdup_printf(\"qemu:///embed?root=%s\", root);\n\n    if (verbose)\n        g_printerr(\"%s: %lld: opening %s\\n\",\n                   argv[0], deltams(), uri);\n\n    conn = virConnectOpen(uri);\n    if (!conn) {\n        g_printerr(\"%s: cannot open %s: %s\\n\",\n                   argv[0], uri, virGetLastErrorMessage());\n        goto cleanup;\n    }\n\n    if (virConnectDomainEventRegisterAny(\n            conn, dom, VIR_DOMAIN_EVENT_ID_LIFECYCLE,\n            VIR_DOMAIN_EVENT_CALLBACK(qemuShimDomShutdown),\n            NULL, NULL) < 0) {\n        g_printerr(\"%s: cannot register for lifecycle events: %s\\n\",\n                   argv[0], virGetLastErrorMessage());\n        goto cleanup;\n    }\n\n    if (verbose)\n        g_printerr(\"%s: %lld: starting guest %s\\n\",\n                   argv[0], deltams(), argv[1]);\n\n    if (!g_file_get_contents(argv[1], &xml, NULL, &error)) {\n        g_printerr(\"%s: cannot read %s: %s\\n\",\n                   argv[0], argv[1], error->message);\n        goto cleanup;\n    }\n\n    dom = virDomainCreateXML(conn, xml, 0);\n    if (!dom) {\n        g_printerr(\"%s: cannot start VM: %s\\n\",\n                   argv[0], virGetLastErrorMessage());\n        goto cleanup;\n    }\n    if (verbose)\n        g_printerr(\"%s: %lld: guest running, Ctrl-C to stop now\\n\",\n                   argv[0], deltams());\n\n    if (debug) {\n        g_autofree char *newxml = NULL;\n        newxml = virDomainGetXMLDesc(dom, 0);\n        g_printerr(\"%s: XML: %s\\n\", argv[0], newxml);\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret != 0 && eventQuitFD != -1)\n        ignore_value(safewrite(eventQuitFD, \"c\", 1));\n\n    if (eventLoopThread != NULL && (ret == 0 || eventQuitFD != -1))\n        g_thread_join(eventLoopThread);\n\n    VIR_FORCE_CLOSE(quitfd[0]);\n    VIR_FORCE_CLOSE(quitfd[1]);\n\n    if (dom != NULL)\n        virDomainFree(dom);\n    if (sconn != NULL)\n        virConnectClose(sconn);\n    if (conn != NULL)\n        virConnectClose(conn);\n    if (tmproot)\n        virFileDeleteTree(root);\n\n    if (verbose)\n        g_printerr(\"%s: %lld: cleaned up, exiting\\n\",\n                   argv[0], deltams());\n    return ret;\n}",
    "includes": [
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include <unistd.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int eventQuitFD = -1;",
      "static virDomainPtr dom;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: %lld: cleaned up, exiting\\n\"",
            "argv[0]",
            "deltams()"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deltams",
          "args": [],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileDeleteTree",
          "args": [
            "root"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "virFileDeleteTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1009-1062",
          "snippet": "int virFileDeleteTree(const char *dir)\n{\n    DIR *dh;\n    struct dirent *de;\n    int ret = -1;\n    int direrr;\n\n    /* Silently return 0 if passed NULL or directory doesn't exist */\n    if (!dir || !virFileExists(dir))\n        return 0;\n\n    if (virDirOpen(&dh, dir) < 0)\n        return -1;\n\n    while ((direrr = virDirRead(dh, &de, dir)) > 0) {\n        g_autofree char *filepath = NULL;\n        GStatBuf sb;\n\n        filepath = g_strdup_printf(\"%s/%s\", dir, de->d_name);\n\n        if (g_lstat(filepath, &sb) < 0) {\n            virReportSystemError(errno, _(\"Cannot access '%s'\"),\n                                 filepath);\n            goto cleanup;\n        }\n\n        if (S_ISDIR(sb.st_mode)) {\n            if (virFileDeleteTree(filepath) < 0)\n                goto cleanup;\n        } else {\n            if (unlink(filepath) < 0 && errno != ENOENT) {\n                virReportSystemError(errno,\n                                     _(\"Cannot delete file '%s'\"),\n                                     filepath);\n                goto cleanup;\n            }\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    if (rmdir(dir) < 0 && errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot delete directory '%s'\"),\n                             dir);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dh);\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileDeleteTree(const char *dir)\n{\n    DIR *dh;\n    struct dirent *de;\n    int ret = -1;\n    int direrr;\n\n    /* Silently return 0 if passed NULL or directory doesn't exist */\n    if (!dir || !virFileExists(dir))\n        return 0;\n\n    if (virDirOpen(&dh, dir) < 0)\n        return -1;\n\n    while ((direrr = virDirRead(dh, &de, dir)) > 0) {\n        g_autofree char *filepath = NULL;\n        GStatBuf sb;\n\n        filepath = g_strdup_printf(\"%s/%s\", dir, de->d_name);\n\n        if (g_lstat(filepath, &sb) < 0) {\n            virReportSystemError(errno, _(\"Cannot access '%s'\"),\n                                 filepath);\n            goto cleanup;\n        }\n\n        if (S_ISDIR(sb.st_mode)) {\n            if (virFileDeleteTree(filepath) < 0)\n                goto cleanup;\n        } else {\n            if (unlink(filepath) < 0 && errno != ENOENT) {\n                virReportSystemError(errno,\n                                     _(\"Cannot delete file '%s'\"),\n                                     filepath);\n                goto cleanup;\n            }\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    if (rmdir(dir) < 0 && errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot delete directory '%s'\"),\n                             dir);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dh);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectClose",
          "args": [
            "conn"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "1271-1283",
          "snippet": "int\nvirConnectClose(virConnectPtr conn)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n\n    if (!virObjectUnref(conn))\n        return 0;\n    return 1;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirConnectClose(virConnectPtr conn)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n\n    if (!virObjectUnref(conn))\n        return 0;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainFree",
          "args": [
            "dom"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-domain.c",
          "lines": "559-570",
          "snippet": "int\nvirDomainFree(virDomainPtr domain)\n{\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n\n    virObjectUnref(domain);\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirDomainFree(virDomainPtr domain)\n{\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n\n    virObjectUnref(domain);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "quitfd[1]"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "quitfd[0]"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_thread_join",
          "args": [
            "eventLoopThread"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "safewrite(eventQuitFD, \"c\", 1)"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "eventQuitFD",
            "\"c\"",
            "1"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: XML: %s\\n\"",
            "argv[0]",
            "newxml"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGetXMLDesc",
          "args": [
            "dom",
            "0"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGetXMLDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-domain.c",
          "lines": "2570-2602",
          "snippet": "char *\nvirDomainGetXMLDesc(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=0x%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    conn = domain->conn;\n\n    if ((conn->flags & VIR_CONNECT_RO) &&\n        (flags & (VIR_DOMAIN_XML_SECURE | VIR_DOMAIN_XML_MIGRATABLE))) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"virDomainGetXMLDesc with secure flag\"));\n        goto error;\n    }\n\n    if (conn->driver->domainGetXMLDesc) {\n        char *ret;\n        ret = conn->driver->domainGetXMLDesc(domain, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nchar *\nvirDomainGetXMLDesc(virDomainPtr domain, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"flags=0x%x\", flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, NULL);\n    conn = domain->conn;\n\n    if ((conn->flags & VIR_CONNECT_RO) &&\n        (flags & (VIR_DOMAIN_XML_SECURE | VIR_DOMAIN_XML_MIGRATABLE))) {\n        virReportError(VIR_ERR_OPERATION_DENIED, \"%s\",\n                       _(\"virDomainGetXMLDesc with secure flag\"));\n        goto error;\n    }\n\n    if (conn->driver->domainGetXMLDesc) {\n        char *ret;\n        ret = conn->driver->domainGetXMLDesc(domain, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: %lld: guest running, Ctrl-C to stop now\\n\"",
            "argv[0]",
            "deltams()"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deltams",
          "args": [],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: cannot start VM: %s\\n\"",
            "argv[0]",
            "virGetLastErrorMessage()"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainCreateXML",
          "args": [
            "conn",
            "xml",
            "0"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCreateXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-domain.c",
          "lines": "162-186",
          "snippet": "virDomainPtr\nvirDomainCreateXML(virConnectPtr conn, const char *xmlDesc,\n                   unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, xmlDesc=%s, flags=0x%x\", conn, NULLSTR(xmlDesc), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(xmlDesc, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainCreateXML) {\n        virDomainPtr ret;\n        ret = conn->driver->domainCreateXML(conn, xmlDesc, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nvirDomainPtr\nvirDomainCreateXML(virConnectPtr conn, const char *xmlDesc,\n                   unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, xmlDesc=%s, flags=0x%x\", conn, NULLSTR(xmlDesc), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(xmlDesc, error);\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainCreateXML) {\n        virDomainPtr ret;\n        ret = conn->driver->domainCreateXML(conn, xmlDesc, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: cannot read %s: %s\\n\"",
            "argv[0]",
            "argv[1]",
            "error->message"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_file_get_contents",
          "args": [
            "argv[1]",
            "&xml",
            "NULL",
            "&error"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: %lld: starting guest %s\\n\"",
            "argv[0]",
            "deltams()",
            "argv[1]"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deltams",
          "args": [],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: cannot register for lifecycle events: %s\\n\"",
            "argv[0]",
            "virGetLastErrorMessage()"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConnectDomainEventRegisterAny",
          "args": [
            "conn",
            "dom",
            "VIR_DOMAIN_EVENT_ID_LIFECYCLE",
            "VIR_DOMAIN_EVENT_CALLBACK(qemuShimDomShutdown)",
            "NULL",
            "NULL"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectDomainEventRegisterAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-domain.c",
          "lines": "9290-9334",
          "snippet": "int\nvirConnectDomainEventRegisterAny(virConnectPtr conn,\n                                 virDomainPtr dom,\n                                 int eventID,\n                                 virConnectDomainEventGenericCallback cb,\n                                 void *opaque,\n                                 virFreeCallback freecb)\n{\n    VIR_DOMAIN_DEBUG(dom, \"conn=%p, eventID=%d, cb=%p, opaque=%p, freecb=%p\",\n                     conn, eventID, cb, opaque, freecb);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    if (dom) {\n        virCheckDomainGoto(dom, error);\n        if (dom->conn != conn) {\n            virReportInvalidArg(dom,\n                                _(\"domain '%s' must match connection\"),\n                                dom->name);\n            goto error;\n        }\n    }\n    virCheckNonNullArgGoto(cb, error);\n    virCheckNonNegativeArgGoto(eventID, error);\n    if (eventID >= VIR_DOMAIN_EVENT_ID_LAST) {\n        virReportInvalidArg(eventID,\n                            _(\"eventID must be less than %d\"),\n                            VIR_DOMAIN_EVENT_ID_LAST);\n        goto error;\n    }\n\n    if (conn->driver && conn->driver->connectDomainEventRegisterAny) {\n        int ret;\n        ret = conn->driver->connectDomainEventRegisterAny(conn, dom, eventID, cb, opaque, freecb);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirConnectDomainEventRegisterAny(virConnectPtr conn,\n                                 virDomainPtr dom,\n                                 int eventID,\n                                 virConnectDomainEventGenericCallback cb,\n                                 void *opaque,\n                                 virFreeCallback freecb)\n{\n    VIR_DOMAIN_DEBUG(dom, \"conn=%p, eventID=%d, cb=%p, opaque=%p, freecb=%p\",\n                     conn, eventID, cb, opaque, freecb);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    if (dom) {\n        virCheckDomainGoto(dom, error);\n        if (dom->conn != conn) {\n            virReportInvalidArg(dom,\n                                _(\"domain '%s' must match connection\"),\n                                dom->name);\n            goto error;\n        }\n    }\n    virCheckNonNullArgGoto(cb, error);\n    virCheckNonNegativeArgGoto(eventID, error);\n    if (eventID >= VIR_DOMAIN_EVENT_ID_LAST) {\n        virReportInvalidArg(eventID,\n                            _(\"eventID must be less than %d\"),\n                            VIR_DOMAIN_EVENT_ID_LAST);\n        goto error;\n    }\n\n    if (conn->driver && conn->driver->connectDomainEventRegisterAny) {\n        int ret;\n        ret = conn->driver->connectDomainEventRegisterAny(conn, dom, eventID, cb, opaque, freecb);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_EVENT_CALLBACK",
          "args": [
            "qemuShimDomShutdown"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: cannot open %s: %s\\n\"",
            "argv[0]",
            "uri",
            "virGetLastErrorMessage()"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConnectOpen",
          "args": [
            "uri"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectOpenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "1181-1199",
          "snippet": "virConnectPtr\nvirConnectOpenReadOnly(const char *name)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n    virResetLastError();\n    ret = virConnectOpenInternal(name, NULL, VIR_CONNECT_RO);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirConnectPtr\nvirConnectOpenReadOnly(const char *name)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n    virResetLastError();\n    ret = virConnectOpenInternal(name, NULL, VIR_CONNECT_RO);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: %lld: opening %s\\n\"",
            "argv[0]",
            "deltams()",
            "uri"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deltams",
          "args": [],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"qemu:///embed?root=%s\"",
            "root"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecretFree",
          "args": [
            "sec"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-secret.c",
          "lines": "681-692",
          "snippet": "int\nvirSecretFree(virSecretPtr secret)\n{\n    VIR_DEBUG(\"secret=%p\", secret);\n\n    virResetLastError();\n\n    virCheckSecretReturn(secret, -1);\n\n    virObjectUnref(secret);\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirSecretFree(virSecretPtr secret)\n{\n    VIR_DEBUG(\"secret=%p\", secret);\n\n    virResetLastError();\n\n    virCheckSecretReturn(secret, -1);\n\n    virObjectUnref(secret);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: cannot set value for secret %s: %s\\n\"",
            "argv[0]",
            "bits[0]",
            "virGetLastErrorMessage()"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecretSetValue",
          "args": [
            "sec",
            "(unsigned char *)value",
            "nvalue",
            "0"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretSetValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-secret.c",
          "lines": "525-556",
          "snippet": "int\nvirSecretSetValue(virSecretPtr secret, const unsigned char *value,\n                  size_t value_size, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DEBUG(\"secret=%p, value=%p, value_size=%zu, flags=0x%x\", secret, value,\n              value_size, flags);\n\n    virResetLastError();\n\n    virCheckSecretReturn(secret, -1);\n    conn = secret->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(value, error);\n\n    if (conn->secretDriver != NULL && conn->secretDriver->secretSetValue != NULL) {\n        int ret;\n\n        ret = conn->secretDriver->secretSetValue(secret, value, value_size, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirSecretSetValue(virSecretPtr secret, const unsigned char *value,\n                  size_t value_size, unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DEBUG(\"secret=%p, value=%p, value_size=%zu, flags=0x%x\", secret, value,\n              value_size, flags);\n\n    virResetLastError();\n\n    virCheckSecretReturn(secret, -1);\n    conn = secret->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(value, error);\n\n    if (conn->secretDriver != NULL && conn->secretDriver->secretSetValue != NULL) {\n        int ret;\n\n        ret = conn->secretDriver->secretSetValue(secret, value, value_size, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: cannot define secret %s: %s\\n\"",
            "argv[0]",
            "bits[0]",
            "virGetLastErrorMessage()"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecretDefineXML",
          "args": [
            "sconn",
            "sxml",
            "0"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "virSecretDefineXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-secret.c",
          "lines": "333-358",
          "snippet": "virSecretPtr\nvirSecretDefineXML(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, xml=%s, flags=0x%x\", conn, NULLSTR(xml), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(xml, error);\n\n    if (conn->secretDriver != NULL && conn->secretDriver->secretDefineXML != NULL) {\n        virSecretPtr ret;\n\n        ret = conn->secretDriver->secretDefineXML(conn, xml, flags);\n        if (ret == NULL)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirSecretPtr\nvirSecretDefineXML(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    VIR_DEBUG(\"conn=%p, xml=%s, flags=0x%x\", conn, NULLSTR(xml), flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckReadOnlyGoto(conn->flags, error);\n    virCheckNonNullArgGoto(xml, error);\n\n    if (conn->secretDriver != NULL && conn->secretDriver->secretDefineXML != NULL) {\n        virSecretPtr ret;\n\n        ret = conn->secretDriver->secretDefineXML(conn, xml, flags);\n        if (ret == NULL)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: cannot read secret value %s: %s\\n\"",
            "argv[0]",
            "bits[1]",
            "error->message"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_file_get_contents",
          "args": [
            "bits[1]",
            "&value",
            "&nvalue",
            "&error"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: cannot read secret XML %s: %s\\n\"",
            "argv[0]",
            "bits[0]",
            "error->message"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_file_get_contents",
          "args": [
            "bits[0]",
            "&sxml",
            "NULL",
            "&error"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: %lld: loading secret %s and %s\\n\"",
            "argv[0]",
            "deltams()",
            "bits[0]",
            "bits[1]"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deltams",
          "args": [],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: expected a pair of filenames for --secret argument\\n\"",
            "argv[0]"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strsplit",
          "args": [
            "*tmpsecrets",
            "\",\"",
            "2"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: cannot open %s: %s\\n\"",
            "argv[0]",
            "suri",
            "virGetLastErrorMessage()"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: %lld: opening %s\\n\"",
            "argv[0]",
            "deltams()",
            "suri"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deltams",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_thread_new",
          "args": [
            "\"event-loop\"",
            "qemuShimEventLoop",
            "NULL"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: cannot register event loop handle: %s\"",
            "argv[0]",
            "virGetLastErrorMessage()"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "quitfd[1]"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "quitfd[0]"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventAddHandle",
          "args": [
            "quitfd[0]",
            "VIR_EVENT_HANDLE_READABLE",
            "qemuShimEventLoopStop",
            "NULL",
            "NULL"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "virEventAddHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "73-84",
          "snippet": "int\nvirEventAddHandle(int fd,\n                  int events,\n                  virEventHandleCallback cb,\n                  void *opaque,\n                  virFreeCallback ff)\n{\n    if (!addHandleImpl)\n        return -1;\n\n    return addHandleImpl(fd, events, cb, opaque, ff);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventAddHandleFunc addHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventAddHandleFunc addHandleImpl;\n\nint\nvirEventAddHandle(int fd,\n                  int events,\n                  virEventHandleCallback cb,\n                  void *opaque,\n                  virFreeCallback ff)\n{\n    if (!addHandleImpl)\n        return -1;\n\n    return addHandleImpl(fd, events, cb, opaque, ff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: cannot create event loop pipe: %s\"",
            "argv[0]",
            "g_strerror(errno)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "quitfd"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventRegisterDefaultImpl",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "virEventRegisterDefaultImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "304-315",
          "snippet": "int virEventRegisterDefaultImpl(void)\n{\n    VIR_DEBUG(\"registering default event implementation\");\n\n    virInitialize();\n\n    virResetLastError();\n\n    virEventGLibRegister();\n\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nint virEventRegisterDefaultImpl(void)\n{\n    VIR_DEBUG(\"registering default event implementation\");\n\n    virInitialize();\n\n    virResetLastError();\n\n    virEventGLibRegister();\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: %lld: preparing event loop thread\\n\"",
            "argv[0]",
            "deltams()"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deltams",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileActivateDirOverrideForProg",
          "args": [
            "argv[0]"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "virFileActivateDirOverrideForProg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1788-1800",
          "snippet": "void\nvirFileActivateDirOverrideForProg(const char *argv0)\n{\n    char *file = strrchr(argv0, '/');\n    if (!file || file[1] == '\\0')\n        return;\n    file++;\n    if (STRPREFIX(file, \"lt-\") ||\n        strstr(argv0, \"/.libs/\")) {\n        useDirOverride = true;\n        VIR_DEBUG(\"Activating build dir override for %s\", argv0);\n    }\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool useDirOverride;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic bool useDirOverride;\n\nvoid\nvirFileActivateDirOverrideForProg(const char *argv0)\n{\n    char *file = strrchr(argv0, '/');\n    if (!file || file[1] == '\\0')\n        return;\n    file++;\n    if (STRPREFIX(file, \"lt-\") ||\n        strstr(argv0, \"/.libs/\")) {\n        useDirOverride = true;\n        VIR_DEBUG(\"Activating build dir override for %s\", argv0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: cannot chown temporary dir: %s\\n\"",
            "argv[0]",
            "g_strerror(errno)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "root",
            "0755"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: cannot create temporary dir: %s\\n\"",
            "argv[0]",
            "error->message"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_dir_make_tmp",
          "args": [
            "\"virt-qemu-run-XXXXXX\"",
            "&error"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGPIPE",
            "SIG_IGN"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGHUP",
            "qemuShimSigShutdown"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGQUIT",
            "qemuShimSigShutdown"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "qemuShimSigShutdown"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "qemuShimSigShutdown"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: %lld: initializing signal handlers\\n\"",
            "argv[0]",
            "deltams()"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deltams",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetErrorFunc",
          "args": [
            "NULL",
            "qemuShimQuench"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "609-614",
          "snippet": "void\nvirSetErrorFunc(void *userData, virErrorFunc handler)\n{\n    virErrorHandler = handler;\n    virUserData = userData;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorFunc virErrorHandler = NULL;",
            "void *virUserData = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorFunc virErrorHandler = NULL;\nvoid *virUserData = NULL;\n\nvoid\nvirSetErrorFunc(void *userData, virErrorFunc handler)\n{\n    virErrorHandler = handler;\n    virUserData = userData;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: cannot initialize libvirt translations\\n\"",
            "argv[0]"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGettextInitialize",
          "args": [],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "virGettextInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virgettext.c",
          "lines": "39-59",
          "snippet": "int\nvirGettextInitialize(void)\n{\n#if HAVE_LIBINTL_H\n    if (!setlocale(LC_ALL, \"\")) {\n        perror(\"setlocale\");\n        /* failure to setup locale is not fatal */\n    }\n\n    if (!bindtextdomain(PACKAGE, LOCALEDIR)) {\n        perror(\"bindtextdomain\");\n        return -1;\n    }\n\n    if (!textdomain(PACKAGE)) {\n        perror(\"textdomain\");\n        return -1;\n    }\n#endif /* HAVE_LIBINTL_H */\n    return 0;\n}",
          "includes": [
            "#include \"virgettext.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virgettext.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <config.h>\n\nint\nvirGettextInitialize(void)\n{\n#if HAVE_LIBINTL_H\n    if (!setlocale(LC_ALL, \"\")) {\n        perror(\"setlocale\");\n        /* failure to setup locale is not fatal */\n    }\n\n    if (!bindtextdomain(PACKAGE, LOCALEDIR)) {\n        perror(\"bindtextdomain\");\n        return -1;\n    }\n\n    if (!textdomain(PACKAGE)) {\n        perror(\"textdomain\");\n        return -1;\n    }\n#endif /* HAVE_LIBINTL_H */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: cannot initialize libvirt\\n\"",
            "argv[0]"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInitialize",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "virInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "306-315",
          "snippet": "int\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool virGlobalError;",
            "static virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic bool virGlobalError;\nstatic virOnceControl virGlobalOnce = VIR_ONCE_CONTROL_INITIALIZER;\n\nint\nvirInitialize(void)\n{\n    if (virOnce(&virGlobalOnce, virGlobalInit) < 0)\n        return -1;\n\n    if (virGlobalError)\n        return -1;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: %lld: initializing libvirt\\n\"",
            "argv[0]",
            "deltams()"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deltams",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s\"",
            "help"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_option_context_get_help",
          "args": [
            "ctx",
            "TRUE",
            "NULL"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_printerr",
          "args": [
            "\"%s: option parsing failed: %s\\n\"",
            "argv[0]",
            "error->message"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_option_context_parse",
          "args": [
            "ctx",
            "&argc",
            "&argv",
            "&error"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_option_context_add_main_entries",
          "args": [
            "ctx",
            "entries",
            "PACKAGE"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_option_context_new",
          "args": [
            "\"- run a standalone QEMU process\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_get_monotonic_time",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include <unistd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int eventQuitFD = -1;\nstatic virDomainPtr dom;\n\nint main(int argc, char **argv)\n{\n    GThread *eventLoopThread = NULL;\n    virConnectPtr conn = NULL;\n    virConnectPtr sconn = NULL;\n    g_autofree char *xml = NULL;\n    g_autofree char *uri = NULL;\n    g_autofree char *suri = NULL;\n    char *root = NULL;\n    bool tmproot = false;\n    int ret = 1;\n    g_autoptr(GError) error = NULL;\n    g_auto(GStrv) secrets = NULL;\n    gboolean verbose = false;\n    gboolean debug = false;\n    GStrv tmpsecrets;\n    GOptionContext *ctx;\n    GOptionEntry entries[] = {\n        { \"secret\", 's', 0, G_OPTION_ARG_STRING_ARRAY, &secrets, \"Load secret file\", \"SECRET-XML-FILE,SECRET-VALUE-FILE\" },\n        { \"root\", 'r', 0, G_OPTION_ARG_STRING, &root, \"Root directory\", \"DIR\" },\n        { \"debug\", 'd', 0, G_OPTION_ARG_NONE, &debug, \"Debug output\", NULL },\n        { \"verbose\", 'v', 0, G_OPTION_ARG_NONE, &verbose, \"Verbose output\", NULL },\n        { 0 }\n    };\n    int quitfd[2] = {-1, -1};\n    long long start = g_get_monotonic_time();\n\n#define deltams() ((long long)g_get_monotonic_time() - start)\n\n    ctx = g_option_context_new(\"- run a standalone QEMU process\");\n    g_option_context_add_main_entries(ctx, entries, PACKAGE);\n    if (!g_option_context_parse(ctx, &argc, &argv, &error)) {\n        g_printerr(\"%s: option parsing failed: %s\\n\",\n                   argv[0], error->message);\n        return 1;\n    }\n\n    if (argc != 2) {\n        g_autofree char *help = g_option_context_get_help(ctx, TRUE, NULL);\n        g_printerr(\"%s\", help);\n        return 1;\n    }\n\n    if (verbose)\n        g_printerr(\"%s: %lld: initializing libvirt\\n\",\n                   argv[0], deltams());\n\n    if (virInitialize() < 0) {\n        g_printerr(\"%s: cannot initialize libvirt\\n\", argv[0]);\n        return 1;\n    }\n    if (virGettextInitialize() < 0) {\n        g_printerr(\"%s: cannot initialize libvirt translations\\n\", argv[0]);\n        return 1;\n    }\n\n    virSetErrorFunc(NULL, qemuShimQuench);\n\n    if (verbose)\n        g_printerr(\"%s: %lld: initializing signal handlers\\n\",\n                   argv[0], deltams());\n\n    signal(SIGTERM, qemuShimSigShutdown);\n    signal(SIGINT, qemuShimSigShutdown);\n    signal(SIGQUIT, qemuShimSigShutdown);\n    signal(SIGHUP, qemuShimSigShutdown);\n    signal(SIGPIPE, SIG_IGN);\n\n    if (root == NULL) {\n        if (!(root = g_dir_make_tmp(\"virt-qemu-run-XXXXXX\", &error))) {\n            g_printerr(\"%s: cannot create temporary dir: %s\\n\",\n                       argv[0], error->message);\n            return 1;\n        }\n        tmproot = true;\n\n        if (chmod(root, 0755) < 0) {\n            g_printerr(\"%s: cannot chown temporary dir: %s\\n\",\n                       argv[0], g_strerror(errno));\n            goto cleanup;\n        }\n    }\n\n    virFileActivateDirOverrideForProg(argv[0]);\n\n    if (verbose)\n        g_printerr(\"%s: %lld: preparing event loop thread\\n\",\n                   argv[0], deltams());\n    virEventRegisterDefaultImpl();\n\n    if (pipe(quitfd) < 0) {\n        g_printerr(\"%s: cannot create event loop pipe: %s\",\n                   argv[0], g_strerror(errno));\n        goto cleanup;\n    }\n\n    if (virEventAddHandle(quitfd[0], VIR_EVENT_HANDLE_READABLE, qemuShimEventLoopStop, NULL, NULL) < 0) {\n        VIR_FORCE_CLOSE(quitfd[0]);\n        VIR_FORCE_CLOSE(quitfd[1]);\n        quitfd[0] = quitfd[1] = -1;\n        g_printerr(\"%s: cannot register event loop handle: %s\",\n                   argv[0], virGetLastErrorMessage());\n        goto cleanup;\n    }\n    eventQuitFD = quitfd[1];\n\n    eventLoopThread = g_thread_new(\"event-loop\", qemuShimEventLoop, NULL);\n\n    if (secrets && *secrets) {\n        suri = g_strdup_printf(\"secret:///embed?root=%s\", root);\n\n        if (verbose)\n            g_printerr(\"%s: %lld: opening %s\\n\",\n                       argv[0], deltams(), suri);\n\n        sconn = virConnectOpen(suri);\n        if (!sconn) {\n            g_printerr(\"%s: cannot open %s: %s\\n\",\n                       argv[0], suri, virGetLastErrorMessage());\n            goto cleanup;\n        }\n\n        tmpsecrets = secrets;\n        while (tmpsecrets && *tmpsecrets) {\n            g_auto(GStrv) bits = g_strsplit(*tmpsecrets, \",\", 2);\n            g_autofree char *sxml = NULL;\n            g_autofree char *value = NULL;\n            virSecretPtr sec;\n            size_t nvalue;\n\n            if (!bits || bits[0] == NULL || bits[1] == NULL) {\n                g_printerr(\"%s: expected a pair of filenames for --secret argument\\n\",\n                    argv[0]);\n                goto cleanup;\n            }\n\n            if (verbose)\n                g_printerr(\"%s: %lld: loading secret %s and %s\\n\",\n                           argv[0], deltams(), bits[0], bits[1]);\n\n            if (!g_file_get_contents(bits[0], &sxml, NULL, &error)) {\n                g_printerr(\"%s: cannot read secret XML %s: %s\\n\",\n                           argv[0], bits[0], error->message);\n                goto cleanup;\n            }\n\n            if (!g_file_get_contents(bits[1], &value, &nvalue, &error)) {\n                g_printerr(\"%s: cannot read secret value %s: %s\\n\",\n                           argv[0], bits[1], error->message);\n                goto cleanup;\n            }\n\n            if (!(sec = virSecretDefineXML(sconn, sxml, 0))) {\n                g_printerr(\"%s: cannot define secret %s: %s\\n\",\n                           argv[0], bits[0], virGetLastErrorMessage());\n                goto cleanup;\n            }\n\n            if (virSecretSetValue(sec, (unsigned char *)value, nvalue, 0) < 0) {\n                virSecretFree(sec);\n                g_printerr(\"%s: cannot set value for secret %s: %s\\n\",\n                argv[0], bits[0], virGetLastErrorMessage());\n                goto cleanup;\n            }\n            virSecretFree(sec);\n\n            tmpsecrets++;\n        }\n    }\n\n    uri = g_strdup_printf(\"qemu:///embed?root=%s\", root);\n\n    if (verbose)\n        g_printerr(\"%s: %lld: opening %s\\n\",\n                   argv[0], deltams(), uri);\n\n    conn = virConnectOpen(uri);\n    if (!conn) {\n        g_printerr(\"%s: cannot open %s: %s\\n\",\n                   argv[0], uri, virGetLastErrorMessage());\n        goto cleanup;\n    }\n\n    if (virConnectDomainEventRegisterAny(\n            conn, dom, VIR_DOMAIN_EVENT_ID_LIFECYCLE,\n            VIR_DOMAIN_EVENT_CALLBACK(qemuShimDomShutdown),\n            NULL, NULL) < 0) {\n        g_printerr(\"%s: cannot register for lifecycle events: %s\\n\",\n                   argv[0], virGetLastErrorMessage());\n        goto cleanup;\n    }\n\n    if (verbose)\n        g_printerr(\"%s: %lld: starting guest %s\\n\",\n                   argv[0], deltams(), argv[1]);\n\n    if (!g_file_get_contents(argv[1], &xml, NULL, &error)) {\n        g_printerr(\"%s: cannot read %s: %s\\n\",\n                   argv[0], argv[1], error->message);\n        goto cleanup;\n    }\n\n    dom = virDomainCreateXML(conn, xml, 0);\n    if (!dom) {\n        g_printerr(\"%s: cannot start VM: %s\\n\",\n                   argv[0], virGetLastErrorMessage());\n        goto cleanup;\n    }\n    if (verbose)\n        g_printerr(\"%s: %lld: guest running, Ctrl-C to stop now\\n\",\n                   argv[0], deltams());\n\n    if (debug) {\n        g_autofree char *newxml = NULL;\n        newxml = virDomainGetXMLDesc(dom, 0);\n        g_printerr(\"%s: XML: %s\\n\", argv[0], newxml);\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret != 0 && eventQuitFD != -1)\n        ignore_value(safewrite(eventQuitFD, \"c\", 1));\n\n    if (eventLoopThread != NULL && (ret == 0 || eventQuitFD != -1))\n        g_thread_join(eventLoopThread);\n\n    VIR_FORCE_CLOSE(quitfd[0]);\n    VIR_FORCE_CLOSE(quitfd[1]);\n\n    if (dom != NULL)\n        virDomainFree(dom);\n    if (sconn != NULL)\n        virConnectClose(sconn);\n    if (conn != NULL)\n        virConnectClose(conn);\n    if (tmproot)\n        virFileDeleteTree(root);\n\n    if (verbose)\n        g_printerr(\"%s: %lld: cleaned up, exiting\\n\",\n                   argv[0], deltams());\n    return ret;\n}"
  },
  {
    "function_name": "qemuShimQuench",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_shim.c",
    "lines": "81-85",
    "snippet": "static void\nqemuShimQuench(void *userData G_GNUC_UNUSED,\n               virErrorPtr error G_GNUC_UNUSED)\n{\n}",
    "includes": [
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include <unistd.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include <unistd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic void\nqemuShimQuench(void *userData G_GNUC_UNUSED,\n               virErrorPtr error G_GNUC_UNUSED)\n{\n}"
  },
  {
    "function_name": "qemuShimSigShutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_shim.c",
    "lines": "73-79",
    "snippet": "static void\nqemuShimSigShutdown(int sig G_GNUC_UNUSED)\n{\n    if (dom)\n        virDomainDestroy(dom);\n    ignore_value(safewrite(eventQuitFD, \"c\", 1));\n}",
    "includes": [
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include <unistd.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int eventQuitFD = -1;",
      "static virDomainPtr dom;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "safewrite(eventQuitFD, \"c\", 1)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "eventQuitFD",
            "\"c\"",
            "1"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDestroy",
          "args": [
            "dom"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-domain.c",
          "lines": "460-487",
          "snippet": "int\nvirDomainDestroy(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainDestroy) {\n        int ret;\n        ret = conn->driver->domainDestroy(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirDomainDestroy(virDomainPtr domain)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    conn = domain->conn;\n\n    virCheckReadOnlyGoto(conn->flags, error);\n\n    if (conn->driver->domainDestroy) {\n        int ret;\n        ret = conn->driver->domainDestroy(domain);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include <unistd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic int eventQuitFD = -1;\nstatic virDomainPtr dom;\n\nstatic void\nqemuShimSigShutdown(int sig G_GNUC_UNUSED)\n{\n    if (dom)\n        virDomainDestroy(dom);\n    ignore_value(safewrite(eventQuitFD, \"c\", 1));\n}"
  },
  {
    "function_name": "qemuShimDomShutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_shim.c",
    "lines": "59-70",
    "snippet": "static int\nqemuShimDomShutdown(virConnectPtr econn G_GNUC_UNUSED,\n                    virDomainPtr edom G_GNUC_UNUSED,\n                    int event,\n                    int detail G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    if (event == VIR_DOMAIN_EVENT_STOPPED)\n        eventQuitFlag = true;\n\n    return 0;\n}",
    "includes": [
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include <unistd.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool eventQuitFlag;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include <unistd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic bool eventQuitFlag;\n\nstatic int\nqemuShimDomShutdown(virConnectPtr econn G_GNUC_UNUSED,\n                    virDomainPtr edom G_GNUC_UNUSED,\n                    int event,\n                    int detail G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    if (event == VIR_DOMAIN_EVENT_STOPPED)\n        eventQuitFlag = true;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuShimEventLoopStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_shim.c",
    "lines": "47-56",
    "snippet": "static void\nqemuShimEventLoopStop(int watch G_GNUC_UNUSED,\n                      int fd,\n                      int event G_GNUC_UNUSED,\n                      void *opaque G_GNUC_UNUSED)\n{\n    char c;\n    ignore_value(read(fd, &c, 1));\n    eventQuitFlag = true;\n}",
    "includes": [
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include <unistd.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool eventQuitFlag;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "read(fd, &c, 1)"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "&c",
            "1"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessDetectIOThreadPIDs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "2434-2495",
          "snippet": "static int\nqemuProcessDetectIOThreadPIDs(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorIOThreadInfoPtr *iothreads = NULL;\n    int niothreads = 0;\n    int ret = -1;\n    size_t i;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_OBJECT_IOTHREAD)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Get the list of IOThreads from qemu */\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n    niothreads = qemuMonitorGetIOThreads(priv->mon, &iothreads);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        goto cleanup;\n    if (niothreads < 0)\n        goto cleanup;\n\n    if (niothreads != vm->def->niothreadids) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"got wrong number of IOThread pids from QEMU monitor. \"\n                         \"got %d, wanted %zu\"),\n                       niothreads, vm->def->niothreadids);\n        goto cleanup;\n    }\n\n    /* Nothing to do */\n    if (niothreads == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    for (i = 0; i < niothreads; i++) {\n        virDomainIOThreadIDDefPtr iothrid;\n\n        if (!(iothrid = virDomainIOThreadIDFind(vm->def,\n                                                iothreads[i]->iothread_id))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"iothread %d not found\"),\n                           iothreads[i]->iothread_id);\n            goto cleanup;\n        }\n        iothrid->thread_id = iothreads[i]->thread_id;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (iothreads) {\n        for (i = 0; i < niothreads; i++)\n            VIR_FREE(iothreads[i]);\n        VIR_FREE(iothreads);\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nqemuProcessDetectIOThreadPIDs(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorIOThreadInfoPtr *iothreads = NULL;\n    int niothreads = 0;\n    int ret = -1;\n    size_t i;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_OBJECT_IOTHREAD)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Get the list of IOThreads from qemu */\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n    niothreads = qemuMonitorGetIOThreads(priv->mon, &iothreads);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        goto cleanup;\n    if (niothreads < 0)\n        goto cleanup;\n\n    if (niothreads != vm->def->niothreadids) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"got wrong number of IOThread pids from QEMU monitor. \"\n                         \"got %d, wanted %zu\"),\n                       niothreads, vm->def->niothreadids);\n        goto cleanup;\n    }\n\n    /* Nothing to do */\n    if (niothreads == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    for (i = 0; i < niothreads; i++) {\n        virDomainIOThreadIDDefPtr iothrid;\n\n        if (!(iothrid = virDomainIOThreadIDFind(vm->def,\n                                                iothreads[i]->iothread_id))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"iothread %d not found\"),\n                           iothreads[i]->iothread_id);\n            goto cleanup;\n        }\n        iothrid->thread_id = iothreads[i]->thread_id;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (iothreads) {\n        for (i = 0; i < niothreads; i++)\n            VIR_FREE(iothreads[i]);\n        VIR_FREE(iothreads);\n    }\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include <unistd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic bool eventQuitFlag;\n\nstatic void\nqemuShimEventLoopStop(int watch G_GNUC_UNUSED,\n                      int fd,\n                      int event G_GNUC_UNUSED,\n                      void *opaque G_GNUC_UNUSED)\n{\n    char c;\n    ignore_value(read(fd, &c, 1));\n    eventQuitFlag = true;\n}"
  },
  {
    "function_name": "qemuShimEventLoop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_shim.c",
    "lines": "37-44",
    "snippet": "static void *\nqemuShimEventLoop(void *opaque G_GNUC_UNUSED)\n{\n    while (!eventQuitFlag)\n        virEventRunDefaultImpl();\n\n    return NULL;\n}",
    "includes": [
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virfile.h\"",
      "#include <unistd.h>",
      "#include <stdbool.h>",
      "#include <stdio.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool eventQuitFlag;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virEventRunDefaultImpl",
          "args": [],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "virEventRunDefaultImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "338-344",
          "snippet": "int virEventRunDefaultImpl(void)\n{\n    VIR_DEBUG(\"running default event implementation\");\n    virResetLastError();\n\n    return virEventGLibRunOnce();\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nint virEventRunDefaultImpl(void)\n{\n    VIR_DEBUG(\"running default event implementation\");\n    virResetLastError();\n\n    return virEventGLibRunOnce();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include <unistd.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <config.h>\n\nstatic bool eventQuitFlag;\n\nstatic void *\nqemuShimEventLoop(void *opaque G_GNUC_UNUSED)\n{\n    while (!eventQuitFlag)\n        virEventRunDefaultImpl();\n\n    return NULL;\n}"
  }
]