[
  {
    "function_name": "xenDomainDefAddImplicitInputDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "2453-2472",
    "snippet": "int\nxenDomainDefAddImplicitInputDevice(virDomainDefPtr def)\n{\n    virDomainInputBus implicitInputBus = VIR_DOMAIN_INPUT_BUS_XEN;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM)\n        implicitInputBus = VIR_DOMAIN_INPUT_BUS_PS2;\n\n    if (virDomainDefMaybeAddInput(def,\n                                  VIR_DOMAIN_INPUT_TYPE_MOUSE,\n                                  implicitInputBus) < 0)\n        return -1;\n\n    if (virDomainDefMaybeAddInput(def,\n                                  VIR_DOMAIN_INPUT_TYPE_KBD,\n                                  implicitInputBus) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefMaybeAddInput",
          "args": [
            "def",
            "VIR_DOMAIN_INPUT_TYPE_KBD",
            "implicitInputBus"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefMaybeAddInput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "19027-19053",
          "snippet": "int\nvirDomainDefMaybeAddInput(virDomainDefPtr def,\n                          int type,\n                          int bus)\n{\n    size_t i;\n    virDomainInputDefPtr input;\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (def->inputs[i]->type == type &&\n            def->inputs[i]->bus == bus)\n            return 0;\n    }\n\n    if (VIR_ALLOC(input) < 0)\n        return -1;\n\n    input->type = type;\n    input->bus = bus;\n\n    if (VIR_APPEND_ELEMENT(def->inputs, def->ninputs, input) < 0) {\n        VIR_FREE(input);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefMaybeAddInput(virDomainDefPtr def,\n                          int type,\n                          int bus)\n{\n    size_t i;\n    virDomainInputDefPtr input;\n\n    for (i = 0; i < def->ninputs; i++) {\n        if (def->inputs[i]->type == type &&\n            def->inputs[i]->bus == bus)\n            return 0;\n    }\n\n    if (VIR_ALLOC(input) < 0)\n        return -1;\n\n    input->type = type;\n    input->bus = bus;\n\n    if (VIR_APPEND_ELEMENT(def->inputs, def->ninputs, input) < 0) {\n        VIR_FREE(input);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenDomainDefAddImplicitInputDevice(virDomainDefPtr def)\n{\n    virDomainInputBus implicitInputBus = VIR_DOMAIN_INPUT_BUS_XEN;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM)\n        implicitInputBus = VIR_DOMAIN_INPUT_BUS_PS2;\n\n    if (virDomainDefMaybeAddInput(def,\n                                  VIR_DOMAIN_INPUT_TYPE_MOUSE,\n                                  implicitInputBus) < 0)\n        return -1;\n\n    if (virDomainDefMaybeAddInput(def,\n                                  VIR_DOMAIN_INPUT_TYPE_KBD,\n                                  implicitInputBus) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "xenFormatConfigCommon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "2398-2450",
    "snippet": "int\nxenFormatConfigCommon(virConfPtr conf,\n                      virDomainDefPtr def,\n                      virConnectPtr conn,\n                      const char *nativeFormat)\n{\n    if (xenFormatGeneralMeta(conf, def) < 0)\n        return -1;\n\n    if (xenFormatMem(conf, def) < 0)\n        return -1;\n\n    if (xenFormatCPUAllocation(conf, def) < 0)\n        return -1;\n\n    if (xenFormatCPUFeatures(conf, def) < 0)\n        return -1;\n\n    if (xenFormatTimeOffset(conf, def) < 0)\n        return -1;\n\n    if (xenFormatEventActions(conf, def) < 0)\n        return -1;\n\n    if (xenFormatEmulator(conf, def) < 0)\n        return -1;\n\n    if (xenFormatVfb(conf, def) < 0)\n        return -1;\n\n    if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XL)) {\n        if (xenFormatVif(conf, conn, def, \"vif\") < 0)\n            return -1;\n    } else if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n        if (xenFormatVif(conf, conn, def, \"netfront\") < 0)\n            return -1;\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported config type %s\"), nativeFormat);\n        return -1;\n    }\n\n    if (xenFormatPCI(conf, def) < 0)\n        return -1;\n\n    if (xenFormatCharDev(conf, def, nativeFormat) < 0)\n        return -1;\n\n    if (xenFormatSound(conf, def) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenFormatSound",
          "args": [
            "conf",
            "def"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatSound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "2328-2355",
          "snippet": "static int\nxenFormatSound(virConfPtr conf, virDomainDefPtr def)\n{\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    const char * model;\n    g_autofree char *str = NULL;\n    size_t i;\n\n    if (def->os.type != VIR_DOMAIN_OSTYPE_HVM ||\n        !def->sounds)\n        return 0;\n\n    for (i = 0; i < def->nsounds; i++) {\n        if (!(model = virDomainSoundModelTypeToString(def->sounds[i]->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected sound model %d\"),\n                           def->sounds[i]->model);\n            return -1;\n        }\n        if (i)\n            virBufferAddChar(&buf, ',');\n        virBufferEscapeSexpr(&buf, \"%s\", model);\n    }\n\n    str = virBufferContentAndReset(&buf);\n\n    return xenConfigSetString(conf, \"soundhw\", str);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatSound(virConfPtr conf, virDomainDefPtr def)\n{\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    const char * model;\n    g_autofree char *str = NULL;\n    size_t i;\n\n    if (def->os.type != VIR_DOMAIN_OSTYPE_HVM ||\n        !def->sounds)\n        return 0;\n\n    for (i = 0; i < def->nsounds; i++) {\n        if (!(model = virDomainSoundModelTypeToString(def->sounds[i]->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected sound model %d\"),\n                           def->sounds[i]->model);\n            return -1;\n        }\n        if (i)\n            virBufferAddChar(&buf, ',');\n        virBufferEscapeSexpr(&buf, \"%s\", model);\n    }\n\n    str = virBufferContentAndReset(&buf);\n\n    return xenConfigSetString(conf, \"soundhw\", str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatCharDev",
          "args": [
            "conf",
            "def",
            "nativeFormat"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatCharDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1988-2078",
          "snippet": "static int\nxenFormatCharDev(virConfPtr conf, virDomainDefPtr def,\n                 const char *nativeFormat)\n{\n    size_t i;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (def->nparallels) {\n            virBuffer buf = VIR_BUFFER_INITIALIZER;\n            char *str;\n            int ret;\n\n            ret = xenFormatSxprChr(def->parallels[0], &buf);\n            str = virBufferContentAndReset(&buf);\n            if (ret == 0)\n                ret = xenConfigSetString(conf, \"parallel\", str);\n            VIR_FREE(str);\n            if (ret < 0)\n                return -1;\n        } else {\n            if (xenConfigSetString(conf, \"parallel\", \"none\") < 0)\n                return -1;\n        }\n\n        if (def->nserials) {\n            if ((def->nserials == 1) && (def->serials[0]->target.port == 0)) {\n                virBuffer buf = VIR_BUFFER_INITIALIZER;\n                char *str;\n                int ret;\n\n                ret = xenFormatSxprChr(def->serials[0], &buf);\n                str = virBufferContentAndReset(&buf);\n                if (ret == 0)\n                    ret = xenConfigSetString(conf, \"serial\", str);\n                VIR_FREE(str);\n                if (ret < 0)\n                    return -1;\n            } else {\n                size_t j = 0;\n                int maxport = -1, port;\n                virConfValuePtr serialVal = NULL;\n\n                if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Multiple serial devices are not supported by xen-xm\"));\n                    return -1;\n                }\n\n                if (VIR_ALLOC(serialVal) < 0)\n                    return -1;\n\n                serialVal->type = VIR_CONF_LIST;\n                serialVal->list = NULL;\n\n                for (i = 0; i < def->nserials; i++)\n                    if (def->serials[i]->target.port > maxport)\n                        maxport = def->serials[i]->target.port;\n\n                for (port = 0; port <= maxport; port++) {\n                    virDomainChrDefPtr chr = NULL;\n\n                    for (j = 0; j < def->nserials; j++) {\n                        if (def->serials[j]->target.port == port) {\n                            chr = def->serials[j];\n                            break;\n                        }\n                    }\n\n                    if (xenFormatSerial(serialVal, chr) < 0) {\n                        VIR_FREE(serialVal);\n                        return -1;\n                    }\n                }\n\n                if (serialVal->list != NULL) {\n                    int ret = virConfSetValue(conf, \"serial\", serialVal);\n\n                    serialVal = NULL;\n                    if (ret < 0)\n                        return -1;\n                }\n                VIR_FREE(serialVal);\n            }\n        } else {\n            if (xenConfigSetString(conf, \"serial\", \"none\") < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatCharDev(virConfPtr conf, virDomainDefPtr def,\n                 const char *nativeFormat)\n{\n    size_t i;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (def->nparallels) {\n            virBuffer buf = VIR_BUFFER_INITIALIZER;\n            char *str;\n            int ret;\n\n            ret = xenFormatSxprChr(def->parallels[0], &buf);\n            str = virBufferContentAndReset(&buf);\n            if (ret == 0)\n                ret = xenConfigSetString(conf, \"parallel\", str);\n            VIR_FREE(str);\n            if (ret < 0)\n                return -1;\n        } else {\n            if (xenConfigSetString(conf, \"parallel\", \"none\") < 0)\n                return -1;\n        }\n\n        if (def->nserials) {\n            if ((def->nserials == 1) && (def->serials[0]->target.port == 0)) {\n                virBuffer buf = VIR_BUFFER_INITIALIZER;\n                char *str;\n                int ret;\n\n                ret = xenFormatSxprChr(def->serials[0], &buf);\n                str = virBufferContentAndReset(&buf);\n                if (ret == 0)\n                    ret = xenConfigSetString(conf, \"serial\", str);\n                VIR_FREE(str);\n                if (ret < 0)\n                    return -1;\n            } else {\n                size_t j = 0;\n                int maxport = -1, port;\n                virConfValuePtr serialVal = NULL;\n\n                if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Multiple serial devices are not supported by xen-xm\"));\n                    return -1;\n                }\n\n                if (VIR_ALLOC(serialVal) < 0)\n                    return -1;\n\n                serialVal->type = VIR_CONF_LIST;\n                serialVal->list = NULL;\n\n                for (i = 0; i < def->nserials; i++)\n                    if (def->serials[i]->target.port > maxport)\n                        maxport = def->serials[i]->target.port;\n\n                for (port = 0; port <= maxport; port++) {\n                    virDomainChrDefPtr chr = NULL;\n\n                    for (j = 0; j < def->nserials; j++) {\n                        if (def->serials[j]->target.port == port) {\n                            chr = def->serials[j];\n                            break;\n                        }\n                    }\n\n                    if (xenFormatSerial(serialVal, chr) < 0) {\n                        VIR_FREE(serialVal);\n                        return -1;\n                    }\n                }\n\n                if (serialVal->list != NULL) {\n                    int ret = virConfSetValue(conf, \"serial\", serialVal);\n\n                    serialVal = NULL;\n                    if (ret < 0)\n                        return -1;\n                }\n                VIR_FREE(serialVal);\n            }\n        } else {\n            if (xenConfigSetString(conf, \"serial\", \"none\") < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatPCI",
          "args": [
            "conf",
            "def"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatPCI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1793-1855",
          "snippet": "static int\nxenFormatPCI(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr pciVal = NULL;\n    int hasPCI = 0;\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++)\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            hasPCI = 1;\n\n    if (!hasPCI)\n        return 0;\n\n    if (VIR_ALLOC(pciVal) < 0)\n        return -1;\n\n    pciVal->type = VIR_CONF_LIST;\n    pciVal->list = NULL;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI) {\n            virConfValuePtr val, tmp;\n            char *buf;\n\n            buf = g_strdup_printf(\"%04x:%02x:%02x.%x\",\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.domain,\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.bus,\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.slot,\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.function);\n\n            if (VIR_ALLOC(val) < 0) {\n                VIR_FREE(buf);\n                goto error;\n            }\n            val->type = VIR_CONF_STRING;\n            val->str = buf;\n            tmp = pciVal->list;\n            while (tmp && tmp->next)\n                tmp = tmp->next;\n            if (tmp)\n                tmp->next = val;\n            else\n                pciVal->list = val;\n        }\n    }\n\n    if (pciVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"pci\", pciVal);\n        pciVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(pciVal);\n\n    return 0;\n\n error:\n    virConfFreeValue(pciVal);\n    return -1;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatPCI(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr pciVal = NULL;\n    int hasPCI = 0;\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++)\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            hasPCI = 1;\n\n    if (!hasPCI)\n        return 0;\n\n    if (VIR_ALLOC(pciVal) < 0)\n        return -1;\n\n    pciVal->type = VIR_CONF_LIST;\n    pciVal->list = NULL;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI) {\n            virConfValuePtr val, tmp;\n            char *buf;\n\n            buf = g_strdup_printf(\"%04x:%02x:%02x.%x\",\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.domain,\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.bus,\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.slot,\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.function);\n\n            if (VIR_ALLOC(val) < 0) {\n                VIR_FREE(buf);\n                goto error;\n            }\n            val->type = VIR_CONF_STRING;\n            val->str = buf;\n            tmp = pciVal->list;\n            while (tmp && tmp->next)\n                tmp = tmp->next;\n            if (tmp)\n                tmp->next = val;\n            else\n                pciVal->list = val;\n        }\n    }\n\n    if (pciVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"pci\", pciVal);\n        pciVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(pciVal);\n\n    return 0;\n\n error:\n    virConfFreeValue(pciVal);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"unsupported config type %s\")",
            "nativeFormat"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported config type %s\""
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatVif",
          "args": [
            "conf",
            "conn",
            "def",
            "\"netfront\""
          ],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatVif",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "2358-2392",
          "snippet": "static int\nxenFormatVif(virConfPtr conf,\n             virConnectPtr conn,\n             virDomainDefPtr def,\n             const char *vif_typename)\n{\n    virConfValuePtr netVal = NULL;\n    size_t i;\n    int hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM;\n\n    if (VIR_ALLOC(netVal) < 0)\n        goto cleanup;\n    netVal->type = VIR_CONF_LIST;\n    netVal->list = NULL;\n\n    for (i = 0; i < def->nnets; i++) {\n        if (xenFormatNet(conn, netVal, def->nets[i],\n                         hvm, vif_typename) < 0)\n            goto cleanup;\n    }\n\n    if (netVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"vif\", netVal);\n        netVal = NULL;\n        if (ret < 0)\n            goto cleanup;\n    }\n\n    VIR_FREE(netVal);\n    return 0;\n\n cleanup:\n    virConfFreeValue(netVal);\n    return -1;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatVif(virConfPtr conf,\n             virConnectPtr conn,\n             virDomainDefPtr def,\n             const char *vif_typename)\n{\n    virConfValuePtr netVal = NULL;\n    size_t i;\n    int hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM;\n\n    if (VIR_ALLOC(netVal) < 0)\n        goto cleanup;\n    netVal->type = VIR_CONF_LIST;\n    netVal->list = NULL;\n\n    for (i = 0; i < def->nnets; i++) {\n        if (xenFormatNet(conn, netVal, def->nets[i],\n                         hvm, vif_typename) < 0)\n            goto cleanup;\n    }\n\n    if (netVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"vif\", netVal);\n        netVal = NULL;\n        if (ret < 0)\n            goto cleanup;\n    }\n\n    VIR_FREE(netVal);\n    return 0;\n\n cleanup:\n    virConfFreeValue(netVal);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "nativeFormat",
            "XEN_CONFIG_FORMAT_XM"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "nativeFormat",
            "XEN_CONFIG_FORMAT_XL"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenFormatVfb",
          "args": [
            "conf",
            "def"
          ],
          "line": 2425
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatVfb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "2211-2325",
          "snippet": "static int\nxenFormatVfb(virConfPtr conf, virDomainDefPtr def)\n{\n    int hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM ? 1 : 0;\n\n    if (def->ngraphics == 1 &&\n        def->graphics[0]->type != VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n        if (hvm) {\n            if (def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL) {\n                if (xenConfigSetInt(conf, \"sdl\", 1) < 0)\n                    return -1;\n\n                if (xenConfigSetInt(conf, \"vnc\", 0) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.sdl.display &&\n                    xenConfigSetString(conf, \"display\",\n                                       def->graphics[0]->data.sdl.display) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.sdl.xauth &&\n                    xenConfigSetString(conf, \"xauthority\",\n                                       def->graphics[0]->data.sdl.xauth) < 0)\n                    return -1;\n            } else {\n                virDomainGraphicsListenDefPtr glisten;\n\n                if (xenConfigSetInt(conf, \"sdl\", 0) < 0)\n                    return -1;\n\n                if (xenConfigSetInt(conf, \"vnc\", 1) < 0)\n                    return -1;\n\n                if (xenConfigSetInt(conf, \"vncunused\",\n                              def->graphics[0]->data.vnc.autoport ? 1 : 0) < 0)\n                    return -1;\n\n                if (!def->graphics[0]->data.vnc.autoport &&\n                    xenConfigSetInt(conf, \"vncdisplay\",\n                                    def->graphics[0]->data.vnc.port - 5900) < 0)\n                    return -1;\n\n                if ((glisten = virDomainGraphicsGetListen(def->graphics[0], 0)) &&\n                    glisten->address &&\n                    xenConfigSetString(conf, \"vnclisten\", glisten->address) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.vnc.auth.passwd &&\n                    xenConfigSetString(conf, \"vncpasswd\",\n                                       def->graphics[0]->data.vnc.auth.passwd) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.vnc.keymap &&\n                    xenConfigSetString(conf, \"keymap\",\n                                       def->graphics[0]->data.vnc.keymap) < 0)\n                    return -1;\n            }\n        } else {\n            virConfValuePtr vfb, disp;\n            char *vfbstr = NULL;\n            virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n            if (def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL) {\n                virBufferAddLit(&buf, \"type=sdl\");\n                if (def->graphics[0]->data.sdl.display)\n                    virBufferAsprintf(&buf, \",display=%s\",\n                                      def->graphics[0]->data.sdl.display);\n                if (def->graphics[0]->data.sdl.xauth)\n                    virBufferAsprintf(&buf, \",xauthority=%s\",\n                                      def->graphics[0]->data.sdl.xauth);\n            } else {\n                virDomainGraphicsListenDefPtr glisten\n                    = virDomainGraphicsGetListen(def->graphics[0], 0);\n\n                virBufferAddLit(&buf, \"type=vnc\");\n                virBufferAsprintf(&buf, \",vncunused=%d\",\n                                  def->graphics[0]->data.vnc.autoport ? 1 : 0);\n                if (!def->graphics[0]->data.vnc.autoport)\n                    virBufferAsprintf(&buf, \",vncdisplay=%d\",\n                                      def->graphics[0]->data.vnc.port - 5900);\n                if (glisten && glisten->address)\n                    virBufferAsprintf(&buf, \",vnclisten=%s\", glisten->address);\n                if (def->graphics[0]->data.vnc.auth.passwd)\n                    virBufferAsprintf(&buf, \",vncpasswd=%s\",\n                                      def->graphics[0]->data.vnc.auth.passwd);\n                if (def->graphics[0]->data.vnc.keymap)\n                    virBufferAsprintf(&buf, \",keymap=%s\",\n                                      def->graphics[0]->data.vnc.keymap);\n            }\n\n            vfbstr = virBufferContentAndReset(&buf);\n\n            if (VIR_ALLOC(vfb) < 0) {\n                VIR_FREE(vfbstr);\n                return -1;\n            }\n\n            if (VIR_ALLOC(disp) < 0) {\n                VIR_FREE(vfb);\n                VIR_FREE(vfbstr);\n                return -1;\n            }\n\n            vfb->type = VIR_CONF_LIST;\n            vfb->list = disp;\n            disp->type = VIR_CONF_STRING;\n            disp->str = vfbstr;\n\n            if (virConfSetValue(conf, \"vfb\", vfb) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatVfb(virConfPtr conf, virDomainDefPtr def)\n{\n    int hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM ? 1 : 0;\n\n    if (def->ngraphics == 1 &&\n        def->graphics[0]->type != VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n        if (hvm) {\n            if (def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL) {\n                if (xenConfigSetInt(conf, \"sdl\", 1) < 0)\n                    return -1;\n\n                if (xenConfigSetInt(conf, \"vnc\", 0) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.sdl.display &&\n                    xenConfigSetString(conf, \"display\",\n                                       def->graphics[0]->data.sdl.display) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.sdl.xauth &&\n                    xenConfigSetString(conf, \"xauthority\",\n                                       def->graphics[0]->data.sdl.xauth) < 0)\n                    return -1;\n            } else {\n                virDomainGraphicsListenDefPtr glisten;\n\n                if (xenConfigSetInt(conf, \"sdl\", 0) < 0)\n                    return -1;\n\n                if (xenConfigSetInt(conf, \"vnc\", 1) < 0)\n                    return -1;\n\n                if (xenConfigSetInt(conf, \"vncunused\",\n                              def->graphics[0]->data.vnc.autoport ? 1 : 0) < 0)\n                    return -1;\n\n                if (!def->graphics[0]->data.vnc.autoport &&\n                    xenConfigSetInt(conf, \"vncdisplay\",\n                                    def->graphics[0]->data.vnc.port - 5900) < 0)\n                    return -1;\n\n                if ((glisten = virDomainGraphicsGetListen(def->graphics[0], 0)) &&\n                    glisten->address &&\n                    xenConfigSetString(conf, \"vnclisten\", glisten->address) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.vnc.auth.passwd &&\n                    xenConfigSetString(conf, \"vncpasswd\",\n                                       def->graphics[0]->data.vnc.auth.passwd) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.vnc.keymap &&\n                    xenConfigSetString(conf, \"keymap\",\n                                       def->graphics[0]->data.vnc.keymap) < 0)\n                    return -1;\n            }\n        } else {\n            virConfValuePtr vfb, disp;\n            char *vfbstr = NULL;\n            virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n            if (def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL) {\n                virBufferAddLit(&buf, \"type=sdl\");\n                if (def->graphics[0]->data.sdl.display)\n                    virBufferAsprintf(&buf, \",display=%s\",\n                                      def->graphics[0]->data.sdl.display);\n                if (def->graphics[0]->data.sdl.xauth)\n                    virBufferAsprintf(&buf, \",xauthority=%s\",\n                                      def->graphics[0]->data.sdl.xauth);\n            } else {\n                virDomainGraphicsListenDefPtr glisten\n                    = virDomainGraphicsGetListen(def->graphics[0], 0);\n\n                virBufferAddLit(&buf, \"type=vnc\");\n                virBufferAsprintf(&buf, \",vncunused=%d\",\n                                  def->graphics[0]->data.vnc.autoport ? 1 : 0);\n                if (!def->graphics[0]->data.vnc.autoport)\n                    virBufferAsprintf(&buf, \",vncdisplay=%d\",\n                                      def->graphics[0]->data.vnc.port - 5900);\n                if (glisten && glisten->address)\n                    virBufferAsprintf(&buf, \",vnclisten=%s\", glisten->address);\n                if (def->graphics[0]->data.vnc.auth.passwd)\n                    virBufferAsprintf(&buf, \",vncpasswd=%s\",\n                                      def->graphics[0]->data.vnc.auth.passwd);\n                if (def->graphics[0]->data.vnc.keymap)\n                    virBufferAsprintf(&buf, \",keymap=%s\",\n                                      def->graphics[0]->data.vnc.keymap);\n            }\n\n            vfbstr = virBufferContentAndReset(&buf);\n\n            if (VIR_ALLOC(vfb) < 0) {\n                VIR_FREE(vfbstr);\n                return -1;\n            }\n\n            if (VIR_ALLOC(disp) < 0) {\n                VIR_FREE(vfb);\n                VIR_FREE(vfbstr);\n                return -1;\n            }\n\n            vfb->type = VIR_CONF_LIST;\n            vfb->list = disp;\n            disp->type = VIR_CONF_STRING;\n            disp->str = vfbstr;\n\n            if (virConfSetValue(conf, \"vfb\", vfb) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatEmulator",
          "args": [
            "conf",
            "def"
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatEmulator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "2200-2208",
          "snippet": "static int\nxenFormatEmulator(virConfPtr conf, virDomainDefPtr def)\n{\n    if (def->emulator &&\n        xenConfigSetString(conf, \"device_model\", def->emulator) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatEmulator(virConfPtr conf, virDomainDefPtr def)\n{\n    if (def->emulator &&\n        xenConfigSetString(conf, \"device_model\", def->emulator) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatEventActions",
          "args": [
            "conf",
            "def"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatEventActions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1953-1985",
          "snippet": "static int\nxenFormatEventActions(virConfPtr conf, virDomainDefPtr def)\n{\n    const char *lifecycle = NULL;\n\n    if (!(lifecycle = virDomainLifecycleActionTypeToString(def->onPoweroff))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected lifecycle action %d\"), def->onPoweroff);\n        return -1;\n    }\n    if (xenConfigSetString(conf, \"on_poweroff\", lifecycle) < 0)\n        return -1;\n\n\n    if (!(lifecycle = virDomainLifecycleActionTypeToString(def->onReboot))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected lifecycle action %d\"), def->onReboot);\n        return -1;\n    }\n    if (xenConfigSetString(conf, \"on_reboot\", lifecycle) < 0)\n        return -1;\n\n\n    if (!(lifecycle = virDomainLifecycleActionTypeToString(def->onCrash))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected lifecycle action %d\"), def->onCrash);\n        return -1;\n    }\n    if (xenConfigSetString(conf, \"on_crash\", lifecycle) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatEventActions(virConfPtr conf, virDomainDefPtr def)\n{\n    const char *lifecycle = NULL;\n\n    if (!(lifecycle = virDomainLifecycleActionTypeToString(def->onPoweroff))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected lifecycle action %d\"), def->onPoweroff);\n        return -1;\n    }\n    if (xenConfigSetString(conf, \"on_poweroff\", lifecycle) < 0)\n        return -1;\n\n\n    if (!(lifecycle = virDomainLifecycleActionTypeToString(def->onReboot))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected lifecycle action %d\"), def->onReboot);\n        return -1;\n    }\n    if (xenConfigSetString(conf, \"on_reboot\", lifecycle) < 0)\n        return -1;\n\n\n    if (!(lifecycle = virDomainLifecycleActionTypeToString(def->onCrash))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected lifecycle action %d\"), def->onCrash);\n        return -1;\n    }\n    if (xenConfigSetString(conf, \"on_crash\", lifecycle) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatTimeOffset",
          "args": [
            "conf",
            "def"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatTimeOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1889-1950",
          "snippet": "static int\nxenFormatTimeOffset(virConfPtr conf, virDomainDefPtr def)\n{\n    int vmlocaltime;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        /* >=3.1 HV: VARIABLE */\n        int rtc_timeoffset;\n\n        switch (def->clock.offset) {\n        case VIR_DOMAIN_CLOCK_OFFSET_VARIABLE:\n            vmlocaltime = (int)def->clock.data.variable.basis;\n            rtc_timeoffset = def->clock.data.variable.adjustment;\n            break;\n        case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n            if (def->clock.data.utc_reset) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"unsupported clock adjustment='reset'\"));\n                return -1;\n            }\n            vmlocaltime = 0;\n            rtc_timeoffset = 0;\n            break;\n        case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n            if (def->clock.data.utc_reset) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"unsupported clock adjustment='reset'\"));\n                return -1;\n            }\n            vmlocaltime = 1;\n            rtc_timeoffset = 0;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported clock offset='%s'\"),\n                           virDomainClockOffsetTypeToString(def->clock.offset));\n            return -1;\n        }\n        if (xenConfigSetInt(conf, \"rtc_timeoffset\", rtc_timeoffset) < 0)\n            return -1;\n    } else {\n        /* PV: UTC and LOCALTIME */\n        switch (def->clock.offset) {\n        case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n            vmlocaltime = 0;\n            break;\n        case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n            vmlocaltime = 1;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported clock offset='%s'\"),\n                           virDomainClockOffsetTypeToString(def->clock.offset));\n            return -1;\n        }\n    } /* !hvm */\n\n    if (xenConfigSetInt(conf, \"localtime\", vmlocaltime) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatTimeOffset(virConfPtr conf, virDomainDefPtr def)\n{\n    int vmlocaltime;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        /* >=3.1 HV: VARIABLE */\n        int rtc_timeoffset;\n\n        switch (def->clock.offset) {\n        case VIR_DOMAIN_CLOCK_OFFSET_VARIABLE:\n            vmlocaltime = (int)def->clock.data.variable.basis;\n            rtc_timeoffset = def->clock.data.variable.adjustment;\n            break;\n        case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n            if (def->clock.data.utc_reset) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"unsupported clock adjustment='reset'\"));\n                return -1;\n            }\n            vmlocaltime = 0;\n            rtc_timeoffset = 0;\n            break;\n        case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n            if (def->clock.data.utc_reset) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"unsupported clock adjustment='reset'\"));\n                return -1;\n            }\n            vmlocaltime = 1;\n            rtc_timeoffset = 0;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported clock offset='%s'\"),\n                           virDomainClockOffsetTypeToString(def->clock.offset));\n            return -1;\n        }\n        if (xenConfigSetInt(conf, \"rtc_timeoffset\", rtc_timeoffset) < 0)\n            return -1;\n    } else {\n        /* PV: UTC and LOCALTIME */\n        switch (def->clock.offset) {\n        case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n            vmlocaltime = 0;\n            break;\n        case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n            vmlocaltime = 1;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported clock offset='%s'\"),\n                           virDomainClockOffsetTypeToString(def->clock.offset));\n            return -1;\n        }\n    } /* !hvm */\n\n    if (xenConfigSetInt(conf, \"localtime\", vmlocaltime) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatCPUFeatures",
          "args": [
            "conf",
            "def"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatCPUFeatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "2110-2197",
          "snippet": "static int\nxenFormatCPUFeatures(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n    bool hvm = !!(def->os.type == VIR_DOMAIN_OSTYPE_HVM);\n\n    if (hvm) {\n        if (xenConfigSetInt(conf, \"pae\",\n                            (def->features[VIR_DOMAIN_FEATURE_PAE] ==\n                            VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n\n        if (xenConfigSetInt(conf, \"acpi\",\n                            (def->features[VIR_DOMAIN_FEATURE_ACPI] ==\n                            VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n\n        if (xenConfigSetInt(conf, \"apic\",\n                            (def->features[VIR_DOMAIN_FEATURE_APIC] ==\n                            VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n\n        if (def->features[VIR_DOMAIN_FEATURE_HAP] == VIR_TRISTATE_SWITCH_OFF) {\n            if (xenConfigSetInt(conf, \"hap\", 0) < 0)\n                return -1;\n        }\n\n        if (xenConfigSetInt(conf, \"viridian\",\n                            (def->features[VIR_DOMAIN_FEATURE_VIRIDIAN] ==\n                             VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->clock.ntimers; i++) {\n        switch ((virDomainTimerNameType)def->clock.timers[i]->name) {\n        case VIR_DOMAIN_TIMER_NAME_TSC:\n            switch (def->clock.timers[i]->mode) {\n            case VIR_DOMAIN_TIMER_MODE_NATIVE:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"native\") < 0)\n                    return -1;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_PARAVIRT:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"native_paravirt\") < 0)\n                    return -1;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_EMULATE:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"always_emulate\") < 0)\n                    return -1;\n                break;\n            default:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"default\") < 0)\n                    return -1;\n            }\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_HPET:\n            if (hvm) {\n                int enable_hpet = def->clock.timers[i]->present != 0;\n\n                /* disable hpet if 'present' is 0, enable otherwise */\n                if (xenConfigSetInt(conf, \"hpet\", enable_hpet) < 0)\n                    return -1;\n            } else {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unsupported timer type (name) '%s'\"),\n                               virDomainTimerNameTypeToString(def->clock.timers[i]->name));\n                return -1;\n            }\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_PLATFORM:\n        case VIR_DOMAIN_TIMER_NAME_KVMCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_HYPERVCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_RTC:\n        case VIR_DOMAIN_TIMER_NAME_PIT:\n        case VIR_DOMAIN_TIMER_NAME_ARMVTIMER:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported timer type (name) '%s'\"),\n                           virDomainTimerNameTypeToString(def->clock.timers[i]->name));\n            return -1;\n\n        case VIR_DOMAIN_TIMER_NAME_LAST:\n            break;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatCPUFeatures(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n    bool hvm = !!(def->os.type == VIR_DOMAIN_OSTYPE_HVM);\n\n    if (hvm) {\n        if (xenConfigSetInt(conf, \"pae\",\n                            (def->features[VIR_DOMAIN_FEATURE_PAE] ==\n                            VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n\n        if (xenConfigSetInt(conf, \"acpi\",\n                            (def->features[VIR_DOMAIN_FEATURE_ACPI] ==\n                            VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n\n        if (xenConfigSetInt(conf, \"apic\",\n                            (def->features[VIR_DOMAIN_FEATURE_APIC] ==\n                            VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n\n        if (def->features[VIR_DOMAIN_FEATURE_HAP] == VIR_TRISTATE_SWITCH_OFF) {\n            if (xenConfigSetInt(conf, \"hap\", 0) < 0)\n                return -1;\n        }\n\n        if (xenConfigSetInt(conf, \"viridian\",\n                            (def->features[VIR_DOMAIN_FEATURE_VIRIDIAN] ==\n                             VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->clock.ntimers; i++) {\n        switch ((virDomainTimerNameType)def->clock.timers[i]->name) {\n        case VIR_DOMAIN_TIMER_NAME_TSC:\n            switch (def->clock.timers[i]->mode) {\n            case VIR_DOMAIN_TIMER_MODE_NATIVE:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"native\") < 0)\n                    return -1;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_PARAVIRT:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"native_paravirt\") < 0)\n                    return -1;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_EMULATE:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"always_emulate\") < 0)\n                    return -1;\n                break;\n            default:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"default\") < 0)\n                    return -1;\n            }\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_HPET:\n            if (hvm) {\n                int enable_hpet = def->clock.timers[i]->present != 0;\n\n                /* disable hpet if 'present' is 0, enable otherwise */\n                if (xenConfigSetInt(conf, \"hpet\", enable_hpet) < 0)\n                    return -1;\n            } else {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unsupported timer type (name) '%s'\"),\n                               virDomainTimerNameTypeToString(def->clock.timers[i]->name));\n                return -1;\n            }\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_PLATFORM:\n        case VIR_DOMAIN_TIMER_NAME_KVMCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_HYPERVCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_RTC:\n        case VIR_DOMAIN_TIMER_NAME_PIT:\n        case VIR_DOMAIN_TIMER_NAME_ARMVTIMER:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported timer type (name) '%s'\"),\n                           virDomainTimerNameTypeToString(def->clock.timers[i]->name));\n            return -1;\n\n        case VIR_DOMAIN_TIMER_NAME_LAST:\n            break;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatCPUAllocation",
          "args": [
            "conf",
            "def"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatCPUAllocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "2081-2107",
          "snippet": "static int\nxenFormatCPUAllocation(virConfPtr conf, virDomainDefPtr def)\n{\n    int ret = -1;\n    char *cpus = NULL;\n\n    if (virDomainDefGetVcpus(def) < virDomainDefGetVcpusMax(def) &&\n        xenConfigSetInt(conf, \"maxvcpus\", virDomainDefGetVcpusMax(def)) < 0)\n        goto cleanup;\n    if (xenConfigSetInt(conf, \"vcpus\", virDomainDefGetVcpus(def)) < 0)\n        goto cleanup;\n\n    if ((def->cpumask != NULL) &&\n        ((cpus = virBitmapFormat(def->cpumask)) == NULL)) {\n        goto cleanup;\n    }\n\n    if (cpus &&\n        xenConfigSetString(conf, \"cpus\", cpus) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cpus);\n    return ret;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatCPUAllocation(virConfPtr conf, virDomainDefPtr def)\n{\n    int ret = -1;\n    char *cpus = NULL;\n\n    if (virDomainDefGetVcpus(def) < virDomainDefGetVcpusMax(def) &&\n        xenConfigSetInt(conf, \"maxvcpus\", virDomainDefGetVcpusMax(def)) < 0)\n        goto cleanup;\n    if (xenConfigSetInt(conf, \"vcpus\", virDomainDefGetVcpus(def)) < 0)\n        goto cleanup;\n\n    if ((def->cpumask != NULL) &&\n        ((cpus = virBitmapFormat(def->cpumask)) == NULL)) {\n        goto cleanup;\n    }\n\n    if (cpus &&\n        xenConfigSetString(conf, \"cpus\", cpus) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cpus);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatMem",
          "args": [
            "conf",
            "def"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatMem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1874-1886",
          "snippet": "static int\nxenFormatMem(virConfPtr conf, virDomainDefPtr def)\n{\n    if (xenConfigSetInt(conf, \"maxmem\",\n                        VIR_DIV_UP(virDomainDefGetMemoryTotal(def), 1024)) < 0)\n        return -1;\n\n    if (xenConfigSetInt(conf, \"memory\",\n                        VIR_DIV_UP(def->mem.cur_balloon, 1024)) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatMem(virConfPtr conf, virDomainDefPtr def)\n{\n    if (xenConfigSetInt(conf, \"maxmem\",\n                        VIR_DIV_UP(virDomainDefGetMemoryTotal(def), 1024)) < 0)\n        return -1;\n\n    if (xenConfigSetInt(conf, \"memory\",\n                        VIR_DIV_UP(def->mem.cur_balloon, 1024)) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatGeneralMeta",
          "args": [
            "conf",
            "def"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatGeneralMeta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1858-1871",
          "snippet": "static int\nxenFormatGeneralMeta(virConfPtr conf, virDomainDefPtr def)\n{\n    char uuid[VIR_UUID_STRING_BUFLEN];\n\n    if (xenConfigSetString(conf, \"name\", def->name) < 0)\n        return -1;\n\n    virUUIDFormat(def->uuid, uuid);\n    if (xenConfigSetString(conf, \"uuid\", uuid) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatGeneralMeta(virConfPtr conf, virDomainDefPtr def)\n{\n    char uuid[VIR_UUID_STRING_BUFLEN];\n\n    if (xenConfigSetString(conf, \"name\", def->name) < 0)\n        return -1;\n\n    virUUIDFormat(def->uuid, uuid);\n    if (xenConfigSetString(conf, \"uuid\", uuid) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenFormatConfigCommon(virConfPtr conf,\n                      virDomainDefPtr def,\n                      virConnectPtr conn,\n                      const char *nativeFormat)\n{\n    if (xenFormatGeneralMeta(conf, def) < 0)\n        return -1;\n\n    if (xenFormatMem(conf, def) < 0)\n        return -1;\n\n    if (xenFormatCPUAllocation(conf, def) < 0)\n        return -1;\n\n    if (xenFormatCPUFeatures(conf, def) < 0)\n        return -1;\n\n    if (xenFormatTimeOffset(conf, def) < 0)\n        return -1;\n\n    if (xenFormatEventActions(conf, def) < 0)\n        return -1;\n\n    if (xenFormatEmulator(conf, def) < 0)\n        return -1;\n\n    if (xenFormatVfb(conf, def) < 0)\n        return -1;\n\n    if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XL)) {\n        if (xenFormatVif(conf, conn, def, \"vif\") < 0)\n            return -1;\n    } else if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n        if (xenFormatVif(conf, conn, def, \"netfront\") < 0)\n            return -1;\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported config type %s\"), nativeFormat);\n        return -1;\n    }\n\n    if (xenFormatPCI(conf, def) < 0)\n        return -1;\n\n    if (xenFormatCharDev(conf, def, nativeFormat) < 0)\n        return -1;\n\n    if (xenFormatSound(conf, def) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "xenFormatVif",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "2358-2392",
    "snippet": "static int\nxenFormatVif(virConfPtr conf,\n             virConnectPtr conn,\n             virDomainDefPtr def,\n             const char *vif_typename)\n{\n    virConfValuePtr netVal = NULL;\n    size_t i;\n    int hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM;\n\n    if (VIR_ALLOC(netVal) < 0)\n        goto cleanup;\n    netVal->type = VIR_CONF_LIST;\n    netVal->list = NULL;\n\n    for (i = 0; i < def->nnets; i++) {\n        if (xenFormatNet(conn, netVal, def->nets[i],\n                         hvm, vif_typename) < 0)\n            goto cleanup;\n    }\n\n    if (netVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"vif\", netVal);\n        netVal = NULL;\n        if (ret < 0)\n            goto cleanup;\n    }\n\n    VIR_FREE(netVal);\n    return 0;\n\n cleanup:\n    virConfFreeValue(netVal);\n    return -1;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConfFreeValue",
          "args": [
            "netVal"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "virConfFreeValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "147-159",
          "snippet": "void\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "netVal"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfSetValue",
          "args": [
            "conf",
            "\"vif\"",
            "netVal"
          ],
          "line": 2380
        },
        "resolved": true,
        "details": {
          "function_name": "virConfSetValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1338-1378",
          "snippet": "int\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatNet",
          "args": [
            "conn",
            "netVal",
            "def->nets[i]",
            "hvm",
            "vif_typename"
          ],
          "line": 2374
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatNet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1649-1790",
          "snippet": "static int\nxenFormatNet(virConnectPtr conn,\n             virConfValuePtr list,\n             virDomainNetDefPtr net,\n             int hvm,\n             const char *vif_typename)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr val, tmp;\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n\n    virBufferAsprintf(&buf, \"mac=%s\", virMacAddrFormat(&net->mac, macaddr));\n\n    switch (net->type) {\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    {\n        const virNetDevVPortProfile *port_profile = virDomainNetGetActualVirtPortProfile(net);\n        const virNetDevVlan *virt_vlan = virDomainNetGetActualVlan(net);\n        const char *script = net->script;\n        size_t i;\n\n        virBufferAsprintf(&buf, \",bridge=%s\", net->data.bridge.brname);\n        if (port_profile &&\n            port_profile->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n            if (!script)\n                script = \"vif-openvswitch\";\n            /*\n             * libxl_device_nic->bridge supports an extended format for\n             * specifying VLAN tags and trunks\n             *\n             * BRIDGE_NAME[.VLAN][:TRUNK:TRUNK]\n             */\n            if (virt_vlan && virt_vlan->nTags > 0) {\n                if (virt_vlan->trunk) {\n                    for (i = 0; i < virt_vlan->nTags; i++)\n                        virBufferAsprintf(&buf, \":%d\", virt_vlan->tag[i]);\n                } else {\n                    virBufferAsprintf(&buf, \".%d\", virt_vlan->tag[0]);\n                }\n            }\n        }\n\n        if (net->guestIP.nips > 0) {\n            char *ipStr = xenMakeIPList(&net->guestIP);\n            virBufferAsprintf(&buf, \",ip=%s\", ipStr);\n            VIR_FREE(ipStr);\n        }\n        virBufferAsprintf(&buf, \",script=%s\", script ? script : DEFAULT_VIF_SCRIPT);\n    }\n    break;\n\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n        if (net->script)\n            virBufferAsprintf(&buf, \",script=%s\", net->script);\n        if (net->guestIP.nips > 0) {\n            char *ipStr = xenMakeIPList(&net->guestIP);\n            virBufferAsprintf(&buf, \",ip=%s\", ipStr);\n            VIR_FREE(ipStr);\n        }\n        break;\n\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n    {\n        virNetworkPtr network = virNetworkLookupByName(conn, net->data.network.name);\n        char *bridge;\n        if (!network) {\n            virReportError(VIR_ERR_NO_NETWORK, \"%s\",\n                           net->data.network.name);\n            return -1;\n        }\n        bridge = virNetworkGetBridgeName(network);\n        virObjectUnref(network);\n        if (!bridge) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network %s is not active\"),\n                           net->data.network.name);\n            return -1;\n        }\n\n        virBufferAsprintf(&buf, \",bridge=%s\", bridge);\n        virBufferAsprintf(&buf, \",script=%s\", DEFAULT_VIF_SCRIPT);\n    }\n    break;\n\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_USER:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, _(\"Unsupported net type '%s'\"),\n                       virDomainNetTypeToString(net->type));\n        goto cleanup;\n\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virDomainNetType, net->type);\n        goto cleanup;\n    }\n\n    if (virDomainNetGetModelString(net)) {\n        if (!hvm) {\n            virBufferAsprintf(&buf, \",model=%s\",\n                              virDomainNetGetModelString(net));\n        } else {\n            if (net->model == VIR_DOMAIN_NET_MODEL_NETFRONT)\n                virBufferAsprintf(&buf, \",type=%s\", vif_typename);\n            else\n                virBufferAsprintf(&buf, \",model=%s\",\n                                  virDomainNetGetModelString(net));\n        }\n    }\n\n    if (net->ifname)\n        virBufferAsprintf(&buf, \",vifname=%s\",\n                          net->ifname);\n\n    if (net->bandwidth && net->bandwidth->out && net->bandwidth->out->average)\n        virBufferAsprintf(&buf, \",rate=%lluKB/s\", net->bandwidth->out->average);\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n\n    return 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatNet(virConnectPtr conn,\n             virConfValuePtr list,\n             virDomainNetDefPtr net,\n             int hvm,\n             const char *vif_typename)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr val, tmp;\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n\n    virBufferAsprintf(&buf, \"mac=%s\", virMacAddrFormat(&net->mac, macaddr));\n\n    switch (net->type) {\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    {\n        const virNetDevVPortProfile *port_profile = virDomainNetGetActualVirtPortProfile(net);\n        const virNetDevVlan *virt_vlan = virDomainNetGetActualVlan(net);\n        const char *script = net->script;\n        size_t i;\n\n        virBufferAsprintf(&buf, \",bridge=%s\", net->data.bridge.brname);\n        if (port_profile &&\n            port_profile->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n            if (!script)\n                script = \"vif-openvswitch\";\n            /*\n             * libxl_device_nic->bridge supports an extended format for\n             * specifying VLAN tags and trunks\n             *\n             * BRIDGE_NAME[.VLAN][:TRUNK:TRUNK]\n             */\n            if (virt_vlan && virt_vlan->nTags > 0) {\n                if (virt_vlan->trunk) {\n                    for (i = 0; i < virt_vlan->nTags; i++)\n                        virBufferAsprintf(&buf, \":%d\", virt_vlan->tag[i]);\n                } else {\n                    virBufferAsprintf(&buf, \".%d\", virt_vlan->tag[0]);\n                }\n            }\n        }\n\n        if (net->guestIP.nips > 0) {\n            char *ipStr = xenMakeIPList(&net->guestIP);\n            virBufferAsprintf(&buf, \",ip=%s\", ipStr);\n            VIR_FREE(ipStr);\n        }\n        virBufferAsprintf(&buf, \",script=%s\", script ? script : DEFAULT_VIF_SCRIPT);\n    }\n    break;\n\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n        if (net->script)\n            virBufferAsprintf(&buf, \",script=%s\", net->script);\n        if (net->guestIP.nips > 0) {\n            char *ipStr = xenMakeIPList(&net->guestIP);\n            virBufferAsprintf(&buf, \",ip=%s\", ipStr);\n            VIR_FREE(ipStr);\n        }\n        break;\n\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n    {\n        virNetworkPtr network = virNetworkLookupByName(conn, net->data.network.name);\n        char *bridge;\n        if (!network) {\n            virReportError(VIR_ERR_NO_NETWORK, \"%s\",\n                           net->data.network.name);\n            return -1;\n        }\n        bridge = virNetworkGetBridgeName(network);\n        virObjectUnref(network);\n        if (!bridge) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network %s is not active\"),\n                           net->data.network.name);\n            return -1;\n        }\n\n        virBufferAsprintf(&buf, \",bridge=%s\", bridge);\n        virBufferAsprintf(&buf, \",script=%s\", DEFAULT_VIF_SCRIPT);\n    }\n    break;\n\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_USER:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, _(\"Unsupported net type '%s'\"),\n                       virDomainNetTypeToString(net->type));\n        goto cleanup;\n\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virDomainNetType, net->type);\n        goto cleanup;\n    }\n\n    if (virDomainNetGetModelString(net)) {\n        if (!hvm) {\n            virBufferAsprintf(&buf, \",model=%s\",\n                              virDomainNetGetModelString(net));\n        } else {\n            if (net->model == VIR_DOMAIN_NET_MODEL_NETFRONT)\n                virBufferAsprintf(&buf, \",type=%s\", vif_typename);\n            else\n                virBufferAsprintf(&buf, \",model=%s\",\n                                  virDomainNetGetModelString(net));\n        }\n    }\n\n    if (net->ifname)\n        virBufferAsprintf(&buf, \",vifname=%s\",\n                          net->ifname);\n\n    if (net->bandwidth && net->bandwidth->out && net->bandwidth->out->average)\n        virBufferAsprintf(&buf, \",rate=%lluKB/s\", net->bandwidth->out->average);\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n\n    return 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "netVal"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatVif(virConfPtr conf,\n             virConnectPtr conn,\n             virDomainDefPtr def,\n             const char *vif_typename)\n{\n    virConfValuePtr netVal = NULL;\n    size_t i;\n    int hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM;\n\n    if (VIR_ALLOC(netVal) < 0)\n        goto cleanup;\n    netVal->type = VIR_CONF_LIST;\n    netVal->list = NULL;\n\n    for (i = 0; i < def->nnets; i++) {\n        if (xenFormatNet(conn, netVal, def->nets[i],\n                         hvm, vif_typename) < 0)\n            goto cleanup;\n    }\n\n    if (netVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"vif\", netVal);\n        netVal = NULL;\n        if (ret < 0)\n            goto cleanup;\n    }\n\n    VIR_FREE(netVal);\n    return 0;\n\n cleanup:\n    virConfFreeValue(netVal);\n    return -1;\n}"
  },
  {
    "function_name": "xenFormatSound",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "2328-2355",
    "snippet": "static int\nxenFormatSound(virConfPtr conf, virDomainDefPtr def)\n{\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    const char * model;\n    g_autofree char *str = NULL;\n    size_t i;\n\n    if (def->os.type != VIR_DOMAIN_OSTYPE_HVM ||\n        !def->sounds)\n        return 0;\n\n    for (i = 0; i < def->nsounds; i++) {\n        if (!(model = virDomainSoundModelTypeToString(def->sounds[i]->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected sound model %d\"),\n                           def->sounds[i]->model);\n            return -1;\n        }\n        if (i)\n            virBufferAddChar(&buf, ',');\n        virBufferEscapeSexpr(&buf, \"%s\", model);\n    }\n\n    str = virBufferContentAndReset(&buf);\n\n    return xenConfigSetString(conf, \"soundhw\", str);\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenConfigSetString",
          "args": [
            "conf",
            "\"soundhw\"",
            "str"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "267-280",
          "snippet": "int\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeSexpr",
          "args": [
            "&buf",
            "\"%s\"",
            "model"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeSexpr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "431-437",
          "snippet": "void\nvirBufferEscapeSexpr(virBufferPtr buf,\n                     const char *format,\n                     const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"\\\\'\", format, str);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeSexpr(virBufferPtr buf,\n                     const char *format,\n                     const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"\\\\'\", format, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddChar",
          "args": [
            "&buf",
            "','"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "206-210",
          "snippet": "void\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected sound model %d\")",
            "def->sounds[i]->model"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected sound model %d\""
          ],
          "line": 2343
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSoundModelTypeToString",
          "args": [
            "def->sounds[i]->model"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatSound(virConfPtr conf, virDomainDefPtr def)\n{\n    g_auto(virBuffer) buf = VIR_BUFFER_INITIALIZER;\n    const char * model;\n    g_autofree char *str = NULL;\n    size_t i;\n\n    if (def->os.type != VIR_DOMAIN_OSTYPE_HVM ||\n        !def->sounds)\n        return 0;\n\n    for (i = 0; i < def->nsounds; i++) {\n        if (!(model = virDomainSoundModelTypeToString(def->sounds[i]->model))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected sound model %d\"),\n                           def->sounds[i]->model);\n            return -1;\n        }\n        if (i)\n            virBufferAddChar(&buf, ',');\n        virBufferEscapeSexpr(&buf, \"%s\", model);\n    }\n\n    str = virBufferContentAndReset(&buf);\n\n    return xenConfigSetString(conf, \"soundhw\", str);\n}"
  },
  {
    "function_name": "xenFormatVfb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "2211-2325",
    "snippet": "static int\nxenFormatVfb(virConfPtr conf, virDomainDefPtr def)\n{\n    int hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM ? 1 : 0;\n\n    if (def->ngraphics == 1 &&\n        def->graphics[0]->type != VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n        if (hvm) {\n            if (def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL) {\n                if (xenConfigSetInt(conf, \"sdl\", 1) < 0)\n                    return -1;\n\n                if (xenConfigSetInt(conf, \"vnc\", 0) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.sdl.display &&\n                    xenConfigSetString(conf, \"display\",\n                                       def->graphics[0]->data.sdl.display) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.sdl.xauth &&\n                    xenConfigSetString(conf, \"xauthority\",\n                                       def->graphics[0]->data.sdl.xauth) < 0)\n                    return -1;\n            } else {\n                virDomainGraphicsListenDefPtr glisten;\n\n                if (xenConfigSetInt(conf, \"sdl\", 0) < 0)\n                    return -1;\n\n                if (xenConfigSetInt(conf, \"vnc\", 1) < 0)\n                    return -1;\n\n                if (xenConfigSetInt(conf, \"vncunused\",\n                              def->graphics[0]->data.vnc.autoport ? 1 : 0) < 0)\n                    return -1;\n\n                if (!def->graphics[0]->data.vnc.autoport &&\n                    xenConfigSetInt(conf, \"vncdisplay\",\n                                    def->graphics[0]->data.vnc.port - 5900) < 0)\n                    return -1;\n\n                if ((glisten = virDomainGraphicsGetListen(def->graphics[0], 0)) &&\n                    glisten->address &&\n                    xenConfigSetString(conf, \"vnclisten\", glisten->address) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.vnc.auth.passwd &&\n                    xenConfigSetString(conf, \"vncpasswd\",\n                                       def->graphics[0]->data.vnc.auth.passwd) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.vnc.keymap &&\n                    xenConfigSetString(conf, \"keymap\",\n                                       def->graphics[0]->data.vnc.keymap) < 0)\n                    return -1;\n            }\n        } else {\n            virConfValuePtr vfb, disp;\n            char *vfbstr = NULL;\n            virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n            if (def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL) {\n                virBufferAddLit(&buf, \"type=sdl\");\n                if (def->graphics[0]->data.sdl.display)\n                    virBufferAsprintf(&buf, \",display=%s\",\n                                      def->graphics[0]->data.sdl.display);\n                if (def->graphics[0]->data.sdl.xauth)\n                    virBufferAsprintf(&buf, \",xauthority=%s\",\n                                      def->graphics[0]->data.sdl.xauth);\n            } else {\n                virDomainGraphicsListenDefPtr glisten\n                    = virDomainGraphicsGetListen(def->graphics[0], 0);\n\n                virBufferAddLit(&buf, \"type=vnc\");\n                virBufferAsprintf(&buf, \",vncunused=%d\",\n                                  def->graphics[0]->data.vnc.autoport ? 1 : 0);\n                if (!def->graphics[0]->data.vnc.autoport)\n                    virBufferAsprintf(&buf, \",vncdisplay=%d\",\n                                      def->graphics[0]->data.vnc.port - 5900);\n                if (glisten && glisten->address)\n                    virBufferAsprintf(&buf, \",vnclisten=%s\", glisten->address);\n                if (def->graphics[0]->data.vnc.auth.passwd)\n                    virBufferAsprintf(&buf, \",vncpasswd=%s\",\n                                      def->graphics[0]->data.vnc.auth.passwd);\n                if (def->graphics[0]->data.vnc.keymap)\n                    virBufferAsprintf(&buf, \",keymap=%s\",\n                                      def->graphics[0]->data.vnc.keymap);\n            }\n\n            vfbstr = virBufferContentAndReset(&buf);\n\n            if (VIR_ALLOC(vfb) < 0) {\n                VIR_FREE(vfbstr);\n                return -1;\n            }\n\n            if (VIR_ALLOC(disp) < 0) {\n                VIR_FREE(vfb);\n                VIR_FREE(vfbstr);\n                return -1;\n            }\n\n            vfb->type = VIR_CONF_LIST;\n            vfb->list = disp;\n            disp->type = VIR_CONF_STRING;\n            disp->str = vfbstr;\n\n            if (virConfSetValue(conf, \"vfb\", vfb) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConfSetValue",
          "args": [
            "conf",
            "\"vfb\"",
            "vfb"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "virConfSetValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1338-1378",
          "snippet": "int\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vfbstr"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vfb"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "disp"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vfbstr"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "vfb"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\",keymap=%s\"",
            "def->graphics[0]->data.vnc.keymap"
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"type=vnc\""
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsGetListen",
          "args": [
            "def->graphics[0]",
            "0"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsGetListen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30357-30364",
          "snippet": "virDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"type=sdl\""
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigSetString",
          "args": [
            "conf",
            "\"keymap\"",
            "def->graphics[0]->data.vnc.keymap"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "267-280",
          "snippet": "int\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigSetInt",
          "args": [
            "conf",
            "\"vncdisplay\"",
            "def->graphics[0]->data.vnc.port - 5900"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "246-264",
          "snippet": "int\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatVfb(virConfPtr conf, virDomainDefPtr def)\n{\n    int hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM ? 1 : 0;\n\n    if (def->ngraphics == 1 &&\n        def->graphics[0]->type != VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n        if (hvm) {\n            if (def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL) {\n                if (xenConfigSetInt(conf, \"sdl\", 1) < 0)\n                    return -1;\n\n                if (xenConfigSetInt(conf, \"vnc\", 0) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.sdl.display &&\n                    xenConfigSetString(conf, \"display\",\n                                       def->graphics[0]->data.sdl.display) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.sdl.xauth &&\n                    xenConfigSetString(conf, \"xauthority\",\n                                       def->graphics[0]->data.sdl.xauth) < 0)\n                    return -1;\n            } else {\n                virDomainGraphicsListenDefPtr glisten;\n\n                if (xenConfigSetInt(conf, \"sdl\", 0) < 0)\n                    return -1;\n\n                if (xenConfigSetInt(conf, \"vnc\", 1) < 0)\n                    return -1;\n\n                if (xenConfigSetInt(conf, \"vncunused\",\n                              def->graphics[0]->data.vnc.autoport ? 1 : 0) < 0)\n                    return -1;\n\n                if (!def->graphics[0]->data.vnc.autoport &&\n                    xenConfigSetInt(conf, \"vncdisplay\",\n                                    def->graphics[0]->data.vnc.port - 5900) < 0)\n                    return -1;\n\n                if ((glisten = virDomainGraphicsGetListen(def->graphics[0], 0)) &&\n                    glisten->address &&\n                    xenConfigSetString(conf, \"vnclisten\", glisten->address) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.vnc.auth.passwd &&\n                    xenConfigSetString(conf, \"vncpasswd\",\n                                       def->graphics[0]->data.vnc.auth.passwd) < 0)\n                    return -1;\n\n                if (def->graphics[0]->data.vnc.keymap &&\n                    xenConfigSetString(conf, \"keymap\",\n                                       def->graphics[0]->data.vnc.keymap) < 0)\n                    return -1;\n            }\n        } else {\n            virConfValuePtr vfb, disp;\n            char *vfbstr = NULL;\n            virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n            if (def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL) {\n                virBufferAddLit(&buf, \"type=sdl\");\n                if (def->graphics[0]->data.sdl.display)\n                    virBufferAsprintf(&buf, \",display=%s\",\n                                      def->graphics[0]->data.sdl.display);\n                if (def->graphics[0]->data.sdl.xauth)\n                    virBufferAsprintf(&buf, \",xauthority=%s\",\n                                      def->graphics[0]->data.sdl.xauth);\n            } else {\n                virDomainGraphicsListenDefPtr glisten\n                    = virDomainGraphicsGetListen(def->graphics[0], 0);\n\n                virBufferAddLit(&buf, \"type=vnc\");\n                virBufferAsprintf(&buf, \",vncunused=%d\",\n                                  def->graphics[0]->data.vnc.autoport ? 1 : 0);\n                if (!def->graphics[0]->data.vnc.autoport)\n                    virBufferAsprintf(&buf, \",vncdisplay=%d\",\n                                      def->graphics[0]->data.vnc.port - 5900);\n                if (glisten && glisten->address)\n                    virBufferAsprintf(&buf, \",vnclisten=%s\", glisten->address);\n                if (def->graphics[0]->data.vnc.auth.passwd)\n                    virBufferAsprintf(&buf, \",vncpasswd=%s\",\n                                      def->graphics[0]->data.vnc.auth.passwd);\n                if (def->graphics[0]->data.vnc.keymap)\n                    virBufferAsprintf(&buf, \",keymap=%s\",\n                                      def->graphics[0]->data.vnc.keymap);\n            }\n\n            vfbstr = virBufferContentAndReset(&buf);\n\n            if (VIR_ALLOC(vfb) < 0) {\n                VIR_FREE(vfbstr);\n                return -1;\n            }\n\n            if (VIR_ALLOC(disp) < 0) {\n                VIR_FREE(vfb);\n                VIR_FREE(vfbstr);\n                return -1;\n            }\n\n            vfb->type = VIR_CONF_LIST;\n            vfb->list = disp;\n            disp->type = VIR_CONF_STRING;\n            disp->str = vfbstr;\n\n            if (virConfSetValue(conf, \"vfb\", vfb) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenFormatEmulator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "2200-2208",
    "snippet": "static int\nxenFormatEmulator(virConfPtr conf, virDomainDefPtr def)\n{\n    if (def->emulator &&\n        xenConfigSetString(conf, \"device_model\", def->emulator) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenConfigSetString",
          "args": [
            "conf",
            "\"device_model\"",
            "def->emulator"
          ],
          "line": 2204
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "267-280",
          "snippet": "int\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatEmulator(virConfPtr conf, virDomainDefPtr def)\n{\n    if (def->emulator &&\n        xenConfigSetString(conf, \"device_model\", def->emulator) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "xenFormatCPUFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "2110-2197",
    "snippet": "static int\nxenFormatCPUFeatures(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n    bool hvm = !!(def->os.type == VIR_DOMAIN_OSTYPE_HVM);\n\n    if (hvm) {\n        if (xenConfigSetInt(conf, \"pae\",\n                            (def->features[VIR_DOMAIN_FEATURE_PAE] ==\n                            VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n\n        if (xenConfigSetInt(conf, \"acpi\",\n                            (def->features[VIR_DOMAIN_FEATURE_ACPI] ==\n                            VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n\n        if (xenConfigSetInt(conf, \"apic\",\n                            (def->features[VIR_DOMAIN_FEATURE_APIC] ==\n                            VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n\n        if (def->features[VIR_DOMAIN_FEATURE_HAP] == VIR_TRISTATE_SWITCH_OFF) {\n            if (xenConfigSetInt(conf, \"hap\", 0) < 0)\n                return -1;\n        }\n\n        if (xenConfigSetInt(conf, \"viridian\",\n                            (def->features[VIR_DOMAIN_FEATURE_VIRIDIAN] ==\n                             VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->clock.ntimers; i++) {\n        switch ((virDomainTimerNameType)def->clock.timers[i]->name) {\n        case VIR_DOMAIN_TIMER_NAME_TSC:\n            switch (def->clock.timers[i]->mode) {\n            case VIR_DOMAIN_TIMER_MODE_NATIVE:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"native\") < 0)\n                    return -1;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_PARAVIRT:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"native_paravirt\") < 0)\n                    return -1;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_EMULATE:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"always_emulate\") < 0)\n                    return -1;\n                break;\n            default:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"default\") < 0)\n                    return -1;\n            }\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_HPET:\n            if (hvm) {\n                int enable_hpet = def->clock.timers[i]->present != 0;\n\n                /* disable hpet if 'present' is 0, enable otherwise */\n                if (xenConfigSetInt(conf, \"hpet\", enable_hpet) < 0)\n                    return -1;\n            } else {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unsupported timer type (name) '%s'\"),\n                               virDomainTimerNameTypeToString(def->clock.timers[i]->name));\n                return -1;\n            }\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_PLATFORM:\n        case VIR_DOMAIN_TIMER_NAME_KVMCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_HYPERVCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_RTC:\n        case VIR_DOMAIN_TIMER_NAME_PIT:\n        case VIR_DOMAIN_TIMER_NAME_ARMVTIMER:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported timer type (name) '%s'\"),\n                           virDomainTimerNameTypeToString(def->clock.timers[i]->name));\n            return -1;\n\n        case VIR_DOMAIN_TIMER_NAME_LAST:\n            break;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported timer type (name) '%s'\")",
            "virDomainTimerNameTypeToString(def->clock.timers[i]->name)"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainTimerNameTypeToString",
          "args": [
            "def->clock.timers[i]->name"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported timer type (name) '%s'\""
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported timer type (name) '%s'\")",
            "virDomainTimerNameTypeToString(def->clock.timers[i]->name)"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainTimerNameTypeToString",
          "args": [
            "def->clock.timers[i]->name"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigSetInt",
          "args": [
            "conf",
            "\"hpet\"",
            "enable_hpet"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "246-264",
          "snippet": "int\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigSetString",
          "args": [
            "conf",
            "\"tsc_mode\"",
            "\"default\""
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "267-280",
          "snippet": "int\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatCPUFeatures(virConfPtr conf, virDomainDefPtr def)\n{\n    size_t i;\n    bool hvm = !!(def->os.type == VIR_DOMAIN_OSTYPE_HVM);\n\n    if (hvm) {\n        if (xenConfigSetInt(conf, \"pae\",\n                            (def->features[VIR_DOMAIN_FEATURE_PAE] ==\n                            VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n\n        if (xenConfigSetInt(conf, \"acpi\",\n                            (def->features[VIR_DOMAIN_FEATURE_ACPI] ==\n                            VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n\n        if (xenConfigSetInt(conf, \"apic\",\n                            (def->features[VIR_DOMAIN_FEATURE_APIC] ==\n                            VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n\n        if (def->features[VIR_DOMAIN_FEATURE_HAP] == VIR_TRISTATE_SWITCH_OFF) {\n            if (xenConfigSetInt(conf, \"hap\", 0) < 0)\n                return -1;\n        }\n\n        if (xenConfigSetInt(conf, \"viridian\",\n                            (def->features[VIR_DOMAIN_FEATURE_VIRIDIAN] ==\n                             VIR_TRISTATE_SWITCH_ON) ? 1 : 0) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->clock.ntimers; i++) {\n        switch ((virDomainTimerNameType)def->clock.timers[i]->name) {\n        case VIR_DOMAIN_TIMER_NAME_TSC:\n            switch (def->clock.timers[i]->mode) {\n            case VIR_DOMAIN_TIMER_MODE_NATIVE:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"native\") < 0)\n                    return -1;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_PARAVIRT:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"native_paravirt\") < 0)\n                    return -1;\n                break;\n            case VIR_DOMAIN_TIMER_MODE_EMULATE:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"always_emulate\") < 0)\n                    return -1;\n                break;\n            default:\n                if (xenConfigSetString(conf, \"tsc_mode\", \"default\") < 0)\n                    return -1;\n            }\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_HPET:\n            if (hvm) {\n                int enable_hpet = def->clock.timers[i]->present != 0;\n\n                /* disable hpet if 'present' is 0, enable otherwise */\n                if (xenConfigSetInt(conf, \"hpet\", enable_hpet) < 0)\n                    return -1;\n            } else {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"unsupported timer type (name) '%s'\"),\n                               virDomainTimerNameTypeToString(def->clock.timers[i]->name));\n                return -1;\n            }\n            break;\n\n        case VIR_DOMAIN_TIMER_NAME_PLATFORM:\n        case VIR_DOMAIN_TIMER_NAME_KVMCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_HYPERVCLOCK:\n        case VIR_DOMAIN_TIMER_NAME_RTC:\n        case VIR_DOMAIN_TIMER_NAME_PIT:\n        case VIR_DOMAIN_TIMER_NAME_ARMVTIMER:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported timer type (name) '%s'\"),\n                           virDomainTimerNameTypeToString(def->clock.timers[i]->name));\n            return -1;\n\n        case VIR_DOMAIN_TIMER_NAME_LAST:\n            break;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenFormatCPUAllocation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "2081-2107",
    "snippet": "static int\nxenFormatCPUAllocation(virConfPtr conf, virDomainDefPtr def)\n{\n    int ret = -1;\n    char *cpus = NULL;\n\n    if (virDomainDefGetVcpus(def) < virDomainDefGetVcpusMax(def) &&\n        xenConfigSetInt(conf, \"maxvcpus\", virDomainDefGetVcpusMax(def)) < 0)\n        goto cleanup;\n    if (xenConfigSetInt(conf, \"vcpus\", virDomainDefGetVcpus(def)) < 0)\n        goto cleanup;\n\n    if ((def->cpumask != NULL) &&\n        ((cpus = virBitmapFormat(def->cpumask)) == NULL)) {\n        goto cleanup;\n    }\n\n    if (cpus &&\n        xenConfigSetString(conf, \"cpus\", cpus) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cpus);\n    return ret;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpus"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigSetString",
          "args": [
            "conf",
            "\"cpus\"",
            "cpus"
          ],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "267-280",
          "snippet": "int\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapFormat",
          "args": [
            "def->cpumask"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "404-442",
          "snippet": "char *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigSetInt",
          "args": [
            "conf",
            "\"vcpus\"",
            "virDomainDefGetVcpus(def)"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "246-264",
          "snippet": "int\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetVcpus",
          "args": [
            "def"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1912-1924",
          "snippet": "unsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int\nvirDomainDefGetVcpus(const virDomainDef *def)\n{\n    size_t i;\n    unsigned int ret = 0;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (def->vcpus[i]->online)\n            ret++;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetVcpusMax",
          "args": [
            "def"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetVcpusMax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1882-1886",
          "snippet": "unsigned int\nvirDomainDefGetVcpusMax(const virDomainDef *def)\n{\n    return def->maxvcpus;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int\nvirDomainDefGetVcpusMax(const virDomainDef *def)\n{\n    return def->maxvcpus;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatCPUAllocation(virConfPtr conf, virDomainDefPtr def)\n{\n    int ret = -1;\n    char *cpus = NULL;\n\n    if (virDomainDefGetVcpus(def) < virDomainDefGetVcpusMax(def) &&\n        xenConfigSetInt(conf, \"maxvcpus\", virDomainDefGetVcpusMax(def)) < 0)\n        goto cleanup;\n    if (xenConfigSetInt(conf, \"vcpus\", virDomainDefGetVcpus(def)) < 0)\n        goto cleanup;\n\n    if ((def->cpumask != NULL) &&\n        ((cpus = virBitmapFormat(def->cpumask)) == NULL)) {\n        goto cleanup;\n    }\n\n    if (cpus &&\n        xenConfigSetString(conf, \"cpus\", cpus) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(cpus);\n    return ret;\n}"
  },
  {
    "function_name": "xenFormatCharDev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1988-2078",
    "snippet": "static int\nxenFormatCharDev(virConfPtr conf, virDomainDefPtr def,\n                 const char *nativeFormat)\n{\n    size_t i;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (def->nparallels) {\n            virBuffer buf = VIR_BUFFER_INITIALIZER;\n            char *str;\n            int ret;\n\n            ret = xenFormatSxprChr(def->parallels[0], &buf);\n            str = virBufferContentAndReset(&buf);\n            if (ret == 0)\n                ret = xenConfigSetString(conf, \"parallel\", str);\n            VIR_FREE(str);\n            if (ret < 0)\n                return -1;\n        } else {\n            if (xenConfigSetString(conf, \"parallel\", \"none\") < 0)\n                return -1;\n        }\n\n        if (def->nserials) {\n            if ((def->nserials == 1) && (def->serials[0]->target.port == 0)) {\n                virBuffer buf = VIR_BUFFER_INITIALIZER;\n                char *str;\n                int ret;\n\n                ret = xenFormatSxprChr(def->serials[0], &buf);\n                str = virBufferContentAndReset(&buf);\n                if (ret == 0)\n                    ret = xenConfigSetString(conf, \"serial\", str);\n                VIR_FREE(str);\n                if (ret < 0)\n                    return -1;\n            } else {\n                size_t j = 0;\n                int maxport = -1, port;\n                virConfValuePtr serialVal = NULL;\n\n                if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Multiple serial devices are not supported by xen-xm\"));\n                    return -1;\n                }\n\n                if (VIR_ALLOC(serialVal) < 0)\n                    return -1;\n\n                serialVal->type = VIR_CONF_LIST;\n                serialVal->list = NULL;\n\n                for (i = 0; i < def->nserials; i++)\n                    if (def->serials[i]->target.port > maxport)\n                        maxport = def->serials[i]->target.port;\n\n                for (port = 0; port <= maxport; port++) {\n                    virDomainChrDefPtr chr = NULL;\n\n                    for (j = 0; j < def->nserials; j++) {\n                        if (def->serials[j]->target.port == port) {\n                            chr = def->serials[j];\n                            break;\n                        }\n                    }\n\n                    if (xenFormatSerial(serialVal, chr) < 0) {\n                        VIR_FREE(serialVal);\n                        return -1;\n                    }\n                }\n\n                if (serialVal->list != NULL) {\n                    int ret = virConfSetValue(conf, \"serial\", serialVal);\n\n                    serialVal = NULL;\n                    if (ret < 0)\n                        return -1;\n                }\n                VIR_FREE(serialVal);\n            }\n        } else {\n            if (xenConfigSetString(conf, \"serial\", \"none\") < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenConfigSetString",
          "args": [
            "conf",
            "\"serial\"",
            "\"none\""
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "267-280",
          "snippet": "int\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "serialVal"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfSetValue",
          "args": [
            "conf",
            "\"serial\"",
            "serialVal"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "virConfSetValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1338-1378",
          "snippet": "int\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "serialVal"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenFormatSerial",
          "args": [
            "serialVal",
            "chr"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatSerial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1592-1625",
          "snippet": "static int\nxenFormatSerial(virConfValuePtr list, virDomainChrDefPtr serial)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr val, tmp;\n    int ret;\n\n    if (serial) {\n        ret = xenFormatSxprChr(serial, &buf);\n        if (ret < 0)\n            goto cleanup;\n    } else {\n        virBufferAddLit(&buf, \"none\");\n    }\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n\n    return 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatSerial(virConfValuePtr list, virDomainChrDefPtr serial)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr val, tmp;\n    int ret;\n\n    if (serial) {\n        ret = xenFormatSxprChr(serial, &buf);\n        if (ret < 0)\n            goto cleanup;\n    } else {\n        virBufferAddLit(&buf, \"none\");\n    }\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n\n    return 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "serialVal"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Multiple serial devices are not supported by xen-xm\")"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Multiple serial devices are not supported by xen-xm\""
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "nativeFormat",
            "XEN_CONFIG_FORMAT_XM"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenFormatSxprChr",
          "args": [
            "def->serials[0]",
            "&buf"
          ],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatSxprChr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1526-1589",
          "snippet": "static int\nxenFormatSxprChr(virDomainChrDefPtr def,\n                 virBufferPtr buf)\n{\n    const char *type = virDomainChrTypeToString(def->source->type);\n\n    if (!type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unexpected chr device type\"));\n        return -1;\n    }\n\n    switch (def->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        virBufferAdd(buf, type, -1);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        virBufferAsprintf(buf, \"%s:\", type);\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n        virBufferAsprintf(buf, \"%s:%s:%s%s\",\n                          (def->source->data.tcp.protocol\n                           == VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW ?\n                           \"tcp\" : \"telnet\"),\n                          NULLSTR_EMPTY(def->source->data.tcp.host),\n                          NULLSTR_EMPTY(def->source->data.tcp.service),\n                          (def->source->data.tcp.listen ?\n                           \",server,nowait\" : \"\"));\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n        virBufferAsprintf(buf, \"%s:%s:%s@%s:%s\", type,\n                          NULLSTR_EMPTY(def->source->data.udp.connectHost),\n                          NULLSTR_EMPTY(def->source->data.udp.connectService),\n                          NULLSTR_EMPTY(def->source->data.udp.bindHost),\n                          NULLSTR_EMPTY(def->source->data.udp.bindService));\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        virBufferAsprintf(buf, \"%s:\", type);\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.nix.path);\n        if (def->source->data.nix.listen)\n            virBufferAddLit(buf, \",server,nowait\");\n        break;\n\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unsupported chr device type '%s'\"), type);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatSxprChr(virDomainChrDefPtr def,\n                 virBufferPtr buf)\n{\n    const char *type = virDomainChrTypeToString(def->source->type);\n\n    if (!type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unexpected chr device type\"));\n        return -1;\n    }\n\n    switch (def->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        virBufferAdd(buf, type, -1);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        virBufferAsprintf(buf, \"%s:\", type);\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n        virBufferAsprintf(buf, \"%s:%s:%s%s\",\n                          (def->source->data.tcp.protocol\n                           == VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW ?\n                           \"tcp\" : \"telnet\"),\n                          NULLSTR_EMPTY(def->source->data.tcp.host),\n                          NULLSTR_EMPTY(def->source->data.tcp.service),\n                          (def->source->data.tcp.listen ?\n                           \",server,nowait\" : \"\"));\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n        virBufferAsprintf(buf, \"%s:%s:%s@%s:%s\", type,\n                          NULLSTR_EMPTY(def->source->data.udp.connectHost),\n                          NULLSTR_EMPTY(def->source->data.udp.connectService),\n                          NULLSTR_EMPTY(def->source->data.udp.bindHost),\n                          NULLSTR_EMPTY(def->source->data.udp.bindService));\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        virBufferAsprintf(buf, \"%s:\", type);\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.nix.path);\n        if (def->source->data.nix.listen)\n            virBufferAddLit(buf, \",server,nowait\");\n        break;\n\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unsupported chr device type '%s'\"), type);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "str"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatCharDev(virConfPtr conf, virDomainDefPtr def,\n                 const char *nativeFormat)\n{\n    size_t i;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (def->nparallels) {\n            virBuffer buf = VIR_BUFFER_INITIALIZER;\n            char *str;\n            int ret;\n\n            ret = xenFormatSxprChr(def->parallels[0], &buf);\n            str = virBufferContentAndReset(&buf);\n            if (ret == 0)\n                ret = xenConfigSetString(conf, \"parallel\", str);\n            VIR_FREE(str);\n            if (ret < 0)\n                return -1;\n        } else {\n            if (xenConfigSetString(conf, \"parallel\", \"none\") < 0)\n                return -1;\n        }\n\n        if (def->nserials) {\n            if ((def->nserials == 1) && (def->serials[0]->target.port == 0)) {\n                virBuffer buf = VIR_BUFFER_INITIALIZER;\n                char *str;\n                int ret;\n\n                ret = xenFormatSxprChr(def->serials[0], &buf);\n                str = virBufferContentAndReset(&buf);\n                if (ret == 0)\n                    ret = xenConfigSetString(conf, \"serial\", str);\n                VIR_FREE(str);\n                if (ret < 0)\n                    return -1;\n            } else {\n                size_t j = 0;\n                int maxport = -1, port;\n                virConfValuePtr serialVal = NULL;\n\n                if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Multiple serial devices are not supported by xen-xm\"));\n                    return -1;\n                }\n\n                if (VIR_ALLOC(serialVal) < 0)\n                    return -1;\n\n                serialVal->type = VIR_CONF_LIST;\n                serialVal->list = NULL;\n\n                for (i = 0; i < def->nserials; i++)\n                    if (def->serials[i]->target.port > maxport)\n                        maxport = def->serials[i]->target.port;\n\n                for (port = 0; port <= maxport; port++) {\n                    virDomainChrDefPtr chr = NULL;\n\n                    for (j = 0; j < def->nserials; j++) {\n                        if (def->serials[j]->target.port == port) {\n                            chr = def->serials[j];\n                            break;\n                        }\n                    }\n\n                    if (xenFormatSerial(serialVal, chr) < 0) {\n                        VIR_FREE(serialVal);\n                        return -1;\n                    }\n                }\n\n                if (serialVal->list != NULL) {\n                    int ret = virConfSetValue(conf, \"serial\", serialVal);\n\n                    serialVal = NULL;\n                    if (ret < 0)\n                        return -1;\n                }\n                VIR_FREE(serialVal);\n            }\n        } else {\n            if (xenConfigSetString(conf, \"serial\", \"none\") < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenFormatEventActions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1953-1985",
    "snippet": "static int\nxenFormatEventActions(virConfPtr conf, virDomainDefPtr def)\n{\n    const char *lifecycle = NULL;\n\n    if (!(lifecycle = virDomainLifecycleActionTypeToString(def->onPoweroff))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected lifecycle action %d\"), def->onPoweroff);\n        return -1;\n    }\n    if (xenConfigSetString(conf, \"on_poweroff\", lifecycle) < 0)\n        return -1;\n\n\n    if (!(lifecycle = virDomainLifecycleActionTypeToString(def->onReboot))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected lifecycle action %d\"), def->onReboot);\n        return -1;\n    }\n    if (xenConfigSetString(conf, \"on_reboot\", lifecycle) < 0)\n        return -1;\n\n\n    if (!(lifecycle = virDomainLifecycleActionTypeToString(def->onCrash))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected lifecycle action %d\"), def->onCrash);\n        return -1;\n    }\n    if (xenConfigSetString(conf, \"on_crash\", lifecycle) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenConfigSetString",
          "args": [
            "conf",
            "\"on_crash\"",
            "lifecycle"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "267-280",
          "snippet": "int\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected lifecycle action %d\")",
            "def->onCrash"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected lifecycle action %d\""
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainLifecycleActionTypeToString",
          "args": [
            "def->onCrash"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected lifecycle action %d\")",
            "def->onReboot"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainLifecycleActionTypeToString",
          "args": [
            "def->onReboot"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected lifecycle action %d\")",
            "def->onPoweroff"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainLifecycleActionTypeToString",
          "args": [
            "def->onPoweroff"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatEventActions(virConfPtr conf, virDomainDefPtr def)\n{\n    const char *lifecycle = NULL;\n\n    if (!(lifecycle = virDomainLifecycleActionTypeToString(def->onPoweroff))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected lifecycle action %d\"), def->onPoweroff);\n        return -1;\n    }\n    if (xenConfigSetString(conf, \"on_poweroff\", lifecycle) < 0)\n        return -1;\n\n\n    if (!(lifecycle = virDomainLifecycleActionTypeToString(def->onReboot))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected lifecycle action %d\"), def->onReboot);\n        return -1;\n    }\n    if (xenConfigSetString(conf, \"on_reboot\", lifecycle) < 0)\n        return -1;\n\n\n    if (!(lifecycle = virDomainLifecycleActionTypeToString(def->onCrash))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected lifecycle action %d\"), def->onCrash);\n        return -1;\n    }\n    if (xenConfigSetString(conf, \"on_crash\", lifecycle) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "xenFormatTimeOffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1889-1950",
    "snippet": "static int\nxenFormatTimeOffset(virConfPtr conf, virDomainDefPtr def)\n{\n    int vmlocaltime;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        /* >=3.1 HV: VARIABLE */\n        int rtc_timeoffset;\n\n        switch (def->clock.offset) {\n        case VIR_DOMAIN_CLOCK_OFFSET_VARIABLE:\n            vmlocaltime = (int)def->clock.data.variable.basis;\n            rtc_timeoffset = def->clock.data.variable.adjustment;\n            break;\n        case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n            if (def->clock.data.utc_reset) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"unsupported clock adjustment='reset'\"));\n                return -1;\n            }\n            vmlocaltime = 0;\n            rtc_timeoffset = 0;\n            break;\n        case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n            if (def->clock.data.utc_reset) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"unsupported clock adjustment='reset'\"));\n                return -1;\n            }\n            vmlocaltime = 1;\n            rtc_timeoffset = 0;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported clock offset='%s'\"),\n                           virDomainClockOffsetTypeToString(def->clock.offset));\n            return -1;\n        }\n        if (xenConfigSetInt(conf, \"rtc_timeoffset\", rtc_timeoffset) < 0)\n            return -1;\n    } else {\n        /* PV: UTC and LOCALTIME */\n        switch (def->clock.offset) {\n        case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n            vmlocaltime = 0;\n            break;\n        case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n            vmlocaltime = 1;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported clock offset='%s'\"),\n                           virDomainClockOffsetTypeToString(def->clock.offset));\n            return -1;\n        }\n    } /* !hvm */\n\n    if (xenConfigSetInt(conf, \"localtime\", vmlocaltime) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenConfigSetInt",
          "args": [
            "conf",
            "\"localtime\"",
            "vmlocaltime"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "246-264",
          "snippet": "int\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported clock offset='%s'\")",
            "virDomainClockOffsetTypeToString(def->clock.offset)"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainClockOffsetTypeToString",
          "args": [
            "def->clock.offset"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported clock offset='%s'\""
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported clock offset='%s'\")",
            "virDomainClockOffsetTypeToString(def->clock.offset)"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainClockOffsetTypeToString",
          "args": [
            "def->clock.offset"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unsupported clock adjustment='reset'\")"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"unsupported clock adjustment='reset'\")"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatTimeOffset(virConfPtr conf, virDomainDefPtr def)\n{\n    int vmlocaltime;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        /* >=3.1 HV: VARIABLE */\n        int rtc_timeoffset;\n\n        switch (def->clock.offset) {\n        case VIR_DOMAIN_CLOCK_OFFSET_VARIABLE:\n            vmlocaltime = (int)def->clock.data.variable.basis;\n            rtc_timeoffset = def->clock.data.variable.adjustment;\n            break;\n        case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n            if (def->clock.data.utc_reset) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"unsupported clock adjustment='reset'\"));\n                return -1;\n            }\n            vmlocaltime = 0;\n            rtc_timeoffset = 0;\n            break;\n        case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n            if (def->clock.data.utc_reset) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"unsupported clock adjustment='reset'\"));\n                return -1;\n            }\n            vmlocaltime = 1;\n            rtc_timeoffset = 0;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported clock offset='%s'\"),\n                           virDomainClockOffsetTypeToString(def->clock.offset));\n            return -1;\n        }\n        if (xenConfigSetInt(conf, \"rtc_timeoffset\", rtc_timeoffset) < 0)\n            return -1;\n    } else {\n        /* PV: UTC and LOCALTIME */\n        switch (def->clock.offset) {\n        case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n            vmlocaltime = 0;\n            break;\n        case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n            vmlocaltime = 1;\n            break;\n        default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unsupported clock offset='%s'\"),\n                           virDomainClockOffsetTypeToString(def->clock.offset));\n            return -1;\n        }\n    } /* !hvm */\n\n    if (xenConfigSetInt(conf, \"localtime\", vmlocaltime) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "xenFormatMem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1874-1886",
    "snippet": "static int\nxenFormatMem(virConfPtr conf, virDomainDefPtr def)\n{\n    if (xenConfigSetInt(conf, \"maxmem\",\n                        VIR_DIV_UP(virDomainDefGetMemoryTotal(def), 1024)) < 0)\n        return -1;\n\n    if (xenConfigSetInt(conf, \"memory\",\n                        VIR_DIV_UP(def->mem.cur_balloon, 1024)) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenConfigSetInt",
          "args": [
            "conf",
            "\"memory\"",
            "VIR_DIV_UP(def->mem.cur_balloon, 1024)"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "246-264",
          "snippet": "int\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "def->mem.cur_balloon",
            "1024"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "virDomainDefGetMemoryTotal(def)",
            "1024"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetMemoryTotal",
          "args": [
            "def"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10946-10950",
          "snippet": "unsigned long long\nvirDomainDefGetMemoryTotal(const virDomainDef *def)\n{\n    return def->mem.total_memory;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned long long\nvirDomainDefGetMemoryTotal(const virDomainDef *def)\n{\n    return def->mem.total_memory;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatMem(virConfPtr conf, virDomainDefPtr def)\n{\n    if (xenConfigSetInt(conf, \"maxmem\",\n                        VIR_DIV_UP(virDomainDefGetMemoryTotal(def), 1024)) < 0)\n        return -1;\n\n    if (xenConfigSetInt(conf, \"memory\",\n                        VIR_DIV_UP(def->mem.cur_balloon, 1024)) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "xenFormatGeneralMeta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1858-1871",
    "snippet": "static int\nxenFormatGeneralMeta(virConfPtr conf, virDomainDefPtr def)\n{\n    char uuid[VIR_UUID_STRING_BUFLEN];\n\n    if (xenConfigSetString(conf, \"name\", def->name) < 0)\n        return -1;\n\n    virUUIDFormat(def->uuid, uuid);\n    if (xenConfigSetString(conf, \"uuid\", uuid) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenConfigSetString",
          "args": [
            "conf",
            "\"uuid\"",
            "uuid"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigSetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "267-280",
          "snippet": "int\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "def->uuid",
            "uuid"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatGeneralMeta(virConfPtr conf, virDomainDefPtr def)\n{\n    char uuid[VIR_UUID_STRING_BUFLEN];\n\n    if (xenConfigSetString(conf, \"name\", def->name) < 0)\n        return -1;\n\n    virUUIDFormat(def->uuid, uuid);\n    if (xenConfigSetString(conf, \"uuid\", uuid) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "xenFormatPCI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1793-1855",
    "snippet": "static int\nxenFormatPCI(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr pciVal = NULL;\n    int hasPCI = 0;\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++)\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            hasPCI = 1;\n\n    if (!hasPCI)\n        return 0;\n\n    if (VIR_ALLOC(pciVal) < 0)\n        return -1;\n\n    pciVal->type = VIR_CONF_LIST;\n    pciVal->list = NULL;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI) {\n            virConfValuePtr val, tmp;\n            char *buf;\n\n            buf = g_strdup_printf(\"%04x:%02x:%02x.%x\",\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.domain,\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.bus,\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.slot,\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.function);\n\n            if (VIR_ALLOC(val) < 0) {\n                VIR_FREE(buf);\n                goto error;\n            }\n            val->type = VIR_CONF_STRING;\n            val->str = buf;\n            tmp = pciVal->list;\n            while (tmp && tmp->next)\n                tmp = tmp->next;\n            if (tmp)\n                tmp->next = val;\n            else\n                pciVal->list = val;\n        }\n    }\n\n    if (pciVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"pci\", pciVal);\n        pciVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(pciVal);\n\n    return 0;\n\n error:\n    virConfFreeValue(pciVal);\n    return -1;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConfFreeValue",
          "args": [
            "pciVal"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "virConfFreeValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "147-159",
          "snippet": "void\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirConfFreeValue(virConfValuePtr val)\n{\n    if (val == NULL)\n        return;\n    if (val->type == VIR_CONF_STRING &&\n        val->str != NULL)\n        VIR_FREE(val->str);\n    if (val->type == VIR_CONF_LIST &&\n        val->list != NULL)\n        virConfFreeList(val->list);\n    VIR_FREE(val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pciVal"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfSetValue",
          "args": [
            "conf",
            "\"pci\"",
            "pciVal"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "virConfSetValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1338-1378",
          "snippet": "int\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buf"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "val"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%04x:%02x:%02x.%x\"",
            "def->hostdevs[i]->source.subsys.u.pci.addr.domain",
            "def->hostdevs[i]->source.subsys.u.pci.addr.bus",
            "def->hostdevs[i]->source.subsys.u.pci.addr.slot",
            "def->hostdevs[i]->source.subsys.u.pci.addr.function"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "pciVal"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatPCI(virConfPtr conf, virDomainDefPtr def)\n{\n    virConfValuePtr pciVal = NULL;\n    int hasPCI = 0;\n    size_t i;\n\n    for (i = 0; i < def->nhostdevs; i++)\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            hasPCI = 1;\n\n    if (!hasPCI)\n        return 0;\n\n    if (VIR_ALLOC(pciVal) < 0)\n        return -1;\n\n    pciVal->type = VIR_CONF_LIST;\n    pciVal->list = NULL;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n            def->hostdevs[i]->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI) {\n            virConfValuePtr val, tmp;\n            char *buf;\n\n            buf = g_strdup_printf(\"%04x:%02x:%02x.%x\",\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.domain,\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.bus,\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.slot,\n                                  def->hostdevs[i]->source.subsys.u.pci.addr.function);\n\n            if (VIR_ALLOC(val) < 0) {\n                VIR_FREE(buf);\n                goto error;\n            }\n            val->type = VIR_CONF_STRING;\n            val->str = buf;\n            tmp = pciVal->list;\n            while (tmp && tmp->next)\n                tmp = tmp->next;\n            if (tmp)\n                tmp->next = val;\n            else\n                pciVal->list = val;\n        }\n    }\n\n    if (pciVal->list != NULL) {\n        int ret = virConfSetValue(conf, \"pci\", pciVal);\n        pciVal = NULL;\n        if (ret < 0)\n            return -1;\n    }\n    VIR_FREE(pciVal);\n\n    return 0;\n\n error:\n    virConfFreeValue(pciVal);\n    return -1;\n}"
  },
  {
    "function_name": "xenFormatNet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1649-1790",
    "snippet": "static int\nxenFormatNet(virConnectPtr conn,\n             virConfValuePtr list,\n             virDomainNetDefPtr net,\n             int hvm,\n             const char *vif_typename)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr val, tmp;\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n\n    virBufferAsprintf(&buf, \"mac=%s\", virMacAddrFormat(&net->mac, macaddr));\n\n    switch (net->type) {\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    {\n        const virNetDevVPortProfile *port_profile = virDomainNetGetActualVirtPortProfile(net);\n        const virNetDevVlan *virt_vlan = virDomainNetGetActualVlan(net);\n        const char *script = net->script;\n        size_t i;\n\n        virBufferAsprintf(&buf, \",bridge=%s\", net->data.bridge.brname);\n        if (port_profile &&\n            port_profile->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n            if (!script)\n                script = \"vif-openvswitch\";\n            /*\n             * libxl_device_nic->bridge supports an extended format for\n             * specifying VLAN tags and trunks\n             *\n             * BRIDGE_NAME[.VLAN][:TRUNK:TRUNK]\n             */\n            if (virt_vlan && virt_vlan->nTags > 0) {\n                if (virt_vlan->trunk) {\n                    for (i = 0; i < virt_vlan->nTags; i++)\n                        virBufferAsprintf(&buf, \":%d\", virt_vlan->tag[i]);\n                } else {\n                    virBufferAsprintf(&buf, \".%d\", virt_vlan->tag[0]);\n                }\n            }\n        }\n\n        if (net->guestIP.nips > 0) {\n            char *ipStr = xenMakeIPList(&net->guestIP);\n            virBufferAsprintf(&buf, \",ip=%s\", ipStr);\n            VIR_FREE(ipStr);\n        }\n        virBufferAsprintf(&buf, \",script=%s\", script ? script : DEFAULT_VIF_SCRIPT);\n    }\n    break;\n\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n        if (net->script)\n            virBufferAsprintf(&buf, \",script=%s\", net->script);\n        if (net->guestIP.nips > 0) {\n            char *ipStr = xenMakeIPList(&net->guestIP);\n            virBufferAsprintf(&buf, \",ip=%s\", ipStr);\n            VIR_FREE(ipStr);\n        }\n        break;\n\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n    {\n        virNetworkPtr network = virNetworkLookupByName(conn, net->data.network.name);\n        char *bridge;\n        if (!network) {\n            virReportError(VIR_ERR_NO_NETWORK, \"%s\",\n                           net->data.network.name);\n            return -1;\n        }\n        bridge = virNetworkGetBridgeName(network);\n        virObjectUnref(network);\n        if (!bridge) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network %s is not active\"),\n                           net->data.network.name);\n            return -1;\n        }\n\n        virBufferAsprintf(&buf, \",bridge=%s\", bridge);\n        virBufferAsprintf(&buf, \",script=%s\", DEFAULT_VIF_SCRIPT);\n    }\n    break;\n\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_USER:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, _(\"Unsupported net type '%s'\"),\n                       virDomainNetTypeToString(net->type));\n        goto cleanup;\n\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virDomainNetType, net->type);\n        goto cleanup;\n    }\n\n    if (virDomainNetGetModelString(net)) {\n        if (!hvm) {\n            virBufferAsprintf(&buf, \",model=%s\",\n                              virDomainNetGetModelString(net));\n        } else {\n            if (net->model == VIR_DOMAIN_NET_MODEL_NETFRONT)\n                virBufferAsprintf(&buf, \",type=%s\", vif_typename);\n            else\n                virBufferAsprintf(&buf, \",model=%s\",\n                                  virDomainNetGetModelString(net));\n        }\n    }\n\n    if (net->ifname)\n        virBufferAsprintf(&buf, \",vifname=%s\",\n                          net->ifname);\n\n    if (net->bandwidth && net->bandwidth->out && net->bandwidth->out->average)\n        virBufferAsprintf(&buf, \",rate=%lluKB/s\", net->bandwidth->out->average);\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n\n    return 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "val"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\",rate=%lluKB/s\"",
            "net->bandwidth->out->average"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetModelString",
          "args": [
            "net"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetModelString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30308-30314",
          "snippet": "const char *\nvirDomainNetGetModelString(const virDomainNetDef *net)\n{\n    if (net->model)\n        return virDomainNetModelTypeToString(net->model);\n    return net->modelstr;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainNetGetModelString(const virDomainNetDef *net)\n{\n    if (net->model)\n        return virDomainNetModelTypeToString(net->model);\n    return net->modelstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virDomainNetType",
            "net->type"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported net type '%s'\")",
            "virDomainNetTypeToString(net->type)"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetTypeToString",
          "args": [
            "net->type"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported net type '%s'\""
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"network %s is not active\")",
            "net->data.network.name"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "network"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkGetBridgeName",
          "args": [
            "network"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkGetBridgeName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-network.c",
          "lines": "827-851",
          "snippet": "char *\nvirNetworkGetBridgeName(virNetworkPtr network)\n{\n    virConnectPtr conn;\n    VIR_DEBUG(\"network=%p\", network);\n\n    virResetLastError();\n\n    virCheckNetworkReturn(network, NULL);\n    conn = network->conn;\n\n    if (conn->networkDriver && conn->networkDriver->networkGetBridgeName) {\n        char *ret;\n        ret = conn->networkDriver->networkGetBridgeName(network);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(network->conn);\n    return NULL;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nchar *\nvirNetworkGetBridgeName(virNetworkPtr network)\n{\n    virConnectPtr conn;\n    VIR_DEBUG(\"network=%p\", network);\n\n    virResetLastError();\n\n    virCheckNetworkReturn(network, NULL);\n    conn = network->conn;\n\n    if (conn->networkDriver && conn->networkDriver->networkGetBridgeName) {\n        char *ret;\n        ret = conn->networkDriver->networkGetBridgeName(network);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(network->conn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_NETWORK",
            "\"%s\"",
            "net->data.network.name"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkLookupByName",
          "args": [
            "conn",
            "net->data.network.name"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkLookupByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-network.c",
          "lines": "287-310",
          "snippet": "virNetworkPtr\nvirNetworkLookupByName(virConnectPtr conn, const char *name)\n{\n    VIR_DEBUG(\"conn=%p, name=%s\", conn, NULLSTR(name));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(name, error);\n\n    if (conn->networkDriver && conn->networkDriver->networkLookupByName) {\n        virNetworkPtr ret;\n        ret = conn->networkDriver->networkLookupByName(conn, name);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNetworkPtr\nvirNetworkLookupByName(virConnectPtr conn, const char *name)\n{\n    VIR_DEBUG(\"conn=%p, name=%s\", conn, NULLSTR(name));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(name, error);\n\n    if (conn->networkDriver && conn->networkDriver->networkLookupByName) {\n        virNetworkPtr ret;\n        ret = conn->networkDriver->networkLookupByName(conn, name);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ipStr"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenMakeIPList",
          "args": [
            "&net->guestIP"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "xenMakeIPList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1627-1647",
          "snippet": "char *\nxenMakeIPList(virNetDevIPInfoPtr guestIP)\n{\n    size_t i;\n    char **address_array;\n    char *ret = NULL;\n\n    if (VIR_ALLOC_N(address_array, guestIP->nips + 1) < 0)\n        return NULL;\n\n    for (i = 0; i < guestIP->nips; i++) {\n        address_array[i] = virSocketAddrFormat(&guestIP->ips[i]->address);\n        if (!address_array[i])\n            goto cleanup;\n    }\n    ret = virStringListJoin((const char**)address_array, \" \");\n\n cleanup:\n    virStringListFree(address_array);\n    return ret;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nxenMakeIPList(virNetDevIPInfoPtr guestIP)\n{\n    size_t i;\n    char **address_array;\n    char *ret = NULL;\n\n    if (VIR_ALLOC_N(address_array, guestIP->nips + 1) < 0)\n        return NULL;\n\n    for (i = 0; i < guestIP->nips; i++) {\n        address_array[i] = virSocketAddrFormat(&guestIP->ips[i]->address);\n        if (!address_array[i])\n            goto cleanup;\n    }\n    ret = virStringListJoin((const char**)address_array, \" \");\n\n cleanup:\n    virStringListFree(address_array);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ipStr"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVlan",
          "args": [
            "net"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30269-30284",
          "snippet": "const virNetDevVlan *\nvirDomainNetGetActualVlan(const virDomainNetDef *iface)\n{\n    const virNetDevVlan *vlan = &iface->vlan;\n\n    /* if there is an ActualNetDef, *always* return\n     * its vlan rather than the NetDef's vlan.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        vlan = &iface->data.network.actual->vlan;\n\n    if (vlan->nTags > 0)\n        return vlan;\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVlan *\nvirDomainNetGetActualVlan(const virDomainNetDef *iface)\n{\n    const virNetDevVlan *vlan = &iface->vlan;\n\n    /* if there is an ActualNetDef, *always* return\n     * its vlan rather than the NetDef's vlan.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        vlan = &iface->data.network.actual->vlan;\n\n    if (vlan->nTags > 0)\n        return vlan;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVirtPortProfile",
          "args": [
            "net"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVirtPortProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30224-30255",
          "snippet": "const virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "&net->mac",
            "macaddr"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatNet(virConnectPtr conn,\n             virConfValuePtr list,\n             virDomainNetDefPtr net,\n             int hvm,\n             const char *vif_typename)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr val, tmp;\n    char macaddr[VIR_MAC_STRING_BUFLEN];\n\n    virBufferAsprintf(&buf, \"mac=%s\", virMacAddrFormat(&net->mac, macaddr));\n\n    switch (net->type) {\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    {\n        const virNetDevVPortProfile *port_profile = virDomainNetGetActualVirtPortProfile(net);\n        const virNetDevVlan *virt_vlan = virDomainNetGetActualVlan(net);\n        const char *script = net->script;\n        size_t i;\n\n        virBufferAsprintf(&buf, \",bridge=%s\", net->data.bridge.brname);\n        if (port_profile &&\n            port_profile->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n            if (!script)\n                script = \"vif-openvswitch\";\n            /*\n             * libxl_device_nic->bridge supports an extended format for\n             * specifying VLAN tags and trunks\n             *\n             * BRIDGE_NAME[.VLAN][:TRUNK:TRUNK]\n             */\n            if (virt_vlan && virt_vlan->nTags > 0) {\n                if (virt_vlan->trunk) {\n                    for (i = 0; i < virt_vlan->nTags; i++)\n                        virBufferAsprintf(&buf, \":%d\", virt_vlan->tag[i]);\n                } else {\n                    virBufferAsprintf(&buf, \".%d\", virt_vlan->tag[0]);\n                }\n            }\n        }\n\n        if (net->guestIP.nips > 0) {\n            char *ipStr = xenMakeIPList(&net->guestIP);\n            virBufferAsprintf(&buf, \",ip=%s\", ipStr);\n            VIR_FREE(ipStr);\n        }\n        virBufferAsprintf(&buf, \",script=%s\", script ? script : DEFAULT_VIF_SCRIPT);\n    }\n    break;\n\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n        if (net->script)\n            virBufferAsprintf(&buf, \",script=%s\", net->script);\n        if (net->guestIP.nips > 0) {\n            char *ipStr = xenMakeIPList(&net->guestIP);\n            virBufferAsprintf(&buf, \",ip=%s\", ipStr);\n            VIR_FREE(ipStr);\n        }\n        break;\n\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n    {\n        virNetworkPtr network = virNetworkLookupByName(conn, net->data.network.name);\n        char *bridge;\n        if (!network) {\n            virReportError(VIR_ERR_NO_NETWORK, \"%s\",\n                           net->data.network.name);\n            return -1;\n        }\n        bridge = virNetworkGetBridgeName(network);\n        virObjectUnref(network);\n        if (!bridge) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network %s is not active\"),\n                           net->data.network.name);\n            return -1;\n        }\n\n        virBufferAsprintf(&buf, \",bridge=%s\", bridge);\n        virBufferAsprintf(&buf, \",script=%s\", DEFAULT_VIF_SCRIPT);\n    }\n    break;\n\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_USER:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, _(\"Unsupported net type '%s'\"),\n                       virDomainNetTypeToString(net->type));\n        goto cleanup;\n\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        virReportEnumRangeError(virDomainNetType, net->type);\n        goto cleanup;\n    }\n\n    if (virDomainNetGetModelString(net)) {\n        if (!hvm) {\n            virBufferAsprintf(&buf, \",model=%s\",\n                              virDomainNetGetModelString(net));\n        } else {\n            if (net->model == VIR_DOMAIN_NET_MODEL_NETFRONT)\n                virBufferAsprintf(&buf, \",type=%s\", vif_typename);\n            else\n                virBufferAsprintf(&buf, \",model=%s\",\n                                  virDomainNetGetModelString(net));\n        }\n    }\n\n    if (net->ifname)\n        virBufferAsprintf(&buf, \",vifname=%s\",\n                          net->ifname);\n\n    if (net->bandwidth && net->bandwidth->out && net->bandwidth->out->average)\n        virBufferAsprintf(&buf, \",rate=%lluKB/s\", net->bandwidth->out->average);\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n\n    return 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}"
  },
  {
    "function_name": "xenMakeIPList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1627-1647",
    "snippet": "char *\nxenMakeIPList(virNetDevIPInfoPtr guestIP)\n{\n    size_t i;\n    char **address_array;\n    char *ret = NULL;\n\n    if (VIR_ALLOC_N(address_array, guestIP->nips + 1) < 0)\n        return NULL;\n\n    for (i = 0; i < guestIP->nips; i++) {\n        address_array[i] = virSocketAddrFormat(&guestIP->ips[i]->address);\n        if (!address_array[i])\n            goto cleanup;\n    }\n    ret = virStringListJoin((const char**)address_array, \" \");\n\n cleanup:\n    virStringListFree(address_array);\n    return ret;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "address_array"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringListJoin",
          "args": [
            "(const char**)address_array",
            "\" \""
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListJoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "147-162",
          "snippet": "char *virStringListJoin(const char **strings,\n                        const char *delim)\n{\n    char *ret;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    while (*strings) {\n        virBufferAdd(&buf, *strings, -1);\n        if (*(strings+1))\n            virBufferAdd(&buf, delim, -1);\n        strings++;\n    }\n    ret = virBufferContentAndReset(&buf);\n    if (!ret)\n        ret = g_strdup(\"\");\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar *virStringListJoin(const char **strings,\n                        const char *delim)\n{\n    char *ret;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    while (*strings) {\n        virBufferAdd(&buf, *strings, -1);\n        if (*(strings+1))\n            virBufferAdd(&buf, delim, -1);\n        strings++;\n    }\n    ret = virBufferContentAndReset(&buf);\n    if (!ret)\n        ret = g_strdup(\"\");\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&guestIP->ips[i]->address"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "address_array",
            "guestIP->nips + 1"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nxenMakeIPList(virNetDevIPInfoPtr guestIP)\n{\n    size_t i;\n    char **address_array;\n    char *ret = NULL;\n\n    if (VIR_ALLOC_N(address_array, guestIP->nips + 1) < 0)\n        return NULL;\n\n    for (i = 0; i < guestIP->nips; i++) {\n        address_array[i] = virSocketAddrFormat(&guestIP->ips[i]->address);\n        if (!address_array[i])\n            goto cleanup;\n    }\n    ret = virStringListJoin((const char**)address_array, \" \");\n\n cleanup:\n    virStringListFree(address_array);\n    return ret;\n}"
  },
  {
    "function_name": "xenFormatSerial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1592-1625",
    "snippet": "static int\nxenFormatSerial(virConfValuePtr list, virDomainChrDefPtr serial)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr val, tmp;\n    int ret;\n\n    if (serial) {\n        ret = xenFormatSxprChr(serial, &buf);\n        if (ret < 0)\n            goto cleanup;\n    } else {\n        virBufferAddLit(&buf, \"none\");\n    }\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n\n    return 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "val"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"none\""
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenFormatSxprChr",
          "args": [
            "serial",
            "&buf"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "xenFormatSxprChr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1526-1589",
          "snippet": "static int\nxenFormatSxprChr(virDomainChrDefPtr def,\n                 virBufferPtr buf)\n{\n    const char *type = virDomainChrTypeToString(def->source->type);\n\n    if (!type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unexpected chr device type\"));\n        return -1;\n    }\n\n    switch (def->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        virBufferAdd(buf, type, -1);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        virBufferAsprintf(buf, \"%s:\", type);\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n        virBufferAsprintf(buf, \"%s:%s:%s%s\",\n                          (def->source->data.tcp.protocol\n                           == VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW ?\n                           \"tcp\" : \"telnet\"),\n                          NULLSTR_EMPTY(def->source->data.tcp.host),\n                          NULLSTR_EMPTY(def->source->data.tcp.service),\n                          (def->source->data.tcp.listen ?\n                           \",server,nowait\" : \"\"));\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n        virBufferAsprintf(buf, \"%s:%s:%s@%s:%s\", type,\n                          NULLSTR_EMPTY(def->source->data.udp.connectHost),\n                          NULLSTR_EMPTY(def->source->data.udp.connectService),\n                          NULLSTR_EMPTY(def->source->data.udp.bindHost),\n                          NULLSTR_EMPTY(def->source->data.udp.bindService));\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        virBufferAsprintf(buf, \"%s:\", type);\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.nix.path);\n        if (def->source->data.nix.listen)\n            virBufferAddLit(buf, \",server,nowait\");\n        break;\n\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unsupported chr device type '%s'\"), type);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatSxprChr(virDomainChrDefPtr def,\n                 virBufferPtr buf)\n{\n    const char *type = virDomainChrTypeToString(def->source->type);\n\n    if (!type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unexpected chr device type\"));\n        return -1;\n    }\n\n    switch (def->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        virBufferAdd(buf, type, -1);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        virBufferAsprintf(buf, \"%s:\", type);\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n        virBufferAsprintf(buf, \"%s:%s:%s%s\",\n                          (def->source->data.tcp.protocol\n                           == VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW ?\n                           \"tcp\" : \"telnet\"),\n                          NULLSTR_EMPTY(def->source->data.tcp.host),\n                          NULLSTR_EMPTY(def->source->data.tcp.service),\n                          (def->source->data.tcp.listen ?\n                           \",server,nowait\" : \"\"));\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n        virBufferAsprintf(buf, \"%s:%s:%s@%s:%s\", type,\n                          NULLSTR_EMPTY(def->source->data.udp.connectHost),\n                          NULLSTR_EMPTY(def->source->data.udp.connectService),\n                          NULLSTR_EMPTY(def->source->data.udp.bindHost),\n                          NULLSTR_EMPTY(def->source->data.udp.bindService));\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        virBufferAsprintf(buf, \"%s:\", type);\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.nix.path);\n        if (def->source->data.nix.listen)\n            virBufferAddLit(buf, \",server,nowait\");\n        break;\n\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unsupported chr device type '%s'\"), type);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatSerial(virConfValuePtr list, virDomainChrDefPtr serial)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    virConfValuePtr val, tmp;\n    int ret;\n\n    if (serial) {\n        ret = xenFormatSxprChr(serial, &buf);\n        if (ret < 0)\n            goto cleanup;\n    } else {\n        virBufferAddLit(&buf, \"none\");\n    }\n\n    if (VIR_ALLOC(val) < 0)\n        goto cleanup;\n\n    val->type = VIR_CONF_STRING;\n    val->str = virBufferContentAndReset(&buf);\n    tmp = list->list;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n    if (tmp)\n        tmp->next = val;\n    else\n        list->list = val;\n\n    return 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return -1;\n}"
  },
  {
    "function_name": "xenFormatSxprChr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1526-1589",
    "snippet": "static int\nxenFormatSxprChr(virDomainChrDefPtr def,\n                 virBufferPtr buf)\n{\n    const char *type = virDomainChrTypeToString(def->source->type);\n\n    if (!type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unexpected chr device type\"));\n        return -1;\n    }\n\n    switch (def->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        virBufferAdd(buf, type, -1);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        virBufferAsprintf(buf, \"%s:\", type);\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n        virBufferAsprintf(buf, \"%s:%s:%s%s\",\n                          (def->source->data.tcp.protocol\n                           == VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW ?\n                           \"tcp\" : \"telnet\"),\n                          NULLSTR_EMPTY(def->source->data.tcp.host),\n                          NULLSTR_EMPTY(def->source->data.tcp.service),\n                          (def->source->data.tcp.listen ?\n                           \",server,nowait\" : \"\"));\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n        virBufferAsprintf(buf, \"%s:%s:%s@%s:%s\", type,\n                          NULLSTR_EMPTY(def->source->data.udp.connectHost),\n                          NULLSTR_EMPTY(def->source->data.udp.connectService),\n                          NULLSTR_EMPTY(def->source->data.udp.bindHost),\n                          NULLSTR_EMPTY(def->source->data.udp.bindService));\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        virBufferAsprintf(buf, \"%s:\", type);\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.nix.path);\n        if (def->source->data.nix.listen)\n            virBufferAddLit(buf, \",server,nowait\");\n        break;\n\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unsupported chr device type '%s'\"), type);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unsupported chr device type '%s'\")",
            "type"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported chr device type '%s'\""
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\",server,nowait\""
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeSexpr",
          "args": [
            "buf",
            "\"%s\"",
            "def->source->data.nix.path"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeSexpr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "431-437",
          "snippet": "void\nvirBufferEscapeSexpr(virBufferPtr buf,\n                     const char *format,\n                     const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"\\\\'\", format, str);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeSexpr(virBufferPtr buf,\n                     const char *format,\n                     const char *str)\n{\n    virBufferEscape(buf, '\\\\', \"\\\\'\", format, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"%s:\"",
            "type"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "def->source->data.udp.bindService"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "def->source->data.udp.bindHost"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "def->source->data.udp.connectService"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "def->source->data.udp.connectHost"
          ],
          "line": 1569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "def->source->data.tcp.service"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "def->source->data.tcp.host"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "buf",
            "type",
            "-1"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unexpected chr device type\")"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrTypeToString",
          "args": [
            "def->source->type"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenFormatSxprChr(virDomainChrDefPtr def,\n                 virBufferPtr buf)\n{\n    const char *type = virDomainChrTypeToString(def->source->type);\n\n    if (!type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"unexpected chr device type\"));\n        return -1;\n    }\n\n    switch (def->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_NULL:\n    case VIR_DOMAIN_CHR_TYPE_STDIO:\n    case VIR_DOMAIN_CHR_TYPE_VC:\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        virBufferAdd(buf, type, -1);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        virBufferAsprintf(buf, \"%s:\", type);\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_DEV:\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.file.path);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n        virBufferAsprintf(buf, \"%s:%s:%s%s\",\n                          (def->source->data.tcp.protocol\n                           == VIR_DOMAIN_CHR_TCP_PROTOCOL_RAW ?\n                           \"tcp\" : \"telnet\"),\n                          NULLSTR_EMPTY(def->source->data.tcp.host),\n                          NULLSTR_EMPTY(def->source->data.tcp.service),\n                          (def->source->data.tcp.listen ?\n                           \",server,nowait\" : \"\"));\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n        virBufferAsprintf(buf, \"%s:%s:%s@%s:%s\", type,\n                          NULLSTR_EMPTY(def->source->data.udp.connectHost),\n                          NULLSTR_EMPTY(def->source->data.udp.connectService),\n                          NULLSTR_EMPTY(def->source->data.udp.bindHost),\n                          NULLSTR_EMPTY(def->source->data.udp.bindService));\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n        virBufferAsprintf(buf, \"%s:\", type);\n        virBufferEscapeSexpr(buf, \"%s\", def->source->data.nix.path);\n        if (def->source->data.nix.listen)\n            virBufferAddLit(buf, \",server,nowait\");\n        break;\n\n    default:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unsupported chr device type '%s'\"), type);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenParseConfigCommon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1463-1513",
    "snippet": "int\nxenParseConfigCommon(virConfPtr conf,\n                     virDomainDefPtr def,\n                     virCapsPtr caps,\n                     const char *nativeFormat,\n                     virDomainXMLOptionPtr xmlopt)\n{\n    if (xenParseGeneralMeta(conf, def, caps) < 0)\n        return -1;\n\n    if (xenParseMem(conf, def) < 0)\n        return -1;\n\n    if (xenParseEventsActions(conf, def) < 0)\n        return -1;\n\n    if (xenParseCPUFeatures(conf, def, xmlopt) < 0)\n        return -1;\n\n    if (xenParseTimeOffset(conf, def) < 0)\n        return -1;\n\n    if (xenConfigCopyStringOpt(conf, \"device_model\", &def->emulator) < 0)\n        return -1;\n\n    if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XL)) {\n        if (xenParseVifList(conf, def, \"vif\") < 0)\n            return -1;\n    } else if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n        if (xenParseVifList(conf, def, \"netfront\") < 0)\n            return -1;\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported config type %s\"), nativeFormat);\n        return -1;\n    }\n\n    if (xenParsePCIList(conf, def) < 0)\n        return -1;\n\n    if (xenParseEmulatedDevices(conf, def) < 0)\n        return -1;\n\n    if (xenParseVfb(conf, def) < 0)\n        return -1;\n\n    if (xenParseCharDev(conf, def, nativeFormat) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenParseCharDev",
          "args": [
            "conf",
            "def",
            "nativeFormat"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseCharDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "895-983",
          "snippet": "static int\nxenParseCharDev(virConfPtr conf, virDomainDefPtr def, const char *nativeFormat)\n{\n    VIR_AUTOSTRINGLIST serials = NULL;\n    virDomainChrDefPtr chr = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        g_autofree char *parallel = NULL;\n        int rc;\n\n        if (xenConfigGetString(conf, \"parallel\", &parallel, NULL) < 0)\n            goto cleanup;\n        if (parallel && STRNEQ(parallel, \"none\") &&\n            !(chr = xenParseSxprChar(parallel, NULL)))\n            goto cleanup;\n        if (chr) {\n            if (VIR_ALLOC_N(def->parallels, 1) < 0)\n                goto cleanup;\n\n            chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_PARALLEL;\n            chr->target.port = 0;\n            def->parallels[0] = chr;\n            def->nparallels++;\n            chr = NULL;\n        }\n\n        /* Try to get the list of values to support multiple serial ports */\n        if ((rc = virConfGetValueStringList(conf, \"serial\", false, &serials)) == 1) {\n            char **entries;\n            int portnum = -1;\n\n            if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple serial devices are not supported by xen-xm\"));\n                goto cleanup;\n            }\n\n            for (entries = serials; *entries; entries++) {\n                char *port = *entries;\n\n                portnum++;\n                if (STREQ(port, \"none\"))\n                    continue;\n\n                if (!(chr = xenParseSxprChar(port, NULL)))\n                    goto cleanup;\n                chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n                chr->target.port = portnum;\n                if (VIR_APPEND_ELEMENT(def->serials, def->nserials, chr) < 0)\n                    goto cleanup;\n            }\n        } else {\n            g_autofree char *serial = NULL;\n\n            if (xenHandleConfGetValueStringListErrors(rc) < 0)\n                goto cleanup;\n\n            /* If domain is not using multiple serial ports we parse data old way */\n            if (xenConfigGetString(conf, \"serial\", &serial, NULL) < 0)\n                goto cleanup;\n            if (serial && STRNEQ(serial, \"none\") &&\n                !(chr = xenParseSxprChar(serial, NULL)))\n                goto cleanup;\n            if (chr) {\n                if (VIR_ALLOC_N(def->serials, 1) < 0)\n                    goto cleanup;\n                chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n                chr->target.port = 0;\n                def->serials[0] = chr;\n                def->nserials++;\n            }\n        }\n    } else {\n        if (VIR_ALLOC_N(def->consoles, 1) < 0)\n            goto cleanup;\n        def->nconsoles = 1;\n        if (!(def->consoles[0] = xenParseSxprChar(\"pty\", NULL)))\n            goto cleanup;\n        def->consoles[0]->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE;\n        def->consoles[0]->target.port = 0;\n        def->consoles[0]->targetType = VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_XEN;\n    }\n\n    return 0;\n\n cleanup:\n    virDomainChrDefFree(chr);\n    return -1;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseCharDev(virConfPtr conf, virDomainDefPtr def, const char *nativeFormat)\n{\n    VIR_AUTOSTRINGLIST serials = NULL;\n    virDomainChrDefPtr chr = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        g_autofree char *parallel = NULL;\n        int rc;\n\n        if (xenConfigGetString(conf, \"parallel\", &parallel, NULL) < 0)\n            goto cleanup;\n        if (parallel && STRNEQ(parallel, \"none\") &&\n            !(chr = xenParseSxprChar(parallel, NULL)))\n            goto cleanup;\n        if (chr) {\n            if (VIR_ALLOC_N(def->parallels, 1) < 0)\n                goto cleanup;\n\n            chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_PARALLEL;\n            chr->target.port = 0;\n            def->parallels[0] = chr;\n            def->nparallels++;\n            chr = NULL;\n        }\n\n        /* Try to get the list of values to support multiple serial ports */\n        if ((rc = virConfGetValueStringList(conf, \"serial\", false, &serials)) == 1) {\n            char **entries;\n            int portnum = -1;\n\n            if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple serial devices are not supported by xen-xm\"));\n                goto cleanup;\n            }\n\n            for (entries = serials; *entries; entries++) {\n                char *port = *entries;\n\n                portnum++;\n                if (STREQ(port, \"none\"))\n                    continue;\n\n                if (!(chr = xenParseSxprChar(port, NULL)))\n                    goto cleanup;\n                chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n                chr->target.port = portnum;\n                if (VIR_APPEND_ELEMENT(def->serials, def->nserials, chr) < 0)\n                    goto cleanup;\n            }\n        } else {\n            g_autofree char *serial = NULL;\n\n            if (xenHandleConfGetValueStringListErrors(rc) < 0)\n                goto cleanup;\n\n            /* If domain is not using multiple serial ports we parse data old way */\n            if (xenConfigGetString(conf, \"serial\", &serial, NULL) < 0)\n                goto cleanup;\n            if (serial && STRNEQ(serial, \"none\") &&\n                !(chr = xenParseSxprChar(serial, NULL)))\n                goto cleanup;\n            if (chr) {\n                if (VIR_ALLOC_N(def->serials, 1) < 0)\n                    goto cleanup;\n                chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n                chr->target.port = 0;\n                def->serials[0] = chr;\n                def->nserials++;\n            }\n        }\n    } else {\n        if (VIR_ALLOC_N(def->consoles, 1) < 0)\n            goto cleanup;\n        def->nconsoles = 1;\n        if (!(def->consoles[0] = xenParseSxprChar(\"pty\", NULL)))\n            goto cleanup;\n        def->consoles[0]->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE;\n        def->consoles[0]->target.port = 0;\n        def->consoles[0]->targetType = VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_XEN;\n    }\n\n    return 0;\n\n cleanup:\n    virDomainChrDefFree(chr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseVfb",
          "args": [
            "conf",
            "def"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseVfb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "603-751",
          "snippet": "static int\nxenParseVfb(virConfPtr conf, virDomainDefPtr def)\n{\n    int val;\n    char *listenAddr = NULL;\n    int hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM;\n    virDomainGraphicsDefPtr graphics = NULL;\n\n    if (hvm) {\n        if (xenConfigGetBool(conf, \"vnc\", &val, 0) < 0)\n            goto cleanup;\n        if (val) {\n            if (VIR_ALLOC(graphics) < 0)\n                goto cleanup;\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n            if (xenConfigGetBool(conf, \"vncunused\", &val, 1) < 0)\n                goto cleanup;\n            graphics->data.vnc.autoport = val ? 1 : 0;\n            if (!graphics->data.vnc.autoport) {\n                unsigned long vncdisplay;\n                if (xenConfigGetULong(conf, \"vncdisplay\", &vncdisplay, 0) < 0)\n                    goto cleanup;\n                graphics->data.vnc.port = (int)vncdisplay + 5900;\n            }\n\n            if (xenConfigCopyStringOpt(conf, \"vnclisten\", &listenAddr) < 0)\n                goto cleanup;\n            if (virDomainGraphicsListenAppendAddress(graphics, listenAddr) < 0)\n                goto cleanup;\n            VIR_FREE(listenAddr);\n\n            if (xenConfigCopyStringOpt(conf, \"vncpasswd\", &graphics->data.vnc.auth.passwd) < 0)\n                goto cleanup;\n            if (xenConfigCopyStringOpt(conf, \"keymap\", &graphics->data.vnc.keymap) < 0)\n                goto cleanup;\n            if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                goto cleanup;\n            def->graphics[0] = graphics;\n            def->ngraphics = 1;\n            graphics = NULL;\n        } else {\n            if (xenConfigGetBool(conf, \"sdl\", &val, 0) < 0)\n                goto cleanup;\n            if (val) {\n                if (VIR_ALLOC(graphics) < 0)\n                    goto cleanup;\n                graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SDL;\n                if (xenConfigCopyStringOpt(conf, \"display\", &graphics->data.sdl.display) < 0)\n                    goto cleanup;\n                if (xenConfigCopyStringOpt(conf, \"xauthority\", &graphics->data.sdl.xauth) < 0)\n                    goto cleanup;\n                if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                    goto cleanup;\n                def->graphics[0] = graphics;\n                def->ngraphics = 1;\n                graphics = NULL;\n            }\n        }\n    }\n\n    if (!hvm && def->graphics == NULL) { /* New PV guests use this format */\n        VIR_AUTOSTRINGLIST vfbs = NULL;\n        int rc;\n\n        if ((rc = virConfGetValueStringList(conf, \"vfb\", false, &vfbs)) == 1) {\n            char vfb[MAX_VFB];\n            char *key = vfb;\n\n            if (virStrcpyStatic(vfb, *vfbs) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"VFB %s too big for destination\"),\n                               *vfbs);\n                goto cleanup;\n            }\n\n            if (VIR_ALLOC(graphics) < 0)\n                goto cleanup;\n            if (strstr(key, \"type=sdl\"))\n                graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SDL;\n            else\n                graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n            while (key) {\n                char *nextkey = strchr(key, ',');\n                char *end = nextkey;\n                if (nextkey) {\n                    *end = '\\0';\n                    nextkey++;\n                }\n\n                if (!strchr(key, '='))\n                    break;\n                if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n                    if (STRPREFIX(key, \"vncunused=\")) {\n                        if (STREQ(key + 10, \"1\"))\n                            graphics->data.vnc.autoport = true;\n                    } else if (STRPREFIX(key, \"vnclisten=\")) {\n                        listenAddr = g_strdup(key + 10);\n                    } else if (STRPREFIX(key, \"vncpasswd=\")) {\n                        graphics->data.vnc.auth.passwd = g_strdup(key + 10);\n                    } else if (STRPREFIX(key, \"keymap=\")) {\n                        graphics->data.vnc.keymap = g_strdup(key + 7);\n                    } else if (STRPREFIX(key, \"vncdisplay=\")) {\n                        if (virStrToLong_i(key + 11, NULL, 10,\n                                           &graphics->data.vnc.port) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"invalid vncdisplay value '%s'\"),\n                                           key + 11);\n                            goto cleanup;\n                        }\n                        graphics->data.vnc.port += 5900;\n                    }\n                } else {\n                    if (STRPREFIX(key, \"display=\")) {\n                        graphics->data.sdl.display = g_strdup(key + 8);\n                    } else if (STRPREFIX(key, \"xauthority=\")) {\n                        graphics->data.sdl.xauth = g_strdup(key + 11);\n                    }\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n            if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n                if (virDomainGraphicsListenAppendAddress(graphics,\n                                                         listenAddr) < 0)\n                    goto cleanup;\n                VIR_FREE(listenAddr);\n            }\n            if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                goto cleanup;\n            def->graphics[0] = graphics;\n            def->ngraphics = 1;\n            graphics = NULL;\n        } else {\n            if (xenHandleConfGetValueStringListErrors(rc) < 0)\n                goto cleanup;\n        }\n    }\n\n    return 0;\n\n cleanup:\n    virDomainGraphicsDefFree(graphics);\n    VIR_FREE(listenAddr);\n    return -1;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_VFB 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\n#define MAX_VFB 1024\n\nstatic int\nxenParseVfb(virConfPtr conf, virDomainDefPtr def)\n{\n    int val;\n    char *listenAddr = NULL;\n    int hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM;\n    virDomainGraphicsDefPtr graphics = NULL;\n\n    if (hvm) {\n        if (xenConfigGetBool(conf, \"vnc\", &val, 0) < 0)\n            goto cleanup;\n        if (val) {\n            if (VIR_ALLOC(graphics) < 0)\n                goto cleanup;\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n            if (xenConfigGetBool(conf, \"vncunused\", &val, 1) < 0)\n                goto cleanup;\n            graphics->data.vnc.autoport = val ? 1 : 0;\n            if (!graphics->data.vnc.autoport) {\n                unsigned long vncdisplay;\n                if (xenConfigGetULong(conf, \"vncdisplay\", &vncdisplay, 0) < 0)\n                    goto cleanup;\n                graphics->data.vnc.port = (int)vncdisplay + 5900;\n            }\n\n            if (xenConfigCopyStringOpt(conf, \"vnclisten\", &listenAddr) < 0)\n                goto cleanup;\n            if (virDomainGraphicsListenAppendAddress(graphics, listenAddr) < 0)\n                goto cleanup;\n            VIR_FREE(listenAddr);\n\n            if (xenConfigCopyStringOpt(conf, \"vncpasswd\", &graphics->data.vnc.auth.passwd) < 0)\n                goto cleanup;\n            if (xenConfigCopyStringOpt(conf, \"keymap\", &graphics->data.vnc.keymap) < 0)\n                goto cleanup;\n            if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                goto cleanup;\n            def->graphics[0] = graphics;\n            def->ngraphics = 1;\n            graphics = NULL;\n        } else {\n            if (xenConfigGetBool(conf, \"sdl\", &val, 0) < 0)\n                goto cleanup;\n            if (val) {\n                if (VIR_ALLOC(graphics) < 0)\n                    goto cleanup;\n                graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SDL;\n                if (xenConfigCopyStringOpt(conf, \"display\", &graphics->data.sdl.display) < 0)\n                    goto cleanup;\n                if (xenConfigCopyStringOpt(conf, \"xauthority\", &graphics->data.sdl.xauth) < 0)\n                    goto cleanup;\n                if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                    goto cleanup;\n                def->graphics[0] = graphics;\n                def->ngraphics = 1;\n                graphics = NULL;\n            }\n        }\n    }\n\n    if (!hvm && def->graphics == NULL) { /* New PV guests use this format */\n        VIR_AUTOSTRINGLIST vfbs = NULL;\n        int rc;\n\n        if ((rc = virConfGetValueStringList(conf, \"vfb\", false, &vfbs)) == 1) {\n            char vfb[MAX_VFB];\n            char *key = vfb;\n\n            if (virStrcpyStatic(vfb, *vfbs) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"VFB %s too big for destination\"),\n                               *vfbs);\n                goto cleanup;\n            }\n\n            if (VIR_ALLOC(graphics) < 0)\n                goto cleanup;\n            if (strstr(key, \"type=sdl\"))\n                graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SDL;\n            else\n                graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n            while (key) {\n                char *nextkey = strchr(key, ',');\n                char *end = nextkey;\n                if (nextkey) {\n                    *end = '\\0';\n                    nextkey++;\n                }\n\n                if (!strchr(key, '='))\n                    break;\n                if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n                    if (STRPREFIX(key, \"vncunused=\")) {\n                        if (STREQ(key + 10, \"1\"))\n                            graphics->data.vnc.autoport = true;\n                    } else if (STRPREFIX(key, \"vnclisten=\")) {\n                        listenAddr = g_strdup(key + 10);\n                    } else if (STRPREFIX(key, \"vncpasswd=\")) {\n                        graphics->data.vnc.auth.passwd = g_strdup(key + 10);\n                    } else if (STRPREFIX(key, \"keymap=\")) {\n                        graphics->data.vnc.keymap = g_strdup(key + 7);\n                    } else if (STRPREFIX(key, \"vncdisplay=\")) {\n                        if (virStrToLong_i(key + 11, NULL, 10,\n                                           &graphics->data.vnc.port) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"invalid vncdisplay value '%s'\"),\n                                           key + 11);\n                            goto cleanup;\n                        }\n                        graphics->data.vnc.port += 5900;\n                    }\n                } else {\n                    if (STRPREFIX(key, \"display=\")) {\n                        graphics->data.sdl.display = g_strdup(key + 8);\n                    } else if (STRPREFIX(key, \"xauthority=\")) {\n                        graphics->data.sdl.xauth = g_strdup(key + 11);\n                    }\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n            if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n                if (virDomainGraphicsListenAppendAddress(graphics,\n                                                         listenAddr) < 0)\n                    goto cleanup;\n                VIR_FREE(listenAddr);\n            }\n            if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                goto cleanup;\n            def->graphics[0] = graphics;\n            def->ngraphics = 1;\n            graphics = NULL;\n        } else {\n            if (xenHandleConfGetValueStringListErrors(rc) < 0)\n                goto cleanup;\n        }\n    }\n\n    return 0;\n\n cleanup:\n    virDomainGraphicsDefFree(graphics);\n    VIR_FREE(listenAddr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseEmulatedDevices",
          "args": [
            "conf",
            "def"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseEmulatedDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1394-1409",
          "snippet": "static int\nxenParseEmulatedDevices(virConfPtr conf, virDomainDefPtr def)\n{\n    g_autofree char *str = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (xenConfigGetString(conf, \"soundhw\", &str, NULL) < 0)\n            return -1;\n\n        if (str &&\n            xenParseSxprSound(def, str) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseEmulatedDevices(virConfPtr conf, virDomainDefPtr def)\n{\n    g_autofree char *str = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (xenConfigGetString(conf, \"soundhw\", &str, NULL) < 0)\n            return -1;\n\n        if (str &&\n            xenParseSxprSound(def, str) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParsePCIList",
          "args": [
            "conf",
            "def"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "xenParsePCIList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "468-492",
          "snippet": "static int\nxenParsePCIList(virConfPtr conf, virDomainDefPtr def)\n{\n    VIR_AUTOSTRINGLIST pcis = NULL;\n    char **entries = NULL;\n    int rc;\n\n    if ((rc = virConfGetValueStringList(conf, \"pci\", false, &pcis)) <= 0)\n        return xenHandleConfGetValueStringListErrors(rc);\n\n    for (entries = pcis; *entries; entries++) {\n        char *entry = *entries;\n        virDomainHostdevDefPtr hostdev;\n\n        if (!(hostdev = xenParsePCI(entry)))\n            return -1;\n\n        if (VIR_APPEND_ELEMENT(def->hostdevs, def->nhostdevs, hostdev) < 0) {\n            virDomainHostdevDefFree(hostdev);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParsePCIList(virConfPtr conf, virDomainDefPtr def)\n{\n    VIR_AUTOSTRINGLIST pcis = NULL;\n    char **entries = NULL;\n    int rc;\n\n    if ((rc = virConfGetValueStringList(conf, \"pci\", false, &pcis)) <= 0)\n        return xenHandleConfGetValueStringListErrors(rc);\n\n    for (entries = pcis; *entries; entries++) {\n        char *entry = *entries;\n        virDomainHostdevDefPtr hostdev;\n\n        if (!(hostdev = xenParsePCI(entry)))\n            return -1;\n\n        if (VIR_APPEND_ELEMENT(def->hostdevs, def->nhostdevs, hostdev) < 0) {\n            virDomainHostdevDefFree(hostdev);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"unsupported config type %s\")",
            "nativeFormat"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported config type %s\""
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseVifList",
          "args": [
            "conf",
            "def",
            "\"netfront\""
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseVifList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1284-1310",
          "snippet": "static int\nxenParseVifList(virConfPtr conf, virDomainDefPtr def, const char *vif_typename)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"vif\");\n\n    if (!list || list->type != VIR_CONF_LIST)\n        return 0;\n\n    for (list = list->list; list; list = list->next) {\n        virDomainNetDefPtr net = NULL;\n        int rc;\n\n        if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n            continue;\n\n        if (!(net = xenParseVif(list->str, vif_typename)))\n            return -1;\n\n        rc = VIR_APPEND_ELEMENT(def->nets, def->nnets, net);\n        if (rc < 0) {\n            virDomainNetDefFree(net);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseVifList(virConfPtr conf, virDomainDefPtr def, const char *vif_typename)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"vif\");\n\n    if (!list || list->type != VIR_CONF_LIST)\n        return 0;\n\n    for (list = list->list; list; list = list->next) {\n        virDomainNetDefPtr net = NULL;\n        int rc;\n\n        if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n            continue;\n\n        if (!(net = xenParseVif(list->str, vif_typename)))\n            return -1;\n\n        rc = VIR_APPEND_ELEMENT(def->nets, def->nnets, net);\n        if (rc < 0) {\n            virDomainNetDefFree(net);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "nativeFormat",
            "XEN_CONFIG_FORMAT_XM"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "nativeFormat",
            "XEN_CONFIG_FORMAT_XL"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigCopyStringOpt",
          "args": [
            "conf",
            "\"device_model\"",
            "&def->emulator"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigCopyStringOpt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "168-172",
          "snippet": "int\nxenConfigCopyStringOpt(virConfPtr conf, const char *name, char **value)\n{\n    return xenConfigCopyStringInternal(conf, name, value, 1);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigCopyStringOpt(virConfPtr conf, const char *name, char **value)\n{\n    return xenConfigCopyStringInternal(conf, name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseTimeOffset",
          "args": [
            "conf",
            "def"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseTimeOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "303-330",
          "snippet": "static int\nxenParseTimeOffset(virConfPtr conf, virDomainDefPtr def)\n{\n    int vmlocaltime;\n\n    if (xenConfigGetBool(conf, \"localtime\", &vmlocaltime, 0) < 0)\n        return -1;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        unsigned long rtc_timeoffset;\n        def->clock.offset = VIR_DOMAIN_CLOCK_OFFSET_VARIABLE;\n        if (xenConfigGetULong(conf, \"rtc_timeoffset\", &rtc_timeoffset, 0) < 0)\n            return -1;\n\n        def->clock.data.variable.adjustment = (int)rtc_timeoffset;\n        def->clock.data.variable.basis = vmlocaltime ?\n            VIR_DOMAIN_CLOCK_BASIS_LOCALTIME :\n            VIR_DOMAIN_CLOCK_BASIS_UTC;\n    } else {\n        /* PV domains do not have an emulated RTC and the offset is fixed. */\n        def->clock.offset = vmlocaltime ?\n            VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME :\n            VIR_DOMAIN_CLOCK_OFFSET_UTC;\n        def->clock.data.utc_reset = true;\n    } /* !hvm */\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseTimeOffset(virConfPtr conf, virDomainDefPtr def)\n{\n    int vmlocaltime;\n\n    if (xenConfigGetBool(conf, \"localtime\", &vmlocaltime, 0) < 0)\n        return -1;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        unsigned long rtc_timeoffset;\n        def->clock.offset = VIR_DOMAIN_CLOCK_OFFSET_VARIABLE;\n        if (xenConfigGetULong(conf, \"rtc_timeoffset\", &rtc_timeoffset, 0) < 0)\n            return -1;\n\n        def->clock.data.variable.adjustment = (int)rtc_timeoffset;\n        def->clock.data.variable.basis = vmlocaltime ?\n            VIR_DOMAIN_CLOCK_BASIS_LOCALTIME :\n            VIR_DOMAIN_CLOCK_BASIS_UTC;\n    } else {\n        /* PV domains do not have an emulated RTC and the offset is fixed. */\n        def->clock.offset = vmlocaltime ?\n            VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME :\n            VIR_DOMAIN_CLOCK_OFFSET_UTC;\n        def->clock.data.utc_reset = true;\n    } /* !hvm */\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseCPUFeatures",
          "args": [
            "conf",
            "def",
            "xmlopt"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseCPUFeatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "495-598",
          "snippet": "static int\nxenParseCPUFeatures(virConfPtr conf,\n                    virDomainDefPtr def,\n                    virDomainXMLOptionPtr xmlopt)\n{\n    unsigned long count = 0;\n    g_autofree char *cpus = NULL;\n    g_autofree char *tsc_mode = NULL;\n    int val = 0;\n    virDomainTimerDefPtr timer;\n\n    if (xenConfigGetULong(conf, \"vcpus\", &count, 1) < 0)\n        return -1;\n\n    if (virDomainDefSetVcpusMax(def, count, xmlopt) < 0)\n        return -1;\n\n    if (virDomainDefSetVcpus(def, count) < 0)\n        return -1;\n\n    if (virConfGetValue(conf, \"maxvcpus\")) {\n        if (xenConfigGetULong(conf, \"maxvcpus\", &count, 0) < 0)\n            return -1;\n\n        if (virDomainDefSetVcpusMax(def, count, xmlopt) < 0)\n            return -1;\n    }\n\n    if (xenConfigGetString(conf, \"cpus\", &cpus, NULL) < 0)\n        return -1;\n\n    if (cpus && (virBitmapParse(cpus, &def->cpumask, 4096) < 0))\n        return -1;\n\n    if (xenConfigGetString(conf, \"tsc_mode\", &tsc_mode, NULL) < 0)\n        return -1;\n\n    if (tsc_mode) {\n        if (VIR_EXPAND_N(def->clock.timers, def->clock.ntimers, 1) < 0 ||\n            VIR_ALLOC(timer) < 0)\n            return -1;\n\n        timer->name = VIR_DOMAIN_TIMER_NAME_TSC;\n        timer->present = 1;\n        timer->tickpolicy = -1;\n        timer->mode = VIR_DOMAIN_TIMER_MODE_AUTO;\n        timer->track = -1;\n        if (STREQ_NULLABLE(tsc_mode, \"always_emulate\"))\n            timer->mode = VIR_DOMAIN_TIMER_MODE_EMULATE;\n        else if (STREQ_NULLABLE(tsc_mode, \"native\"))\n            timer->mode = VIR_DOMAIN_TIMER_MODE_NATIVE;\n        else if (STREQ_NULLABLE(tsc_mode, \"native_paravirt\"))\n            timer->mode = VIR_DOMAIN_TIMER_MODE_PARAVIRT;\n\n        def->clock.timers[def->clock.ntimers - 1] = timer;\n    }\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (xenConfigGetBool(conf, \"pae\", &val, 1) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_PAE] = VIR_TRISTATE_SWITCH_ON;\n        if (xenConfigGetBool(conf, \"acpi\", &val, 1) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_ACPI] = VIR_TRISTATE_SWITCH_ON;\n        if (xenConfigGetBool(conf, \"apic\", &val, 1) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_APIC] = VIR_TRISTATE_SWITCH_ON;\n        if (xenConfigGetBool(conf, \"hap\", &val, 1) < 0)\n            return -1;\n\n        else if (!val)\n            def->features[VIR_DOMAIN_FEATURE_HAP] = VIR_TRISTATE_SWITCH_OFF;\n        if (xenConfigGetBool(conf, \"viridian\", &val, 0) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_VIRIDIAN] = VIR_TRISTATE_SWITCH_ON;\n\n        if (xenConfigGetBool(conf, \"hpet\", &val, -1) < 0)\n            return -1;\n\n        if (val != -1) {\n            if (VIR_EXPAND_N(def->clock.timers, def->clock.ntimers, 1) < 0 ||\n                VIR_ALLOC(timer) < 0)\n                return -1;\n\n            timer->name = VIR_DOMAIN_TIMER_NAME_HPET;\n            timer->present = val;\n            timer->tickpolicy = -1;\n            timer->mode = -1;\n            timer->track = -1;\n\n            def->clock.timers[def->clock.ntimers - 1] = timer;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseCPUFeatures(virConfPtr conf,\n                    virDomainDefPtr def,\n                    virDomainXMLOptionPtr xmlopt)\n{\n    unsigned long count = 0;\n    g_autofree char *cpus = NULL;\n    g_autofree char *tsc_mode = NULL;\n    int val = 0;\n    virDomainTimerDefPtr timer;\n\n    if (xenConfigGetULong(conf, \"vcpus\", &count, 1) < 0)\n        return -1;\n\n    if (virDomainDefSetVcpusMax(def, count, xmlopt) < 0)\n        return -1;\n\n    if (virDomainDefSetVcpus(def, count) < 0)\n        return -1;\n\n    if (virConfGetValue(conf, \"maxvcpus\")) {\n        if (xenConfigGetULong(conf, \"maxvcpus\", &count, 0) < 0)\n            return -1;\n\n        if (virDomainDefSetVcpusMax(def, count, xmlopt) < 0)\n            return -1;\n    }\n\n    if (xenConfigGetString(conf, \"cpus\", &cpus, NULL) < 0)\n        return -1;\n\n    if (cpus && (virBitmapParse(cpus, &def->cpumask, 4096) < 0))\n        return -1;\n\n    if (xenConfigGetString(conf, \"tsc_mode\", &tsc_mode, NULL) < 0)\n        return -1;\n\n    if (tsc_mode) {\n        if (VIR_EXPAND_N(def->clock.timers, def->clock.ntimers, 1) < 0 ||\n            VIR_ALLOC(timer) < 0)\n            return -1;\n\n        timer->name = VIR_DOMAIN_TIMER_NAME_TSC;\n        timer->present = 1;\n        timer->tickpolicy = -1;\n        timer->mode = VIR_DOMAIN_TIMER_MODE_AUTO;\n        timer->track = -1;\n        if (STREQ_NULLABLE(tsc_mode, \"always_emulate\"))\n            timer->mode = VIR_DOMAIN_TIMER_MODE_EMULATE;\n        else if (STREQ_NULLABLE(tsc_mode, \"native\"))\n            timer->mode = VIR_DOMAIN_TIMER_MODE_NATIVE;\n        else if (STREQ_NULLABLE(tsc_mode, \"native_paravirt\"))\n            timer->mode = VIR_DOMAIN_TIMER_MODE_PARAVIRT;\n\n        def->clock.timers[def->clock.ntimers - 1] = timer;\n    }\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (xenConfigGetBool(conf, \"pae\", &val, 1) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_PAE] = VIR_TRISTATE_SWITCH_ON;\n        if (xenConfigGetBool(conf, \"acpi\", &val, 1) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_ACPI] = VIR_TRISTATE_SWITCH_ON;\n        if (xenConfigGetBool(conf, \"apic\", &val, 1) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_APIC] = VIR_TRISTATE_SWITCH_ON;\n        if (xenConfigGetBool(conf, \"hap\", &val, 1) < 0)\n            return -1;\n\n        else if (!val)\n            def->features[VIR_DOMAIN_FEATURE_HAP] = VIR_TRISTATE_SWITCH_OFF;\n        if (xenConfigGetBool(conf, \"viridian\", &val, 0) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_VIRIDIAN] = VIR_TRISTATE_SWITCH_ON;\n\n        if (xenConfigGetBool(conf, \"hpet\", &val, -1) < 0)\n            return -1;\n\n        if (val != -1) {\n            if (VIR_EXPAND_N(def->clock.timers, def->clock.ntimers, 1) < 0 ||\n                VIR_ALLOC(timer) < 0)\n                return -1;\n\n            timer->name = VIR_DOMAIN_TIMER_NAME_HPET;\n            timer->present = val;\n            timer->tickpolicy = -1;\n            timer->mode = -1;\n            timer->track = -1;\n\n            def->clock.timers[def->clock.ntimers - 1] = timer;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseEventsActions",
          "args": [
            "conf",
            "def"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseEventsActions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "333-368",
          "snippet": "static int\nxenParseEventsActions(virConfPtr conf, virDomainDefPtr def)\n{\n    g_autofree char *on_poweroff = NULL;\n    g_autofree char *on_reboot = NULL;\n    g_autofree char *on_crash = NULL;\n\n    if (xenConfigGetString(conf, \"on_poweroff\", &on_poweroff, \"destroy\") < 0)\n        return -1;\n\n    if ((def->onPoweroff = virDomainLifecycleActionTypeFromString(on_poweroff)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected value %s for on_poweroff\"), on_poweroff);\n        return -1;\n    }\n\n    if (xenConfigGetString(conf, \"on_reboot\", &on_reboot, \"restart\") < 0)\n        return -1;\n\n    if ((def->onReboot = virDomainLifecycleActionTypeFromString(on_reboot)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected value %s for on_reboot\"), on_reboot);\n        return -1;\n    }\n\n    if (xenConfigGetString(conf, \"on_crash\", &on_crash, \"restart\") < 0)\n        return -1;\n\n    if ((def->onCrash = virDomainLifecycleActionTypeFromString(on_crash)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected value %s for on_crash\"), on_crash);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseEventsActions(virConfPtr conf, virDomainDefPtr def)\n{\n    g_autofree char *on_poweroff = NULL;\n    g_autofree char *on_reboot = NULL;\n    g_autofree char *on_crash = NULL;\n\n    if (xenConfigGetString(conf, \"on_poweroff\", &on_poweroff, \"destroy\") < 0)\n        return -1;\n\n    if ((def->onPoweroff = virDomainLifecycleActionTypeFromString(on_poweroff)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected value %s for on_poweroff\"), on_poweroff);\n        return -1;\n    }\n\n    if (xenConfigGetString(conf, \"on_reboot\", &on_reboot, \"restart\") < 0)\n        return -1;\n\n    if ((def->onReboot = virDomainLifecycleActionTypeFromString(on_reboot)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected value %s for on_reboot\"), on_reboot);\n        return -1;\n    }\n\n    if (xenConfigGetString(conf, \"on_crash\", &on_crash, \"restart\") < 0)\n        return -1;\n\n    if ((def->onCrash = virDomainLifecycleActionTypeFromString(on_crash)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected value %s for on_crash\"), on_crash);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseMem",
          "args": [
            "conf",
            "def"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseMem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "283-300",
          "snippet": "static int\nxenParseMem(virConfPtr conf, virDomainDefPtr def)\n{\n    unsigned long long memory;\n\n    if (xenConfigGetULongLong(conf, \"memory\", &def->mem.cur_balloon,\n                                MIN_XEN_GUEST_SIZE * 2) < 0)\n        return -1;\n\n    if (xenConfigGetULongLong(conf, \"maxmem\", &memory,\n                                def->mem.cur_balloon) < 0)\n        return -1;\n\n    def->mem.cur_balloon *= 1024;\n    virDomainDefSetMemoryTotal(def, memory * 1024);\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseMem(virConfPtr conf, virDomainDefPtr def)\n{\n    unsigned long long memory;\n\n    if (xenConfigGetULongLong(conf, \"memory\", &def->mem.cur_balloon,\n                                MIN_XEN_GUEST_SIZE * 2) < 0)\n        return -1;\n\n    if (xenConfigGetULongLong(conf, \"maxmem\", &memory,\n                                def->mem.cur_balloon) < 0)\n        return -1;\n\n    def->mem.cur_balloon *= 1024;\n    virDomainDefSetMemoryTotal(def, memory * 1024);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseGeneralMeta",
          "args": [
            "conf",
            "def",
            "caps"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseGeneralMeta",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1412-1457",
          "snippet": "static int\nxenParseGeneralMeta(virConfPtr conf, virDomainDefPtr def, virCapsPtr caps)\n{\n    virCapsDomainDataPtr capsdata = NULL;\n    g_autofree char *str = NULL;\n    int ret = -1;\n\n    if (xenConfigCopyString(conf, \"name\", &def->name) < 0)\n        goto out;\n\n    if (xenConfigGetUUID(conf, \"uuid\", def->uuid) < 0)\n        goto out;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_XEN;\n\n    if (xenConfigGetString(conf, \"type\", &str, NULL) == 0 && str) {\n        if (STREQ(str, \"pv\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_XEN;\n        } else if (STREQ(str, \"pvh\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_XENPVH;\n        } else if (STREQ(str, \"hvm\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"type %s is not supported\"), str);\n            return -1;\n        }\n    } else {\n        if ((xenConfigGetString(conf, \"builder\", &str, \"linux\") == 0) &&\n            STREQ(str, \"hvm\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        }\n    }\n\n    if (!(capsdata = virCapabilitiesDomainDataLookup(caps, def->os.type,\n            VIR_ARCH_NONE, def->virtType, NULL, NULL)))\n        goto out;\n\n    def->os.arch = capsdata->arch;\n    def->os.machine = g_strdup(capsdata->machinetype);\n\n    ret = 0;\n out:\n    VIR_FREE(capsdata);\n    return ret;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseGeneralMeta(virConfPtr conf, virDomainDefPtr def, virCapsPtr caps)\n{\n    virCapsDomainDataPtr capsdata = NULL;\n    g_autofree char *str = NULL;\n    int ret = -1;\n\n    if (xenConfigCopyString(conf, \"name\", &def->name) < 0)\n        goto out;\n\n    if (xenConfigGetUUID(conf, \"uuid\", def->uuid) < 0)\n        goto out;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_XEN;\n\n    if (xenConfigGetString(conf, \"type\", &str, NULL) == 0 && str) {\n        if (STREQ(str, \"pv\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_XEN;\n        } else if (STREQ(str, \"pvh\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_XENPVH;\n        } else if (STREQ(str, \"hvm\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"type %s is not supported\"), str);\n            return -1;\n        }\n    } else {\n        if ((xenConfigGetString(conf, \"builder\", &str, \"linux\") == 0) &&\n            STREQ(str, \"hvm\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        }\n    }\n\n    if (!(capsdata = virCapabilitiesDomainDataLookup(caps, def->os.type,\n            VIR_ARCH_NONE, def->virtType, NULL, NULL)))\n        goto out;\n\n    def->os.arch = capsdata->arch;\n    def->os.machine = g_strdup(capsdata->machinetype);\n\n    ret = 0;\n out:\n    VIR_FREE(capsdata);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenParseConfigCommon(virConfPtr conf,\n                     virDomainDefPtr def,\n                     virCapsPtr caps,\n                     const char *nativeFormat,\n                     virDomainXMLOptionPtr xmlopt)\n{\n    if (xenParseGeneralMeta(conf, def, caps) < 0)\n        return -1;\n\n    if (xenParseMem(conf, def) < 0)\n        return -1;\n\n    if (xenParseEventsActions(conf, def) < 0)\n        return -1;\n\n    if (xenParseCPUFeatures(conf, def, xmlopt) < 0)\n        return -1;\n\n    if (xenParseTimeOffset(conf, def) < 0)\n        return -1;\n\n    if (xenConfigCopyStringOpt(conf, \"device_model\", &def->emulator) < 0)\n        return -1;\n\n    if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XL)) {\n        if (xenParseVifList(conf, def, \"vif\") < 0)\n            return -1;\n    } else if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n        if (xenParseVifList(conf, def, \"netfront\") < 0)\n            return -1;\n    } else {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported config type %s\"), nativeFormat);\n        return -1;\n    }\n\n    if (xenParsePCIList(conf, def) < 0)\n        return -1;\n\n    if (xenParseEmulatedDevices(conf, def) < 0)\n        return -1;\n\n    if (xenParseVfb(conf, def) < 0)\n        return -1;\n\n    if (xenParseCharDev(conf, def, nativeFormat) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "xenParseGeneralMeta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1412-1457",
    "snippet": "static int\nxenParseGeneralMeta(virConfPtr conf, virDomainDefPtr def, virCapsPtr caps)\n{\n    virCapsDomainDataPtr capsdata = NULL;\n    g_autofree char *str = NULL;\n    int ret = -1;\n\n    if (xenConfigCopyString(conf, \"name\", &def->name) < 0)\n        goto out;\n\n    if (xenConfigGetUUID(conf, \"uuid\", def->uuid) < 0)\n        goto out;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_XEN;\n\n    if (xenConfigGetString(conf, \"type\", &str, NULL) == 0 && str) {\n        if (STREQ(str, \"pv\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_XEN;\n        } else if (STREQ(str, \"pvh\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_XENPVH;\n        } else if (STREQ(str, \"hvm\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"type %s is not supported\"), str);\n            return -1;\n        }\n    } else {\n        if ((xenConfigGetString(conf, \"builder\", &str, \"linux\") == 0) &&\n            STREQ(str, \"hvm\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        }\n    }\n\n    if (!(capsdata = virCapabilitiesDomainDataLookup(caps, def->os.type,\n            VIR_ARCH_NONE, def->virtType, NULL, NULL)))\n        goto out;\n\n    def->os.arch = capsdata->arch;\n    def->os.machine = g_strdup(capsdata->machinetype);\n\n    ret = 0;\n out:\n    VIR_FREE(capsdata);\n    return ret;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "capsdata"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "capsdata->machinetype"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesDomainDataLookup",
          "args": [
            "caps",
            "def->os.type",
            "VIR_ARCH_NONE",
            "def->virtType",
            "NULL",
            "NULL"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesDomainDataLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "761-784",
          "snippet": "virCapsDomainDataPtr\nvirCapabilitiesDomainDataLookup(virCapsPtr caps,\n                                int ostype,\n                                virArch arch,\n                                int domaintype,\n                                const char *emulator,\n                                const char *machinetype)\n{\n    virCapsDomainDataPtr ret;\n\n    if (arch == VIR_ARCH_NONE) {\n        /* Prefer host arch if its available */\n        ret = virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                      caps->host.arch,\n                                                      domaintype,\n                                                      emulator, machinetype);\n        if (ret)\n            return ret;\n    }\n\n    return virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                   arch, domaintype,\n                                                   emulator, machinetype);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsDomainDataPtr\nvirCapabilitiesDomainDataLookup(virCapsPtr caps,\n                                int ostype,\n                                virArch arch,\n                                int domaintype,\n                                const char *emulator,\n                                const char *machinetype)\n{\n    virCapsDomainDataPtr ret;\n\n    if (arch == VIR_ARCH_NONE) {\n        /* Prefer host arch if its available */\n        ret = virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                      caps->host.arch,\n                                                      domaintype,\n                                                      emulator, machinetype);\n        if (ret)\n            return ret;\n    }\n\n    return virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                   arch, domaintype,\n                                                   emulator, machinetype);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "str",
            "\"hvm\""
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigGetString",
          "args": [
            "conf",
            "\"builder\"",
            "&str",
            "\"linux\""
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "223-243",
          "snippet": "int\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"type %s is not supported\")",
            "str"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"type %s is not supported\""
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "str",
            "\"hvm\""
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "str",
            "\"pvh\""
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "str",
            "\"pv\""
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigGetUUID",
          "args": [
            "conf",
            "\"uuid\"",
            "def->uuid"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "178-217",
          "snippet": "static int\nxenConfigGetUUID(virConfPtr conf, const char *name, unsigned char *uuid)\n{\n    g_autofree char *string = NULL;\n    int rc;\n\n    if (!uuid || !name || !conf) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Arguments must be non null\"));\n        return -1;\n    }\n\n\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0) {\n        if (virUUIDGenerate(uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Failed to generate UUID\"));\n            return -1;\n        } else {\n            return 0;\n        }\n    }\n\n    if (!string) {\n        virReportError(VIR_ERR_CONF_SYNTAX,\n                       _(\"%s can't be empty\"), name);\n        return -1;\n    }\n\n    if (virUUIDParse(string, uuid) < 0) {\n        virReportError(VIR_ERR_CONF_SYNTAX,\n                       _(\"%s not parseable\"), string);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenConfigGetUUID(virConfPtr conf, const char *name, unsigned char *uuid)\n{\n    g_autofree char *string = NULL;\n    int rc;\n\n    if (!uuid || !name || !conf) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Arguments must be non null\"));\n        return -1;\n    }\n\n\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0) {\n        if (virUUIDGenerate(uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Failed to generate UUID\"));\n            return -1;\n        } else {\n            return 0;\n        }\n    }\n\n    if (!string) {\n        virReportError(VIR_ERR_CONF_SYNTAX,\n                       _(\"%s can't be empty\"), name);\n        return -1;\n    }\n\n    if (virUUIDParse(string, uuid) < 0) {\n        virReportError(VIR_ERR_CONF_SYNTAX,\n                       _(\"%s not parseable\"), string);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigCopyString",
          "args": [
            "conf",
            "\"name\"",
            "&def->name"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigCopyStringOpt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "168-172",
          "snippet": "int\nxenConfigCopyStringOpt(virConfPtr conf, const char *name, char **value)\n{\n    return xenConfigCopyStringInternal(conf, name, value, 1);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigCopyStringOpt(virConfPtr conf, const char *name, char **value)\n{\n    return xenConfigCopyStringInternal(conf, name, value, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseGeneralMeta(virConfPtr conf, virDomainDefPtr def, virCapsPtr caps)\n{\n    virCapsDomainDataPtr capsdata = NULL;\n    g_autofree char *str = NULL;\n    int ret = -1;\n\n    if (xenConfigCopyString(conf, \"name\", &def->name) < 0)\n        goto out;\n\n    if (xenConfigGetUUID(conf, \"uuid\", def->uuid) < 0)\n        goto out;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_XEN;\n\n    if (xenConfigGetString(conf, \"type\", &str, NULL) == 0 && str) {\n        if (STREQ(str, \"pv\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_XEN;\n        } else if (STREQ(str, \"pvh\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_XENPVH;\n        } else if (STREQ(str, \"hvm\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"type %s is not supported\"), str);\n            return -1;\n        }\n    } else {\n        if ((xenConfigGetString(conf, \"builder\", &str, \"linux\") == 0) &&\n            STREQ(str, \"hvm\")) {\n            def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        }\n    }\n\n    if (!(capsdata = virCapabilitiesDomainDataLookup(caps, def->os.type,\n            VIR_ARCH_NONE, def->virtType, NULL, NULL)))\n        goto out;\n\n    def->os.arch = capsdata->arch;\n    def->os.machine = g_strdup(capsdata->machinetype);\n\n    ret = 0;\n out:\n    VIR_FREE(capsdata);\n    return ret;\n}"
  },
  {
    "function_name": "xenParseEmulatedDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1394-1409",
    "snippet": "static int\nxenParseEmulatedDevices(virConfPtr conf, virDomainDefPtr def)\n{\n    g_autofree char *str = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (xenConfigGetString(conf, \"soundhw\", &str, NULL) < 0)\n            return -1;\n\n        if (str &&\n            xenParseSxprSound(def, str) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenParseSxprSound",
          "args": [
            "def",
            "str"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseSxprSound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1322-1391",
          "snippet": "static int\nxenParseSxprSound(virDomainDefPtr def,\n                  const char *str)\n{\n    if (STREQ(str, \"all\")) {\n        size_t i;\n\n        /*\n         * Special compatibility code for Xen with a bogus\n         * sound=all in config.\n         *\n         * NB deliberately, don't include all possible\n         * sound models anymore, just the 2 that were\n         * historically present in Xen's QEMU.\n         *\n         * ie just es1370 + sb16.\n         *\n         * Hence use of MODEL_ES1370 + 1, instead of MODEL_LAST\n         */\n\n        if (VIR_ALLOC_N(def->sounds,\n                        VIR_DOMAIN_SOUND_MODEL_ES1370 + 1) < 0)\n            return -1;\n\n\n        for (i = 0; i < (VIR_DOMAIN_SOUND_MODEL_ES1370 + 1); i++) {\n            virDomainSoundDefPtr sound;\n            if (VIR_ALLOC(sound) < 0)\n                return -1;\n            sound->model = i;\n            def->sounds[def->nsounds++] = sound;\n        }\n    } else {\n        char model[10];\n        const char *offset = str, *offset2;\n\n        do {\n            int len;\n            virDomainSoundDefPtr sound;\n            offset2 = strchr(offset, ',');\n            if (offset2)\n                len = (offset2 - offset);\n            else\n                len = strlen(offset);\n            if (virStrncpy(model, offset, len, sizeof(model)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Sound model %s too big for destination\"),\n                               offset);\n                return -1;\n            }\n\n            if (VIR_ALLOC(sound) < 0)\n                return -1;\n\n            if ((sound->model = virDomainSoundModelTypeFromString(model)) < 0) {\n                VIR_FREE(sound);\n                return -1;\n            }\n\n            if (VIR_APPEND_ELEMENT(def->sounds, def->nsounds, sound) < 0) {\n                virDomainSoundDefFree(sound);\n                return -1;\n            }\n\n            offset = offset2 ? offset2 + 1 : NULL;\n        } while (offset);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseSxprSound(virDomainDefPtr def,\n                  const char *str)\n{\n    if (STREQ(str, \"all\")) {\n        size_t i;\n\n        /*\n         * Special compatibility code for Xen with a bogus\n         * sound=all in config.\n         *\n         * NB deliberately, don't include all possible\n         * sound models anymore, just the 2 that were\n         * historically present in Xen's QEMU.\n         *\n         * ie just es1370 + sb16.\n         *\n         * Hence use of MODEL_ES1370 + 1, instead of MODEL_LAST\n         */\n\n        if (VIR_ALLOC_N(def->sounds,\n                        VIR_DOMAIN_SOUND_MODEL_ES1370 + 1) < 0)\n            return -1;\n\n\n        for (i = 0; i < (VIR_DOMAIN_SOUND_MODEL_ES1370 + 1); i++) {\n            virDomainSoundDefPtr sound;\n            if (VIR_ALLOC(sound) < 0)\n                return -1;\n            sound->model = i;\n            def->sounds[def->nsounds++] = sound;\n        }\n    } else {\n        char model[10];\n        const char *offset = str, *offset2;\n\n        do {\n            int len;\n            virDomainSoundDefPtr sound;\n            offset2 = strchr(offset, ',');\n            if (offset2)\n                len = (offset2 - offset);\n            else\n                len = strlen(offset);\n            if (virStrncpy(model, offset, len, sizeof(model)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Sound model %s too big for destination\"),\n                               offset);\n                return -1;\n            }\n\n            if (VIR_ALLOC(sound) < 0)\n                return -1;\n\n            if ((sound->model = virDomainSoundModelTypeFromString(model)) < 0) {\n                VIR_FREE(sound);\n                return -1;\n            }\n\n            if (VIR_APPEND_ELEMENT(def->sounds, def->nsounds, sound) < 0) {\n                virDomainSoundDefFree(sound);\n                return -1;\n            }\n\n            offset = offset2 ? offset2 + 1 : NULL;\n        } while (offset);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigGetString",
          "args": [
            "conf",
            "\"soundhw\"",
            "&str",
            "NULL"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "223-243",
          "snippet": "int\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseEmulatedDevices(virConfPtr conf, virDomainDefPtr def)\n{\n    g_autofree char *str = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (xenConfigGetString(conf, \"soundhw\", &str, NULL) < 0)\n            return -1;\n\n        if (str &&\n            xenParseSxprSound(def, str) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenParseSxprSound",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1322-1391",
    "snippet": "static int\nxenParseSxprSound(virDomainDefPtr def,\n                  const char *str)\n{\n    if (STREQ(str, \"all\")) {\n        size_t i;\n\n        /*\n         * Special compatibility code for Xen with a bogus\n         * sound=all in config.\n         *\n         * NB deliberately, don't include all possible\n         * sound models anymore, just the 2 that were\n         * historically present in Xen's QEMU.\n         *\n         * ie just es1370 + sb16.\n         *\n         * Hence use of MODEL_ES1370 + 1, instead of MODEL_LAST\n         */\n\n        if (VIR_ALLOC_N(def->sounds,\n                        VIR_DOMAIN_SOUND_MODEL_ES1370 + 1) < 0)\n            return -1;\n\n\n        for (i = 0; i < (VIR_DOMAIN_SOUND_MODEL_ES1370 + 1); i++) {\n            virDomainSoundDefPtr sound;\n            if (VIR_ALLOC(sound) < 0)\n                return -1;\n            sound->model = i;\n            def->sounds[def->nsounds++] = sound;\n        }\n    } else {\n        char model[10];\n        const char *offset = str, *offset2;\n\n        do {\n            int len;\n            virDomainSoundDefPtr sound;\n            offset2 = strchr(offset, ',');\n            if (offset2)\n                len = (offset2 - offset);\n            else\n                len = strlen(offset);\n            if (virStrncpy(model, offset, len, sizeof(model)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Sound model %s too big for destination\"),\n                               offset);\n                return -1;\n            }\n\n            if (VIR_ALLOC(sound) < 0)\n                return -1;\n\n            if ((sound->model = virDomainSoundModelTypeFromString(model)) < 0) {\n                VIR_FREE(sound);\n                return -1;\n            }\n\n            if (VIR_APPEND_ELEMENT(def->sounds, def->nsounds, sound) < 0) {\n                virDomainSoundDefFree(sound);\n                return -1;\n            }\n\n            offset = offset2 ? offset2 + 1 : NULL;\n        } while (offset);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainSoundDefFree",
          "args": [
            "sound"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSoundDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2772-2785",
          "snippet": "void virDomainSoundDefFree(virDomainSoundDefPtr def)\n{\n    if (!def)\n        return;\n\n    virDomainDeviceInfoClear(&def->info);\n\n    size_t i;\n    for (i = 0; i < def->ncodecs; i++)\n        virDomainSoundCodecDefFree(def->codecs[i]);\n    VIR_FREE(def->codecs);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def)\n{\n    if (!def)\n        return;\n\n    virDomainDeviceInfoClear(&def->info);\n\n    size_t i;\n    for (i = 0; i < def->ncodecs; i++)\n        virDomainSoundCodecDefFree(def->codecs[i]);\n    VIR_FREE(def->codecs);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->sounds",
            "def->nsounds",
            "sound"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sound"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSoundModelTypeFromString",
          "args": [
            "model"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "sound"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Sound model %s too big for destination\")",
            "offset"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Sound model %s too big for destination\""
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrncpy",
          "args": [
            "model",
            "offset",
            "len",
            "sizeof(model)"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "virStrncpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "746-765",
          "snippet": "int\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "offset"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "offset",
            "','"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "sound"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->sounds",
            "VIR_DOMAIN_SOUND_MODEL_ES1370 + 1"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "str",
            "\"all\""
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseSxprSound(virDomainDefPtr def,\n                  const char *str)\n{\n    if (STREQ(str, \"all\")) {\n        size_t i;\n\n        /*\n         * Special compatibility code for Xen with a bogus\n         * sound=all in config.\n         *\n         * NB deliberately, don't include all possible\n         * sound models anymore, just the 2 that were\n         * historically present in Xen's QEMU.\n         *\n         * ie just es1370 + sb16.\n         *\n         * Hence use of MODEL_ES1370 + 1, instead of MODEL_LAST\n         */\n\n        if (VIR_ALLOC_N(def->sounds,\n                        VIR_DOMAIN_SOUND_MODEL_ES1370 + 1) < 0)\n            return -1;\n\n\n        for (i = 0; i < (VIR_DOMAIN_SOUND_MODEL_ES1370 + 1); i++) {\n            virDomainSoundDefPtr sound;\n            if (VIR_ALLOC(sound) < 0)\n                return -1;\n            sound->model = i;\n            def->sounds[def->nsounds++] = sound;\n        }\n    } else {\n        char model[10];\n        const char *offset = str, *offset2;\n\n        do {\n            int len;\n            virDomainSoundDefPtr sound;\n            offset2 = strchr(offset, ',');\n            if (offset2)\n                len = (offset2 - offset);\n            else\n                len = strlen(offset);\n            if (virStrncpy(model, offset, len, sizeof(model)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Sound model %s too big for destination\"),\n                               offset);\n                return -1;\n            }\n\n            if (VIR_ALLOC(sound) < 0)\n                return -1;\n\n            if ((sound->model = virDomainSoundModelTypeFromString(model)) < 0) {\n                VIR_FREE(sound);\n                return -1;\n            }\n\n            if (VIR_APPEND_ELEMENT(def->sounds, def->nsounds, sound) < 0) {\n                virDomainSoundDefFree(sound);\n                return -1;\n            }\n\n            offset = offset2 ? offset2 + 1 : NULL;\n        } while (offset);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenParseVifList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1284-1310",
    "snippet": "static int\nxenParseVifList(virConfPtr conf, virDomainDefPtr def, const char *vif_typename)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"vif\");\n\n    if (!list || list->type != VIR_CONF_LIST)\n        return 0;\n\n    for (list = list->list; list; list = list->next) {\n        virDomainNetDefPtr net = NULL;\n        int rc;\n\n        if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n            continue;\n\n        if (!(net = xenParseVif(list->str, vif_typename)))\n            return -1;\n\n        rc = VIR_APPEND_ELEMENT(def->nets, def->nnets, net);\n        if (rc < 0) {\n            virDomainNetDefFree(net);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainNetDefFree",
          "args": [
            "net"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2481-2489",
          "snippet": "void\nvirDomainNetDefFree(virDomainNetDefPtr def)\n{\n    if (!def)\n        return;\n    virDomainNetDefClear(def);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainNetDefFree(virDomainNetDefPtr def)\n{\n    if (!def)\n        return;\n    virDomainNetDefClear(def);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->nets",
            "def->nnets",
            "net"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenParseVif",
          "args": [
            "list->str",
            "vif_typename"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseVif",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1105-1281",
          "snippet": "static virDomainNetDefPtr\nxenParseVif(char *entry, const char *vif_typename)\n{\n    virDomainNetDefPtr net = NULL;\n    virDomainNetDefPtr ret = NULL;\n    char *script = NULL;\n    char model[10];\n    char type[10];\n    char ip[128];\n    char mac[18];\n    char bridge[50];\n    char vifname[50];\n    char rate[50];\n    char *key;\n\n    bridge[0] = '\\0';\n    mac[0] = '\\0';\n    ip[0] = '\\0';\n    model[0] = '\\0';\n    type[0] = '\\0';\n    vifname[0] = '\\0';\n    rate[0] = '\\0';\n\n    key = entry;\n    while (key) {\n        char *data;\n        char *nextkey = strchr(key, ',');\n\n        if (!(data = strchr(key, '=')))\n            return NULL;\n        data++;\n\n        if (STRPREFIX(key, \"mac=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(mac, data, len, sizeof(mac)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"MAC address %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"bridge=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(bridge, data, len, sizeof(bridge)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Bridge %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"script=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            VIR_FREE(script);\n            script = g_strndup(data, len);\n        } else if (STRPREFIX(key, \"model=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(model, data, len, sizeof(model)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Model %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"type=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(type, data, len, sizeof(type)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Type %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"vifname=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(vifname, data, len, sizeof(vifname)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Vifname %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"ip=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(ip, data, len, sizeof(ip)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"IP %s too big for destination\"), data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"rate=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(rate, data, len, sizeof(rate)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"rate %s too big for destination\"), data);\n                return NULL;\n            }\n        }\n\n        while (nextkey && (nextkey[0] == ',' ||\n                           nextkey[0] == ' ' ||\n                           nextkey[0] == '\\t'))\n            nextkey++;\n        key = nextkey;\n    }\n\n    if (!(net = virDomainNetDefNew(NULL)))\n        goto cleanup;\n\n    if (mac[0]) {\n        if (virMacAddrParse(mac, &net->mac) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"malformed mac address '%s'\"), mac);\n            goto cleanup;\n        }\n    }\n\n    if (bridge[0] || STREQ_NULLABLE(script, \"vif-bridge\") ||\n        STREQ_NULLABLE(script, \"vif-vnic\")) {\n        net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n    } else {\n        net->type = VIR_DOMAIN_NET_TYPE_ETHERNET;\n    }\n\n    if (net->type == VIR_DOMAIN_NET_TYPE_BRIDGE && bridge[0]) {\n        if (xenParseVifBridge(net, bridge) < 0)\n            goto cleanup;\n    }\n    if (ip[0]) {\n        char **ip_list = virStringSplit(ip, \" \", 0);\n        size_t i;\n\n        if (!ip_list)\n            goto cleanup;\n\n        for (i = 0; ip_list[i]; i++) {\n            if (virDomainNetAppendIPAddress(net, ip_list[i], 0, 0) < 0) {\n                virStringListFree(ip_list);\n                goto cleanup;\n            }\n        }\n        virStringListFree(ip_list);\n    }\n\n    if (script && script[0])\n        net->script = g_strdup(script);\n\n    if (model[0]) {\n        if (virDomainNetSetModelString(net, model) < 0)\n            goto cleanup;\n    } else {\n        if (type[0] && STREQ(type, vif_typename))\n            net->model = VIR_DOMAIN_NET_MODEL_NETFRONT;\n    }\n\n    if (vifname[0])\n        net->ifname = g_strdup(vifname);\n\n    if (rate[0]) {\n        virNetDevBandwidthPtr bandwidth;\n        unsigned long long kbytes_per_sec;\n\n        if (xenParseSxprVifRate(rate, &kbytes_per_sec) < 0)\n            goto cleanup;\n\n        if (VIR_ALLOC(bandwidth) < 0)\n            goto cleanup;\n\n        if (VIR_ALLOC(bandwidth->out) < 0) {\n            VIR_FREE(bandwidth);\n            goto cleanup;\n        }\n\n        bandwidth->out->average = kbytes_per_sec;\n        net->bandwidth = bandwidth;\n    }\n\n    ret = g_steal_pointer(&net);\n\n cleanup:\n    virDomainNetDefFree(net);\n    VIR_FREE(script);\n    return ret;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainNetDefPtr\nxenParseVif(char *entry, const char *vif_typename)\n{\n    virDomainNetDefPtr net = NULL;\n    virDomainNetDefPtr ret = NULL;\n    char *script = NULL;\n    char model[10];\n    char type[10];\n    char ip[128];\n    char mac[18];\n    char bridge[50];\n    char vifname[50];\n    char rate[50];\n    char *key;\n\n    bridge[0] = '\\0';\n    mac[0] = '\\0';\n    ip[0] = '\\0';\n    model[0] = '\\0';\n    type[0] = '\\0';\n    vifname[0] = '\\0';\n    rate[0] = '\\0';\n\n    key = entry;\n    while (key) {\n        char *data;\n        char *nextkey = strchr(key, ',');\n\n        if (!(data = strchr(key, '=')))\n            return NULL;\n        data++;\n\n        if (STRPREFIX(key, \"mac=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(mac, data, len, sizeof(mac)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"MAC address %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"bridge=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(bridge, data, len, sizeof(bridge)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Bridge %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"script=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            VIR_FREE(script);\n            script = g_strndup(data, len);\n        } else if (STRPREFIX(key, \"model=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(model, data, len, sizeof(model)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Model %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"type=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(type, data, len, sizeof(type)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Type %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"vifname=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(vifname, data, len, sizeof(vifname)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Vifname %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"ip=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(ip, data, len, sizeof(ip)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"IP %s too big for destination\"), data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"rate=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(rate, data, len, sizeof(rate)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"rate %s too big for destination\"), data);\n                return NULL;\n            }\n        }\n\n        while (nextkey && (nextkey[0] == ',' ||\n                           nextkey[0] == ' ' ||\n                           nextkey[0] == '\\t'))\n            nextkey++;\n        key = nextkey;\n    }\n\n    if (!(net = virDomainNetDefNew(NULL)))\n        goto cleanup;\n\n    if (mac[0]) {\n        if (virMacAddrParse(mac, &net->mac) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"malformed mac address '%s'\"), mac);\n            goto cleanup;\n        }\n    }\n\n    if (bridge[0] || STREQ_NULLABLE(script, \"vif-bridge\") ||\n        STREQ_NULLABLE(script, \"vif-vnic\")) {\n        net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n    } else {\n        net->type = VIR_DOMAIN_NET_TYPE_ETHERNET;\n    }\n\n    if (net->type == VIR_DOMAIN_NET_TYPE_BRIDGE && bridge[0]) {\n        if (xenParseVifBridge(net, bridge) < 0)\n            goto cleanup;\n    }\n    if (ip[0]) {\n        char **ip_list = virStringSplit(ip, \" \", 0);\n        size_t i;\n\n        if (!ip_list)\n            goto cleanup;\n\n        for (i = 0; ip_list[i]; i++) {\n            if (virDomainNetAppendIPAddress(net, ip_list[i], 0, 0) < 0) {\n                virStringListFree(ip_list);\n                goto cleanup;\n            }\n        }\n        virStringListFree(ip_list);\n    }\n\n    if (script && script[0])\n        net->script = g_strdup(script);\n\n    if (model[0]) {\n        if (virDomainNetSetModelString(net, model) < 0)\n            goto cleanup;\n    } else {\n        if (type[0] && STREQ(type, vif_typename))\n            net->model = VIR_DOMAIN_NET_MODEL_NETFRONT;\n    }\n\n    if (vifname[0])\n        net->ifname = g_strdup(vifname);\n\n    if (rate[0]) {\n        virNetDevBandwidthPtr bandwidth;\n        unsigned long long kbytes_per_sec;\n\n        if (xenParseSxprVifRate(rate, &kbytes_per_sec) < 0)\n            goto cleanup;\n\n        if (VIR_ALLOC(bandwidth) < 0)\n            goto cleanup;\n\n        if (VIR_ALLOC(bandwidth->out) < 0) {\n            VIR_FREE(bandwidth);\n            goto cleanup;\n        }\n\n        bandwidth->out->average = kbytes_per_sec;\n        net->bandwidth = bandwidth;\n    }\n\n    ret = g_steal_pointer(&net);\n\n cleanup:\n    virDomainNetDefFree(net);\n    VIR_FREE(script);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValue",
          "args": [
            "conf",
            "\"vif\""
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "849-857",
          "snippet": "virConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvirConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseVifList(virConfPtr conf, virDomainDefPtr def, const char *vif_typename)\n{\n    virConfValuePtr list = virConfGetValue(conf, \"vif\");\n\n    if (!list || list->type != VIR_CONF_LIST)\n        return 0;\n\n    for (list = list->list; list; list = list->next) {\n        virDomainNetDefPtr net = NULL;\n        int rc;\n\n        if ((list->type != VIR_CONF_STRING) || (list->str == NULL))\n            continue;\n\n        if (!(net = xenParseVif(list->str, vif_typename)))\n            return -1;\n\n        rc = VIR_APPEND_ELEMENT(def->nets, def->nnets, net);\n        if (rc < 0) {\n            virDomainNetDefFree(net);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenParseVif",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1105-1281",
    "snippet": "static virDomainNetDefPtr\nxenParseVif(char *entry, const char *vif_typename)\n{\n    virDomainNetDefPtr net = NULL;\n    virDomainNetDefPtr ret = NULL;\n    char *script = NULL;\n    char model[10];\n    char type[10];\n    char ip[128];\n    char mac[18];\n    char bridge[50];\n    char vifname[50];\n    char rate[50];\n    char *key;\n\n    bridge[0] = '\\0';\n    mac[0] = '\\0';\n    ip[0] = '\\0';\n    model[0] = '\\0';\n    type[0] = '\\0';\n    vifname[0] = '\\0';\n    rate[0] = '\\0';\n\n    key = entry;\n    while (key) {\n        char *data;\n        char *nextkey = strchr(key, ',');\n\n        if (!(data = strchr(key, '=')))\n            return NULL;\n        data++;\n\n        if (STRPREFIX(key, \"mac=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(mac, data, len, sizeof(mac)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"MAC address %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"bridge=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(bridge, data, len, sizeof(bridge)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Bridge %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"script=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            VIR_FREE(script);\n            script = g_strndup(data, len);\n        } else if (STRPREFIX(key, \"model=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(model, data, len, sizeof(model)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Model %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"type=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(type, data, len, sizeof(type)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Type %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"vifname=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(vifname, data, len, sizeof(vifname)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Vifname %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"ip=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(ip, data, len, sizeof(ip)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"IP %s too big for destination\"), data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"rate=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(rate, data, len, sizeof(rate)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"rate %s too big for destination\"), data);\n                return NULL;\n            }\n        }\n\n        while (nextkey && (nextkey[0] == ',' ||\n                           nextkey[0] == ' ' ||\n                           nextkey[0] == '\\t'))\n            nextkey++;\n        key = nextkey;\n    }\n\n    if (!(net = virDomainNetDefNew(NULL)))\n        goto cleanup;\n\n    if (mac[0]) {\n        if (virMacAddrParse(mac, &net->mac) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"malformed mac address '%s'\"), mac);\n            goto cleanup;\n        }\n    }\n\n    if (bridge[0] || STREQ_NULLABLE(script, \"vif-bridge\") ||\n        STREQ_NULLABLE(script, \"vif-vnic\")) {\n        net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n    } else {\n        net->type = VIR_DOMAIN_NET_TYPE_ETHERNET;\n    }\n\n    if (net->type == VIR_DOMAIN_NET_TYPE_BRIDGE && bridge[0]) {\n        if (xenParseVifBridge(net, bridge) < 0)\n            goto cleanup;\n    }\n    if (ip[0]) {\n        char **ip_list = virStringSplit(ip, \" \", 0);\n        size_t i;\n\n        if (!ip_list)\n            goto cleanup;\n\n        for (i = 0; ip_list[i]; i++) {\n            if (virDomainNetAppendIPAddress(net, ip_list[i], 0, 0) < 0) {\n                virStringListFree(ip_list);\n                goto cleanup;\n            }\n        }\n        virStringListFree(ip_list);\n    }\n\n    if (script && script[0])\n        net->script = g_strdup(script);\n\n    if (model[0]) {\n        if (virDomainNetSetModelString(net, model) < 0)\n            goto cleanup;\n    } else {\n        if (type[0] && STREQ(type, vif_typename))\n            net->model = VIR_DOMAIN_NET_MODEL_NETFRONT;\n    }\n\n    if (vifname[0])\n        net->ifname = g_strdup(vifname);\n\n    if (rate[0]) {\n        virNetDevBandwidthPtr bandwidth;\n        unsigned long long kbytes_per_sec;\n\n        if (xenParseSxprVifRate(rate, &kbytes_per_sec) < 0)\n            goto cleanup;\n\n        if (VIR_ALLOC(bandwidth) < 0)\n            goto cleanup;\n\n        if (VIR_ALLOC(bandwidth->out) < 0) {\n            VIR_FREE(bandwidth);\n            goto cleanup;\n        }\n\n        bandwidth->out->average = kbytes_per_sec;\n        net->bandwidth = bandwidth;\n    }\n\n    ret = g_steal_pointer(&net);\n\n cleanup:\n    virDomainNetDefFree(net);\n    VIR_FREE(script);\n    return ret;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "script"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetDefFree",
          "args": [
            "net"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2481-2489",
          "snippet": "void\nvirDomainNetDefFree(virDomainNetDefPtr def)\n{\n    if (!def)\n        return;\n    virDomainNetDefClear(def);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainNetDefFree(virDomainNetDefPtr def)\n{\n    if (!def)\n        return;\n    virDomainNetDefClear(def);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&net"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "bandwidth"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "bandwidth->out"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "bandwidth"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenParseSxprVifRate",
          "args": [
            "rate",
            "&kbytes_per_sec"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseSxprVifRate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "1057-1102",
          "snippet": "static int\nxenParseSxprVifRate(const char *rate, unsigned long long *kbytes_per_sec)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    g_autofree char *trate = NULL;\n    char *p;\n    char *suffix;\n    unsigned long long tmp;\n\n    trate = g_strdup(rate);\n\n    p = strchr(trate, '@');\n    if (p != NULL)\n        *p = 0;\n\n    regex = g_regex_new(vif_bytes_per_sec_re, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (!g_regex_match(regex, trate, 0, NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid rate '%s' specified\"), rate);\n        return -1;\n    }\n\n    if (virStrToLong_ull(rate, &suffix, 10, &tmp)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to parse rate '%s'\"), rate);\n        return -1;\n    }\n\n    if (*suffix == 'G')\n       tmp *= 1024 * 1024;\n    else if (*suffix == 'M')\n       tmp *= 1024;\n\n    if (*suffix == 'b' || *(suffix + 1) == 'b')\n       tmp /= 8;\n\n    *kbytes_per_sec = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *vif_bytes_per_sec_re = \"^[0-9]+[GMK]?[Bb]/s$\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic const char *vif_bytes_per_sec_re = \"^[0-9]+[GMK]?[Bb]/s$\";\n\nstatic int\nxenParseSxprVifRate(const char *rate, unsigned long long *kbytes_per_sec)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    g_autofree char *trate = NULL;\n    char *p;\n    char *suffix;\n    unsigned long long tmp;\n\n    trate = g_strdup(rate);\n\n    p = strchr(trate, '@');\n    if (p != NULL)\n        *p = 0;\n\n    regex = g_regex_new(vif_bytes_per_sec_re, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (!g_regex_match(regex, trate, 0, NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid rate '%s' specified\"), rate);\n        return -1;\n    }\n\n    if (virStrToLong_ull(rate, &suffix, 10, &tmp)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to parse rate '%s'\"), rate);\n        return -1;\n    }\n\n    if (*suffix == 'G')\n       tmp *= 1024 * 1024;\n    else if (*suffix == 'M')\n       tmp *= 1024;\n\n    if (*suffix == 'b' || *(suffix + 1) == 'b')\n       tmp /= 8;\n\n    *kbytes_per_sec = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "vifname"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "type",
            "vif_typename"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetSetModelString",
          "args": [
            "net",
            "model"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetSetModelString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30316-30342",
          "snippet": "int\nvirDomainNetSetModelString(virDomainNetDefPtr net,\n                           const char *model)\n{\n    size_t i;\n\n    VIR_FREE(net->modelstr);\n    net->model = VIR_DOMAIN_NET_MODEL_UNKNOWN;\n    if (!model)\n        return 0;\n\n    for (i = 0; i < G_N_ELEMENTS(virDomainNetModelTypeList); i++) {\n        if (STRCASEEQ(virDomainNetModelTypeList[i], model)) {\n            net->model = i;\n            return 0;\n        }\n    }\n\n    if (strspn(model, NET_MODEL_CHARS) < strlen(model)) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Model name contains invalid characters\"));\n        return -1;\n    }\n\n    net->modelstr = g_strdup(model);\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define NET_MODEL_CHARS \\\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define NET_MODEL_CHARS \\\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-\"\n\nint\nvirDomainNetSetModelString(virDomainNetDefPtr net,\n                           const char *model)\n{\n    size_t i;\n\n    VIR_FREE(net->modelstr);\n    net->model = VIR_DOMAIN_NET_MODEL_UNKNOWN;\n    if (!model)\n        return 0;\n\n    for (i = 0; i < G_N_ELEMENTS(virDomainNetModelTypeList); i++) {\n        if (STRCASEEQ(virDomainNetModelTypeList[i], model)) {\n            net->model = i;\n            return 0;\n        }\n    }\n\n    if (strspn(model, NET_MODEL_CHARS) < strlen(model)) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Model name contains invalid characters\"));\n        return -1;\n    }\n\n    net->modelstr = g_strdup(model);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "ip_list"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetAppendIPAddress",
          "args": [
            "net",
            "ip_list[i]",
            "0",
            "0"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetAppendIPAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "11775-11797",
          "snippet": "int\nvirDomainNetAppendIPAddress(virDomainNetDefPtr def,\n                            const char *address,\n                            int family,\n                            unsigned int prefix)\n{\n    virNetDevIPAddrPtr ipDef = NULL;\n    if (VIR_ALLOC(ipDef) < 0)\n        return -1;\n\n    if (virSocketAddrParse(&ipDef->address, address, family) < 0)\n        goto error;\n    ipDef->prefix = prefix;\n\n    if (VIR_APPEND_ELEMENT(def->guestIP.ips, def->guestIP.nips, ipDef) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FREE(ipDef);\n    return -1;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainNetAppendIPAddress(virDomainNetDefPtr def,\n                            const char *address,\n                            int family,\n                            unsigned int prefix)\n{\n    virNetDevIPAddrPtr ipDef = NULL;\n    if (VIR_ALLOC(ipDef) < 0)\n        return -1;\n\n    if (virSocketAddrParse(&ipDef->address, address, family) < 0)\n        goto error;\n    ipDef->prefix = prefix;\n\n    if (VIR_APPEND_ELEMENT(def->guestIP.ips, def->guestIP.nips, ipDef) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    VIR_FREE(ipDef);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringSplit",
          "args": [
            "ip",
            "\" \"",
            "0"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "126-132",
          "snippet": "char **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseVifBridge",
          "args": [
            "net",
            "bridge"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseVifBridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "986-1052",
          "snippet": "static int\nxenParseVifBridge(virDomainNetDefPtr net, char *bridge)\n{\n    char *vlanstr;\n    unsigned int tag;\n\n    if ((vlanstr = strchr(bridge, '.'))) {\n        /* 'bridge' string contains a bridge name and single vlan tag */\n        net->data.bridge.brname = g_strndup(bridge, vlanstr - bridge);\n\n        vlanstr++;\n        if (virStrToLong_ui(vlanstr, NULL, 10, &tag) < 0)\n            return -1;\n\n        if (VIR_ALLOC_N(net->vlan.tag, 1) < 0)\n            return -1;\n\n        net->vlan.tag[0] = tag;\n        net->vlan.nTags = 1;\n\n        if (VIR_ALLOC(net->virtPortProfile) < 0)\n            return -1;\n\n        net->virtPortProfile->virtPortType = VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH;\n        return 0;\n    } else if ((vlanstr = strchr(bridge, ':'))) {\n        /* 'bridge' string contains a bridge name and one or more vlan trunks */\n        size_t i;\n        size_t nvlans = 0;\n        char **vlanstr_list = virStringSplit(bridge, \":\", 0);\n\n        if (!vlanstr_list)\n            return -1;\n\n        net->data.bridge.brname = g_strdup(vlanstr_list[0]);\n\n        for (i = 1; vlanstr_list[i]; i++)\n            nvlans++;\n\n        if (VIR_ALLOC_N(net->vlan.tag, nvlans) < 0) {\n            virStringListFree(vlanstr_list);\n            return -1;\n        }\n\n        for (i = 1; i <= nvlans; i++) {\n            if (virStrToLong_ui(vlanstr_list[i], NULL, 10, &tag) < 0) {\n                virStringListFree(vlanstr_list);\n                return -1;\n            }\n            net->vlan.tag[i - 1] = tag;\n        }\n        net->vlan.nTags = nvlans;\n        net->vlan.trunk = true;\n        virStringListFree(vlanstr_list);\n\n        if (VIR_ALLOC(net->virtPortProfile) < 0)\n            return -1;\n\n        net->virtPortProfile->virtPortType = VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH;\n        return 0;\n    } else {\n        /* 'bridge' string only contains the bridge name */\n        net->data.bridge.brname = g_strdup(bridge);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseVifBridge(virDomainNetDefPtr net, char *bridge)\n{\n    char *vlanstr;\n    unsigned int tag;\n\n    if ((vlanstr = strchr(bridge, '.'))) {\n        /* 'bridge' string contains a bridge name and single vlan tag */\n        net->data.bridge.brname = g_strndup(bridge, vlanstr - bridge);\n\n        vlanstr++;\n        if (virStrToLong_ui(vlanstr, NULL, 10, &tag) < 0)\n            return -1;\n\n        if (VIR_ALLOC_N(net->vlan.tag, 1) < 0)\n            return -1;\n\n        net->vlan.tag[0] = tag;\n        net->vlan.nTags = 1;\n\n        if (VIR_ALLOC(net->virtPortProfile) < 0)\n            return -1;\n\n        net->virtPortProfile->virtPortType = VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH;\n        return 0;\n    } else if ((vlanstr = strchr(bridge, ':'))) {\n        /* 'bridge' string contains a bridge name and one or more vlan trunks */\n        size_t i;\n        size_t nvlans = 0;\n        char **vlanstr_list = virStringSplit(bridge, \":\", 0);\n\n        if (!vlanstr_list)\n            return -1;\n\n        net->data.bridge.brname = g_strdup(vlanstr_list[0]);\n\n        for (i = 1; vlanstr_list[i]; i++)\n            nvlans++;\n\n        if (VIR_ALLOC_N(net->vlan.tag, nvlans) < 0) {\n            virStringListFree(vlanstr_list);\n            return -1;\n        }\n\n        for (i = 1; i <= nvlans; i++) {\n            if (virStrToLong_ui(vlanstr_list[i], NULL, 10, &tag) < 0) {\n                virStringListFree(vlanstr_list);\n                return -1;\n            }\n            net->vlan.tag[i - 1] = tag;\n        }\n        net->vlan.nTags = nvlans;\n        net->vlan.trunk = true;\n        virStringListFree(vlanstr_list);\n\n        if (VIR_ALLOC(net->virtPortProfile) < 0)\n            return -1;\n\n        net->virtPortProfile->virtPortType = VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH;\n        return 0;\n    } else {\n        /* 'bridge' string only contains the bridge name */\n        net->data.bridge.brname = g_strdup(bridge);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "script",
            "\"vif-vnic\""
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "script",
            "\"vif-bridge\""
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"malformed mac address '%s'\")",
            "mac"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed mac address '%s'\""
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrParse",
          "args": [
            "mac",
            "&net->mac"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "205-218",
          "snippet": "int\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetDefNew",
          "args": [
            "NULL"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "14783-14798",
          "snippet": "virDomainNetDefPtr\nvirDomainNetDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainNetDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (xmlopt && xmlopt->privateData.networkNew &&\n        !(def->privateData = xmlopt->privateData.networkNew())) {\n        virDomainNetDefFree(def);\n        def = NULL;\n    }\n\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainNetDefPtr\nvirDomainNetDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainNetDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (xmlopt && xmlopt->privateData.networkNew &&\n        !(def->privateData = xmlopt->privateData.networkNew())) {\n        virDomainNetDefFree(def);\n        def = NULL;\n    }\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"rate %s too big for destination\")",
            "data"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrncpy",
          "args": [
            "rate",
            "data",
            "len",
            "sizeof(rate)"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "virStrncpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "746-765",
          "snippet": "int\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"rate=\""
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"IP %s too big for destination\")",
            "data"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"ip=\""
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Vifname %s too big for destination\")",
            "data"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"vifname=\""
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Type %s too big for destination\")",
            "data"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"type=\""
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Model %s too big for destination\")",
            "data"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"model=\""
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "data",
            "len"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "script"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"script=\""
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Bridge %s too big for destination\")",
            "data"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"bridge=\""
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"MAC address %s too big for destination\")",
            "data"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "data"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"mac=\""
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "key",
            "'='"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "key",
            "','"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainNetDefPtr\nxenParseVif(char *entry, const char *vif_typename)\n{\n    virDomainNetDefPtr net = NULL;\n    virDomainNetDefPtr ret = NULL;\n    char *script = NULL;\n    char model[10];\n    char type[10];\n    char ip[128];\n    char mac[18];\n    char bridge[50];\n    char vifname[50];\n    char rate[50];\n    char *key;\n\n    bridge[0] = '\\0';\n    mac[0] = '\\0';\n    ip[0] = '\\0';\n    model[0] = '\\0';\n    type[0] = '\\0';\n    vifname[0] = '\\0';\n    rate[0] = '\\0';\n\n    key = entry;\n    while (key) {\n        char *data;\n        char *nextkey = strchr(key, ',');\n\n        if (!(data = strchr(key, '=')))\n            return NULL;\n        data++;\n\n        if (STRPREFIX(key, \"mac=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(mac, data, len, sizeof(mac)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"MAC address %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"bridge=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(bridge, data, len, sizeof(bridge)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Bridge %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"script=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            VIR_FREE(script);\n            script = g_strndup(data, len);\n        } else if (STRPREFIX(key, \"model=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(model, data, len, sizeof(model)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Model %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"type=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(type, data, len, sizeof(type)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Type %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"vifname=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(vifname, data, len, sizeof(vifname)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Vifname %s too big for destination\"),\n                               data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"ip=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(ip, data, len, sizeof(ip)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"IP %s too big for destination\"), data);\n                return NULL;\n            }\n        } else if (STRPREFIX(key, \"rate=\")) {\n            int len = nextkey ? (nextkey - data) : strlen(data);\n            if (virStrncpy(rate, data, len, sizeof(rate)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"rate %s too big for destination\"), data);\n                return NULL;\n            }\n        }\n\n        while (nextkey && (nextkey[0] == ',' ||\n                           nextkey[0] == ' ' ||\n                           nextkey[0] == '\\t'))\n            nextkey++;\n        key = nextkey;\n    }\n\n    if (!(net = virDomainNetDefNew(NULL)))\n        goto cleanup;\n\n    if (mac[0]) {\n        if (virMacAddrParse(mac, &net->mac) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"malformed mac address '%s'\"), mac);\n            goto cleanup;\n        }\n    }\n\n    if (bridge[0] || STREQ_NULLABLE(script, \"vif-bridge\") ||\n        STREQ_NULLABLE(script, \"vif-vnic\")) {\n        net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n    } else {\n        net->type = VIR_DOMAIN_NET_TYPE_ETHERNET;\n    }\n\n    if (net->type == VIR_DOMAIN_NET_TYPE_BRIDGE && bridge[0]) {\n        if (xenParseVifBridge(net, bridge) < 0)\n            goto cleanup;\n    }\n    if (ip[0]) {\n        char **ip_list = virStringSplit(ip, \" \", 0);\n        size_t i;\n\n        if (!ip_list)\n            goto cleanup;\n\n        for (i = 0; ip_list[i]; i++) {\n            if (virDomainNetAppendIPAddress(net, ip_list[i], 0, 0) < 0) {\n                virStringListFree(ip_list);\n                goto cleanup;\n            }\n        }\n        virStringListFree(ip_list);\n    }\n\n    if (script && script[0])\n        net->script = g_strdup(script);\n\n    if (model[0]) {\n        if (virDomainNetSetModelString(net, model) < 0)\n            goto cleanup;\n    } else {\n        if (type[0] && STREQ(type, vif_typename))\n            net->model = VIR_DOMAIN_NET_MODEL_NETFRONT;\n    }\n\n    if (vifname[0])\n        net->ifname = g_strdup(vifname);\n\n    if (rate[0]) {\n        virNetDevBandwidthPtr bandwidth;\n        unsigned long long kbytes_per_sec;\n\n        if (xenParseSxprVifRate(rate, &kbytes_per_sec) < 0)\n            goto cleanup;\n\n        if (VIR_ALLOC(bandwidth) < 0)\n            goto cleanup;\n\n        if (VIR_ALLOC(bandwidth->out) < 0) {\n            VIR_FREE(bandwidth);\n            goto cleanup;\n        }\n\n        bandwidth->out->average = kbytes_per_sec;\n        net->bandwidth = bandwidth;\n    }\n\n    ret = g_steal_pointer(&net);\n\n cleanup:\n    virDomainNetDefFree(net);\n    VIR_FREE(script);\n    return ret;\n}"
  },
  {
    "function_name": "xenParseSxprVifRate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "1057-1102",
    "snippet": "static int\nxenParseSxprVifRate(const char *rate, unsigned long long *kbytes_per_sec)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    g_autofree char *trate = NULL;\n    char *p;\n    char *suffix;\n    unsigned long long tmp;\n\n    trate = g_strdup(rate);\n\n    p = strchr(trate, '@');\n    if (p != NULL)\n        *p = 0;\n\n    regex = g_regex_new(vif_bytes_per_sec_re, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (!g_regex_match(regex, trate, 0, NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid rate '%s' specified\"), rate);\n        return -1;\n    }\n\n    if (virStrToLong_ull(rate, &suffix, 10, &tmp)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to parse rate '%s'\"), rate);\n        return -1;\n    }\n\n    if (*suffix == 'G')\n       tmp *= 1024 * 1024;\n    else if (*suffix == 'M')\n       tmp *= 1024;\n\n    if (*suffix == 'b' || *(suffix + 1) == 'b')\n       tmp /= 8;\n\n    *kbytes_per_sec = tmp;\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *vif_bytes_per_sec_re = \"^[0-9]+[GMK]?[Bb]/s$\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to parse rate '%s'\")",
            "rate"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to parse rate '%s'\""
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ull",
          "args": [
            "rate",
            "&suffix",
            "10",
            "&tmp"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid rate '%s' specified\")",
            "rate"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_regex_match",
          "args": [
            "regex",
            "trate",
            "0",
            "NULL"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to compile regex %s\")",
            "err->message"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_regex_new",
          "args": [
            "vif_bytes_per_sec_re",
            "0",
            "0",
            "&err"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "trate",
            "'@'"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "rate"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic const char *vif_bytes_per_sec_re = \"^[0-9]+[GMK]?[Bb]/s$\";\n\nstatic int\nxenParseSxprVifRate(const char *rate, unsigned long long *kbytes_per_sec)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    g_autofree char *trate = NULL;\n    char *p;\n    char *suffix;\n    unsigned long long tmp;\n\n    trate = g_strdup(rate);\n\n    p = strchr(trate, '@');\n    if (p != NULL)\n        *p = 0;\n\n    regex = g_regex_new(vif_bytes_per_sec_re, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (!g_regex_match(regex, trate, 0, NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid rate '%s' specified\"), rate);\n        return -1;\n    }\n\n    if (virStrToLong_ull(rate, &suffix, 10, &tmp)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to parse rate '%s'\"), rate);\n        return -1;\n    }\n\n    if (*suffix == 'G')\n       tmp *= 1024 * 1024;\n    else if (*suffix == 'M')\n       tmp *= 1024;\n\n    if (*suffix == 'b' || *(suffix + 1) == 'b')\n       tmp /= 8;\n\n    *kbytes_per_sec = tmp;\n    return 0;\n}"
  },
  {
    "function_name": "xenParseVifBridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "986-1052",
    "snippet": "static int\nxenParseVifBridge(virDomainNetDefPtr net, char *bridge)\n{\n    char *vlanstr;\n    unsigned int tag;\n\n    if ((vlanstr = strchr(bridge, '.'))) {\n        /* 'bridge' string contains a bridge name and single vlan tag */\n        net->data.bridge.brname = g_strndup(bridge, vlanstr - bridge);\n\n        vlanstr++;\n        if (virStrToLong_ui(vlanstr, NULL, 10, &tag) < 0)\n            return -1;\n\n        if (VIR_ALLOC_N(net->vlan.tag, 1) < 0)\n            return -1;\n\n        net->vlan.tag[0] = tag;\n        net->vlan.nTags = 1;\n\n        if (VIR_ALLOC(net->virtPortProfile) < 0)\n            return -1;\n\n        net->virtPortProfile->virtPortType = VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH;\n        return 0;\n    } else if ((vlanstr = strchr(bridge, ':'))) {\n        /* 'bridge' string contains a bridge name and one or more vlan trunks */\n        size_t i;\n        size_t nvlans = 0;\n        char **vlanstr_list = virStringSplit(bridge, \":\", 0);\n\n        if (!vlanstr_list)\n            return -1;\n\n        net->data.bridge.brname = g_strdup(vlanstr_list[0]);\n\n        for (i = 1; vlanstr_list[i]; i++)\n            nvlans++;\n\n        if (VIR_ALLOC_N(net->vlan.tag, nvlans) < 0) {\n            virStringListFree(vlanstr_list);\n            return -1;\n        }\n\n        for (i = 1; i <= nvlans; i++) {\n            if (virStrToLong_ui(vlanstr_list[i], NULL, 10, &tag) < 0) {\n                virStringListFree(vlanstr_list);\n                return -1;\n            }\n            net->vlan.tag[i - 1] = tag;\n        }\n        net->vlan.nTags = nvlans;\n        net->vlan.trunk = true;\n        virStringListFree(vlanstr_list);\n\n        if (VIR_ALLOC(net->virtPortProfile) < 0)\n            return -1;\n\n        net->virtPortProfile->virtPortType = VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH;\n        return 0;\n    } else {\n        /* 'bridge' string only contains the bridge name */\n        net->data.bridge.brname = g_strdup(bridge);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "bridge"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "net->virtPortProfile"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "vlanstr_list"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "vlanstr_list[i]",
            "NULL",
            "10",
            "&tag"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "net->vlan.tag",
            "nvlans"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSplit",
          "args": [
            "bridge",
            "\":\"",
            "0"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSplit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "126-132",
          "snippet": "char **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar **\nvirStringSplit(const char *string,\n               const char *delim,\n               size_t max_tokens)\n{\n    return virStringSplitCount(string, delim, max_tokens, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "bridge",
            "':'"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "net->virtPortProfile"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "net->vlan.tag",
            "1"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "bridge",
            "vlanstr - bridge"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "bridge",
            "'.'"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseVifBridge(virDomainNetDefPtr net, char *bridge)\n{\n    char *vlanstr;\n    unsigned int tag;\n\n    if ((vlanstr = strchr(bridge, '.'))) {\n        /* 'bridge' string contains a bridge name and single vlan tag */\n        net->data.bridge.brname = g_strndup(bridge, vlanstr - bridge);\n\n        vlanstr++;\n        if (virStrToLong_ui(vlanstr, NULL, 10, &tag) < 0)\n            return -1;\n\n        if (VIR_ALLOC_N(net->vlan.tag, 1) < 0)\n            return -1;\n\n        net->vlan.tag[0] = tag;\n        net->vlan.nTags = 1;\n\n        if (VIR_ALLOC(net->virtPortProfile) < 0)\n            return -1;\n\n        net->virtPortProfile->virtPortType = VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH;\n        return 0;\n    } else if ((vlanstr = strchr(bridge, ':'))) {\n        /* 'bridge' string contains a bridge name and one or more vlan trunks */\n        size_t i;\n        size_t nvlans = 0;\n        char **vlanstr_list = virStringSplit(bridge, \":\", 0);\n\n        if (!vlanstr_list)\n            return -1;\n\n        net->data.bridge.brname = g_strdup(vlanstr_list[0]);\n\n        for (i = 1; vlanstr_list[i]; i++)\n            nvlans++;\n\n        if (VIR_ALLOC_N(net->vlan.tag, nvlans) < 0) {\n            virStringListFree(vlanstr_list);\n            return -1;\n        }\n\n        for (i = 1; i <= nvlans; i++) {\n            if (virStrToLong_ui(vlanstr_list[i], NULL, 10, &tag) < 0) {\n                virStringListFree(vlanstr_list);\n                return -1;\n            }\n            net->vlan.tag[i - 1] = tag;\n        }\n        net->vlan.nTags = nvlans;\n        net->vlan.trunk = true;\n        virStringListFree(vlanstr_list);\n\n        if (VIR_ALLOC(net->virtPortProfile) < 0)\n            return -1;\n\n        net->virtPortProfile->virtPortType = VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH;\n        return 0;\n    } else {\n        /* 'bridge' string only contains the bridge name */\n        net->data.bridge.brname = g_strdup(bridge);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenParseCharDev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "895-983",
    "snippet": "static int\nxenParseCharDev(virConfPtr conf, virDomainDefPtr def, const char *nativeFormat)\n{\n    VIR_AUTOSTRINGLIST serials = NULL;\n    virDomainChrDefPtr chr = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        g_autofree char *parallel = NULL;\n        int rc;\n\n        if (xenConfigGetString(conf, \"parallel\", &parallel, NULL) < 0)\n            goto cleanup;\n        if (parallel && STRNEQ(parallel, \"none\") &&\n            !(chr = xenParseSxprChar(parallel, NULL)))\n            goto cleanup;\n        if (chr) {\n            if (VIR_ALLOC_N(def->parallels, 1) < 0)\n                goto cleanup;\n\n            chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_PARALLEL;\n            chr->target.port = 0;\n            def->parallels[0] = chr;\n            def->nparallels++;\n            chr = NULL;\n        }\n\n        /* Try to get the list of values to support multiple serial ports */\n        if ((rc = virConfGetValueStringList(conf, \"serial\", false, &serials)) == 1) {\n            char **entries;\n            int portnum = -1;\n\n            if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple serial devices are not supported by xen-xm\"));\n                goto cleanup;\n            }\n\n            for (entries = serials; *entries; entries++) {\n                char *port = *entries;\n\n                portnum++;\n                if (STREQ(port, \"none\"))\n                    continue;\n\n                if (!(chr = xenParseSxprChar(port, NULL)))\n                    goto cleanup;\n                chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n                chr->target.port = portnum;\n                if (VIR_APPEND_ELEMENT(def->serials, def->nserials, chr) < 0)\n                    goto cleanup;\n            }\n        } else {\n            g_autofree char *serial = NULL;\n\n            if (xenHandleConfGetValueStringListErrors(rc) < 0)\n                goto cleanup;\n\n            /* If domain is not using multiple serial ports we parse data old way */\n            if (xenConfigGetString(conf, \"serial\", &serial, NULL) < 0)\n                goto cleanup;\n            if (serial && STRNEQ(serial, \"none\") &&\n                !(chr = xenParseSxprChar(serial, NULL)))\n                goto cleanup;\n            if (chr) {\n                if (VIR_ALLOC_N(def->serials, 1) < 0)\n                    goto cleanup;\n                chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n                chr->target.port = 0;\n                def->serials[0] = chr;\n                def->nserials++;\n            }\n        }\n    } else {\n        if (VIR_ALLOC_N(def->consoles, 1) < 0)\n            goto cleanup;\n        def->nconsoles = 1;\n        if (!(def->consoles[0] = xenParseSxprChar(\"pty\", NULL)))\n            goto cleanup;\n        def->consoles[0]->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE;\n        def->consoles[0]->target.port = 0;\n        def->consoles[0]->targetType = VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_XEN;\n    }\n\n    return 0;\n\n cleanup:\n    virDomainChrDefFree(chr);\n    return -1;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainChrDefFree",
          "args": [
            "chr"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2706-2733",
          "snippet": "void virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenParseSxprChar",
          "args": [
            "\"pty\"",
            "NULL"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "xenParseSxprChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "763-892",
          "snippet": "static virDomainChrDefPtr\nxenParseSxprChar(const char *value,\n                 const char *tty)\n{\n    const char *prefix;\n    char *tmp;\n    virDomainChrDefPtr def;\n\n    if (!(def = virDomainChrDefNew(NULL)))\n        return NULL;\n\n    prefix = value;\n\n    if (value[0] == '/') {\n        def->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        def->source->data.file.path = g_strdup(value);\n    } else {\n        if ((tmp = strchr(value, ':')) != NULL) {\n            *tmp = '\\0';\n            value = tmp + 1;\n        }\n\n        if (STRPREFIX(prefix, \"telnet\")) {\n            def->source->type = VIR_DOMAIN_CHR_TYPE_TCP;\n            def->source->data.tcp.protocol = VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET;\n        } else {\n            if ((def->source->type = virDomainChrTypeFromString(prefix)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unknown chr device type '%s'\"), prefix);\n                goto error;\n            }\n        }\n    }\n\n    switch (def->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        def->source->data.file.path = g_strdup(tty);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        def->source->data.file.path = g_strdup(value);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    {\n        const char *offset = strchr(value, ':');\n        const char *offset2;\n\n        if (offset == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed char device string\"));\n            goto error;\n        }\n\n        if (offset != value)\n            def->source->data.tcp.host = g_strndup(value, offset - value);\n\n        offset2 = strchr(offset, ',');\n        offset++;\n        if (offset2)\n            def->source->data.tcp.service = g_strndup(offset,\n                                                      offset2 - offset);\n        else\n            def->source->data.tcp.service = g_strdup(offset);\n\n        if (offset2 && strstr(offset2, \",server\"))\n            def->source->data.tcp.listen = true;\n    }\n    break;\n\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    {\n        const char *offset = strchr(value, ':');\n        const char *offset2, *offset3;\n\n        if (offset == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed char device string\"));\n            goto error;\n        }\n\n        if (offset != value)\n            def->source->data.udp.connectHost = g_strndup(value,\n                                                          offset - value);\n\n        offset2 = strchr(offset, '@');\n        if (offset2 != NULL) {\n            def->source->data.udp.connectService = g_strndup(offset + 1,\n                                                             offset2 - offset - 1);\n\n            offset3 = strchr(offset2, ':');\n            if (offset3 == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               \"%s\", _(\"malformed char device string\"));\n                goto error;\n            }\n\n            if (offset3 > (offset2 + 1))\n                def->source->data.udp.bindHost = g_strndup(offset2 + 1,\n                                                           offset3 - offset2 - 1);\n\n            def->source->data.udp.bindService = g_strdup(offset3 + 1);\n        } else {\n            def->source->data.udp.connectService = g_strdup(offset + 1);\n        }\n    }\n    break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n    {\n        const char *offset = strchr(value, ',');\n        if (offset)\n            def->source->data.nix.path = g_strndup(value, offset - value);\n        else\n            def->source->data.nix.path = g_strdup(value);\n\n        if (offset != NULL &&\n            strstr(offset, \",server\") != NULL)\n            def->source->data.nix.listen = true;\n    }\n    break;\n    }\n\n    return def;\n\n error:\n    virDomainChrDefFree(def);\n    return NULL;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainChrDefPtr\nxenParseSxprChar(const char *value,\n                 const char *tty)\n{\n    const char *prefix;\n    char *tmp;\n    virDomainChrDefPtr def;\n\n    if (!(def = virDomainChrDefNew(NULL)))\n        return NULL;\n\n    prefix = value;\n\n    if (value[0] == '/') {\n        def->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        def->source->data.file.path = g_strdup(value);\n    } else {\n        if ((tmp = strchr(value, ':')) != NULL) {\n            *tmp = '\\0';\n            value = tmp + 1;\n        }\n\n        if (STRPREFIX(prefix, \"telnet\")) {\n            def->source->type = VIR_DOMAIN_CHR_TYPE_TCP;\n            def->source->data.tcp.protocol = VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET;\n        } else {\n            if ((def->source->type = virDomainChrTypeFromString(prefix)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unknown chr device type '%s'\"), prefix);\n                goto error;\n            }\n        }\n    }\n\n    switch (def->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        def->source->data.file.path = g_strdup(tty);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        def->source->data.file.path = g_strdup(value);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    {\n        const char *offset = strchr(value, ':');\n        const char *offset2;\n\n        if (offset == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed char device string\"));\n            goto error;\n        }\n\n        if (offset != value)\n            def->source->data.tcp.host = g_strndup(value, offset - value);\n\n        offset2 = strchr(offset, ',');\n        offset++;\n        if (offset2)\n            def->source->data.tcp.service = g_strndup(offset,\n                                                      offset2 - offset);\n        else\n            def->source->data.tcp.service = g_strdup(offset);\n\n        if (offset2 && strstr(offset2, \",server\"))\n            def->source->data.tcp.listen = true;\n    }\n    break;\n\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    {\n        const char *offset = strchr(value, ':');\n        const char *offset2, *offset3;\n\n        if (offset == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed char device string\"));\n            goto error;\n        }\n\n        if (offset != value)\n            def->source->data.udp.connectHost = g_strndup(value,\n                                                          offset - value);\n\n        offset2 = strchr(offset, '@');\n        if (offset2 != NULL) {\n            def->source->data.udp.connectService = g_strndup(offset + 1,\n                                                             offset2 - offset - 1);\n\n            offset3 = strchr(offset2, ':');\n            if (offset3 == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               \"%s\", _(\"malformed char device string\"));\n                goto error;\n            }\n\n            if (offset3 > (offset2 + 1))\n                def->source->data.udp.bindHost = g_strndup(offset2 + 1,\n                                                           offset3 - offset2 - 1);\n\n            def->source->data.udp.bindService = g_strdup(offset3 + 1);\n        } else {\n            def->source->data.udp.connectService = g_strdup(offset + 1);\n        }\n    }\n    break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n    {\n        const char *offset = strchr(value, ',');\n        if (offset)\n            def->source->data.nix.path = g_strndup(value, offset - value);\n        else\n            def->source->data.nix.path = g_strdup(value);\n\n        if (offset != NULL &&\n            strstr(offset, \",server\") != NULL)\n            def->source->data.nix.listen = true;\n    }\n    break;\n    }\n\n    return def;\n\n error:\n    virDomainChrDefFree(def);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->consoles",
            "1"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->serials",
            "1"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "serial",
            "\"none\""
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigGetString",
          "args": [
            "conf",
            "\"serial\"",
            "&serial",
            "NULL"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "223-243",
          "snippet": "int\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenHandleConfGetValueStringListErrors",
          "args": [
            "rc"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "xenHandleConfGetValueStringListErrors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "448-465",
          "snippet": "static int\nxenHandleConfGetValueStringListErrors(int ret)\n{\n    if (ret < 0) {\n        /* It means virConfGetValueStringList() didn't fail because the\n         * cval->type switch fell through - since we're passing\n         * @compatString == false - assumes failures for memory allocation\n         * and VIR_CONF_LIST traversal failure should cause -1 to be\n         * returned to the caller with the error message set. */\n        if (virGetLastErrorCode() != VIR_ERR_INTERNAL_ERROR)\n            return -1;\n\n        /* If we did fall through the switch, then ignore and clear the\n         * last error. */\n        virResetLastError();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenHandleConfGetValueStringListErrors(int ret)\n{\n    if (ret < 0) {\n        /* It means virConfGetValueStringList() didn't fail because the\n         * cval->type switch fell through - since we're passing\n         * @compatString == false - assumes failures for memory allocation\n         * and VIR_CONF_LIST traversal failure should cause -1 to be\n         * returned to the caller with the error message set. */\n        if (virGetLastErrorCode() != VIR_ERR_INTERNAL_ERROR)\n            return -1;\n\n        /* If we did fall through the switch, then ignore and clear the\n         * last error. */\n        virResetLastError();\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->serials",
            "def->nserials",
            "chr"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "port",
            "\"none\""
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Multiple serial devices are not supported by xen-xm\")"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Multiple serial devices are not supported by xen-xm\""
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "nativeFormat",
            "XEN_CONFIG_FORMAT_XM"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfGetValueStringList",
          "args": [
            "conf",
            "\"serial\"",
            "false",
            "&serials"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueStringList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "920-984",
          "snippet": "int virConfGetValueStringList(virConfPtr conf,\n                              const char *setting,\n                              bool compatString,\n                              char ***values)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    size_t len;\n    virConfValuePtr eval;\n\n    VIR_DEBUG(\"Get value string list %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    virStringListFree(*values);\n    *values = NULL;\n\n    switch (cval->type) {\n    case VIR_CONF_LIST:\n        /* Calc length and check items */\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next) {\n            if (eval->type != VIR_CONF_STRING) {\n                virReportError(VIR_ERR_CONF_SYNTAX,\n                               _(\"%s: expected a string list for '%s' parameter\"),\n                               conf->filename, setting);\n                return -1;\n            }\n        }\n\n        if (VIR_ALLOC_N(*values, len + 1) < 0)\n            return -1;\n\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next)\n            (*values)[len] = g_strdup(eval->str);\n        break;\n\n    case VIR_CONF_STRING:\n        if (compatString) {\n            if (VIR_ALLOC_N(*values, cval->str ? 2 : 1) < 0)\n                return -1;\n            if (cval->str)\n                (*values)[0] = g_strdup(cval->str);\n            break;\n        }\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_CONF_LLONG:\n    case VIR_CONF_ULLONG:\n    case VIR_CONF_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       compatString ?\n                       _(\"%s: expected a string or string list for '%s' parameter\") :\n                       _(\"%s: expected a string list for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n\n    case VIR_CONF_LAST:\n    default:\n        virReportEnumRangeError(virConfType, cval->type);\n        return -1;\n    }\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueStringList(virConfPtr conf,\n                              const char *setting,\n                              bool compatString,\n                              char ***values)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    size_t len;\n    virConfValuePtr eval;\n\n    VIR_DEBUG(\"Get value string list %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    virStringListFree(*values);\n    *values = NULL;\n\n    switch (cval->type) {\n    case VIR_CONF_LIST:\n        /* Calc length and check items */\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next) {\n            if (eval->type != VIR_CONF_STRING) {\n                virReportError(VIR_ERR_CONF_SYNTAX,\n                               _(\"%s: expected a string list for '%s' parameter\"),\n                               conf->filename, setting);\n                return -1;\n            }\n        }\n\n        if (VIR_ALLOC_N(*values, len + 1) < 0)\n            return -1;\n\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next)\n            (*values)[len] = g_strdup(eval->str);\n        break;\n\n    case VIR_CONF_STRING:\n        if (compatString) {\n            if (VIR_ALLOC_N(*values, cval->str ? 2 : 1) < 0)\n                return -1;\n            if (cval->str)\n                (*values)[0] = g_strdup(cval->str);\n            break;\n        }\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_CONF_LLONG:\n    case VIR_CONF_ULLONG:\n    case VIR_CONF_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       compatString ?\n                       _(\"%s: expected a string or string list for '%s' parameter\") :\n                       _(\"%s: expected a string list for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n\n    case VIR_CONF_LAST:\n    default:\n        virReportEnumRangeError(virConfType, cval->type);\n        return -1;\n    }\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->parallels",
            "1"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "parallel",
            "\"none\""
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseCharDev(virConfPtr conf, virDomainDefPtr def, const char *nativeFormat)\n{\n    VIR_AUTOSTRINGLIST serials = NULL;\n    virDomainChrDefPtr chr = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        g_autofree char *parallel = NULL;\n        int rc;\n\n        if (xenConfigGetString(conf, \"parallel\", &parallel, NULL) < 0)\n            goto cleanup;\n        if (parallel && STRNEQ(parallel, \"none\") &&\n            !(chr = xenParseSxprChar(parallel, NULL)))\n            goto cleanup;\n        if (chr) {\n            if (VIR_ALLOC_N(def->parallels, 1) < 0)\n                goto cleanup;\n\n            chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_PARALLEL;\n            chr->target.port = 0;\n            def->parallels[0] = chr;\n            def->nparallels++;\n            chr = NULL;\n        }\n\n        /* Try to get the list of values to support multiple serial ports */\n        if ((rc = virConfGetValueStringList(conf, \"serial\", false, &serials)) == 1) {\n            char **entries;\n            int portnum = -1;\n\n            if (STREQ(nativeFormat, XEN_CONFIG_FORMAT_XM)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Multiple serial devices are not supported by xen-xm\"));\n                goto cleanup;\n            }\n\n            for (entries = serials; *entries; entries++) {\n                char *port = *entries;\n\n                portnum++;\n                if (STREQ(port, \"none\"))\n                    continue;\n\n                if (!(chr = xenParseSxprChar(port, NULL)))\n                    goto cleanup;\n                chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n                chr->target.port = portnum;\n                if (VIR_APPEND_ELEMENT(def->serials, def->nserials, chr) < 0)\n                    goto cleanup;\n            }\n        } else {\n            g_autofree char *serial = NULL;\n\n            if (xenHandleConfGetValueStringListErrors(rc) < 0)\n                goto cleanup;\n\n            /* If domain is not using multiple serial ports we parse data old way */\n            if (xenConfigGetString(conf, \"serial\", &serial, NULL) < 0)\n                goto cleanup;\n            if (serial && STRNEQ(serial, \"none\") &&\n                !(chr = xenParseSxprChar(serial, NULL)))\n                goto cleanup;\n            if (chr) {\n                if (VIR_ALLOC_N(def->serials, 1) < 0)\n                    goto cleanup;\n                chr->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n                chr->target.port = 0;\n                def->serials[0] = chr;\n                def->nserials++;\n            }\n        }\n    } else {\n        if (VIR_ALLOC_N(def->consoles, 1) < 0)\n            goto cleanup;\n        def->nconsoles = 1;\n        if (!(def->consoles[0] = xenParseSxprChar(\"pty\", NULL)))\n            goto cleanup;\n        def->consoles[0]->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE;\n        def->consoles[0]->target.port = 0;\n        def->consoles[0]->targetType = VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_XEN;\n    }\n\n    return 0;\n\n cleanup:\n    virDomainChrDefFree(chr);\n    return -1;\n}"
  },
  {
    "function_name": "xenParseSxprChar",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "763-892",
    "snippet": "static virDomainChrDefPtr\nxenParseSxprChar(const char *value,\n                 const char *tty)\n{\n    const char *prefix;\n    char *tmp;\n    virDomainChrDefPtr def;\n\n    if (!(def = virDomainChrDefNew(NULL)))\n        return NULL;\n\n    prefix = value;\n\n    if (value[0] == '/') {\n        def->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        def->source->data.file.path = g_strdup(value);\n    } else {\n        if ((tmp = strchr(value, ':')) != NULL) {\n            *tmp = '\\0';\n            value = tmp + 1;\n        }\n\n        if (STRPREFIX(prefix, \"telnet\")) {\n            def->source->type = VIR_DOMAIN_CHR_TYPE_TCP;\n            def->source->data.tcp.protocol = VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET;\n        } else {\n            if ((def->source->type = virDomainChrTypeFromString(prefix)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unknown chr device type '%s'\"), prefix);\n                goto error;\n            }\n        }\n    }\n\n    switch (def->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        def->source->data.file.path = g_strdup(tty);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        def->source->data.file.path = g_strdup(value);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    {\n        const char *offset = strchr(value, ':');\n        const char *offset2;\n\n        if (offset == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed char device string\"));\n            goto error;\n        }\n\n        if (offset != value)\n            def->source->data.tcp.host = g_strndup(value, offset - value);\n\n        offset2 = strchr(offset, ',');\n        offset++;\n        if (offset2)\n            def->source->data.tcp.service = g_strndup(offset,\n                                                      offset2 - offset);\n        else\n            def->source->data.tcp.service = g_strdup(offset);\n\n        if (offset2 && strstr(offset2, \",server\"))\n            def->source->data.tcp.listen = true;\n    }\n    break;\n\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    {\n        const char *offset = strchr(value, ':');\n        const char *offset2, *offset3;\n\n        if (offset == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed char device string\"));\n            goto error;\n        }\n\n        if (offset != value)\n            def->source->data.udp.connectHost = g_strndup(value,\n                                                          offset - value);\n\n        offset2 = strchr(offset, '@');\n        if (offset2 != NULL) {\n            def->source->data.udp.connectService = g_strndup(offset + 1,\n                                                             offset2 - offset - 1);\n\n            offset3 = strchr(offset2, ':');\n            if (offset3 == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               \"%s\", _(\"malformed char device string\"));\n                goto error;\n            }\n\n            if (offset3 > (offset2 + 1))\n                def->source->data.udp.bindHost = g_strndup(offset2 + 1,\n                                                           offset3 - offset2 - 1);\n\n            def->source->data.udp.bindService = g_strdup(offset3 + 1);\n        } else {\n            def->source->data.udp.connectService = g_strdup(offset + 1);\n        }\n    }\n    break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n    {\n        const char *offset = strchr(value, ',');\n        if (offset)\n            def->source->data.nix.path = g_strndup(value, offset - value);\n        else\n            def->source->data.nix.path = g_strdup(value);\n\n        if (offset != NULL &&\n            strstr(offset, \",server\") != NULL)\n            def->source->data.nix.listen = true;\n    }\n    break;\n    }\n\n    return def;\n\n error:\n    virDomainChrDefFree(def);\n    return NULL;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainChrDefFree",
          "args": [
            "def"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2706-2733",
          "snippet": "void virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainChrDefFree(virDomainChrDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch (def->deviceType) {\n    case VIR_DOMAIN_CHR_DEVICE_TYPE_CHANNEL:\n        switch (def->targetType) {\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_GUESTFWD:\n            VIR_FREE(def->target.addr);\n            break;\n\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_XEN:\n        case VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO:\n            VIR_FREE(def->target.name);\n            break;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    virObjectUnref(def->source);\n    virDomainDeviceInfoClear(&def->info);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "offset",
            "\",server\""
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "value"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "value",
            "offset - value"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "value",
            "','"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "offset2 + 1",
            "offset3 - offset2 - 1"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed char device string\")"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"malformed char device string\""
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "offset2",
            "':'"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "offset + 1",
            "offset2 - offset - 1"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "offset",
            "'@'"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "value",
            "offset - value"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed char device string\")"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "value",
            "':'"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "offset2",
            "\",server\""
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "offset",
            "offset2 - offset"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "offset",
            "','"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "value",
            "offset - value"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed char device string\")"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "value",
            "':'"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unknown chr device type '%s'\")",
            "prefix"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrTypeFromString",
          "args": [
            "prefix"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "prefix",
            "\"telnet\""
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "value",
            "':'"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrDefNew",
          "args": [
            "NULL"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "13232-13246",
          "snippet": "virDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainChrDefPtr\nxenParseSxprChar(const char *value,\n                 const char *tty)\n{\n    const char *prefix;\n    char *tmp;\n    virDomainChrDefPtr def;\n\n    if (!(def = virDomainChrDefNew(NULL)))\n        return NULL;\n\n    prefix = value;\n\n    if (value[0] == '/') {\n        def->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n        def->source->data.file.path = g_strdup(value);\n    } else {\n        if ((tmp = strchr(value, ':')) != NULL) {\n            *tmp = '\\0';\n            value = tmp + 1;\n        }\n\n        if (STRPREFIX(prefix, \"telnet\")) {\n            def->source->type = VIR_DOMAIN_CHR_TYPE_TCP;\n            def->source->data.tcp.protocol = VIR_DOMAIN_CHR_TCP_PROTOCOL_TELNET;\n        } else {\n            if ((def->source->type = virDomainChrTypeFromString(prefix)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unknown chr device type '%s'\"), prefix);\n                goto error;\n            }\n        }\n    }\n\n    switch (def->source->type) {\n    case VIR_DOMAIN_CHR_TYPE_PTY:\n        def->source->data.file.path = g_strdup(tty);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_FILE:\n    case VIR_DOMAIN_CHR_TYPE_PIPE:\n        def->source->data.file.path = g_strdup(value);\n        break;\n\n    case VIR_DOMAIN_CHR_TYPE_TCP:\n    {\n        const char *offset = strchr(value, ':');\n        const char *offset2;\n\n        if (offset == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed char device string\"));\n            goto error;\n        }\n\n        if (offset != value)\n            def->source->data.tcp.host = g_strndup(value, offset - value);\n\n        offset2 = strchr(offset, ',');\n        offset++;\n        if (offset2)\n            def->source->data.tcp.service = g_strndup(offset,\n                                                      offset2 - offset);\n        else\n            def->source->data.tcp.service = g_strdup(offset);\n\n        if (offset2 && strstr(offset2, \",server\"))\n            def->source->data.tcp.listen = true;\n    }\n    break;\n\n    case VIR_DOMAIN_CHR_TYPE_UDP:\n    {\n        const char *offset = strchr(value, ':');\n        const char *offset2, *offset3;\n\n        if (offset == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"malformed char device string\"));\n            goto error;\n        }\n\n        if (offset != value)\n            def->source->data.udp.connectHost = g_strndup(value,\n                                                          offset - value);\n\n        offset2 = strchr(offset, '@');\n        if (offset2 != NULL) {\n            def->source->data.udp.connectService = g_strndup(offset + 1,\n                                                             offset2 - offset - 1);\n\n            offset3 = strchr(offset2, ':');\n            if (offset3 == NULL) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               \"%s\", _(\"malformed char device string\"));\n                goto error;\n            }\n\n            if (offset3 > (offset2 + 1))\n                def->source->data.udp.bindHost = g_strndup(offset2 + 1,\n                                                           offset3 - offset2 - 1);\n\n            def->source->data.udp.bindService = g_strdup(offset3 + 1);\n        } else {\n            def->source->data.udp.connectService = g_strdup(offset + 1);\n        }\n    }\n    break;\n\n    case VIR_DOMAIN_CHR_TYPE_UNIX:\n    {\n        const char *offset = strchr(value, ',');\n        if (offset)\n            def->source->data.nix.path = g_strndup(value, offset - value);\n        else\n            def->source->data.nix.path = g_strdup(value);\n\n        if (offset != NULL &&\n            strstr(offset, \",server\") != NULL)\n            def->source->data.nix.listen = true;\n    }\n    break;\n    }\n\n    return def;\n\n error:\n    virDomainChrDefFree(def);\n    return NULL;\n}"
  },
  {
    "function_name": "xenParseVfb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "603-751",
    "snippet": "static int\nxenParseVfb(virConfPtr conf, virDomainDefPtr def)\n{\n    int val;\n    char *listenAddr = NULL;\n    int hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM;\n    virDomainGraphicsDefPtr graphics = NULL;\n\n    if (hvm) {\n        if (xenConfigGetBool(conf, \"vnc\", &val, 0) < 0)\n            goto cleanup;\n        if (val) {\n            if (VIR_ALLOC(graphics) < 0)\n                goto cleanup;\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n            if (xenConfigGetBool(conf, \"vncunused\", &val, 1) < 0)\n                goto cleanup;\n            graphics->data.vnc.autoport = val ? 1 : 0;\n            if (!graphics->data.vnc.autoport) {\n                unsigned long vncdisplay;\n                if (xenConfigGetULong(conf, \"vncdisplay\", &vncdisplay, 0) < 0)\n                    goto cleanup;\n                graphics->data.vnc.port = (int)vncdisplay + 5900;\n            }\n\n            if (xenConfigCopyStringOpt(conf, \"vnclisten\", &listenAddr) < 0)\n                goto cleanup;\n            if (virDomainGraphicsListenAppendAddress(graphics, listenAddr) < 0)\n                goto cleanup;\n            VIR_FREE(listenAddr);\n\n            if (xenConfigCopyStringOpt(conf, \"vncpasswd\", &graphics->data.vnc.auth.passwd) < 0)\n                goto cleanup;\n            if (xenConfigCopyStringOpt(conf, \"keymap\", &graphics->data.vnc.keymap) < 0)\n                goto cleanup;\n            if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                goto cleanup;\n            def->graphics[0] = graphics;\n            def->ngraphics = 1;\n            graphics = NULL;\n        } else {\n            if (xenConfigGetBool(conf, \"sdl\", &val, 0) < 0)\n                goto cleanup;\n            if (val) {\n                if (VIR_ALLOC(graphics) < 0)\n                    goto cleanup;\n                graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SDL;\n                if (xenConfigCopyStringOpt(conf, \"display\", &graphics->data.sdl.display) < 0)\n                    goto cleanup;\n                if (xenConfigCopyStringOpt(conf, \"xauthority\", &graphics->data.sdl.xauth) < 0)\n                    goto cleanup;\n                if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                    goto cleanup;\n                def->graphics[0] = graphics;\n                def->ngraphics = 1;\n                graphics = NULL;\n            }\n        }\n    }\n\n    if (!hvm && def->graphics == NULL) { /* New PV guests use this format */\n        VIR_AUTOSTRINGLIST vfbs = NULL;\n        int rc;\n\n        if ((rc = virConfGetValueStringList(conf, \"vfb\", false, &vfbs)) == 1) {\n            char vfb[MAX_VFB];\n            char *key = vfb;\n\n            if (virStrcpyStatic(vfb, *vfbs) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"VFB %s too big for destination\"),\n                               *vfbs);\n                goto cleanup;\n            }\n\n            if (VIR_ALLOC(graphics) < 0)\n                goto cleanup;\n            if (strstr(key, \"type=sdl\"))\n                graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SDL;\n            else\n                graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n            while (key) {\n                char *nextkey = strchr(key, ',');\n                char *end = nextkey;\n                if (nextkey) {\n                    *end = '\\0';\n                    nextkey++;\n                }\n\n                if (!strchr(key, '='))\n                    break;\n                if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n                    if (STRPREFIX(key, \"vncunused=\")) {\n                        if (STREQ(key + 10, \"1\"))\n                            graphics->data.vnc.autoport = true;\n                    } else if (STRPREFIX(key, \"vnclisten=\")) {\n                        listenAddr = g_strdup(key + 10);\n                    } else if (STRPREFIX(key, \"vncpasswd=\")) {\n                        graphics->data.vnc.auth.passwd = g_strdup(key + 10);\n                    } else if (STRPREFIX(key, \"keymap=\")) {\n                        graphics->data.vnc.keymap = g_strdup(key + 7);\n                    } else if (STRPREFIX(key, \"vncdisplay=\")) {\n                        if (virStrToLong_i(key + 11, NULL, 10,\n                                           &graphics->data.vnc.port) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"invalid vncdisplay value '%s'\"),\n                                           key + 11);\n                            goto cleanup;\n                        }\n                        graphics->data.vnc.port += 5900;\n                    }\n                } else {\n                    if (STRPREFIX(key, \"display=\")) {\n                        graphics->data.sdl.display = g_strdup(key + 8);\n                    } else if (STRPREFIX(key, \"xauthority=\")) {\n                        graphics->data.sdl.xauth = g_strdup(key + 11);\n                    }\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n            if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n                if (virDomainGraphicsListenAppendAddress(graphics,\n                                                         listenAddr) < 0)\n                    goto cleanup;\n                VIR_FREE(listenAddr);\n            }\n            if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                goto cleanup;\n            def->graphics[0] = graphics;\n            def->ngraphics = 1;\n            graphics = NULL;\n        } else {\n            if (xenHandleConfGetValueStringListErrors(rc) < 0)\n                goto cleanup;\n        }\n    }\n\n    return 0;\n\n cleanup:\n    virDomainGraphicsDefFree(graphics);\n    VIR_FREE(listenAddr);\n    return -1;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define MAX_VFB 1024"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "listenAddr"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsDefFree",
          "args": [
            "graphics"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1719-1764",
          "snippet": "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    switch (def->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        VIR_FREE(def->data.vnc.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.vnc.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n        VIR_FREE(def->data.sdl.display);\n        VIR_FREE(def->data.sdl.xauth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n        VIR_FREE(def->data.desktop.display);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        VIR_FREE(def->data.spice.rendernode);\n        VIR_FREE(def->data.spice.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.spice.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        VIR_FREE(def->data.egl_headless.rendernode);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    for (i = 0; i < def->nListens; i++)\n        virDomainGraphicsListenDefClear(&def->listens[i]);\n    VIR_FREE(def->listens);\n\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    switch (def->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        VIR_FREE(def->data.vnc.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.vnc.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n        VIR_FREE(def->data.sdl.display);\n        VIR_FREE(def->data.sdl.xauth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n        VIR_FREE(def->data.desktop.display);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        VIR_FREE(def->data.spice.rendernode);\n        VIR_FREE(def->data.spice.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.spice.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        VIR_FREE(def->data.egl_headless.rendernode);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    for (i = 0; i < def->nListens; i++)\n        virDomainGraphicsListenDefClear(&def->listens[i]);\n    VIR_FREE(def->listens);\n\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenHandleConfGetValueStringListErrors",
          "args": [
            "rc"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "xenHandleConfGetValueStringListErrors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "448-465",
          "snippet": "static int\nxenHandleConfGetValueStringListErrors(int ret)\n{\n    if (ret < 0) {\n        /* It means virConfGetValueStringList() didn't fail because the\n         * cval->type switch fell through - since we're passing\n         * @compatString == false - assumes failures for memory allocation\n         * and VIR_CONF_LIST traversal failure should cause -1 to be\n         * returned to the caller with the error message set. */\n        if (virGetLastErrorCode() != VIR_ERR_INTERNAL_ERROR)\n            return -1;\n\n        /* If we did fall through the switch, then ignore and clear the\n         * last error. */\n        virResetLastError();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenHandleConfGetValueStringListErrors(int ret)\n{\n    if (ret < 0) {\n        /* It means virConfGetValueStringList() didn't fail because the\n         * cval->type switch fell through - since we're passing\n         * @compatString == false - assumes failures for memory allocation\n         * and VIR_CONF_LIST traversal failure should cause -1 to be\n         * returned to the caller with the error message set. */\n        if (virGetLastErrorCode() != VIR_ERR_INTERNAL_ERROR)\n            return -1;\n\n        /* If we did fall through the switch, then ignore and clear the\n         * last error. */\n        virResetLastError();\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->graphics",
            "1"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "listenAddr"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsListenAppendAddress",
          "args": [
            "graphics",
            "listenAddr"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsListenAppendAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30367-30386",
          "snippet": "int\nvirDomainGraphicsListenAppendAddress(virDomainGraphicsDefPtr def,\n                                     const char *address)\n{\n    virDomainGraphicsListenDef glisten;\n\n    memset(&glisten, 0, sizeof(glisten));\n\n    glisten.type = VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS;\n\n    glisten.address = g_strdup(address);\n\n    if (VIR_APPEND_ELEMENT_COPY(def->listens, def->nListens, glisten) < 0)\n        goto error;\n\n    return 0;\n error:\n    VIR_FREE(glisten.address);\n    return -1;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainGraphicsListenAppendAddress(virDomainGraphicsDefPtr def,\n                                     const char *address)\n{\n    virDomainGraphicsListenDef glisten;\n\n    memset(&glisten, 0, sizeof(glisten));\n\n    glisten.type = VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS;\n\n    glisten.address = g_strdup(address);\n\n    if (VIR_APPEND_ELEMENT_COPY(def->listens, def->nListens, glisten) < 0)\n        goto error;\n\n    return 0;\n error:\n    VIR_FREE(glisten.address);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "key + 11"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"xauthority=\""
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"display=\""
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"invalid vncdisplay value '%s'\")",
            "key + 11"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid vncdisplay value '%s'\""
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "key + 11",
            "NULL",
            "10",
            "&graphics->data.vnc.port"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"vncdisplay=\""
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"keymap=\""
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"vncpasswd=\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"vnclisten=\""
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "key + 10",
            "\"1\""
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "key",
            "\"vncunused=\""
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "key",
            "'='"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "key",
            "','"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "key",
            "\"type=sdl\""
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "graphics"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"VFB %s too big for destination\")",
            "*vfbs"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "vfb",
            "*vfbs"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfGetValueStringList",
          "args": [
            "conf",
            "\"vfb\"",
            "false",
            "&vfbs"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueStringList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "920-984",
          "snippet": "int virConfGetValueStringList(virConfPtr conf,\n                              const char *setting,\n                              bool compatString,\n                              char ***values)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    size_t len;\n    virConfValuePtr eval;\n\n    VIR_DEBUG(\"Get value string list %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    virStringListFree(*values);\n    *values = NULL;\n\n    switch (cval->type) {\n    case VIR_CONF_LIST:\n        /* Calc length and check items */\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next) {\n            if (eval->type != VIR_CONF_STRING) {\n                virReportError(VIR_ERR_CONF_SYNTAX,\n                               _(\"%s: expected a string list for '%s' parameter\"),\n                               conf->filename, setting);\n                return -1;\n            }\n        }\n\n        if (VIR_ALLOC_N(*values, len + 1) < 0)\n            return -1;\n\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next)\n            (*values)[len] = g_strdup(eval->str);\n        break;\n\n    case VIR_CONF_STRING:\n        if (compatString) {\n            if (VIR_ALLOC_N(*values, cval->str ? 2 : 1) < 0)\n                return -1;\n            if (cval->str)\n                (*values)[0] = g_strdup(cval->str);\n            break;\n        }\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_CONF_LLONG:\n    case VIR_CONF_ULLONG:\n    case VIR_CONF_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       compatString ?\n                       _(\"%s: expected a string or string list for '%s' parameter\") :\n                       _(\"%s: expected a string list for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n\n    case VIR_CONF_LAST:\n    default:\n        virReportEnumRangeError(virConfType, cval->type);\n        return -1;\n    }\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueStringList(virConfPtr conf,\n                              const char *setting,\n                              bool compatString,\n                              char ***values)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    size_t len;\n    virConfValuePtr eval;\n\n    VIR_DEBUG(\"Get value string list %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    virStringListFree(*values);\n    *values = NULL;\n\n    switch (cval->type) {\n    case VIR_CONF_LIST:\n        /* Calc length and check items */\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next) {\n            if (eval->type != VIR_CONF_STRING) {\n                virReportError(VIR_ERR_CONF_SYNTAX,\n                               _(\"%s: expected a string list for '%s' parameter\"),\n                               conf->filename, setting);\n                return -1;\n            }\n        }\n\n        if (VIR_ALLOC_N(*values, len + 1) < 0)\n            return -1;\n\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next)\n            (*values)[len] = g_strdup(eval->str);\n        break;\n\n    case VIR_CONF_STRING:\n        if (compatString) {\n            if (VIR_ALLOC_N(*values, cval->str ? 2 : 1) < 0)\n                return -1;\n            if (cval->str)\n                (*values)[0] = g_strdup(cval->str);\n            break;\n        }\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_CONF_LLONG:\n    case VIR_CONF_ULLONG:\n    case VIR_CONF_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       compatString ?\n                       _(\"%s: expected a string or string list for '%s' parameter\") :\n                       _(\"%s: expected a string list for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n\n    case VIR_CONF_LAST:\n    default:\n        virReportEnumRangeError(virConfType, cval->type);\n        return -1;\n    }\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->graphics",
            "1"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigCopyStringOpt",
          "args": [
            "conf",
            "\"xauthority\"",
            "&graphics->data.sdl.xauth"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigCopyStringOpt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "168-172",
          "snippet": "int\nxenConfigCopyStringOpt(virConfPtr conf, const char *name, char **value)\n{\n    return xenConfigCopyStringInternal(conf, name, value, 1);\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigCopyStringOpt(virConfPtr conf, const char *name, char **value)\n{\n    return xenConfigCopyStringInternal(conf, name, value, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "graphics"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigGetBool",
          "args": [
            "conf",
            "\"sdl\"",
            "&val",
            "0"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "42-66",
          "snippet": "int\nxenConfigGetBool(virConfPtr conf,\n                 const char *name,\n                 int *value,\n                 int def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l ? 1 : 0;\n    } else if (val->type == VIR_CONF_STRING) {\n        *value = STREQ(val->str, \"1\") ? 1 : 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetBool(virConfPtr conf,\n                 const char *name,\n                 int *value,\n                 int def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l ? 1 : 0;\n    } else if (val->type == VIR_CONF_STRING) {\n        *value = STREQ(val->str, \"1\") ? 1 : 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->graphics",
            "1"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "listenAddr"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigGetULong",
          "args": [
            "conf",
            "\"vncdisplay\"",
            "&vncdisplay",
            "0"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "106-134",
          "snippet": "static int\nxenConfigGetULongLong(virConfPtr conf,\n                      const char *name,\n                      unsigned long long *value,\n                      unsigned long long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ull(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenConfigGetULongLong(virConfPtr conf,\n                      const char *name,\n                      unsigned long long *value,\n                      unsigned long long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ull(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "graphics"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\n#define MAX_VFB 1024\n\nstatic int\nxenParseVfb(virConfPtr conf, virDomainDefPtr def)\n{\n    int val;\n    char *listenAddr = NULL;\n    int hvm = def->os.type == VIR_DOMAIN_OSTYPE_HVM;\n    virDomainGraphicsDefPtr graphics = NULL;\n\n    if (hvm) {\n        if (xenConfigGetBool(conf, \"vnc\", &val, 0) < 0)\n            goto cleanup;\n        if (val) {\n            if (VIR_ALLOC(graphics) < 0)\n                goto cleanup;\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n            if (xenConfigGetBool(conf, \"vncunused\", &val, 1) < 0)\n                goto cleanup;\n            graphics->data.vnc.autoport = val ? 1 : 0;\n            if (!graphics->data.vnc.autoport) {\n                unsigned long vncdisplay;\n                if (xenConfigGetULong(conf, \"vncdisplay\", &vncdisplay, 0) < 0)\n                    goto cleanup;\n                graphics->data.vnc.port = (int)vncdisplay + 5900;\n            }\n\n            if (xenConfigCopyStringOpt(conf, \"vnclisten\", &listenAddr) < 0)\n                goto cleanup;\n            if (virDomainGraphicsListenAppendAddress(graphics, listenAddr) < 0)\n                goto cleanup;\n            VIR_FREE(listenAddr);\n\n            if (xenConfigCopyStringOpt(conf, \"vncpasswd\", &graphics->data.vnc.auth.passwd) < 0)\n                goto cleanup;\n            if (xenConfigCopyStringOpt(conf, \"keymap\", &graphics->data.vnc.keymap) < 0)\n                goto cleanup;\n            if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                goto cleanup;\n            def->graphics[0] = graphics;\n            def->ngraphics = 1;\n            graphics = NULL;\n        } else {\n            if (xenConfigGetBool(conf, \"sdl\", &val, 0) < 0)\n                goto cleanup;\n            if (val) {\n                if (VIR_ALLOC(graphics) < 0)\n                    goto cleanup;\n                graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SDL;\n                if (xenConfigCopyStringOpt(conf, \"display\", &graphics->data.sdl.display) < 0)\n                    goto cleanup;\n                if (xenConfigCopyStringOpt(conf, \"xauthority\", &graphics->data.sdl.xauth) < 0)\n                    goto cleanup;\n                if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                    goto cleanup;\n                def->graphics[0] = graphics;\n                def->ngraphics = 1;\n                graphics = NULL;\n            }\n        }\n    }\n\n    if (!hvm && def->graphics == NULL) { /* New PV guests use this format */\n        VIR_AUTOSTRINGLIST vfbs = NULL;\n        int rc;\n\n        if ((rc = virConfGetValueStringList(conf, \"vfb\", false, &vfbs)) == 1) {\n            char vfb[MAX_VFB];\n            char *key = vfb;\n\n            if (virStrcpyStatic(vfb, *vfbs) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"VFB %s too big for destination\"),\n                               *vfbs);\n                goto cleanup;\n            }\n\n            if (VIR_ALLOC(graphics) < 0)\n                goto cleanup;\n            if (strstr(key, \"type=sdl\"))\n                graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SDL;\n            else\n                graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_VNC;\n            while (key) {\n                char *nextkey = strchr(key, ',');\n                char *end = nextkey;\n                if (nextkey) {\n                    *end = '\\0';\n                    nextkey++;\n                }\n\n                if (!strchr(key, '='))\n                    break;\n                if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n                    if (STRPREFIX(key, \"vncunused=\")) {\n                        if (STREQ(key + 10, \"1\"))\n                            graphics->data.vnc.autoport = true;\n                    } else if (STRPREFIX(key, \"vnclisten=\")) {\n                        listenAddr = g_strdup(key + 10);\n                    } else if (STRPREFIX(key, \"vncpasswd=\")) {\n                        graphics->data.vnc.auth.passwd = g_strdup(key + 10);\n                    } else if (STRPREFIX(key, \"keymap=\")) {\n                        graphics->data.vnc.keymap = g_strdup(key + 7);\n                    } else if (STRPREFIX(key, \"vncdisplay=\")) {\n                        if (virStrToLong_i(key + 11, NULL, 10,\n                                           &graphics->data.vnc.port) < 0) {\n                            virReportError(VIR_ERR_INTERNAL_ERROR,\n                                           _(\"invalid vncdisplay value '%s'\"),\n                                           key + 11);\n                            goto cleanup;\n                        }\n                        graphics->data.vnc.port += 5900;\n                    }\n                } else {\n                    if (STRPREFIX(key, \"display=\")) {\n                        graphics->data.sdl.display = g_strdup(key + 8);\n                    } else if (STRPREFIX(key, \"xauthority=\")) {\n                        graphics->data.sdl.xauth = g_strdup(key + 11);\n                    }\n                }\n\n                while (nextkey && (nextkey[0] == ',' ||\n                                   nextkey[0] == ' ' ||\n                                   nextkey[0] == '\\t'))\n                    nextkey++;\n                key = nextkey;\n            }\n            if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n                if (virDomainGraphicsListenAppendAddress(graphics,\n                                                         listenAddr) < 0)\n                    goto cleanup;\n                VIR_FREE(listenAddr);\n            }\n            if (VIR_ALLOC_N(def->graphics, 1) < 0)\n                goto cleanup;\n            def->graphics[0] = graphics;\n            def->ngraphics = 1;\n            graphics = NULL;\n        } else {\n            if (xenHandleConfGetValueStringListErrors(rc) < 0)\n                goto cleanup;\n        }\n    }\n\n    return 0;\n\n cleanup:\n    virDomainGraphicsDefFree(graphics);\n    VIR_FREE(listenAddr);\n    return -1;\n}"
  },
  {
    "function_name": "xenParseCPUFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "495-598",
    "snippet": "static int\nxenParseCPUFeatures(virConfPtr conf,\n                    virDomainDefPtr def,\n                    virDomainXMLOptionPtr xmlopt)\n{\n    unsigned long count = 0;\n    g_autofree char *cpus = NULL;\n    g_autofree char *tsc_mode = NULL;\n    int val = 0;\n    virDomainTimerDefPtr timer;\n\n    if (xenConfigGetULong(conf, \"vcpus\", &count, 1) < 0)\n        return -1;\n\n    if (virDomainDefSetVcpusMax(def, count, xmlopt) < 0)\n        return -1;\n\n    if (virDomainDefSetVcpus(def, count) < 0)\n        return -1;\n\n    if (virConfGetValue(conf, \"maxvcpus\")) {\n        if (xenConfigGetULong(conf, \"maxvcpus\", &count, 0) < 0)\n            return -1;\n\n        if (virDomainDefSetVcpusMax(def, count, xmlopt) < 0)\n            return -1;\n    }\n\n    if (xenConfigGetString(conf, \"cpus\", &cpus, NULL) < 0)\n        return -1;\n\n    if (cpus && (virBitmapParse(cpus, &def->cpumask, 4096) < 0))\n        return -1;\n\n    if (xenConfigGetString(conf, \"tsc_mode\", &tsc_mode, NULL) < 0)\n        return -1;\n\n    if (tsc_mode) {\n        if (VIR_EXPAND_N(def->clock.timers, def->clock.ntimers, 1) < 0 ||\n            VIR_ALLOC(timer) < 0)\n            return -1;\n\n        timer->name = VIR_DOMAIN_TIMER_NAME_TSC;\n        timer->present = 1;\n        timer->tickpolicy = -1;\n        timer->mode = VIR_DOMAIN_TIMER_MODE_AUTO;\n        timer->track = -1;\n        if (STREQ_NULLABLE(tsc_mode, \"always_emulate\"))\n            timer->mode = VIR_DOMAIN_TIMER_MODE_EMULATE;\n        else if (STREQ_NULLABLE(tsc_mode, \"native\"))\n            timer->mode = VIR_DOMAIN_TIMER_MODE_NATIVE;\n        else if (STREQ_NULLABLE(tsc_mode, \"native_paravirt\"))\n            timer->mode = VIR_DOMAIN_TIMER_MODE_PARAVIRT;\n\n        def->clock.timers[def->clock.ntimers - 1] = timer;\n    }\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (xenConfigGetBool(conf, \"pae\", &val, 1) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_PAE] = VIR_TRISTATE_SWITCH_ON;\n        if (xenConfigGetBool(conf, \"acpi\", &val, 1) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_ACPI] = VIR_TRISTATE_SWITCH_ON;\n        if (xenConfigGetBool(conf, \"apic\", &val, 1) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_APIC] = VIR_TRISTATE_SWITCH_ON;\n        if (xenConfigGetBool(conf, \"hap\", &val, 1) < 0)\n            return -1;\n\n        else if (!val)\n            def->features[VIR_DOMAIN_FEATURE_HAP] = VIR_TRISTATE_SWITCH_OFF;\n        if (xenConfigGetBool(conf, \"viridian\", &val, 0) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_VIRIDIAN] = VIR_TRISTATE_SWITCH_ON;\n\n        if (xenConfigGetBool(conf, \"hpet\", &val, -1) < 0)\n            return -1;\n\n        if (val != -1) {\n            if (VIR_EXPAND_N(def->clock.timers, def->clock.ntimers, 1) < 0 ||\n                VIR_ALLOC(timer) < 0)\n                return -1;\n\n            timer->name = VIR_DOMAIN_TIMER_NAME_HPET;\n            timer->present = val;\n            timer->tickpolicy = -1;\n            timer->mode = -1;\n            timer->track = -1;\n\n            def->clock.timers[def->clock.ntimers - 1] = timer;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "timer"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "def->clock.timers",
            "def->clock.ntimers",
            "1"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigGetBool",
          "args": [
            "conf",
            "\"hpet\"",
            "&val",
            "-1"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "42-66",
          "snippet": "int\nxenConfigGetBool(virConfPtr conf,\n                 const char *name,\n                 int *value,\n                 int def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l ? 1 : 0;\n    } else if (val->type == VIR_CONF_STRING) {\n        *value = STREQ(val->str, \"1\") ? 1 : 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetBool(virConfPtr conf,\n                 const char *name,\n                 int *value,\n                 int def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l ? 1 : 0;\n    } else if (val->type == VIR_CONF_STRING) {\n        *value = STREQ(val->str, \"1\") ? 1 : 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "tsc_mode",
            "\"native_paravirt\""
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "tsc_mode",
            "\"native\""
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "tsc_mode",
            "\"always_emulate\""
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "timer"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "def->clock.timers",
            "def->clock.ntimers",
            "1"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigGetString",
          "args": [
            "conf",
            "\"tsc_mode\"",
            "&tsc_mode",
            "NULL"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "223-243",
          "snippet": "int\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapParse",
          "args": [
            "cpus",
            "&def->cpumask",
            "4096"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "581-587",
          "snippet": "int\nvirBitmapParse(const char *str,\n               virBitmapPtr *bitmap,\n               size_t bitmapSize)\n{\n    return virBitmapParseSeparator(str, '\\0', bitmap, bitmapSize);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapParse(const char *str,\n               virBitmapPtr *bitmap,\n               size_t bitmapSize)\n{\n    return virBitmapParseSeparator(str, '\\0', bitmap, bitmapSize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetVcpusMax",
          "args": [
            "def",
            "count",
            "xmlopt"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetVcpusMax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1838-1865",
          "snippet": "int\nvirDomainDefSetVcpusMax(virDomainDefPtr def,\n                        unsigned int maxvcpus,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    size_t oldmax = def->maxvcpus;\n    size_t i;\n\n    if (def->maxvcpus == maxvcpus)\n        return 0;\n\n    if (def->maxvcpus < maxvcpus) {\n        if (VIR_EXPAND_N(def->vcpus, def->maxvcpus, maxvcpus - def->maxvcpus) < 0)\n            return -1;\n\n        for (i = oldmax; i < def->maxvcpus; i++) {\n            if (!(def->vcpus[i] = virDomainVcpuDefNew(xmlopt)))\n                return -1;\n        }\n    } else {\n        for (i = maxvcpus; i < def->maxvcpus; i++)\n            virDomainVcpuDefFree(def->vcpus[i]);\n\n        VIR_SHRINK_N(def->vcpus, def->maxvcpus, def->maxvcpus - maxvcpus);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSetVcpusMax(virDomainDefPtr def,\n                        unsigned int maxvcpus,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    size_t oldmax = def->maxvcpus;\n    size_t i;\n\n    if (def->maxvcpus == maxvcpus)\n        return 0;\n\n    if (def->maxvcpus < maxvcpus) {\n        if (VIR_EXPAND_N(def->vcpus, def->maxvcpus, maxvcpus - def->maxvcpus) < 0)\n            return -1;\n\n        for (i = oldmax; i < def->maxvcpus; i++) {\n            if (!(def->vcpus[i] = virDomainVcpuDefNew(xmlopt)))\n                return -1;\n        }\n    } else {\n        for (i = maxvcpus; i < def->maxvcpus; i++)\n            virDomainVcpuDefFree(def->vcpus[i]);\n\n        VIR_SHRINK_N(def->vcpus, def->maxvcpus, def->maxvcpus - maxvcpus);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigGetULong",
          "args": [
            "conf",
            "\"maxvcpus\"",
            "&count",
            "0"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "106-134",
          "snippet": "static int\nxenConfigGetULongLong(virConfPtr conf,\n                      const char *name,\n                      unsigned long long *value,\n                      unsigned long long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ull(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenConfigGetULongLong(virConfPtr conf,\n                      const char *name,\n                      unsigned long long *value,\n                      unsigned long long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ull(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValue",
          "args": [
            "conf",
            "\"maxvcpus\""
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "849-857",
          "snippet": "virConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvirConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetVcpus",
          "args": [
            "def",
            "count"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1889-1909",
          "snippet": "int\nvirDomainDefSetVcpus(virDomainDefPtr def,\n                     unsigned int vcpus)\n{\n    size_t i;\n\n    if (vcpus > def->maxvcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"maximum vCPU count must not be less than current \"\n                         \"vCPU count\"));\n        return -1;\n    }\n\n    for (i = 0; i < vcpus; i++)\n        def->vcpus[i]->online = true;\n\n    for (i = vcpus; i < def->maxvcpus; i++)\n        def->vcpus[i]->online = false;\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSetVcpus(virDomainDefPtr def,\n                     unsigned int vcpus)\n{\n    size_t i;\n\n    if (vcpus > def->maxvcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"maximum vCPU count must not be less than current \"\n                         \"vCPU count\"));\n        return -1;\n    }\n\n    for (i = 0; i < vcpus; i++)\n        def->vcpus[i]->online = true;\n\n    for (i = vcpus; i < def->maxvcpus; i++)\n        def->vcpus[i]->online = false;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseCPUFeatures(virConfPtr conf,\n                    virDomainDefPtr def,\n                    virDomainXMLOptionPtr xmlopt)\n{\n    unsigned long count = 0;\n    g_autofree char *cpus = NULL;\n    g_autofree char *tsc_mode = NULL;\n    int val = 0;\n    virDomainTimerDefPtr timer;\n\n    if (xenConfigGetULong(conf, \"vcpus\", &count, 1) < 0)\n        return -1;\n\n    if (virDomainDefSetVcpusMax(def, count, xmlopt) < 0)\n        return -1;\n\n    if (virDomainDefSetVcpus(def, count) < 0)\n        return -1;\n\n    if (virConfGetValue(conf, \"maxvcpus\")) {\n        if (xenConfigGetULong(conf, \"maxvcpus\", &count, 0) < 0)\n            return -1;\n\n        if (virDomainDefSetVcpusMax(def, count, xmlopt) < 0)\n            return -1;\n    }\n\n    if (xenConfigGetString(conf, \"cpus\", &cpus, NULL) < 0)\n        return -1;\n\n    if (cpus && (virBitmapParse(cpus, &def->cpumask, 4096) < 0))\n        return -1;\n\n    if (xenConfigGetString(conf, \"tsc_mode\", &tsc_mode, NULL) < 0)\n        return -1;\n\n    if (tsc_mode) {\n        if (VIR_EXPAND_N(def->clock.timers, def->clock.ntimers, 1) < 0 ||\n            VIR_ALLOC(timer) < 0)\n            return -1;\n\n        timer->name = VIR_DOMAIN_TIMER_NAME_TSC;\n        timer->present = 1;\n        timer->tickpolicy = -1;\n        timer->mode = VIR_DOMAIN_TIMER_MODE_AUTO;\n        timer->track = -1;\n        if (STREQ_NULLABLE(tsc_mode, \"always_emulate\"))\n            timer->mode = VIR_DOMAIN_TIMER_MODE_EMULATE;\n        else if (STREQ_NULLABLE(tsc_mode, \"native\"))\n            timer->mode = VIR_DOMAIN_TIMER_MODE_NATIVE;\n        else if (STREQ_NULLABLE(tsc_mode, \"native_paravirt\"))\n            timer->mode = VIR_DOMAIN_TIMER_MODE_PARAVIRT;\n\n        def->clock.timers[def->clock.ntimers - 1] = timer;\n    }\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (xenConfigGetBool(conf, \"pae\", &val, 1) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_PAE] = VIR_TRISTATE_SWITCH_ON;\n        if (xenConfigGetBool(conf, \"acpi\", &val, 1) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_ACPI] = VIR_TRISTATE_SWITCH_ON;\n        if (xenConfigGetBool(conf, \"apic\", &val, 1) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_APIC] = VIR_TRISTATE_SWITCH_ON;\n        if (xenConfigGetBool(conf, \"hap\", &val, 1) < 0)\n            return -1;\n\n        else if (!val)\n            def->features[VIR_DOMAIN_FEATURE_HAP] = VIR_TRISTATE_SWITCH_OFF;\n        if (xenConfigGetBool(conf, \"viridian\", &val, 0) < 0)\n            return -1;\n\n        else if (val)\n            def->features[VIR_DOMAIN_FEATURE_VIRIDIAN] = VIR_TRISTATE_SWITCH_ON;\n\n        if (xenConfigGetBool(conf, \"hpet\", &val, -1) < 0)\n            return -1;\n\n        if (val != -1) {\n            if (VIR_EXPAND_N(def->clock.timers, def->clock.ntimers, 1) < 0 ||\n                VIR_ALLOC(timer) < 0)\n                return -1;\n\n            timer->name = VIR_DOMAIN_TIMER_NAME_HPET;\n            timer->present = val;\n            timer->tickpolicy = -1;\n            timer->mode = -1;\n            timer->track = -1;\n\n            def->clock.timers[def->clock.ntimers - 1] = timer;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenParsePCIList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "468-492",
    "snippet": "static int\nxenParsePCIList(virConfPtr conf, virDomainDefPtr def)\n{\n    VIR_AUTOSTRINGLIST pcis = NULL;\n    char **entries = NULL;\n    int rc;\n\n    if ((rc = virConfGetValueStringList(conf, \"pci\", false, &pcis)) <= 0)\n        return xenHandleConfGetValueStringListErrors(rc);\n\n    for (entries = pcis; *entries; entries++) {\n        char *entry = *entries;\n        virDomainHostdevDefPtr hostdev;\n\n        if (!(hostdev = xenParsePCI(entry)))\n            return -1;\n\n        if (VIR_APPEND_ELEMENT(def->hostdevs, def->nhostdevs, hostdev) < 0) {\n            virDomainHostdevDefFree(hostdev);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainHostdevDefFree",
          "args": [
            "hostdev"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainHostdevDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3002-3015",
          "snippet": "void virDomainHostdevDefFree(virDomainHostdevDefPtr def)\n{\n    if (!def)\n        return;\n\n    /* free all subordinate objects */\n    virDomainHostdevDefClear(def);\n\n    /* If there is a parentnet device object, it will handle freeing\n     * the memory.\n     */\n    if (!def->parentnet)\n        VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def)\n{\n    if (!def)\n        return;\n\n    /* free all subordinate objects */\n    virDomainHostdevDefClear(def);\n\n    /* If there is a parentnet device object, it will handle freeing\n     * the memory.\n     */\n    if (!def->parentnet)\n        VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->hostdevs",
            "def->nhostdevs",
            "hostdev"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenParsePCI",
          "args": [
            "entry"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "xenParsePCI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "371-445",
          "snippet": "static virDomainHostdevDefPtr\nxenParsePCI(char *entry)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    char domain[5];\n    char bus[3];\n    char slot[3];\n    char func[2];\n    char *key, *nextkey;\n    int domainID;\n    int busID;\n    int slotID;\n    int funcID;\n\n    domain[0] = bus[0] = slot[0] = func[0] = '\\0';\n\n    /* pci=['0000:00:1b.0','0000:00:13.0'] */\n    if (!(key = entry))\n        return NULL;\n    if (!(nextkey = strchr(key, ':')))\n        return NULL;\n    if (virStrncpy(domain, key, (nextkey - key), sizeof(domain)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Domain %s too big for destination\"), key);\n        return NULL;\n    }\n\n    key = nextkey + 1;\n    if (!(nextkey = strchr(key, ':')))\n        return NULL;\n    if (virStrncpy(bus, key, (nextkey - key), sizeof(bus)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Bus %s too big for destination\"), key);\n        return NULL;\n    }\n\n    key = nextkey + 1;\n    if (!(nextkey = strchr(key, '.')))\n        return NULL;\n    if (virStrncpy(slot, key, (nextkey - key), sizeof(slot)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Slot %s too big for destination\"), key);\n        return NULL;\n    }\n\n    key = nextkey + 1;\n    if (strlen(key) != 1)\n        return NULL;\n    if (virStrncpy(func, key, 1, sizeof(func)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Function %s too big for destination\"), key);\n        return NULL;\n    }\n\n    if (virStrToLong_i(domain, NULL, 16, &domainID) < 0)\n        return NULL;\n    if (virStrToLong_i(bus, NULL, 16, &busID) < 0)\n        return NULL;\n    if (virStrToLong_i(slot, NULL, 16, &slotID) < 0)\n        return NULL;\n    if (virStrToLong_i(func, NULL, 16, &funcID) < 0)\n        return NULL;\n\n    if (!(hostdev = virDomainHostdevDefNew()))\n       return NULL;\n\n    hostdev->managed = false;\n    hostdev->source.subsys.type = VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI;\n    hostdev->source.subsys.u.pci.addr.domain = domainID;\n    hostdev->source.subsys.u.pci.addr.bus = busID;\n    hostdev->source.subsys.u.pci.addr.slot = slotID;\n    hostdev->source.subsys.u.pci.addr.function = funcID;\n\n    return hostdev;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainHostdevDefPtr\nxenParsePCI(char *entry)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    char domain[5];\n    char bus[3];\n    char slot[3];\n    char func[2];\n    char *key, *nextkey;\n    int domainID;\n    int busID;\n    int slotID;\n    int funcID;\n\n    domain[0] = bus[0] = slot[0] = func[0] = '\\0';\n\n    /* pci=['0000:00:1b.0','0000:00:13.0'] */\n    if (!(key = entry))\n        return NULL;\n    if (!(nextkey = strchr(key, ':')))\n        return NULL;\n    if (virStrncpy(domain, key, (nextkey - key), sizeof(domain)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Domain %s too big for destination\"), key);\n        return NULL;\n    }\n\n    key = nextkey + 1;\n    if (!(nextkey = strchr(key, ':')))\n        return NULL;\n    if (virStrncpy(bus, key, (nextkey - key), sizeof(bus)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Bus %s too big for destination\"), key);\n        return NULL;\n    }\n\n    key = nextkey + 1;\n    if (!(nextkey = strchr(key, '.')))\n        return NULL;\n    if (virStrncpy(slot, key, (nextkey - key), sizeof(slot)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Slot %s too big for destination\"), key);\n        return NULL;\n    }\n\n    key = nextkey + 1;\n    if (strlen(key) != 1)\n        return NULL;\n    if (virStrncpy(func, key, 1, sizeof(func)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Function %s too big for destination\"), key);\n        return NULL;\n    }\n\n    if (virStrToLong_i(domain, NULL, 16, &domainID) < 0)\n        return NULL;\n    if (virStrToLong_i(bus, NULL, 16, &busID) < 0)\n        return NULL;\n    if (virStrToLong_i(slot, NULL, 16, &slotID) < 0)\n        return NULL;\n    if (virStrToLong_i(func, NULL, 16, &funcID) < 0)\n        return NULL;\n\n    if (!(hostdev = virDomainHostdevDefNew()))\n       return NULL;\n\n    hostdev->managed = false;\n    hostdev->source.subsys.type = VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI;\n    hostdev->source.subsys.u.pci.addr.domain = domainID;\n    hostdev->source.subsys.u.pci.addr.bus = busID;\n    hostdev->source.subsys.u.pci.addr.slot = slotID;\n    hostdev->source.subsys.u.pci.addr.function = funcID;\n\n    return hostdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenHandleConfGetValueStringListErrors",
          "args": [
            "rc"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "xenHandleConfGetValueStringListErrors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "448-465",
          "snippet": "static int\nxenHandleConfGetValueStringListErrors(int ret)\n{\n    if (ret < 0) {\n        /* It means virConfGetValueStringList() didn't fail because the\n         * cval->type switch fell through - since we're passing\n         * @compatString == false - assumes failures for memory allocation\n         * and VIR_CONF_LIST traversal failure should cause -1 to be\n         * returned to the caller with the error message set. */\n        if (virGetLastErrorCode() != VIR_ERR_INTERNAL_ERROR)\n            return -1;\n\n        /* If we did fall through the switch, then ignore and clear the\n         * last error. */\n        virResetLastError();\n    }\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenHandleConfGetValueStringListErrors(int ret)\n{\n    if (ret < 0) {\n        /* It means virConfGetValueStringList() didn't fail because the\n         * cval->type switch fell through - since we're passing\n         * @compatString == false - assumes failures for memory allocation\n         * and VIR_CONF_LIST traversal failure should cause -1 to be\n         * returned to the caller with the error message set. */\n        if (virGetLastErrorCode() != VIR_ERR_INTERNAL_ERROR)\n            return -1;\n\n        /* If we did fall through the switch, then ignore and clear the\n         * last error. */\n        virResetLastError();\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValueStringList",
          "args": [
            "conf",
            "\"pci\"",
            "false",
            "&pcis"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueStringList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "920-984",
          "snippet": "int virConfGetValueStringList(virConfPtr conf,\n                              const char *setting,\n                              bool compatString,\n                              char ***values)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    size_t len;\n    virConfValuePtr eval;\n\n    VIR_DEBUG(\"Get value string list %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    virStringListFree(*values);\n    *values = NULL;\n\n    switch (cval->type) {\n    case VIR_CONF_LIST:\n        /* Calc length and check items */\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next) {\n            if (eval->type != VIR_CONF_STRING) {\n                virReportError(VIR_ERR_CONF_SYNTAX,\n                               _(\"%s: expected a string list for '%s' parameter\"),\n                               conf->filename, setting);\n                return -1;\n            }\n        }\n\n        if (VIR_ALLOC_N(*values, len + 1) < 0)\n            return -1;\n\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next)\n            (*values)[len] = g_strdup(eval->str);\n        break;\n\n    case VIR_CONF_STRING:\n        if (compatString) {\n            if (VIR_ALLOC_N(*values, cval->str ? 2 : 1) < 0)\n                return -1;\n            if (cval->str)\n                (*values)[0] = g_strdup(cval->str);\n            break;\n        }\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_CONF_LLONG:\n    case VIR_CONF_ULLONG:\n    case VIR_CONF_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       compatString ?\n                       _(\"%s: expected a string or string list for '%s' parameter\") :\n                       _(\"%s: expected a string list for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n\n    case VIR_CONF_LAST:\n    default:\n        virReportEnumRangeError(virConfType, cval->type);\n        return -1;\n    }\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueStringList(virConfPtr conf,\n                              const char *setting,\n                              bool compatString,\n                              char ***values)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    size_t len;\n    virConfValuePtr eval;\n\n    VIR_DEBUG(\"Get value string list %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    virStringListFree(*values);\n    *values = NULL;\n\n    switch (cval->type) {\n    case VIR_CONF_LIST:\n        /* Calc length and check items */\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next) {\n            if (eval->type != VIR_CONF_STRING) {\n                virReportError(VIR_ERR_CONF_SYNTAX,\n                               _(\"%s: expected a string list for '%s' parameter\"),\n                               conf->filename, setting);\n                return -1;\n            }\n        }\n\n        if (VIR_ALLOC_N(*values, len + 1) < 0)\n            return -1;\n\n        for (len = 0, eval = cval->list; eval; len++, eval = eval->next)\n            (*values)[len] = g_strdup(eval->str);\n        break;\n\n    case VIR_CONF_STRING:\n        if (compatString) {\n            if (VIR_ALLOC_N(*values, cval->str ? 2 : 1) < 0)\n                return -1;\n            if (cval->str)\n                (*values)[0] = g_strdup(cval->str);\n            break;\n        }\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_CONF_LLONG:\n    case VIR_CONF_ULLONG:\n    case VIR_CONF_NONE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       compatString ?\n                       _(\"%s: expected a string or string list for '%s' parameter\") :\n                       _(\"%s: expected a string list for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n\n    case VIR_CONF_LAST:\n    default:\n        virReportEnumRangeError(virConfType, cval->type);\n        return -1;\n    }\n\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParsePCIList(virConfPtr conf, virDomainDefPtr def)\n{\n    VIR_AUTOSTRINGLIST pcis = NULL;\n    char **entries = NULL;\n    int rc;\n\n    if ((rc = virConfGetValueStringList(conf, \"pci\", false, &pcis)) <= 0)\n        return xenHandleConfGetValueStringListErrors(rc);\n\n    for (entries = pcis; *entries; entries++) {\n        char *entry = *entries;\n        virDomainHostdevDefPtr hostdev;\n\n        if (!(hostdev = xenParsePCI(entry)))\n            return -1;\n\n        if (VIR_APPEND_ELEMENT(def->hostdevs, def->nhostdevs, hostdev) < 0) {\n            virDomainHostdevDefFree(hostdev);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenHandleConfGetValueStringListErrors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "448-465",
    "snippet": "static int\nxenHandleConfGetValueStringListErrors(int ret)\n{\n    if (ret < 0) {\n        /* It means virConfGetValueStringList() didn't fail because the\n         * cval->type switch fell through - since we're passing\n         * @compatString == false - assumes failures for memory allocation\n         * and VIR_CONF_LIST traversal failure should cause -1 to be\n         * returned to the caller with the error message set. */\n        if (virGetLastErrorCode() != VIR_ERR_INTERNAL_ERROR)\n            return -1;\n\n        /* If we did fall through the switch, then ignore and clear the\n         * last error. */\n        virResetLastError();\n    }\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetLastErrorCode",
          "args": [],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorCode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "280-287",
          "snippet": "int\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenHandleConfGetValueStringListErrors(int ret)\n{\n    if (ret < 0) {\n        /* It means virConfGetValueStringList() didn't fail because the\n         * cval->type switch fell through - since we're passing\n         * @compatString == false - assumes failures for memory allocation\n         * and VIR_CONF_LIST traversal failure should cause -1 to be\n         * returned to the caller with the error message set. */\n        if (virGetLastErrorCode() != VIR_ERR_INTERNAL_ERROR)\n            return -1;\n\n        /* If we did fall through the switch, then ignore and clear the\n         * last error. */\n        virResetLastError();\n    }\n    return 0;\n}"
  },
  {
    "function_name": "xenParsePCI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "371-445",
    "snippet": "static virDomainHostdevDefPtr\nxenParsePCI(char *entry)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    char domain[5];\n    char bus[3];\n    char slot[3];\n    char func[2];\n    char *key, *nextkey;\n    int domainID;\n    int busID;\n    int slotID;\n    int funcID;\n\n    domain[0] = bus[0] = slot[0] = func[0] = '\\0';\n\n    /* pci=['0000:00:1b.0','0000:00:13.0'] */\n    if (!(key = entry))\n        return NULL;\n    if (!(nextkey = strchr(key, ':')))\n        return NULL;\n    if (virStrncpy(domain, key, (nextkey - key), sizeof(domain)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Domain %s too big for destination\"), key);\n        return NULL;\n    }\n\n    key = nextkey + 1;\n    if (!(nextkey = strchr(key, ':')))\n        return NULL;\n    if (virStrncpy(bus, key, (nextkey - key), sizeof(bus)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Bus %s too big for destination\"), key);\n        return NULL;\n    }\n\n    key = nextkey + 1;\n    if (!(nextkey = strchr(key, '.')))\n        return NULL;\n    if (virStrncpy(slot, key, (nextkey - key), sizeof(slot)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Slot %s too big for destination\"), key);\n        return NULL;\n    }\n\n    key = nextkey + 1;\n    if (strlen(key) != 1)\n        return NULL;\n    if (virStrncpy(func, key, 1, sizeof(func)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Function %s too big for destination\"), key);\n        return NULL;\n    }\n\n    if (virStrToLong_i(domain, NULL, 16, &domainID) < 0)\n        return NULL;\n    if (virStrToLong_i(bus, NULL, 16, &busID) < 0)\n        return NULL;\n    if (virStrToLong_i(slot, NULL, 16, &slotID) < 0)\n        return NULL;\n    if (virStrToLong_i(func, NULL, 16, &funcID) < 0)\n        return NULL;\n\n    if (!(hostdev = virDomainHostdevDefNew()))\n       return NULL;\n\n    hostdev->managed = false;\n    hostdev->source.subsys.type = VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI;\n    hostdev->source.subsys.u.pci.addr.domain = domainID;\n    hostdev->source.subsys.u.pci.addr.bus = busID;\n    hostdev->source.subsys.u.pci.addr.slot = slotID;\n    hostdev->source.subsys.u.pci.addr.function = funcID;\n\n    return hostdev;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainHostdevDefNew",
          "args": [],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainHostdevDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2889-2906",
          "snippet": "virDomainHostdevDefPtr\nvirDomainHostdevDefNew(void)\n{\n    virDomainHostdevDefPtr def;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(def->info) < 0)\n        goto error;\n\n    return def;\n\n error:\n    VIR_FREE(def->info);\n    VIR_FREE(def);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainHostdevDefPtr\nvirDomainHostdevDefNew(void)\n{\n    virDomainHostdevDefPtr def;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(def->info) < 0)\n        goto error;\n\n    return def;\n\n error:\n    VIR_FREE(def->info);\n    VIR_FREE(def);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "func",
            "NULL",
            "16",
            "&funcID"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Function %s too big for destination\")",
            "key"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Function %s too big for destination\""
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrncpy",
          "args": [
            "func",
            "key",
            "1",
            "sizeof(func)"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "virStrncpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "746-765",
          "snippet": "int\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrncpy(char *dest, const char *src, size_t n, size_t destbytes)\n{\n    size_t src_len = strlen(src);\n\n    /* As a special case, -1 means \"copy the entire string\".\n     *\n     * This is to avoid calling strlen() twice, once in the virStrcpy()\n     * wrapper and once here for bound checking purposes. */\n    if (n == -1)\n        n = src_len;\n\n    if (n > src_len || n > (destbytes - 1))\n        return -1;\n\n    memcpy(dest, src, n);\n    dest[n] = '\\0';\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Slot %s too big for destination\")",
            "key"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "key",
            "'.'"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Bus %s too big for destination\")",
            "key"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "key",
            "':'"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Domain %s too big for destination\")",
            "key"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "key",
            "':'"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainHostdevDefPtr\nxenParsePCI(char *entry)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    char domain[5];\n    char bus[3];\n    char slot[3];\n    char func[2];\n    char *key, *nextkey;\n    int domainID;\n    int busID;\n    int slotID;\n    int funcID;\n\n    domain[0] = bus[0] = slot[0] = func[0] = '\\0';\n\n    /* pci=['0000:00:1b.0','0000:00:13.0'] */\n    if (!(key = entry))\n        return NULL;\n    if (!(nextkey = strchr(key, ':')))\n        return NULL;\n    if (virStrncpy(domain, key, (nextkey - key), sizeof(domain)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Domain %s too big for destination\"), key);\n        return NULL;\n    }\n\n    key = nextkey + 1;\n    if (!(nextkey = strchr(key, ':')))\n        return NULL;\n    if (virStrncpy(bus, key, (nextkey - key), sizeof(bus)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Bus %s too big for destination\"), key);\n        return NULL;\n    }\n\n    key = nextkey + 1;\n    if (!(nextkey = strchr(key, '.')))\n        return NULL;\n    if (virStrncpy(slot, key, (nextkey - key), sizeof(slot)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Slot %s too big for destination\"), key);\n        return NULL;\n    }\n\n    key = nextkey + 1;\n    if (strlen(key) != 1)\n        return NULL;\n    if (virStrncpy(func, key, 1, sizeof(func)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Function %s too big for destination\"), key);\n        return NULL;\n    }\n\n    if (virStrToLong_i(domain, NULL, 16, &domainID) < 0)\n        return NULL;\n    if (virStrToLong_i(bus, NULL, 16, &busID) < 0)\n        return NULL;\n    if (virStrToLong_i(slot, NULL, 16, &slotID) < 0)\n        return NULL;\n    if (virStrToLong_i(func, NULL, 16, &funcID) < 0)\n        return NULL;\n\n    if (!(hostdev = virDomainHostdevDefNew()))\n       return NULL;\n\n    hostdev->managed = false;\n    hostdev->source.subsys.type = VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI;\n    hostdev->source.subsys.u.pci.addr.domain = domainID;\n    hostdev->source.subsys.u.pci.addr.bus = busID;\n    hostdev->source.subsys.u.pci.addr.slot = slotID;\n    hostdev->source.subsys.u.pci.addr.function = funcID;\n\n    return hostdev;\n}"
  },
  {
    "function_name": "xenParseEventsActions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "333-368",
    "snippet": "static int\nxenParseEventsActions(virConfPtr conf, virDomainDefPtr def)\n{\n    g_autofree char *on_poweroff = NULL;\n    g_autofree char *on_reboot = NULL;\n    g_autofree char *on_crash = NULL;\n\n    if (xenConfigGetString(conf, \"on_poweroff\", &on_poweroff, \"destroy\") < 0)\n        return -1;\n\n    if ((def->onPoweroff = virDomainLifecycleActionTypeFromString(on_poweroff)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected value %s for on_poweroff\"), on_poweroff);\n        return -1;\n    }\n\n    if (xenConfigGetString(conf, \"on_reboot\", &on_reboot, \"restart\") < 0)\n        return -1;\n\n    if ((def->onReboot = virDomainLifecycleActionTypeFromString(on_reboot)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected value %s for on_reboot\"), on_reboot);\n        return -1;\n    }\n\n    if (xenConfigGetString(conf, \"on_crash\", &on_crash, \"restart\") < 0)\n        return -1;\n\n    if ((def->onCrash = virDomainLifecycleActionTypeFromString(on_crash)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected value %s for on_crash\"), on_crash);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected value %s for on_crash\")",
            "on_crash"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected value %s for on_crash\""
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainLifecycleActionTypeFromString",
          "args": [
            "on_crash"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xenConfigGetString",
          "args": [
            "conf",
            "\"on_crash\"",
            "&on_crash",
            "\"restart\""
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "223-243",
          "snippet": "int\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected value %s for on_reboot\")",
            "on_reboot"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainLifecycleActionTypeFromString",
          "args": [
            "on_reboot"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected value %s for on_poweroff\")",
            "on_poweroff"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainLifecycleActionTypeFromString",
          "args": [
            "on_poweroff"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseEventsActions(virConfPtr conf, virDomainDefPtr def)\n{\n    g_autofree char *on_poweroff = NULL;\n    g_autofree char *on_reboot = NULL;\n    g_autofree char *on_crash = NULL;\n\n    if (xenConfigGetString(conf, \"on_poweroff\", &on_poweroff, \"destroy\") < 0)\n        return -1;\n\n    if ((def->onPoweroff = virDomainLifecycleActionTypeFromString(on_poweroff)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected value %s for on_poweroff\"), on_poweroff);\n        return -1;\n    }\n\n    if (xenConfigGetString(conf, \"on_reboot\", &on_reboot, \"restart\") < 0)\n        return -1;\n\n    if ((def->onReboot = virDomainLifecycleActionTypeFromString(on_reboot)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected value %s for on_reboot\"), on_reboot);\n        return -1;\n    }\n\n    if (xenConfigGetString(conf, \"on_crash\", &on_crash, \"restart\") < 0)\n        return -1;\n\n    if ((def->onCrash = virDomainLifecycleActionTypeFromString(on_crash)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected value %s for on_crash\"), on_crash);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenParseTimeOffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "303-330",
    "snippet": "static int\nxenParseTimeOffset(virConfPtr conf, virDomainDefPtr def)\n{\n    int vmlocaltime;\n\n    if (xenConfigGetBool(conf, \"localtime\", &vmlocaltime, 0) < 0)\n        return -1;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        unsigned long rtc_timeoffset;\n        def->clock.offset = VIR_DOMAIN_CLOCK_OFFSET_VARIABLE;\n        if (xenConfigGetULong(conf, \"rtc_timeoffset\", &rtc_timeoffset, 0) < 0)\n            return -1;\n\n        def->clock.data.variable.adjustment = (int)rtc_timeoffset;\n        def->clock.data.variable.basis = vmlocaltime ?\n            VIR_DOMAIN_CLOCK_BASIS_LOCALTIME :\n            VIR_DOMAIN_CLOCK_BASIS_UTC;\n    } else {\n        /* PV domains do not have an emulated RTC and the offset is fixed. */\n        def->clock.offset = vmlocaltime ?\n            VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME :\n            VIR_DOMAIN_CLOCK_OFFSET_UTC;\n        def->clock.data.utc_reset = true;\n    } /* !hvm */\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenConfigGetULong",
          "args": [
            "conf",
            "\"rtc_timeoffset\"",
            "&rtc_timeoffset",
            "0"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "106-134",
          "snippet": "static int\nxenConfigGetULongLong(virConfPtr conf,\n                      const char *name,\n                      unsigned long long *value,\n                      unsigned long long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ull(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenConfigGetULongLong(virConfPtr conf,\n                      const char *name,\n                      unsigned long long *value,\n                      unsigned long long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ull(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigGetBool",
          "args": [
            "conf",
            "\"localtime\"",
            "&vmlocaltime",
            "0"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "42-66",
          "snippet": "int\nxenConfigGetBool(virConfPtr conf,\n                 const char *name,\n                 int *value,\n                 int def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l ? 1 : 0;\n    } else if (val->type == VIR_CONF_STRING) {\n        *value = STREQ(val->str, \"1\") ? 1 : 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetBool(virConfPtr conf,\n                 const char *name,\n                 int *value,\n                 int def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l ? 1 : 0;\n    } else if (val->type == VIR_CONF_STRING) {\n        *value = STREQ(val->str, \"1\") ? 1 : 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseTimeOffset(virConfPtr conf, virDomainDefPtr def)\n{\n    int vmlocaltime;\n\n    if (xenConfigGetBool(conf, \"localtime\", &vmlocaltime, 0) < 0)\n        return -1;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        unsigned long rtc_timeoffset;\n        def->clock.offset = VIR_DOMAIN_CLOCK_OFFSET_VARIABLE;\n        if (xenConfigGetULong(conf, \"rtc_timeoffset\", &rtc_timeoffset, 0) < 0)\n            return -1;\n\n        def->clock.data.variable.adjustment = (int)rtc_timeoffset;\n        def->clock.data.variable.basis = vmlocaltime ?\n            VIR_DOMAIN_CLOCK_BASIS_LOCALTIME :\n            VIR_DOMAIN_CLOCK_BASIS_UTC;\n    } else {\n        /* PV domains do not have an emulated RTC and the offset is fixed. */\n        def->clock.offset = vmlocaltime ?\n            VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME :\n            VIR_DOMAIN_CLOCK_OFFSET_UTC;\n        def->clock.data.utc_reset = true;\n    } /* !hvm */\n\n    return 0;\n}"
  },
  {
    "function_name": "xenParseMem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "283-300",
    "snippet": "static int\nxenParseMem(virConfPtr conf, virDomainDefPtr def)\n{\n    unsigned long long memory;\n\n    if (xenConfigGetULongLong(conf, \"memory\", &def->mem.cur_balloon,\n                                MIN_XEN_GUEST_SIZE * 2) < 0)\n        return -1;\n\n    if (xenConfigGetULongLong(conf, \"maxmem\", &memory,\n                                def->mem.cur_balloon) < 0)\n        return -1;\n\n    def->mem.cur_balloon *= 1024;\n    virDomainDefSetMemoryTotal(def, memory * 1024);\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefSetMemoryTotal",
          "args": [
            "def",
            "memory * 1024"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10931-10936",
          "snippet": "void\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xenConfigGetULongLong",
          "args": [
            "conf",
            "\"maxmem\"",
            "&memory",
            "def->mem.cur_balloon"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigGetULongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "106-134",
          "snippet": "static int\nxenConfigGetULongLong(virConfPtr conf,\n                      const char *name,\n                      unsigned long long *value,\n                      unsigned long long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ull(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenConfigGetULongLong(virConfPtr conf,\n                      const char *name,\n                      unsigned long long *value,\n                      unsigned long long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ull(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenParseMem(virConfPtr conf, virDomainDefPtr def)\n{\n    unsigned long long memory;\n\n    if (xenConfigGetULongLong(conf, \"memory\", &def->mem.cur_balloon,\n                                MIN_XEN_GUEST_SIZE * 2) < 0)\n        return -1;\n\n    if (xenConfigGetULongLong(conf, \"maxmem\", &memory,\n                                def->mem.cur_balloon) < 0)\n        return -1;\n\n    def->mem.cur_balloon *= 1024;\n    virDomainDefSetMemoryTotal(def, memory * 1024);\n\n    return 0;\n}"
  },
  {
    "function_name": "xenConfigSetString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "267-280",
    "snippet": "int\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConfSetValue",
          "args": [
            "conf",
            "setting",
            "value"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "virConfSetValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1338-1378",
          "snippet": "int\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "str"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "value"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetString(virConfPtr conf, const char *setting, const char *str)\n{\n    virConfValuePtr value = NULL;\n\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_STRING;\n    value->next = NULL;\n    value->str = g_strdup(str);\n\n    return virConfSetValue(conf, setting, value);\n}"
  },
  {
    "function_name": "xenConfigSetInt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "246-264",
    "snippet": "int\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virConfSetValue",
          "args": [
            "conf",
            "setting",
            "value"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "virConfSetValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "1338-1378",
          "snippet": "int\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirConfSetValue(virConfPtr conf,\n                const char *setting,\n                virConfValuePtr value)\n{\n    virConfEntryPtr cur, prev = NULL;\n\n    if (value && value->type == VIR_CONF_STRING && value->str == NULL) {\n        virConfFreeValue(value);\n        return -1;\n    }\n\n    cur = conf->entries;\n    while (cur != NULL) {\n        if (STREQ_NULLABLE(cur->name, setting))\n            break;\n        prev = cur;\n        cur = cur->next;\n    }\n\n    if (!cur) {\n        if (VIR_ALLOC(cur) < 0) {\n            virConfFreeValue(value);\n            return -1;\n        }\n        cur->comment = NULL;\n        cur->name = g_strdup(setting);\n        cur->value = value;\n        if (prev) {\n            cur->next = prev->next;\n            prev->next = cur;\n        } else {\n            cur->next = conf->entries;\n            conf->entries = cur;\n        }\n    } else {\n        virConfFreeValue(cur->value);\n        cur->value = value;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "value"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OVERFLOW",
            "_(\"failed to store %lld to %s\")",
            "l",
            "setting"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to store %lld to %s\""
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigSetInt(virConfPtr conf, const char *setting, long long l)\n{\n    virConfValuePtr value = NULL;\n\n    if ((long)l != l) {\n        virReportError(VIR_ERR_OVERFLOW, _(\"failed to store %lld to %s\"),\n                       l, setting);\n        return -1;\n    }\n    if (VIR_ALLOC(value) < 0)\n        return -1;\n\n    value->type = VIR_CONF_LLONG;\n    value->next = NULL;\n    value->l = l;\n\n    return virConfSetValue(conf, setting, value);\n}"
  },
  {
    "function_name": "xenConfigGetString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "223-243",
    "snippet": "int\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "def"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValueString",
          "args": [
            "conf",
            "name",
            "&string"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "875-898",
          "snippet": "int virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetString(virConfPtr conf,\n                   const char *name,\n                   char **value,\n                   const char *def)\n{\n    char *string = NULL;\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0 || !string) {\n        *value = g_strdup(def);\n    } else {\n        *value = string;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenConfigGetUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "178-217",
    "snippet": "static int\nxenConfigGetUUID(virConfPtr conf, const char *name, unsigned char *uuid)\n{\n    g_autofree char *string = NULL;\n    int rc;\n\n    if (!uuid || !name || !conf) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Arguments must be non null\"));\n        return -1;\n    }\n\n\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0) {\n        if (virUUIDGenerate(uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Failed to generate UUID\"));\n            return -1;\n        } else {\n            return 0;\n        }\n    }\n\n    if (!string) {\n        virReportError(VIR_ERR_CONF_SYNTAX,\n                       _(\"%s can't be empty\"), name);\n        return -1;\n    }\n\n    if (virUUIDParse(string, uuid) < 0) {\n        virReportError(VIR_ERR_CONF_SYNTAX,\n                       _(\"%s not parseable\"), string);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONF_SYNTAX",
            "_(\"%s not parseable\")",
            "string"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s not parseable\""
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "string",
            "uuid"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONF_SYNTAX",
            "_(\"%s can't be empty\")",
            "name"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to generate UUID\")"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDGenerate",
          "args": [
            "uuid"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDGenerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "50-79",
          "snippet": "int\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValueString",
          "args": [
            "conf",
            "name",
            "&string"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "875-898",
          "snippet": "int virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Arguments must be non null\")"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenConfigGetUUID(virConfPtr conf, const char *name, unsigned char *uuid)\n{\n    g_autofree char *string = NULL;\n    int rc;\n\n    if (!uuid || !name || !conf) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Arguments must be non null\"));\n        return -1;\n    }\n\n\n    if ((rc = virConfGetValueString(conf, name, &string)) < 0)\n        return -1;\n\n    if (rc == 0) {\n        if (virUUIDGenerate(uuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Failed to generate UUID\"));\n            return -1;\n        } else {\n            return 0;\n        }\n    }\n\n    if (!string) {\n        virReportError(VIR_ERR_CONF_SYNTAX,\n                       _(\"%s can't be empty\"), name);\n        return -1;\n    }\n\n    if (virUUIDParse(string, uuid) < 0) {\n        virReportError(VIR_ERR_CONF_SYNTAX,\n                       _(\"%s not parseable\"), string);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "xenConfigCopyStringOpt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "168-172",
    "snippet": "int\nxenConfigCopyStringOpt(virConfPtr conf, const char *name, char **value)\n{\n    return xenConfigCopyStringInternal(conf, name, value, 1);\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenConfigCopyStringInternal",
          "args": [
            "conf",
            "name",
            "value",
            "1"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigCopyStringInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "137-158",
          "snippet": "static int\nxenConfigCopyStringInternal(virConfPtr conf,\n                            const char *name,\n                            char **value,\n                            int allowMissing)\n{\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, value)) < 0)\n        return -1;\n\n    if (rc == 0) {\n        if (allowMissing)\n            return 0;\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was missing\"), name);\n        return -1;\n    }\n\n    return 1;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenConfigCopyStringInternal(virConfPtr conf,\n                            const char *name,\n                            char **value,\n                            int allowMissing)\n{\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, value)) < 0)\n        return -1;\n\n    if (rc == 0) {\n        if (allowMissing)\n            return 0;\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was missing\"), name);\n        return -1;\n    }\n\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigCopyStringOpt(virConfPtr conf, const char *name, char **value)\n{\n    return xenConfigCopyStringInternal(conf, name, value, 1);\n}"
  },
  {
    "function_name": "xenConfigCopyString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "161-165",
    "snippet": "int\nxenConfigCopyString(virConfPtr conf, const char *name, char **value)\n{\n    return xenConfigCopyStringInternal(conf, name, value, 0);\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xenConfigCopyStringInternal",
          "args": [
            "conf",
            "name",
            "value",
            "0"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "xenConfigCopyStringInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
          "lines": "137-158",
          "snippet": "static int\nxenConfigCopyStringInternal(virConfPtr conf,\n                            const char *name,\n                            char **value,\n                            int allowMissing)\n{\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, value)) < 0)\n        return -1;\n\n    if (rc == 0) {\n        if (allowMissing)\n            return 0;\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was missing\"), name);\n        return -1;\n    }\n\n    return 1;\n}",
          "includes": [
            "#include \"xen_common.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"xenxs_private.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenConfigCopyStringInternal(virConfPtr conf,\n                            const char *name,\n                            char **value,\n                            int allowMissing)\n{\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, value)) < 0)\n        return -1;\n\n    if (rc == 0) {\n        if (allowMissing)\n            return 0;\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was missing\"), name);\n        return -1;\n    }\n\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigCopyString(virConfPtr conf, const char *name, char **value)\n{\n    return xenConfigCopyStringInternal(conf, name, value, 0);\n}"
  },
  {
    "function_name": "xenConfigCopyStringInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "137-158",
    "snippet": "static int\nxenConfigCopyStringInternal(virConfPtr conf,\n                            const char *name,\n                            char **value,\n                            int allowMissing)\n{\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, value)) < 0)\n        return -1;\n\n    if (rc == 0) {\n        if (allowMissing)\n            return 0;\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was missing\"), name);\n        return -1;\n    }\n\n    return 1;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"config value %s was missing\")",
            "name"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"config value %s was missing\""
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValueString",
          "args": [
            "conf",
            "name",
            "value"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "875-898",
          "snippet": "int virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nint virConfGetValueString(virConfPtr conf,\n                          const char *setting,\n                          char **value)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n\n    VIR_DEBUG(\"Get value string %p %d\",\n              cval, cval ? cval->type : VIR_CONF_NONE);\n\n    if (!cval)\n        return 0;\n\n    if (cval->type != VIR_CONF_STRING) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: expected a string for '%s' parameter\"),\n                       conf->filename, setting);\n        return -1;\n    }\n\n    VIR_FREE(*value);\n    *value = g_strdup(cval->str);\n\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenConfigCopyStringInternal(virConfPtr conf,\n                            const char *name,\n                            char **value,\n                            int allowMissing)\n{\n    int rc;\n\n    *value = NULL;\n    if ((rc = virConfGetValueString(conf, name, value)) < 0)\n        return -1;\n\n    if (rc == 0) {\n        if (allowMissing)\n            return 0;\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was missing\"), name);\n        return -1;\n    }\n\n    return 1;\n}"
  },
  {
    "function_name": "xenConfigGetULongLong",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "106-134",
    "snippet": "static int\nxenConfigGetULongLong(virConfPtr conf,\n                      const char *name,\n                      unsigned long long *value,\n                      unsigned long long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ull(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"config value %s was malformed\")",
            "name"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"config value %s was malformed\""
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"config value %s was malformed\")",
            "name"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ull",
          "args": [
            "val->str",
            "NULL",
            "10",
            "value"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValue",
          "args": [
            "conf",
            "name"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "849-857",
          "snippet": "virConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvirConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nxenConfigGetULongLong(virConfPtr conf,\n                      const char *name,\n                      unsigned long long *value,\n                      unsigned long long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ull(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "xenConfigGetULong",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "72-100",
    "snippet": "int\nxenConfigGetULong(virConfPtr conf,\n                  const char *name,\n                  unsigned long *value,\n                  unsigned long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ul(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"config value %s was malformed\")",
            "name"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"config value %s was malformed\""
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"config value %s was malformed\")",
            "name"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ul",
          "args": [
            "val->str",
            "NULL",
            "10",
            "value"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ullp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "568-586",
          "snippet": "int\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ullp(char const *s, char **end_ptr, int base,\n                  unsigned long long *result)\n{\n    unsigned long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoull(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConfGetValue",
          "args": [
            "conf",
            "name"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "849-857",
          "snippet": "virConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvirConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetULong(virConfPtr conf,\n                  const char *name,\n                  unsigned long *value,\n                  unsigned long def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l;\n    } else if (val->type == VIR_CONF_STRING) {\n        if (virStrToLong_ul(val->str, NULL, 10, value) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"config value %s was malformed\"), name);\n            return -1;\n        }\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "xenConfigGetBool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/xen_common.c",
    "lines": "42-66",
    "snippet": "int\nxenConfigGetBool(virConfPtr conf,\n                 const char *name,\n                 int *value,\n                 int def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l ? 1 : 0;\n    } else if (val->type == VIR_CONF_STRING) {\n        *value = STREQ(val->str, \"1\") ? 1 : 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"xen_common.h\"",
      "#include \"virstring.h\"",
      "#include \"domain_conf.h\"",
      "#include \"xenxs_private.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"config value %s was malformed\")",
            "name"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"config value %s was malformed\""
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "val->str",
            "\"1\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConfGetValue",
          "args": [
            "conf",
            "name"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "virConfGetValueType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virconf.c",
          "lines": "849-857",
          "snippet": "virConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nvirConfType virConfGetValueType(virConfPtr conf,\n                                const char *setting)\n{\n    virConfValuePtr cval = virConfGetValue(conf, setting);\n    if (!cval)\n        return VIR_CONF_NONE;\n\n    return cval->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xen_common.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"xenxs_private.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nxenConfigGetBool(virConfPtr conf,\n                 const char *name,\n                 int *value,\n                 int def)\n{\n    virConfValuePtr val;\n\n    *value = 0;\n    if (!(val = virConfGetValue(conf, name))) {\n        *value = def;\n        return 0;\n    }\n\n    if (val->type == VIR_CONF_ULLONG) {\n        *value = val->l ? 1 : 0;\n    } else if (val->type == VIR_CONF_STRING) {\n        *value = STREQ(val->str, \"1\") ? 1 : 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"config value %s was malformed\"), name);\n        return -1;\n    }\n    return 0;\n}"
  }
]