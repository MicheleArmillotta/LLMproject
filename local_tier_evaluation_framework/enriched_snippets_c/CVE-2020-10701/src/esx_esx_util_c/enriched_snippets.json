[
  {
    "function_name": "esxUtil_EscapeForXml",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
    "lines": "456-464",
    "snippet": "char *\nesxUtil_EscapeForXml(const char *string)\n{\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n\n    virBufferEscapeString(&buffer, \"%s\", string);\n\n    return virBufferContentAndReset(&buffer);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_private.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buffer"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "&buffer",
            "\"%s\"",
            "string"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nesxUtil_EscapeForXml(const char *string)\n{\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n\n    virBufferEscapeString(&buffer, \"%s\", string);\n\n    return virBufferContentAndReset(&buffer);\n}"
  },
  {
    "function_name": "esxUtil_EscapeDatastoreItem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
    "lines": "429-452",
    "snippet": "char *\nesxUtil_EscapeDatastoreItem(const char *string)\n{\n    char *replaced;\n    char *escaped1;\n    char *escaped2 = NULL;\n\n    replaced = g_strdup(string);\n\n    esxUtil_ReplaceSpecialWindowsPathChars(replaced);\n\n    escaped1 = virVMXEscapeHexPercent(replaced);\n\n    if (!escaped1)\n        goto cleanup;\n\n    escaped2 = esxUtil_EscapeBase64(escaped1);\n\n cleanup:\n    VIR_FREE(replaced);\n    VIR_FREE(escaped1);\n\n    return escaped2;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_private.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "escaped1"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "replaced"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxUtil_EscapeBase64",
          "args": [
            "escaped1"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_EscapeBase64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "349-401",
          "snippet": "char *\nesxUtil_EscapeBase64(const char *string)\n{\n    /* 'normal' characters don't get base64 encoded */\n    static const char *normal =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'(),. _-\";\n\n    /* VMware uses ',' instead of the path separator '/' in the base64 alphabet */\n    static const char *base64 =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+,\";\n\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    const char *tmp1 = string;\n    size_t length;\n    unsigned char c1, c2, c3;\n\n    /* Escape sequences of non-'normal' characters as base64 without padding */\n    while (*tmp1 != '\\0') {\n        length = strspn(tmp1, normal);\n\n        if (length > 0) {\n            virBufferAdd(&buffer, tmp1, length);\n\n            tmp1 += length;\n        } else {\n            length = strcspn(tmp1, normal);\n\n            virBufferAddChar(&buffer, '+');\n\n            while (length > 0) {\n                c1 = *tmp1++;\n                c2 = length > 1 ? *tmp1++ : 0;\n                c3 = length > 2 ? *tmp1++ : 0;\n\n                virBufferAddChar(&buffer, base64[(c1 >> 2) & 0x3f]);\n                virBufferAddChar(&buffer, base64[((c1 << 4) + (c2 >> 4)) & 0x3f]);\n\n                if (length > 1)\n                    virBufferAddChar(&buffer, base64[((c2 << 2) + (c3 >> 6)) & 0x3f]);\n\n                if (length > 2)\n                    virBufferAddChar(&buffer, base64[c3 & 0x3f]);\n\n                length -= length > 3 ? 3 : length;\n            }\n\n            if (*tmp1 != '\\0')\n                virBufferAddChar(&buffer, '-');\n        }\n    }\n\n    return virBufferContentAndReset(&buffer);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nesxUtil_EscapeBase64(const char *string)\n{\n    /* 'normal' characters don't get base64 encoded */\n    static const char *normal =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'(),. _-\";\n\n    /* VMware uses ',' instead of the path separator '/' in the base64 alphabet */\n    static const char *base64 =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+,\";\n\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    const char *tmp1 = string;\n    size_t length;\n    unsigned char c1, c2, c3;\n\n    /* Escape sequences of non-'normal' characters as base64 without padding */\n    while (*tmp1 != '\\0') {\n        length = strspn(tmp1, normal);\n\n        if (length > 0) {\n            virBufferAdd(&buffer, tmp1, length);\n\n            tmp1 += length;\n        } else {\n            length = strcspn(tmp1, normal);\n\n            virBufferAddChar(&buffer, '+');\n\n            while (length > 0) {\n                c1 = *tmp1++;\n                c2 = length > 1 ? *tmp1++ : 0;\n                c3 = length > 2 ? *tmp1++ : 0;\n\n                virBufferAddChar(&buffer, base64[(c1 >> 2) & 0x3f]);\n                virBufferAddChar(&buffer, base64[((c1 << 4) + (c2 >> 4)) & 0x3f]);\n\n                if (length > 1)\n                    virBufferAddChar(&buffer, base64[((c2 << 2) + (c3 >> 6)) & 0x3f]);\n\n                if (length > 2)\n                    virBufferAddChar(&buffer, base64[c3 & 0x3f]);\n\n                length -= length > 3 ? 3 : length;\n            }\n\n            if (*tmp1 != '\\0')\n                virBufferAddChar(&buffer, '-');\n        }\n    }\n\n    return virBufferContentAndReset(&buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXEscapeHexPercent",
          "args": [
            "replaced"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxUtil_ReplaceSpecialWindowsPathChars",
          "args": [
            "replaced"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ReplaceSpecialWindowsPathChars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "405-425",
          "snippet": "void\nesxUtil_ReplaceSpecialWindowsPathChars(char *string)\n{\n    /* '/' and '\\\\' are missing on purpose */\n    static const char *specials = \"\\\"*<>:|?\";\n\n    char *tmp = string;\n    size_t length;\n\n    while (*tmp != '\\0') {\n        length = strspn(tmp, specials);\n\n        while (length > 0) {\n            *tmp++ = '_';\n            --length;\n        }\n\n        if (*tmp != '\\0')\n            ++tmp;\n    }\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nesxUtil_ReplaceSpecialWindowsPathChars(char *string)\n{\n    /* '/' and '\\\\' are missing on purpose */\n    static const char *specials = \"\\\"*<>:|?\";\n\n    char *tmp = string;\n    size_t length;\n\n    while (*tmp != '\\0') {\n        length = strspn(tmp, specials);\n\n        while (length > 0) {\n            *tmp++ = '_';\n            --length;\n        }\n\n        if (*tmp != '\\0')\n            ++tmp;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "string"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nesxUtil_EscapeDatastoreItem(const char *string)\n{\n    char *replaced;\n    char *escaped1;\n    char *escaped2 = NULL;\n\n    replaced = g_strdup(string);\n\n    esxUtil_ReplaceSpecialWindowsPathChars(replaced);\n\n    escaped1 = virVMXEscapeHexPercent(replaced);\n\n    if (!escaped1)\n        goto cleanup;\n\n    escaped2 = esxUtil_EscapeBase64(escaped1);\n\n cleanup:\n    VIR_FREE(replaced);\n    VIR_FREE(escaped1);\n\n    return escaped2;\n}"
  },
  {
    "function_name": "esxUtil_ReplaceSpecialWindowsPathChars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
    "lines": "405-425",
    "snippet": "void\nesxUtil_ReplaceSpecialWindowsPathChars(char *string)\n{\n    /* '/' and '\\\\' are missing on purpose */\n    static const char *specials = \"\\\"*<>:|?\";\n\n    char *tmp = string;\n    size_t length;\n\n    while (*tmp != '\\0') {\n        length = strspn(tmp, specials);\n\n        while (length > 0) {\n            *tmp++ = '_';\n            --length;\n        }\n\n        if (*tmp != '\\0')\n            ++tmp;\n    }\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_private.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "tmp",
            "specials"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nesxUtil_ReplaceSpecialWindowsPathChars(char *string)\n{\n    /* '/' and '\\\\' are missing on purpose */\n    static const char *specials = \"\\\"*<>:|?\";\n\n    char *tmp = string;\n    size_t length;\n\n    while (*tmp != '\\0') {\n        length = strspn(tmp, specials);\n\n        while (length > 0) {\n            *tmp++ = '_';\n            --length;\n        }\n\n        if (*tmp != '\\0')\n            ++tmp;\n    }\n}"
  },
  {
    "function_name": "esxUtil_EscapeBase64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
    "lines": "349-401",
    "snippet": "char *\nesxUtil_EscapeBase64(const char *string)\n{\n    /* 'normal' characters don't get base64 encoded */\n    static const char *normal =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'(),. _-\";\n\n    /* VMware uses ',' instead of the path separator '/' in the base64 alphabet */\n    static const char *base64 =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+,\";\n\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    const char *tmp1 = string;\n    size_t length;\n    unsigned char c1, c2, c3;\n\n    /* Escape sequences of non-'normal' characters as base64 without padding */\n    while (*tmp1 != '\\0') {\n        length = strspn(tmp1, normal);\n\n        if (length > 0) {\n            virBufferAdd(&buffer, tmp1, length);\n\n            tmp1 += length;\n        } else {\n            length = strcspn(tmp1, normal);\n\n            virBufferAddChar(&buffer, '+');\n\n            while (length > 0) {\n                c1 = *tmp1++;\n                c2 = length > 1 ? *tmp1++ : 0;\n                c3 = length > 2 ? *tmp1++ : 0;\n\n                virBufferAddChar(&buffer, base64[(c1 >> 2) & 0x3f]);\n                virBufferAddChar(&buffer, base64[((c1 << 4) + (c2 >> 4)) & 0x3f]);\n\n                if (length > 1)\n                    virBufferAddChar(&buffer, base64[((c2 << 2) + (c3 >> 6)) & 0x3f]);\n\n                if (length > 2)\n                    virBufferAddChar(&buffer, base64[c3 & 0x3f]);\n\n                length -= length > 3 ? 3 : length;\n            }\n\n            if (*tmp1 != '\\0')\n                virBufferAddChar(&buffer, '-');\n        }\n    }\n\n    return virBufferContentAndReset(&buffer);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_private.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buffer"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddChar",
          "args": [
            "&buffer",
            "'-'"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "206-210",
          "snippet": "void\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "tmp1",
            "normal"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "&buffer",
            "tmp1",
            "length"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "tmp1",
            "normal"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nesxUtil_EscapeBase64(const char *string)\n{\n    /* 'normal' characters don't get base64 encoded */\n    static const char *normal =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'(),. _-\";\n\n    /* VMware uses ',' instead of the path separator '/' in the base64 alphabet */\n    static const char *base64 =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+,\";\n\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    const char *tmp1 = string;\n    size_t length;\n    unsigned char c1, c2, c3;\n\n    /* Escape sequences of non-'normal' characters as base64 without padding */\n    while (*tmp1 != '\\0') {\n        length = strspn(tmp1, normal);\n\n        if (length > 0) {\n            virBufferAdd(&buffer, tmp1, length);\n\n            tmp1 += length;\n        } else {\n            length = strcspn(tmp1, normal);\n\n            virBufferAddChar(&buffer, '+');\n\n            while (length > 0) {\n                c1 = *tmp1++;\n                c2 = length > 1 ? *tmp1++ : 0;\n                c3 = length > 2 ? *tmp1++ : 0;\n\n                virBufferAddChar(&buffer, base64[(c1 >> 2) & 0x3f]);\n                virBufferAddChar(&buffer, base64[((c1 << 4) + (c2 >> 4)) & 0x3f]);\n\n                if (length > 1)\n                    virBufferAddChar(&buffer, base64[((c2 << 2) + (c3 >> 6)) & 0x3f]);\n\n                if (length > 2)\n                    virBufferAddChar(&buffer, base64[c3 & 0x3f]);\n\n                length -= length > 3 ? 3 : length;\n            }\n\n            if (*tmp1 != '\\0')\n                virBufferAddChar(&buffer, '-');\n        }\n    }\n\n    return virBufferContentAndReset(&buffer);\n}"
  },
  {
    "function_name": "esxUtil_ReformatUuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
    "lines": "330-345",
    "snippet": "int\nesxUtil_ReformatUuid(const char *input, char *output)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n\n    if (virUUIDParse(input, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       input);\n        return -1;\n    }\n\n    virUUIDFormat(uuid, output);\n\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_private.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "uuid",
            "output"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not parse UUID from string '%s'\")",
            "input"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not parse UUID from string '%s'\""
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_EscapeForXml",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "456-464",
          "snippet": "char *\nesxUtil_EscapeForXml(const char *string)\n{\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n\n    virBufferEscapeString(&buffer, \"%s\", string);\n\n    return virBufferContentAndReset(&buffer);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nesxUtil_EscapeForXml(const char *string)\n{\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n\n    virBufferEscapeString(&buffer, \"%s\", string);\n\n    return virBufferContentAndReset(&buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "input",
            "uuid"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ReformatUuid(const char *input, char *output)\n{\n    unsigned char uuid[VIR_UUID_BUFLEN];\n\n    if (virUUIDParse(input, uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not parse UUID from string '%s'\"),\n                       input);\n        return -1;\n    }\n\n    virUUIDFormat(uuid, output);\n\n    return 0;\n}"
  },
  {
    "function_name": "esxUtil_ResolveHostname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
    "lines": "281-326",
    "snippet": "int\nesxUtil_ResolveHostname(const char *hostname,\n                        char *ipAddress, size_t ipAddress_length)\n{\n    struct addrinfo hints;\n    struct addrinfo *result = NULL;\n    int errcode;\n\n    memset(&hints, 0, sizeof(hints));\n\n    hints.ai_flags = AI_ADDRCONFIG;\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = 0;\n\n    errcode = getaddrinfo(hostname, NULL, &hints, &result);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"IP address lookup for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    if (!result) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No IP address for host '%s' found: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    errcode = getnameinfo(result->ai_addr, result->ai_addrlen, ipAddress,\n                          ipAddress_length, NULL, 0, NI_NUMERICHOST);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Formatting IP address for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        freeaddrinfo(result);\n        return -1;\n    }\n\n    freeaddrinfo(result);\n\n    return 0;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_private.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "result"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "result"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Formatting IP address for host '%s' failed: %s\")",
            "hostname",
            "gai_strerror(errcode)"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "errcode"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Formatting IP address for host '%s' failed: %s\""
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_EscapeForXml",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "456-464",
          "snippet": "char *\nesxUtil_EscapeForXml(const char *string)\n{\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n\n    virBufferEscapeString(&buffer, \"%s\", string);\n\n    return virBufferContentAndReset(&buffer);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nesxUtil_EscapeForXml(const char *string)\n{\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n\n    virBufferEscapeString(&buffer, \"%s\", string);\n\n    return virBufferContentAndReset(&buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "result->ai_addr",
            "result->ai_addrlen",
            "ipAddress",
            "ipAddress_length",
            "NULL",
            "0",
            "NI_NUMERICHOST"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"No IP address for host '%s' found: %s\")",
            "hostname",
            "gai_strerror(errcode)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "errcode"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"IP address lookup for host '%s' failed: %s\")",
            "hostname",
            "gai_strerror(errcode)"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "errcode"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "hostname",
            "NULL",
            "&hints",
            "&result"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ResolveHostname(const char *hostname,\n                        char *ipAddress, size_t ipAddress_length)\n{\n    struct addrinfo hints;\n    struct addrinfo *result = NULL;\n    int errcode;\n\n    memset(&hints, 0, sizeof(hints));\n\n    hints.ai_flags = AI_ADDRCONFIG;\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = 0;\n\n    errcode = getaddrinfo(hostname, NULL, &hints, &result);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"IP address lookup for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    if (!result) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No IP address for host '%s' found: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    errcode = getnameinfo(result->ai_addr, result->ai_addrlen, ipAddress,\n                          ipAddress_length, NULL, 0, NI_NUMERICHOST);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Formatting IP address for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        freeaddrinfo(result);\n        return -1;\n    }\n\n    freeaddrinfo(result);\n\n    return 0;\n}"
  },
  {
    "function_name": "esxUtil_ParseDatastorePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
    "lines": "206-277",
    "snippet": "int\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_private.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "copyOfDatastorePath"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*directoryAndFileName"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*directoryName"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*datastoreName"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "preliminaryDirectoryAndFileName"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "preliminaryDirectoryAndFileName",
            "'/'"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "preliminaryDirectoryAndFileName",
            "\" \""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\"\"",
            "&saveptr"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\")",
            "datastorePath"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\""
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_EscapeForXml",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "456-464",
          "snippet": "char *\nesxUtil_EscapeForXml(const char *string)\n{\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n\n    virBufferEscapeString(&buffer, \"%s\", string);\n\n    return virBufferContentAndReset(&buffer);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nesxUtil_EscapeForXml(const char *string)\n{\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n\n    virBufferEscapeString(&buffer, \"%s\", string);\n\n    return virBufferContentAndReset(&buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "tmp",
            "\"]\"",
            "&saveptr"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "copyOfDatastorePath",
            "\"[\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}"
  },
  {
    "function_name": "esxUtil_ParseVirtualMachineIDString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
    "lines": "185-202",
    "snippet": "int\nesxUtil_ParseVirtualMachineIDString(const char *id_string, int *id)\n{\n    /* Try to parse an integer from the complete string. */\n    if (virStrToLong_i(id_string, NULL, 10, id) == 0)\n        return 0;\n\n    /*\n     * If that fails try to parse an integer from the string tail\n     * assuming the naming scheme Virtual Center seems to use.\n     */\n    if (STRPREFIX(id_string, \"vm-\")) {\n        if (virStrToLong_i(id_string + 3, NULL, 10, id) == 0)\n            return 0;\n    }\n\n    return -1;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_private.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "id_string + 3",
            "NULL",
            "10",
            "id"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "id_string",
            "\"vm-\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ParseVirtualMachineIDString(const char *id_string, int *id)\n{\n    /* Try to parse an integer from the complete string. */\n    if (virStrToLong_i(id_string, NULL, 10, id) == 0)\n        return 0;\n\n    /*\n     * If that fails try to parse an integer from the string tail\n     * assuming the naming scheme Virtual Center seems to use.\n     */\n    if (STRPREFIX(id_string, \"vm-\")) {\n        if (virStrToLong_i(id_string + 3, NULL, 10, id) == 0)\n            return 0;\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "esxUtil_FreeParsedUri",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
    "lines": "169-181",
    "snippet": "void\nesxUtil_FreeParsedUri(esxUtil_ParsedUri **parsedUri)\n{\n    if (!parsedUri || !(*parsedUri))\n        return;\n\n    VIR_FREE((*parsedUri)->transport);\n    VIR_FREE((*parsedUri)->vCenter);\n    VIR_FREE((*parsedUri)->proxy_hostname);\n    VIR_FREE((*parsedUri)->path);\n\n    VIR_FREE(*parsedUri);\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_private.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*parsedUri"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "(*parsedUri)->path"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "(*parsedUri)->proxy_hostname"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "(*parsedUri)->vCenter"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "(*parsedUri)->transport"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nesxUtil_FreeParsedUri(esxUtil_ParsedUri **parsedUri)\n{\n    if (!parsedUri || !(*parsedUri))\n        return;\n\n    VIR_FREE((*parsedUri)->transport);\n    VIR_FREE((*parsedUri)->vCenter);\n    VIR_FREE((*parsedUri)->proxy_hostname);\n    VIR_FREE((*parsedUri)->path);\n\n    VIR_FREE(*parsedUri);\n}"
  },
  {
    "function_name": "esxUtil_ParseUri",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
    "lines": "41-164",
    "snippet": "int\nesxUtil_ParseUri(esxUtil_ParsedUri **parsedUri, virURIPtr uri)\n{\n    int result = -1;\n    size_t i;\n    int noVerify;\n    int autoAnswer;\n    char *tmp;\n\n    ESX_VI_CHECK_ARG_LIST(parsedUri);\n\n    if (VIR_ALLOC(*parsedUri) < 0)\n        return -1;\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        virURIParamPtr queryParam = &uri->params[i];\n\n        if (STRCASEEQ(queryParam->name, \"transport\")) {\n            VIR_FREE((*parsedUri)->transport);\n\n            (*parsedUri)->transport = g_strdup(queryParam->value);\n\n            if (STRNEQ((*parsedUri)->transport, \"http\") &&\n                STRNEQ((*parsedUri)->transport, \"https\")) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'transport' has unexpected value \"\n                                 \"'%s' (should be http|https)\"),\n                               (*parsedUri)->transport);\n                goto cleanup;\n            }\n        } else if (STRCASEEQ(queryParam->name, \"vcenter\")) {\n            VIR_FREE((*parsedUri)->vCenter);\n\n            (*parsedUri)->vCenter = g_strdup(queryParam->value);\n        } else if (STRCASEEQ(queryParam->name, \"no_verify\")) {\n            if (virStrToLong_i(queryParam->value, NULL, 10, &noVerify) < 0 ||\n                (noVerify != 0 && noVerify != 1)) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'no_verify' has unexpected value \"\n                                 \"'%s' (should be 0 or 1)\"), queryParam->value);\n                goto cleanup;\n            }\n\n            (*parsedUri)->noVerify = noVerify != 0;\n        } else if (STRCASEEQ(queryParam->name, \"auto_answer\")) {\n            if (virStrToLong_i(queryParam->value, NULL, 10, &autoAnswer) < 0 ||\n                (autoAnswer != 0 && autoAnswer != 1)) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'auto_answer' has unexpected \"\n                                 \"value '%s' (should be 0 or 1)\"), queryParam->value);\n                goto cleanup;\n            }\n\n            (*parsedUri)->autoAnswer = autoAnswer != 0;\n        } else if (STRCASEEQ(queryParam->name, \"proxy\")) {\n            /* Expected format: [<type>://]<hostname>[:<port>] */\n            (*parsedUri)->proxy = true;\n            (*parsedUri)->proxy_type = CURLPROXY_HTTP;\n            VIR_FREE((*parsedUri)->proxy_hostname);\n            (*parsedUri)->proxy_port = 1080;\n\n            if ((tmp = STRSKIP(queryParam->value, \"http://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_HTTP;\n            } else if ((tmp = STRSKIP(queryParam->value, \"socks://\")) ||\n                       (tmp = STRSKIP(queryParam->value, \"socks5://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_SOCKS5;\n            } else if ((tmp = STRSKIP(queryParam->value, \"socks4://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_SOCKS4;\n            } else if ((tmp = STRSKIP(queryParam->value, \"socks4a://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_SOCKS4A;\n            } else if ((tmp = strstr(queryParam->value, \"://\"))) {\n                *tmp = '\\0';\n\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'proxy' contains unexpected \"\n                                 \"type '%s' (should be (http|socks(|4|4a|5))\"),\n                               queryParam->value);\n                goto cleanup;\n            } else {\n                tmp = queryParam->value;\n            }\n\n            (*parsedUri)->proxy_hostname = g_strdup(tmp);\n\n            if ((tmp = strchr((*parsedUri)->proxy_hostname, ':'))) {\n                if (tmp == (*parsedUri)->proxy_hostname) {\n                    virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                                   _(\"Query parameter 'proxy' doesn't contain a \"\n                                     \"hostname\"));\n                    goto cleanup;\n                }\n\n                *tmp++ = '\\0';\n\n                if (virStrToLong_i(tmp, NULL, 10,\n                                   &(*parsedUri)->proxy_port) < 0 ||\n                    (*parsedUri)->proxy_port < 1 ||\n                    (*parsedUri)->proxy_port > 65535) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"Query parameter 'proxy' has unexpected \"\n                                     \"port value '%s' (should be [1..65535])\"),\n                                   tmp);\n                    goto cleanup;\n                }\n            }\n        } else {\n            VIR_WARN(\"Ignoring unexpected query parameter '%s'\",\n                     queryParam->name);\n        }\n    }\n\n    (*parsedUri)->path = g_strdup(uri->path);\n\n    if (!(*parsedUri)->transport)\n        (*parsedUri)->transport = g_strdup(\"https\");\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxUtil_FreeParsedUri(parsedUri);\n\n    return result;\n}",
    "includes": [
      "#include \"virsocket.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_private.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxUtil_FreeParsedUri",
          "args": [
            "parsedUri"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_FreeParsedUri",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "169-181",
          "snippet": "void\nesxUtil_FreeParsedUri(esxUtil_ParsedUri **parsedUri)\n{\n    if (!parsedUri || !(*parsedUri))\n        return;\n\n    VIR_FREE((*parsedUri)->transport);\n    VIR_FREE((*parsedUri)->vCenter);\n    VIR_FREE((*parsedUri)->proxy_hostname);\n    VIR_FREE((*parsedUri)->path);\n\n    VIR_FREE(*parsedUri);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nesxUtil_FreeParsedUri(esxUtil_ParsedUri **parsedUri)\n{\n    if (!parsedUri || !(*parsedUri))\n        return;\n\n    VIR_FREE((*parsedUri)->transport);\n    VIR_FREE((*parsedUri)->vCenter);\n    VIR_FREE((*parsedUri)->proxy_hostname);\n    VIR_FREE((*parsedUri)->path);\n\n    VIR_FREE(*parsedUri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"https\""
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Ignoring unexpected query parameter '%s'\"",
            "queryParam->name"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Query parameter 'proxy' has unexpected \"\n                                     \"port value '%s' (should be [1..65535])\")",
            "tmp"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Query parameter 'proxy' has unexpected \"\n                                     \"port value '%s' (should be [1..65535])\""
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_EscapeForXml",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "456-464",
          "snippet": "char *\nesxUtil_EscapeForXml(const char *string)\n{\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n\n    virBufferEscapeString(&buffer, \"%s\", string);\n\n    return virBufferContentAndReset(&buffer);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nesxUtil_EscapeForXml(const char *string)\n{\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n\n    virBufferEscapeString(&buffer, \"%s\", string);\n\n    return virBufferContentAndReset(&buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "tmp",
            "NULL",
            "10",
            "&(*parsedUri)->proxy_port"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Query parameter 'proxy' doesn't contain a \"\n                                     \"hostname\")"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "(*parsedUri)->proxy_hostname",
            "':'"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Query parameter 'proxy' contains unexpected \"\n                                 \"type '%s' (should be (http|socks(|4|4a|5))\")",
            "queryParam->value"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "queryParam->value",
            "\"://\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "queryParam->value",
            "\"socks4a://\""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "queryParam->value",
            "\"socks4://\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "queryParam->value",
            "\"socks5://\""
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "queryParam->value",
            "\"socks://\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "queryParam->value",
            "\"http://\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "(*parsedUri)->proxy_hostname"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "queryParam->name",
            "\"proxy\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Query parameter 'auto_answer' has unexpected \"\n                                 \"value '%s' (should be 0 or 1)\")",
            "queryParam->value"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "queryParam->name",
            "\"auto_answer\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Query parameter 'no_verify' has unexpected value \"\n                                 \"'%s' (should be 0 or 1)\")",
            "queryParam->value"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "queryParam->name",
            "\"no_verify\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "(*parsedUri)->vCenter"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "queryParam->name",
            "\"vcenter\""
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Query parameter 'transport' has unexpected value \"\n                                 \"'%s' (should be http|https)\")",
            "(*parsedUri)->transport"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "(*parsedUri)->transport",
            "\"https\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "(*parsedUri)->transport",
            "\"http\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "(*parsedUri)->transport"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "queryParam->name",
            "\"transport\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "*parsedUri"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "parsedUri"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ParseUri(esxUtil_ParsedUri **parsedUri, virURIPtr uri)\n{\n    int result = -1;\n    size_t i;\n    int noVerify;\n    int autoAnswer;\n    char *tmp;\n\n    ESX_VI_CHECK_ARG_LIST(parsedUri);\n\n    if (VIR_ALLOC(*parsedUri) < 0)\n        return -1;\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        virURIParamPtr queryParam = &uri->params[i];\n\n        if (STRCASEEQ(queryParam->name, \"transport\")) {\n            VIR_FREE((*parsedUri)->transport);\n\n            (*parsedUri)->transport = g_strdup(queryParam->value);\n\n            if (STRNEQ((*parsedUri)->transport, \"http\") &&\n                STRNEQ((*parsedUri)->transport, \"https\")) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'transport' has unexpected value \"\n                                 \"'%s' (should be http|https)\"),\n                               (*parsedUri)->transport);\n                goto cleanup;\n            }\n        } else if (STRCASEEQ(queryParam->name, \"vcenter\")) {\n            VIR_FREE((*parsedUri)->vCenter);\n\n            (*parsedUri)->vCenter = g_strdup(queryParam->value);\n        } else if (STRCASEEQ(queryParam->name, \"no_verify\")) {\n            if (virStrToLong_i(queryParam->value, NULL, 10, &noVerify) < 0 ||\n                (noVerify != 0 && noVerify != 1)) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'no_verify' has unexpected value \"\n                                 \"'%s' (should be 0 or 1)\"), queryParam->value);\n                goto cleanup;\n            }\n\n            (*parsedUri)->noVerify = noVerify != 0;\n        } else if (STRCASEEQ(queryParam->name, \"auto_answer\")) {\n            if (virStrToLong_i(queryParam->value, NULL, 10, &autoAnswer) < 0 ||\n                (autoAnswer != 0 && autoAnswer != 1)) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'auto_answer' has unexpected \"\n                                 \"value '%s' (should be 0 or 1)\"), queryParam->value);\n                goto cleanup;\n            }\n\n            (*parsedUri)->autoAnswer = autoAnswer != 0;\n        } else if (STRCASEEQ(queryParam->name, \"proxy\")) {\n            /* Expected format: [<type>://]<hostname>[:<port>] */\n            (*parsedUri)->proxy = true;\n            (*parsedUri)->proxy_type = CURLPROXY_HTTP;\n            VIR_FREE((*parsedUri)->proxy_hostname);\n            (*parsedUri)->proxy_port = 1080;\n\n            if ((tmp = STRSKIP(queryParam->value, \"http://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_HTTP;\n            } else if ((tmp = STRSKIP(queryParam->value, \"socks://\")) ||\n                       (tmp = STRSKIP(queryParam->value, \"socks5://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_SOCKS5;\n            } else if ((tmp = STRSKIP(queryParam->value, \"socks4://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_SOCKS4;\n            } else if ((tmp = STRSKIP(queryParam->value, \"socks4a://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_SOCKS4A;\n            } else if ((tmp = strstr(queryParam->value, \"://\"))) {\n                *tmp = '\\0';\n\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'proxy' contains unexpected \"\n                                 \"type '%s' (should be (http|socks(|4|4a|5))\"),\n                               queryParam->value);\n                goto cleanup;\n            } else {\n                tmp = queryParam->value;\n            }\n\n            (*parsedUri)->proxy_hostname = g_strdup(tmp);\n\n            if ((tmp = strchr((*parsedUri)->proxy_hostname, ':'))) {\n                if (tmp == (*parsedUri)->proxy_hostname) {\n                    virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                                   _(\"Query parameter 'proxy' doesn't contain a \"\n                                     \"hostname\"));\n                    goto cleanup;\n                }\n\n                *tmp++ = '\\0';\n\n                if (virStrToLong_i(tmp, NULL, 10,\n                                   &(*parsedUri)->proxy_port) < 0 ||\n                    (*parsedUri)->proxy_port < 1 ||\n                    (*parsedUri)->proxy_port > 65535) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"Query parameter 'proxy' has unexpected \"\n                                     \"port value '%s' (should be [1..65535])\"),\n                                   tmp);\n                    goto cleanup;\n                }\n            }\n        } else {\n            VIR_WARN(\"Ignoring unexpected query parameter '%s'\",\n                     queryParam->name);\n        }\n    }\n\n    (*parsedUri)->path = g_strdup(uri->path);\n\n    if (!(*parsedUri)->transport)\n        (*parsedUri)->transport = g_strdup(\"https\");\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxUtil_FreeParsedUri(parsedUri);\n\n    return result;\n}"
  }
]