[
  {
    "function_name": "virCapabilitiesHostInitIOMMU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "2005-2009",
    "snippet": "void\nvirCapabilitiesHostInitIOMMU(virCapsPtr caps)\n{\n    caps->host.iommu = virHostHasIOMMU();\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostHasIOMMU",
          "args": [],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "virHostHasIOMMU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1657-1679",
          "snippet": "bool\nvirHostHasIOMMU(void)\n{\n    DIR *iommuDir = NULL;\n    struct dirent *iommuGroup = NULL;\n    bool ret = false;\n    int direrr;\n\n    if (virDirOpenQuiet(&iommuDir, \"/sys/kernel/iommu_groups/\") < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(iommuDir, &iommuGroup, NULL)) > 0)\n        break;\n\n    if (direrr < 0 || !iommuGroup)\n        goto cleanup;\n\n    ret = true;\n\n cleanup:\n    VIR_DIR_CLOSE(iommuDir);\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirHostHasIOMMU(void)\n{\n    DIR *iommuDir = NULL;\n    struct dirent *iommuGroup = NULL;\n    bool ret = false;\n    int direrr;\n\n    if (virDirOpenQuiet(&iommuDir, \"/sys/kernel/iommu_groups/\") < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(iommuDir, &iommuGroup, NULL)) > 0)\n        break;\n\n    if (direrr < 0 || !iommuGroup)\n        goto cleanup;\n\n    ret = true;\n\n cleanup:\n    VIR_DIR_CLOSE(iommuDir);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesHostInitIOMMU(virCapsPtr caps)\n{\n    caps->host.iommu = virHostHasIOMMU();\n}"
  },
  {
    "function_name": "virCapabilitiesInitCaches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1857-2002",
    "snippet": "int\nvirCapabilitiesInitCaches(virCapsPtr caps)\n{\n    size_t i = 0;\n    virBitmapPtr cpus = NULL;\n    ssize_t pos = -1;\n    DIR *dirp = NULL;\n    int ret = -1;\n    char *path = NULL;\n    char *type = NULL;\n    struct dirent *ent = NULL;\n    virCapsHostCacheBankPtr bank = NULL;\n    const virResctrlMonitorType montype = VIR_RESCTRL_MONITOR_TYPE_CACHE;\n    const char *prefix = virResctrlMonitorPrefixTypeToString(montype);\n\n    /* Minimum level to expose in capabilities.  Can be lowered or removed (with\n     * the appropriate code below), but should not be increased, because we'd\n     * lose information. */\n    const int cache_min_level = 3;\n\n    if (virCapabilitiesInitResctrl(caps) < 0)\n        return -1;\n\n    /* offline CPUs don't provide cache info */\n    if (virFileReadValueBitmap(&cpus, \"%s/cpu/online\", SYSFS_SYSTEM_PATH) < 0)\n        return -1;\n\n    while ((pos = virBitmapNextSetBit(cpus, pos)) >= 0) {\n        int rv = -1;\n\n        VIR_FREE(path);\n        path = g_strdup_printf(\"%s/cpu/cpu%zd/cache/\", SYSFS_SYSTEM_PATH, pos);\n\n        VIR_DIR_CLOSE(dirp);\n\n        rv = virDirOpenIfExists(&dirp, path);\n        if (rv < 0)\n            goto cleanup;\n\n        if (!dirp)\n            continue;\n\n        while ((rv = virDirRead(dirp, &ent, path)) > 0) {\n            int kernel_type;\n            unsigned int level;\n\n            if (!STRPREFIX(ent->d_name, \"index\"))\n                continue;\n\n            if (virFileReadValueUint(&level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (level < cache_min_level)\n                continue;\n\n            if (VIR_ALLOC(bank) < 0)\n                goto cleanup;\n\n            bank->level = level;\n\n            if (virFileReadValueUint(&bank->id,\n                                     \"%s/cpu/cpu%zd/cache/%s/id\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueUint(&bank->level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueString(&type,\n                                       \"%s/cpu/cpu%zd/cache/%s/type\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueScaledInt(&bank->size,\n                                          \"%s/cpu/cpu%zd/cache/%s/size\",\n                                          SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueBitmap(&bank->cpus,\n                                       \"%s/cpu/cpu%zd/cache/%s/shared_cpu_list\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            kernel_type = virCacheKernelTypeFromString(type);\n            if (kernel_type < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown cache type '%s'\"), type);\n                goto cleanup;\n            }\n\n            bank->type = kernel_type;\n            VIR_FREE(type);\n\n            for (i = 0; i < caps->host.cache.nbanks; i++) {\n                if (virCapsHostCacheBankEquals(bank, caps->host.cache.banks[i]))\n                    break;\n            }\n            if (i == caps->host.cache.nbanks) {\n                /* If it is a new cache, then update its resctrl information. */\n                if (virResctrlInfoGetCache(caps->host.resctrl,\n                                           bank->level,\n                                           bank->size,\n                                           &bank->ncontrols,\n                                           &bank->controls) < 0)\n                    goto cleanup;\n\n                if (VIR_APPEND_ELEMENT(caps->host.cache.banks,\n                                       caps->host.cache.nbanks,\n                                       bank) < 0) {\n                    goto cleanup;\n                }\n            }\n\n            virCapsHostCacheBankFree(bank);\n            bank = NULL;\n        }\n        if (rv < 0)\n            goto cleanup;\n    }\n\n    /* Sort the array in order for the tests to be predictable.  This way we can\n     * still traverse the directory instead of guessing names (in case there is\n     * 'index1' and 'index3' but no 'index2'). */\n    qsort(caps->host.cache.banks, caps->host.cache.nbanks,\n          sizeof(*caps->host.cache.banks), virCapsHostCacheBankSorter);\n\n    if (virCapabilitiesInitResctrlMemory(caps) < 0)\n        goto cleanup;\n\n    if (virResctrlInfoGetMonitorPrefix(caps->host.resctrl, prefix,\n                                       &caps->host.cache.monitor) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    VIR_FREE(path);\n    VIR_DIR_CLOSE(dirp);\n    virCapsHostCacheBankFree(bank);\n    virBitmapFree(cpus);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "cpus"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapsHostCacheBankFree",
          "args": [
            "bank"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "virCapsHostCacheBankFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1771-1784",
          "snippet": "void\nvirCapsHostCacheBankFree(virCapsHostCacheBankPtr ptr)\n{\n    size_t i;\n\n    if (!ptr)\n        return;\n\n    virBitmapFree(ptr->cpus);\n    for (i = 0; i < ptr->ncontrols; i++)\n        VIR_FREE(ptr->controls[i]);\n    VIR_FREE(ptr->controls);\n    VIR_FREE(ptr);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapsHostCacheBankFree(virCapsHostCacheBankPtr ptr)\n{\n    size_t i;\n\n    if (!ptr)\n        return;\n\n    virBitmapFree(ptr->cpus);\n    for (i = 0; i < ptr->ncontrols; i++)\n        VIR_FREE(ptr->controls[i]);\n    VIR_FREE(ptr->controls);\n    VIR_FREE(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "dirp"
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlInfoGetMonitorPrefix",
          "args": [
            "caps->host.resctrl",
            "prefix",
            "&caps->host.cache.monitor"
          ],
          "line": 1990
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlInfoGetMonitorPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "954-1030",
          "snippet": "int\nvirResctrlInfoGetMonitorPrefix(virResctrlInfoPtr resctrl,\n                               const char *prefix,\n                               virResctrlInfoMonPtr *monitor)\n{\n    size_t i = 0;\n    virResctrlInfoMongrpPtr mongrp_info = NULL;\n    virResctrlInfoMonPtr mon = NULL;\n    int ret = -1;\n\n    if (!prefix) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Empty prefix name for resctrl monitor\"));\n        return -1;\n    }\n\n    if (virResctrlInfoIsEmpty(resctrl))\n        return 0;\n\n    mongrp_info = resctrl->monitor_info;\n\n    if (!mongrp_info) {\n        VIR_INFO(\"Monitor is not supported in host\");\n        return 0;\n    }\n\n    for (i = 0; i < VIR_RESCTRL_MONITOR_TYPE_LAST; i++) {\n        if (STREQ(prefix, virResctrlMonitorPrefixTypeToString(i))) {\n            if (VIR_ALLOC(mon) < 0)\n                goto cleanup;\n            mon->type = i;\n            break;\n        }\n    }\n\n    if (!mon) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Bad prefix name '%s' for resctrl monitor\"),\n                       prefix);\n        return -1;\n    }\n\n    mon->max_monitor = mongrp_info->max_monitor;\n\n    if (mon->type == VIR_RESCTRL_MONITOR_TYPE_CACHE) {\n        mon->cache_reuse_threshold =  mongrp_info->cache_reuse_threshold;\n        mon->cache_level = mongrp_info->cache_level;\n    }\n\n    for (i = 0; i < mongrp_info->nfeatures; i++) {\n        if (STRPREFIX(mongrp_info->features[i], prefix)) {\n            if (virStringListAdd(&mon->features,\n                                 mongrp_info->features[i]) < 0)\n                goto cleanup;\n            mon->nfeatures++;\n        }\n    }\n\n    ret = 0;\n\n    /* In case *monitor is pointed to some monitor, clean it. */\n    virResctrlInfoMonFree(*monitor);\n\n    if (mon->nfeatures == 0) {\n        /* No feature found for current monitor, means host does not support\n         * monitor type with @prefix name.\n         * Telling caller this monitor is supported by hardware specification,\n         * but not supported by this host. */\n        VIR_INFO(\"No resctrl monitor features using prefix '%s' found\", prefix);\n        goto cleanup;\n    }\n\n    *monitor = g_steal_pointer(&mon);\n cleanup:\n    virResctrlInfoMonFree(mon);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlInfoGetMonitorPrefix(virResctrlInfoPtr resctrl,\n                               const char *prefix,\n                               virResctrlInfoMonPtr *monitor)\n{\n    size_t i = 0;\n    virResctrlInfoMongrpPtr mongrp_info = NULL;\n    virResctrlInfoMonPtr mon = NULL;\n    int ret = -1;\n\n    if (!prefix) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Empty prefix name for resctrl monitor\"));\n        return -1;\n    }\n\n    if (virResctrlInfoIsEmpty(resctrl))\n        return 0;\n\n    mongrp_info = resctrl->monitor_info;\n\n    if (!mongrp_info) {\n        VIR_INFO(\"Monitor is not supported in host\");\n        return 0;\n    }\n\n    for (i = 0; i < VIR_RESCTRL_MONITOR_TYPE_LAST; i++) {\n        if (STREQ(prefix, virResctrlMonitorPrefixTypeToString(i))) {\n            if (VIR_ALLOC(mon) < 0)\n                goto cleanup;\n            mon->type = i;\n            break;\n        }\n    }\n\n    if (!mon) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Bad prefix name '%s' for resctrl monitor\"),\n                       prefix);\n        return -1;\n    }\n\n    mon->max_monitor = mongrp_info->max_monitor;\n\n    if (mon->type == VIR_RESCTRL_MONITOR_TYPE_CACHE) {\n        mon->cache_reuse_threshold =  mongrp_info->cache_reuse_threshold;\n        mon->cache_level = mongrp_info->cache_level;\n    }\n\n    for (i = 0; i < mongrp_info->nfeatures; i++) {\n        if (STRPREFIX(mongrp_info->features[i], prefix)) {\n            if (virStringListAdd(&mon->features,\n                                 mongrp_info->features[i]) < 0)\n                goto cleanup;\n            mon->nfeatures++;\n        }\n    }\n\n    ret = 0;\n\n    /* In case *monitor is pointed to some monitor, clean it. */\n    virResctrlInfoMonFree(*monitor);\n\n    if (mon->nfeatures == 0) {\n        /* No feature found for current monitor, means host does not support\n         * monitor type with @prefix name.\n         * Telling caller this monitor is supported by hardware specification,\n         * but not supported by this host. */\n        VIR_INFO(\"No resctrl monitor features using prefix '%s' found\", prefix);\n        goto cleanup;\n    }\n\n    *monitor = g_steal_pointer(&mon);\n cleanup:\n    virResctrlInfoMonFree(mon);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesInitResctrlMemory",
          "args": [
            "caps"
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesInitResctrlMemory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1817-1854",
          "snippet": "static int\nvirCapabilitiesInitResctrlMemory(virCapsPtr caps)\n{\n    virCapsHostMemBWNodePtr node = NULL;\n    size_t i = 0;\n    int ret = -1;\n    const virResctrlMonitorType montype = VIR_RESCTRL_MONITOR_TYPE_MEMBW;\n    const char *prefix = virResctrlMonitorPrefixTypeToString(montype);\n\n    for (i = 0; i < caps->host.cache.nbanks; i++) {\n        virCapsHostCacheBankPtr bank = caps->host.cache.banks[i];\n        if (VIR_ALLOC(node) < 0)\n            goto cleanup;\n\n        if (virResctrlInfoGetMemoryBandwidth(caps->host.resctrl,\n                                             bank->level, &node->control) > 0) {\n            node->id = bank->id;\n            if (!(node->cpus = virBitmapNewCopy(bank->cpus)))\n                goto cleanup;\n\n            if (VIR_APPEND_ELEMENT(caps->host.memBW.nodes,\n                                   caps->host.memBW.nnodes, node) < 0) {\n                goto cleanup;\n            }\n        }\n        virCapsHostMemBWNodeFree(node);\n        node = NULL;\n    }\n\n    if (virResctrlInfoGetMonitorPrefix(caps->host.resctrl, prefix,\n                                       &caps->host.memBW.monitor) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virCapsHostMemBWNodeFree(node);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesInitResctrlMemory(virCapsPtr caps)\n{\n    virCapsHostMemBWNodePtr node = NULL;\n    size_t i = 0;\n    int ret = -1;\n    const virResctrlMonitorType montype = VIR_RESCTRL_MONITOR_TYPE_MEMBW;\n    const char *prefix = virResctrlMonitorPrefixTypeToString(montype);\n\n    for (i = 0; i < caps->host.cache.nbanks; i++) {\n        virCapsHostCacheBankPtr bank = caps->host.cache.banks[i];\n        if (VIR_ALLOC(node) < 0)\n            goto cleanup;\n\n        if (virResctrlInfoGetMemoryBandwidth(caps->host.resctrl,\n                                             bank->level, &node->control) > 0) {\n            node->id = bank->id;\n            if (!(node->cpus = virBitmapNewCopy(bank->cpus)))\n                goto cleanup;\n\n            if (VIR_APPEND_ELEMENT(caps->host.memBW.nodes,\n                                   caps->host.memBW.nnodes, node) < 0) {\n                goto cleanup;\n            }\n        }\n        virCapsHostMemBWNodeFree(node);\n        node = NULL;\n    }\n\n    if (virResctrlInfoGetMonitorPrefix(caps->host.resctrl, prefix,\n                                       &caps->host.memBW.monitor) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virCapsHostMemBWNodeFree(node);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "caps->host.cache.banks",
            "caps->host.cache.nbanks",
            "sizeof(*caps->host.cache.banks)",
            "virCapsHostCacheBankSorter"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "caps->host.cache.banks",
            "caps->host.cache.nbanks",
            "bank"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlInfoGetCache",
          "args": [
            "caps->host.resctrl",
            "bank->level",
            "bank->size",
            "&bank->ncontrols",
            "&bank->controls"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlInfoGetCache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "865-937",
          "snippet": "int\nvirResctrlInfoGetCache(virResctrlInfoPtr resctrl,\n                       unsigned int level,\n                       unsigned long long size,\n                       size_t *ncontrols,\n                       virResctrlInfoPerCachePtr **controls)\n{\n    virResctrlInfoPerLevelPtr i_level = NULL;\n    virResctrlInfoPerTypePtr i_type = NULL;\n    size_t i = 0;\n\n    if (virResctrlInfoIsEmpty(resctrl))\n        return 0;\n\n    /* Let's take the opportunity to update the number of last level\n     * cache. This number of memory bandwidth controller is same with\n     * last level cache */\n    if (resctrl->membw_info) {\n        virResctrlInfoMemBWPtr membw_info = resctrl->membw_info;\n\n        if (level > membw_info->last_level_cache) {\n            membw_info->last_level_cache = level;\n            membw_info->max_id = 0;\n        } else if (membw_info->last_level_cache == level) {\n            membw_info->max_id++;\n        }\n    }\n\n    if (level >= resctrl->nlevels)\n        return 0;\n\n    i_level = resctrl->levels[level];\n    if (!i_level)\n        return 0;\n\n    for (i = 0; i < VIR_CACHE_TYPE_LAST; i++) {\n        i_type = i_level->types[i];\n        if (!i_type)\n            continue;\n\n        /* Let's take the opportunity to update our internal information about\n         * the cache size */\n        if (!i_type->size) {\n            i_type->size = size;\n            i_type->control.granularity = size / i_type->bits;\n            if (i_type->min_cbm_bits != 1)\n                i_type->control.min = i_type->min_cbm_bits * i_type->control.granularity;\n        } else {\n            if (i_type->size != size) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"level %u cache size %llu does not match \"\n                                 \"expected size %llu\"),\n                               level, i_type->size, size);\n                goto error;\n            }\n            i_type->max_cache_id++;\n        }\n\n        if (VIR_EXPAND_N(*controls, *ncontrols, 1) < 0)\n            goto error;\n        if (VIR_ALLOC((*controls)[*ncontrols - 1]) < 0)\n            goto error;\n\n        memcpy((*controls)[*ncontrols - 1], &i_type->control, sizeof(i_type->control));\n    }\n\n    return 0;\n error:\n    while (*ncontrols)\n        VIR_FREE((*controls)[--*ncontrols]);\n    VIR_FREE(*controls);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlInfoGetCache(virResctrlInfoPtr resctrl,\n                       unsigned int level,\n                       unsigned long long size,\n                       size_t *ncontrols,\n                       virResctrlInfoPerCachePtr **controls)\n{\n    virResctrlInfoPerLevelPtr i_level = NULL;\n    virResctrlInfoPerTypePtr i_type = NULL;\n    size_t i = 0;\n\n    if (virResctrlInfoIsEmpty(resctrl))\n        return 0;\n\n    /* Let's take the opportunity to update the number of last level\n     * cache. This number of memory bandwidth controller is same with\n     * last level cache */\n    if (resctrl->membw_info) {\n        virResctrlInfoMemBWPtr membw_info = resctrl->membw_info;\n\n        if (level > membw_info->last_level_cache) {\n            membw_info->last_level_cache = level;\n            membw_info->max_id = 0;\n        } else if (membw_info->last_level_cache == level) {\n            membw_info->max_id++;\n        }\n    }\n\n    if (level >= resctrl->nlevels)\n        return 0;\n\n    i_level = resctrl->levels[level];\n    if (!i_level)\n        return 0;\n\n    for (i = 0; i < VIR_CACHE_TYPE_LAST; i++) {\n        i_type = i_level->types[i];\n        if (!i_type)\n            continue;\n\n        /* Let's take the opportunity to update our internal information about\n         * the cache size */\n        if (!i_type->size) {\n            i_type->size = size;\n            i_type->control.granularity = size / i_type->bits;\n            if (i_type->min_cbm_bits != 1)\n                i_type->control.min = i_type->min_cbm_bits * i_type->control.granularity;\n        } else {\n            if (i_type->size != size) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"level %u cache size %llu does not match \"\n                                 \"expected size %llu\"),\n                               level, i_type->size, size);\n                goto error;\n            }\n            i_type->max_cache_id++;\n        }\n\n        if (VIR_EXPAND_N(*controls, *ncontrols, 1) < 0)\n            goto error;\n        if (VIR_ALLOC((*controls)[*ncontrols - 1]) < 0)\n            goto error;\n\n        memcpy((*controls)[*ncontrols - 1], &i_type->control, sizeof(i_type->control));\n    }\n\n    return 0;\n error:\n    while (*ncontrols)\n        VIR_FREE((*controls)[--*ncontrols]);\n    VIR_FREE(*controls);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapsHostCacheBankEquals",
          "args": [
            "bank",
            "caps->host.cache.banks[i]"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "virCapsHostCacheBankEquals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1760-1769",
          "snippet": "bool\nvirCapsHostCacheBankEquals(virCapsHostCacheBankPtr a,\n                           virCapsHostCacheBankPtr b)\n{\n    return (a->id == b->id &&\n            a->level == b->level &&\n            a->type == b->type &&\n            a->size == b->size &&\n            virBitmapEqual(a->cpus, b->cpus));\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirCapsHostCacheBankEquals(virCapsHostCacheBankPtr a,\n                           virCapsHostCacheBankPtr b)\n{\n    return (a->id == b->id &&\n            a->level == b->level &&\n            a->type == b->type &&\n            a->size == b->size &&\n            virBitmapEqual(a->cpus, b->cpus));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown cache type '%s'\")",
            "type"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown cache type '%s'\""
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCacheKernelTypeFromString",
          "args": [
            "type"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadValueBitmap",
          "args": [
            "&bank->cpus",
            "\"%s/cpu/cpu%zd/cache/%s/shared_cpu_list\"",
            "SYSFS_SYSTEM_PATH",
            "pos",
            "ent->d_name"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueBitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4241-4265",
          "snippet": "int\nvirFileReadValueBitmap(virBitmapPtr *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    *value = virBitmapParseUnlimited(str);\n    if (!*value)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_FILE_READ_VALUE_STRING_MAX 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\n#define VIR_FILE_READ_VALUE_STRING_MAX 4096\n\nint\nvirFileReadValueBitmap(virBitmapPtr *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    *value = virBitmapParseUnlimited(str);\n    if (!*value)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadValueScaledInt",
          "args": [
            "&bank->size",
            "\"%s/cpu/cpu%zd/cache/%s/size\"",
            "SYSFS_SYSTEM_PATH",
            "pos",
            "ent->d_name"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueScaledInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4197-4225",
          "snippet": "int\nvirFileReadValueScaledInt(unsigned long long *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    char *endp = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_ullp(str, &endp, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned scaled integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return virScaleInteger(value, endp, 1024, ULLONG_MAX);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadValueScaledInt(unsigned long long *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    char *endp = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_ullp(str, &endp, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned scaled integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return virScaleInteger(value, endp, 1024, ULLONG_MAX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadValueString",
          "args": [
            "&type",
            "\"%s/cpu/cpu%zd/cache/%s/type\"",
            "SYSFS_SYSTEM_PATH",
            "pos",
            "ent->d_name"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4279-4299",
          "snippet": "int\nvirFileReadValueString(char **value, const char *format, ...)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    ret = virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, value);\n\n    if (*value)\n        virStringTrimOptionalNewline(*value);\n\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_FILE_READ_VALUE_STRING_MAX 4096"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\n#define VIR_FILE_READ_VALUE_STRING_MAX 4096\n\nint\nvirFileReadValueString(char **value, const char *format, ...)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    ret = virFileReadAll(path, VIR_FILE_READ_VALUE_STRING_MAX, value);\n\n    if (*value)\n        virStringTrimOptionalNewline(*value);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadValueUint",
          "args": [
            "&bank->level",
            "\"%s/cpu/cpu%zd/cache/%s/level\"",
            "SYSFS_SYSTEM_PATH",
            "pos",
            "ent->d_name"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadValueUint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "4117-4144",
          "snippet": "int\nvirFileReadValueUint(unsigned int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_uip(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadValueUint(unsigned int *value, const char *format, ...)\n{\n    g_autofree char *str = NULL;\n    g_autofree char *path = NULL;\n    va_list ap;\n\n    va_start(ap, format);\n    path = g_strdup_vprintf(format, ap);\n    va_end(ap);\n\n    if (!virFileExists(path))\n        return -2;\n\n    if (virFileReadAll(path, VIR_INT64_STR_BUFLEN, &str) < 0)\n        return -1;\n\n    virStringTrimOptionalNewline(str);\n\n    if (virStrToLong_uip(str, NULL, 10, value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid unsigned integer value '%s' in file '%s'\"),\n                       str, path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "bank"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "ent->d_name",
            "\"index\""
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "dirp",
            "&ent",
            "path"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpenIfExists",
          "args": [
            "&dirp",
            "path"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenIfExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2898-2902",
          "snippet": "int\nvirDirOpenIfExists(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, true, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenIfExists(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, true, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "dirp"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/cpu/cpu%zd/cache/\"",
            "SYSFS_SYSTEM_PATH",
            "pos"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "path"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapNextSetBit",
          "args": [
            "cpus",
            "pos"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextSetBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "986-1014",
          "snippet": "ssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlMonitorPrefixTypeToString",
          "args": [
            "montype"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirCapabilitiesInitCaches(virCapsPtr caps)\n{\n    size_t i = 0;\n    virBitmapPtr cpus = NULL;\n    ssize_t pos = -1;\n    DIR *dirp = NULL;\n    int ret = -1;\n    char *path = NULL;\n    char *type = NULL;\n    struct dirent *ent = NULL;\n    virCapsHostCacheBankPtr bank = NULL;\n    const virResctrlMonitorType montype = VIR_RESCTRL_MONITOR_TYPE_CACHE;\n    const char *prefix = virResctrlMonitorPrefixTypeToString(montype);\n\n    /* Minimum level to expose in capabilities.  Can be lowered or removed (with\n     * the appropriate code below), but should not be increased, because we'd\n     * lose information. */\n    const int cache_min_level = 3;\n\n    if (virCapabilitiesInitResctrl(caps) < 0)\n        return -1;\n\n    /* offline CPUs don't provide cache info */\n    if (virFileReadValueBitmap(&cpus, \"%s/cpu/online\", SYSFS_SYSTEM_PATH) < 0)\n        return -1;\n\n    while ((pos = virBitmapNextSetBit(cpus, pos)) >= 0) {\n        int rv = -1;\n\n        VIR_FREE(path);\n        path = g_strdup_printf(\"%s/cpu/cpu%zd/cache/\", SYSFS_SYSTEM_PATH, pos);\n\n        VIR_DIR_CLOSE(dirp);\n\n        rv = virDirOpenIfExists(&dirp, path);\n        if (rv < 0)\n            goto cleanup;\n\n        if (!dirp)\n            continue;\n\n        while ((rv = virDirRead(dirp, &ent, path)) > 0) {\n            int kernel_type;\n            unsigned int level;\n\n            if (!STRPREFIX(ent->d_name, \"index\"))\n                continue;\n\n            if (virFileReadValueUint(&level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (level < cache_min_level)\n                continue;\n\n            if (VIR_ALLOC(bank) < 0)\n                goto cleanup;\n\n            bank->level = level;\n\n            if (virFileReadValueUint(&bank->id,\n                                     \"%s/cpu/cpu%zd/cache/%s/id\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueUint(&bank->level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueString(&type,\n                                       \"%s/cpu/cpu%zd/cache/%s/type\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueScaledInt(&bank->size,\n                                          \"%s/cpu/cpu%zd/cache/%s/size\",\n                                          SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueBitmap(&bank->cpus,\n                                       \"%s/cpu/cpu%zd/cache/%s/shared_cpu_list\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            kernel_type = virCacheKernelTypeFromString(type);\n            if (kernel_type < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown cache type '%s'\"), type);\n                goto cleanup;\n            }\n\n            bank->type = kernel_type;\n            VIR_FREE(type);\n\n            for (i = 0; i < caps->host.cache.nbanks; i++) {\n                if (virCapsHostCacheBankEquals(bank, caps->host.cache.banks[i]))\n                    break;\n            }\n            if (i == caps->host.cache.nbanks) {\n                /* If it is a new cache, then update its resctrl information. */\n                if (virResctrlInfoGetCache(caps->host.resctrl,\n                                           bank->level,\n                                           bank->size,\n                                           &bank->ncontrols,\n                                           &bank->controls) < 0)\n                    goto cleanup;\n\n                if (VIR_APPEND_ELEMENT(caps->host.cache.banks,\n                                       caps->host.cache.nbanks,\n                                       bank) < 0) {\n                    goto cleanup;\n                }\n            }\n\n            virCapsHostCacheBankFree(bank);\n            bank = NULL;\n        }\n        if (rv < 0)\n            goto cleanup;\n    }\n\n    /* Sort the array in order for the tests to be predictable.  This way we can\n     * still traverse the directory instead of guessing names (in case there is\n     * 'index1' and 'index3' but no 'index2'). */\n    qsort(caps->host.cache.banks, caps->host.cache.nbanks,\n          sizeof(*caps->host.cache.banks), virCapsHostCacheBankSorter);\n\n    if (virCapabilitiesInitResctrlMemory(caps) < 0)\n        goto cleanup;\n\n    if (virResctrlInfoGetMonitorPrefix(caps->host.resctrl, prefix,\n                                       &caps->host.cache.monitor) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    VIR_FREE(path);\n    VIR_DIR_CLOSE(dirp);\n    virCapsHostCacheBankFree(bank);\n    virBitmapFree(cpus);\n    return ret;\n}"
  },
  {
    "function_name": "virCapabilitiesInitResctrlMemory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1817-1854",
    "snippet": "static int\nvirCapabilitiesInitResctrlMemory(virCapsPtr caps)\n{\n    virCapsHostMemBWNodePtr node = NULL;\n    size_t i = 0;\n    int ret = -1;\n    const virResctrlMonitorType montype = VIR_RESCTRL_MONITOR_TYPE_MEMBW;\n    const char *prefix = virResctrlMonitorPrefixTypeToString(montype);\n\n    for (i = 0; i < caps->host.cache.nbanks; i++) {\n        virCapsHostCacheBankPtr bank = caps->host.cache.banks[i];\n        if (VIR_ALLOC(node) < 0)\n            goto cleanup;\n\n        if (virResctrlInfoGetMemoryBandwidth(caps->host.resctrl,\n                                             bank->level, &node->control) > 0) {\n            node->id = bank->id;\n            if (!(node->cpus = virBitmapNewCopy(bank->cpus)))\n                goto cleanup;\n\n            if (VIR_APPEND_ELEMENT(caps->host.memBW.nodes,\n                                   caps->host.memBW.nnodes, node) < 0) {\n                goto cleanup;\n            }\n        }\n        virCapsHostMemBWNodeFree(node);\n        node = NULL;\n    }\n\n    if (virResctrlInfoGetMonitorPrefix(caps->host.resctrl, prefix,\n                                       &caps->host.memBW.monitor) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virCapsHostMemBWNodeFree(node);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapsHostMemBWNodeFree",
          "args": [
            "node"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "virCapsHostMemBWNodeFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "203-211",
          "snippet": "static void\nvirCapsHostMemBWNodeFree(virCapsHostMemBWNodePtr ptr)\n{\n    if (!ptr)\n        return;\n\n    virBitmapFree(ptr->cpus);\n    VIR_FREE(ptr);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapsHostMemBWNodeFree(virCapsHostMemBWNodePtr ptr)\n{\n    if (!ptr)\n        return;\n\n    virBitmapFree(ptr->cpus);\n    VIR_FREE(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlInfoGetMonitorPrefix",
          "args": [
            "caps->host.resctrl",
            "prefix",
            "&caps->host.memBW.monitor"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlInfoGetMonitorPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "954-1030",
          "snippet": "int\nvirResctrlInfoGetMonitorPrefix(virResctrlInfoPtr resctrl,\n                               const char *prefix,\n                               virResctrlInfoMonPtr *monitor)\n{\n    size_t i = 0;\n    virResctrlInfoMongrpPtr mongrp_info = NULL;\n    virResctrlInfoMonPtr mon = NULL;\n    int ret = -1;\n\n    if (!prefix) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Empty prefix name for resctrl monitor\"));\n        return -1;\n    }\n\n    if (virResctrlInfoIsEmpty(resctrl))\n        return 0;\n\n    mongrp_info = resctrl->monitor_info;\n\n    if (!mongrp_info) {\n        VIR_INFO(\"Monitor is not supported in host\");\n        return 0;\n    }\n\n    for (i = 0; i < VIR_RESCTRL_MONITOR_TYPE_LAST; i++) {\n        if (STREQ(prefix, virResctrlMonitorPrefixTypeToString(i))) {\n            if (VIR_ALLOC(mon) < 0)\n                goto cleanup;\n            mon->type = i;\n            break;\n        }\n    }\n\n    if (!mon) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Bad prefix name '%s' for resctrl monitor\"),\n                       prefix);\n        return -1;\n    }\n\n    mon->max_monitor = mongrp_info->max_monitor;\n\n    if (mon->type == VIR_RESCTRL_MONITOR_TYPE_CACHE) {\n        mon->cache_reuse_threshold =  mongrp_info->cache_reuse_threshold;\n        mon->cache_level = mongrp_info->cache_level;\n    }\n\n    for (i = 0; i < mongrp_info->nfeatures; i++) {\n        if (STRPREFIX(mongrp_info->features[i], prefix)) {\n            if (virStringListAdd(&mon->features,\n                                 mongrp_info->features[i]) < 0)\n                goto cleanup;\n            mon->nfeatures++;\n        }\n    }\n\n    ret = 0;\n\n    /* In case *monitor is pointed to some monitor, clean it. */\n    virResctrlInfoMonFree(*monitor);\n\n    if (mon->nfeatures == 0) {\n        /* No feature found for current monitor, means host does not support\n         * monitor type with @prefix name.\n         * Telling caller this monitor is supported by hardware specification,\n         * but not supported by this host. */\n        VIR_INFO(\"No resctrl monitor features using prefix '%s' found\", prefix);\n        goto cleanup;\n    }\n\n    *monitor = g_steal_pointer(&mon);\n cleanup:\n    virResctrlInfoMonFree(mon);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlInfoGetMonitorPrefix(virResctrlInfoPtr resctrl,\n                               const char *prefix,\n                               virResctrlInfoMonPtr *monitor)\n{\n    size_t i = 0;\n    virResctrlInfoMongrpPtr mongrp_info = NULL;\n    virResctrlInfoMonPtr mon = NULL;\n    int ret = -1;\n\n    if (!prefix) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Empty prefix name for resctrl monitor\"));\n        return -1;\n    }\n\n    if (virResctrlInfoIsEmpty(resctrl))\n        return 0;\n\n    mongrp_info = resctrl->monitor_info;\n\n    if (!mongrp_info) {\n        VIR_INFO(\"Monitor is not supported in host\");\n        return 0;\n    }\n\n    for (i = 0; i < VIR_RESCTRL_MONITOR_TYPE_LAST; i++) {\n        if (STREQ(prefix, virResctrlMonitorPrefixTypeToString(i))) {\n            if (VIR_ALLOC(mon) < 0)\n                goto cleanup;\n            mon->type = i;\n            break;\n        }\n    }\n\n    if (!mon) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Bad prefix name '%s' for resctrl monitor\"),\n                       prefix);\n        return -1;\n    }\n\n    mon->max_monitor = mongrp_info->max_monitor;\n\n    if (mon->type == VIR_RESCTRL_MONITOR_TYPE_CACHE) {\n        mon->cache_reuse_threshold =  mongrp_info->cache_reuse_threshold;\n        mon->cache_level = mongrp_info->cache_level;\n    }\n\n    for (i = 0; i < mongrp_info->nfeatures; i++) {\n        if (STRPREFIX(mongrp_info->features[i], prefix)) {\n            if (virStringListAdd(&mon->features,\n                                 mongrp_info->features[i]) < 0)\n                goto cleanup;\n            mon->nfeatures++;\n        }\n    }\n\n    ret = 0;\n\n    /* In case *monitor is pointed to some monitor, clean it. */\n    virResctrlInfoMonFree(*monitor);\n\n    if (mon->nfeatures == 0) {\n        /* No feature found for current monitor, means host does not support\n         * monitor type with @prefix name.\n         * Telling caller this monitor is supported by hardware specification,\n         * but not supported by this host. */\n        VIR_INFO(\"No resctrl monitor features using prefix '%s' found\", prefix);\n        goto cleanup;\n    }\n\n    *monitor = g_steal_pointer(&mon);\n cleanup:\n    virResctrlInfoMonFree(mon);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "caps->host.memBW.nodes",
            "caps->host.memBW.nnodes",
            "node"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapNewCopy",
          "args": [
            "bank->cpus"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "707-721",
          "snippet": "virBitmapPtr\nvirBitmapNewCopy(virBitmapPtr src)\n{\n    virBitmapPtr dst;\n\n    if ((dst = virBitmapNew(src->nbits)) == NULL)\n        return NULL;\n\n    if (virBitmapCopy(dst, src) != 0) {\n        virBitmapFree(dst);\n        return NULL;\n    }\n\n    return dst;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewCopy(virBitmapPtr src)\n{\n    virBitmapPtr dst;\n\n    if ((dst = virBitmapNew(src->nbits)) == NULL)\n        return NULL;\n\n    if (virBitmapCopy(dst, src) != 0) {\n        virBitmapFree(dst);\n        return NULL;\n    }\n\n    return dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResctrlInfoGetMemoryBandwidth",
          "args": [
            "caps->host.resctrl",
            "bank->level",
            "&node->control"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlInfoGetMemoryBandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "845-862",
          "snippet": "int\nvirResctrlInfoGetMemoryBandwidth(virResctrlInfoPtr resctrl,\n                                 unsigned int level,\n                                 virResctrlInfoMemBWPerNodePtr control)\n{\n    virResctrlInfoMemBWPtr membw_info = resctrl->membw_info;\n\n    if (!membw_info)\n        return 0;\n\n    if (membw_info->last_level_cache != level)\n        return 0;\n\n    control->granularity = membw_info->bandwidth_granularity;\n    control->min = membw_info->min_bandwidth;\n    control->max_allocation = membw_info->max_allocation;\n    return 1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nint\nvirResctrlInfoGetMemoryBandwidth(virResctrlInfoPtr resctrl,\n                                 unsigned int level,\n                                 virResctrlInfoMemBWPerNodePtr control)\n{\n    virResctrlInfoMemBWPtr membw_info = resctrl->membw_info;\n\n    if (!membw_info)\n        return 0;\n\n    if (membw_info->last_level_cache != level)\n        return 0;\n\n    control->granularity = membw_info->bandwidth_granularity;\n    control->min = membw_info->min_bandwidth;\n    control->max_allocation = membw_info->max_allocation;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "node"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlMonitorPrefixTypeToString",
          "args": [
            "montype"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesInitResctrlMemory(virCapsPtr caps)\n{\n    virCapsHostMemBWNodePtr node = NULL;\n    size_t i = 0;\n    int ret = -1;\n    const virResctrlMonitorType montype = VIR_RESCTRL_MONITOR_TYPE_MEMBW;\n    const char *prefix = virResctrlMonitorPrefixTypeToString(montype);\n\n    for (i = 0; i < caps->host.cache.nbanks; i++) {\n        virCapsHostCacheBankPtr bank = caps->host.cache.banks[i];\n        if (VIR_ALLOC(node) < 0)\n            goto cleanup;\n\n        if (virResctrlInfoGetMemoryBandwidth(caps->host.resctrl,\n                                             bank->level, &node->control) > 0) {\n            node->id = bank->id;\n            if (!(node->cpus = virBitmapNewCopy(bank->cpus)))\n                goto cleanup;\n\n            if (VIR_APPEND_ELEMENT(caps->host.memBW.nodes,\n                                   caps->host.memBW.nnodes, node) < 0) {\n                goto cleanup;\n            }\n        }\n        virCapsHostMemBWNodeFree(node);\n        node = NULL;\n    }\n\n    if (virResctrlInfoGetMonitorPrefix(caps->host.resctrl, prefix,\n                                       &caps->host.memBW.monitor) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virCapsHostMemBWNodeFree(node);\n    return ret;\n}"
  },
  {
    "function_name": "virCapabilitiesInitResctrl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1803-1814",
    "snippet": "static int\nvirCapabilitiesInitResctrl(virCapsPtr caps)\n{\n    if (caps->host.resctrl)\n        return 0;\n\n    caps->host.resctrl = virResctrlInfoNew();\n    if (!caps->host.resctrl)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResctrlInfoNew",
          "args": [],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlInfoNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "793-811",
          "snippet": "virResctrlInfoPtr\nvirResctrlInfoNew(void)\n{\n    virResctrlInfoPtr ret = NULL;\n\n    if (virResctrlInitialize() < 0)\n        return NULL;\n\n    ret = virObjectNew(virResctrlInfoClass);\n    if (!ret)\n        return NULL;\n\n    if (virResctrlGetInfo(ret) < 0) {\n        virObjectUnref(ret);\n        return NULL;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virResctrlInfoClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nstatic virClassPtr virResctrlInfoClass;\n\nvirResctrlInfoPtr\nvirResctrlInfoNew(void)\n{\n    virResctrlInfoPtr ret = NULL;\n\n    if (virResctrlInitialize() < 0)\n        return NULL;\n\n    ret = virObjectNew(virResctrlInfoClass);\n    if (!ret)\n        return NULL;\n\n    if (virResctrlGetInfo(ret) < 0) {\n        virObjectUnref(ret);\n        return NULL;\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesInitResctrl(virCapsPtr caps)\n{\n    if (caps->host.resctrl)\n        return 0;\n\n    caps->host.resctrl = virResctrlInfoNew();\n    if (!caps->host.resctrl)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virCapsHostCacheBankSorter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1787-1800",
    "snippet": "static int\nvirCapsHostCacheBankSorter(const void *a,\n                           const void *b)\n{\n    virCapsHostCacheBankPtr ca = *(virCapsHostCacheBankPtr *)a;\n    virCapsHostCacheBankPtr cb = *(virCapsHostCacheBankPtr *)b;\n\n    if (ca->level < cb->level)\n        return -1;\n    if (ca->level > cb->level)\n        return 1;\n\n    return ca->id - cb->id;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapsHostCacheBankSorter(const void *a,\n                           const void *b)\n{\n    virCapsHostCacheBankPtr ca = *(virCapsHostCacheBankPtr *)a;\n    virCapsHostCacheBankPtr cb = *(virCapsHostCacheBankPtr *)b;\n\n    if (ca->level < cb->level)\n        return -1;\n    if (ca->level > cb->level)\n        return 1;\n\n    return ca->id - cb->id;\n}"
  },
  {
    "function_name": "virCapsHostCacheBankFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1771-1784",
    "snippet": "void\nvirCapsHostCacheBankFree(virCapsHostCacheBankPtr ptr)\n{\n    size_t i;\n\n    if (!ptr)\n        return;\n\n    virBitmapFree(ptr->cpus);\n    for (i = 0; i < ptr->ncontrols; i++)\n        VIR_FREE(ptr->controls[i]);\n    VIR_FREE(ptr->controls);\n    VIR_FREE(ptr);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ptr"
          ],
          "line": 1783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ptr->controls"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ptr->controls[i]"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "ptr->cpus"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapsHostCacheBankFree(virCapsHostCacheBankPtr ptr)\n{\n    size_t i;\n\n    if (!ptr)\n        return;\n\n    virBitmapFree(ptr->cpus);\n    for (i = 0; i < ptr->ncontrols; i++)\n        VIR_FREE(ptr->controls[i]);\n    VIR_FREE(ptr->controls);\n    VIR_FREE(ptr);\n}"
  },
  {
    "function_name": "virCapsHostCacheBankEquals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1760-1769",
    "snippet": "bool\nvirCapsHostCacheBankEquals(virCapsHostCacheBankPtr a,\n                           virCapsHostCacheBankPtr b)\n{\n    return (a->id == b->id &&\n            a->level == b->level &&\n            a->type == b->type &&\n            a->size == b->size &&\n            virBitmapEqual(a->cpus, b->cpus));\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapEqual",
          "args": [
            "a->cpus",
            "b->cpus"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "841-873",
          "snippet": "bool\nvirBitmapEqual(virBitmapPtr b1,\n               virBitmapPtr b2)\n{\n    virBitmapPtr tmp;\n    size_t i;\n\n    if (!b1 && !b2)\n        return true;\n\n    if (!b1 || !b2)\n        return false;\n\n    if (b1->nbits > b2->nbits) {\n        tmp = b1;\n        b1 = b2;\n        b2 = tmp;\n    }\n\n    /* Now b1 is the smaller one, if not equal */\n\n    for (i = 0; i < b1->map_len; i++) {\n        if (b1->map[i] != b2->map[i])\n            return false;\n    }\n\n    for (; i < b2->map_len; i++) {\n        if (b2->map[i])\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapEqual(virBitmapPtr b1,\n               virBitmapPtr b2)\n{\n    virBitmapPtr tmp;\n    size_t i;\n\n    if (!b1 && !b2)\n        return true;\n\n    if (!b1 || !b2)\n        return false;\n\n    if (b1->nbits > b2->nbits) {\n        tmp = b1;\n        b1 = b2;\n        b2 = tmp;\n    }\n\n    /* Now b1 is the smaller one, if not equal */\n\n    for (i = 0; i < b1->map_len; i++) {\n        if (b1->map[i] != b2->map[i])\n            return false;\n    }\n\n    for (; i < b2->map_len; i++) {\n        if (b2->map[i])\n            return false;\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirCapsHostCacheBankEquals(virCapsHostCacheBankPtr a,\n                           virCapsHostCacheBankPtr b)\n{\n    return (a->id == b->id &&\n            a->level == b->level &&\n            a->type == b->type &&\n            a->size == b->size &&\n            virBitmapEqual(a->cpus, b->cpus));\n}"
  },
  {
    "function_name": "virCapabilitiesInitPages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1737-1757",
    "snippet": "int\nvirCapabilitiesInitPages(virCapsPtr caps)\n{\n    int ret = -1;\n    unsigned int *pages_size = NULL;\n    size_t npages;\n\n    if (virNumaGetPages(-1 /* Magic constant for overall info */,\n                        &pages_size, NULL, NULL, &npages) < 0)\n        goto cleanup;\n\n    caps->host.pagesSize = pages_size;\n    pages_size = NULL;\n    caps->host.nPagesSize = npages;\n    npages = 0;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pages_size);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pages_size"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNumaGetPages",
          "args": [
            "-1/* Magic constant for overall info */",
            "&pages_size",
            "NULL",
            "NULL",
            "&npages"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetPages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "968-978",
          "snippet": "int\nvirNumaGetPages(int node G_GNUC_UNUSED,\n                unsigned int **pages_size G_GNUC_UNUSED,\n                unsigned long long **pages_avail G_GNUC_UNUSED,\n                unsigned long long **pages_free G_GNUC_UNUSED,\n                size_t *npages G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page info is not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetPages(int node G_GNUC_UNUSED,\n                unsigned int **pages_size G_GNUC_UNUSED,\n                unsigned long long **pages_avail G_GNUC_UNUSED,\n                unsigned long long **pages_free G_GNUC_UNUSED,\n                size_t *npages G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page info is not supported on this platform\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirCapabilitiesInitPages(virCapsPtr caps)\n{\n    int ret = -1;\n    unsigned int *pages_size = NULL;\n    size_t npages;\n\n    if (virNumaGetPages(-1 /* Magic constant for overall info */,\n                        &pages_size, NULL, NULL, &npages) < 0)\n        goto cleanup;\n\n    caps->host.pagesSize = pages_size;\n    pages_size = NULL;\n    caps->host.nPagesSize = npages;\n    npages = 0;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pages_size);\n    return ret;\n}"
  },
  {
    "function_name": "virCapabilitiesHostNUMANewHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1714-1734",
    "snippet": "virCapsHostNUMAPtr\nvirCapabilitiesHostNUMANewHost(void)\n{\n    virCapsHostNUMAPtr caps = virCapabilitiesHostNUMANew();\n\n    if (virNumaIsAvailable()) {\n        if (virCapabilitiesHostNUMAInitReal(caps) == 0)\n            return caps;\n\n        virCapabilitiesHostNUMAUnref(caps);\n        caps = virCapabilitiesHostNUMANew();\n        VIR_WARN(\"Failed to query host NUMA topology, faking single NUMA node\");\n    }\n\n    if (virCapabilitiesHostNUMAInitFake(caps) < 0) {\n        virCapabilitiesHostNUMAUnref(caps);\n        return NULL;\n    }\n\n    return caps;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMAUnref",
          "args": [
            "caps"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMAUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "184-195",
          "snippet": "void\nvirCapabilitiesHostNUMAUnref(virCapsHostNUMAPtr caps)\n{\n    if (!caps)\n        return;\n\n    if (g_atomic_int_dec_and_test(&caps->refs)) {\n        g_ptr_array_unref(caps->cells);\n\n        VIR_FREE(caps);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesHostNUMAUnref(virCapsHostNUMAPtr caps)\n{\n    if (!caps)\n        return;\n\n    if (g_atomic_int_dec_and_test(&caps->refs)) {\n        g_ptr_array_unref(caps->cells);\n\n        VIR_FREE(caps);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMAInitFake",
          "args": [
            "caps"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMAInitFake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1560-1624",
          "snippet": "static int\nvirCapabilitiesHostNUMAInitFake(virCapsHostNUMAPtr caps)\n{\n    virNodeInfo nodeinfo;\n    virCapsHostNUMACellCPUPtr cpus;\n    int ncpus;\n    int n, s, c, t;\n    int id, cid;\n    int onlinecpus G_GNUC_UNUSED;\n    bool tmp;\n\n    if (virCapabilitiesGetNodeInfo(&nodeinfo) < 0)\n        return -1;\n\n    ncpus = VIR_NODEINFO_MAXCPUS(nodeinfo);\n\n\n    id = 0;\n    for (n = 0; n < nodeinfo.nodes; n++) {\n        int nodecpus = nodeinfo.sockets * nodeinfo.cores * nodeinfo.threads;\n        cid = 0;\n\n        if (VIR_ALLOC_N(cpus, nodecpus) < 0)\n            return -1;\n\n        for (s = 0; s < nodeinfo.sockets; s++) {\n            for (c = 0; c < nodeinfo.cores; c++) {\n                g_autoptr(virBitmap) siblings = virBitmapNew(ncpus);\n                for (t = 0; t < nodeinfo.threads; t++)\n                    ignore_value(virBitmapSetBit(siblings, id + t));\n\n                for (t = 0; t < nodeinfo.threads; t++) {\n                    if (virHostCPUGetOnline(id, &tmp) < 0)\n                        goto error;\n                    if (tmp) {\n                        cpus[cid].id = id;\n                        cpus[cid].die_id = 0;\n                        cpus[cid].socket_id = s;\n                        cpus[cid].core_id = c;\n                        if (!(cpus[cid].siblings = virBitmapNew(ncpus)))\n                            goto error;\n                        virBitmapCopy(cpus[cid].siblings, siblings);\n                        cid++;\n                    }\n\n                    id++;\n                }\n            }\n        }\n\n        virCapabilitiesHostNUMAAddCell(caps, 0,\n                                       nodeinfo.memory,\n                                       cid, cpus,\n                                       0, NULL,\n                                       0, NULL);\n    }\n\n    return 0;\n\n error:\n    for (; cid >= 0; cid--)\n        virBitmapFree(cpus[cid].siblings);\n    VIR_FREE(cpus);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesHostNUMAInitFake(virCapsHostNUMAPtr caps)\n{\n    virNodeInfo nodeinfo;\n    virCapsHostNUMACellCPUPtr cpus;\n    int ncpus;\n    int n, s, c, t;\n    int id, cid;\n    int onlinecpus G_GNUC_UNUSED;\n    bool tmp;\n\n    if (virCapabilitiesGetNodeInfo(&nodeinfo) < 0)\n        return -1;\n\n    ncpus = VIR_NODEINFO_MAXCPUS(nodeinfo);\n\n\n    id = 0;\n    for (n = 0; n < nodeinfo.nodes; n++) {\n        int nodecpus = nodeinfo.sockets * nodeinfo.cores * nodeinfo.threads;\n        cid = 0;\n\n        if (VIR_ALLOC_N(cpus, nodecpus) < 0)\n            return -1;\n\n        for (s = 0; s < nodeinfo.sockets; s++) {\n            for (c = 0; c < nodeinfo.cores; c++) {\n                g_autoptr(virBitmap) siblings = virBitmapNew(ncpus);\n                for (t = 0; t < nodeinfo.threads; t++)\n                    ignore_value(virBitmapSetBit(siblings, id + t));\n\n                for (t = 0; t < nodeinfo.threads; t++) {\n                    if (virHostCPUGetOnline(id, &tmp) < 0)\n                        goto error;\n                    if (tmp) {\n                        cpus[cid].id = id;\n                        cpus[cid].die_id = 0;\n                        cpus[cid].socket_id = s;\n                        cpus[cid].core_id = c;\n                        if (!(cpus[cid].siblings = virBitmapNew(ncpus)))\n                            goto error;\n                        virBitmapCopy(cpus[cid].siblings, siblings);\n                        cid++;\n                    }\n\n                    id++;\n                }\n            }\n        }\n\n        virCapabilitiesHostNUMAAddCell(caps, 0,\n                                       nodeinfo.memory,\n                                       cid, cpus,\n                                       0, NULL,\n                                       0, NULL);\n    }\n\n    return 0;\n\n error:\n    for (; cid >= 0; cid--)\n        virBitmapFree(cpus[cid].siblings);\n    VIR_FREE(cpus);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to query host NUMA topology, faking single NUMA node\""
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMANew",
          "args": [],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMANewHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1714-1734",
          "snippet": "virCapsHostNUMAPtr\nvirCapabilitiesHostNUMANewHost(void)\n{\n    virCapsHostNUMAPtr caps = virCapabilitiesHostNUMANew();\n\n    if (virNumaIsAvailable()) {\n        if (virCapabilitiesHostNUMAInitReal(caps) == 0)\n            return caps;\n\n        virCapabilitiesHostNUMAUnref(caps);\n        caps = virCapabilitiesHostNUMANew();\n        VIR_WARN(\"Failed to query host NUMA topology, faking single NUMA node\");\n    }\n\n    if (virCapabilitiesHostNUMAInitFake(caps) < 0) {\n        virCapabilitiesHostNUMAUnref(caps);\n        return NULL;\n    }\n\n    return caps;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMAInitReal",
          "args": [
            "caps"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMAInitReal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1627-1697",
          "snippet": "static int\nvirCapabilitiesHostNUMAInitReal(virCapsHostNUMAPtr caps)\n{\n    int n;\n    unsigned long long memory;\n    virCapsHostNUMACellCPUPtr cpus = NULL;\n    virBitmapPtr cpumap = NULL;\n    virCapsHostNUMACellSiblingInfoPtr siblings = NULL;\n    int nsiblings = 0;\n    virCapsHostNUMACellPageInfoPtr pageinfo = NULL;\n    int npageinfo;\n    int ret = -1;\n    int ncpus = 0;\n    int cpu;\n    int max_node;\n\n    if ((max_node = virNumaGetMaxNode()) < 0)\n        goto cleanup;\n\n    for (n = 0; n <= max_node; n++) {\n        size_t i;\n\n        if ((ncpus = virNumaGetNodeCPUs(n, &cpumap)) < 0) {\n            if (ncpus == -2)\n                continue;\n\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC_N(cpus, ncpus) < 0)\n            goto cleanup;\n        cpu = 0;\n\n        for (i = 0; i < virBitmapSize(cpumap); i++) {\n            if (virBitmapIsBitSet(cpumap, i)) {\n                if (virCapabilitiesFillCPUInfo(i, cpus + cpu++) < 0)\n                    goto cleanup;\n            }\n        }\n\n        if (virCapabilitiesGetNUMASiblingInfo(n, &siblings, &nsiblings) < 0)\n            goto cleanup;\n\n        if (virCapabilitiesGetNUMAPagesInfo(n, &pageinfo, &npageinfo) < 0)\n            goto cleanup;\n\n        /* Detect the amount of memory in the numa cell in KiB */\n        virNumaGetNodeMemory(n, &memory, NULL);\n        memory >>= 10;\n\n        virCapabilitiesHostNUMAAddCell(caps, n, memory,\n                                       ncpus, cpus,\n                                       nsiblings, siblings,\n                                       npageinfo, pageinfo);\n\n        cpus = NULL;\n        siblings = NULL;\n        pageinfo = NULL;\n        virBitmapFree(cpumap);\n        cpumap = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virBitmapFree(cpumap);\n    VIR_FREE(cpus);\n    VIR_FREE(siblings);\n    VIR_FREE(pageinfo);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesHostNUMAInitReal(virCapsHostNUMAPtr caps)\n{\n    int n;\n    unsigned long long memory;\n    virCapsHostNUMACellCPUPtr cpus = NULL;\n    virBitmapPtr cpumap = NULL;\n    virCapsHostNUMACellSiblingInfoPtr siblings = NULL;\n    int nsiblings = 0;\n    virCapsHostNUMACellPageInfoPtr pageinfo = NULL;\n    int npageinfo;\n    int ret = -1;\n    int ncpus = 0;\n    int cpu;\n    int max_node;\n\n    if ((max_node = virNumaGetMaxNode()) < 0)\n        goto cleanup;\n\n    for (n = 0; n <= max_node; n++) {\n        size_t i;\n\n        if ((ncpus = virNumaGetNodeCPUs(n, &cpumap)) < 0) {\n            if (ncpus == -2)\n                continue;\n\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC_N(cpus, ncpus) < 0)\n            goto cleanup;\n        cpu = 0;\n\n        for (i = 0; i < virBitmapSize(cpumap); i++) {\n            if (virBitmapIsBitSet(cpumap, i)) {\n                if (virCapabilitiesFillCPUInfo(i, cpus + cpu++) < 0)\n                    goto cleanup;\n            }\n        }\n\n        if (virCapabilitiesGetNUMASiblingInfo(n, &siblings, &nsiblings) < 0)\n            goto cleanup;\n\n        if (virCapabilitiesGetNUMAPagesInfo(n, &pageinfo, &npageinfo) < 0)\n            goto cleanup;\n\n        /* Detect the amount of memory in the numa cell in KiB */\n        virNumaGetNodeMemory(n, &memory, NULL);\n        memory >>= 10;\n\n        virCapabilitiesHostNUMAAddCell(caps, n, memory,\n                                       ncpus, cpus,\n                                       nsiblings, siblings,\n                                       npageinfo, pageinfo);\n\n        cpus = NULL;\n        siblings = NULL;\n        pageinfo = NULL;\n        virBitmapFree(cpumap);\n        cpumap = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virBitmapFree(cpumap);\n    VIR_FREE(cpus);\n    VIR_FREE(siblings);\n    VIR_FREE(pageinfo);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaIsAvailable",
          "args": [],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaIsAvailable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "355-359",
          "snippet": "bool\nvirNumaIsAvailable(void)\n{\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nbool\nvirNumaIsAvailable(void)\n{\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsHostNUMAPtr\nvirCapabilitiesHostNUMANewHost(void)\n{\n    virCapsHostNUMAPtr caps = virCapabilitiesHostNUMANew();\n\n    if (virNumaIsAvailable()) {\n        if (virCapabilitiesHostNUMAInitReal(caps) == 0)\n            return caps;\n\n        virCapabilitiesHostNUMAUnref(caps);\n        caps = virCapabilitiesHostNUMANew();\n        VIR_WARN(\"Failed to query host NUMA topology, faking single NUMA node\");\n    }\n\n    if (virCapabilitiesHostNUMAInitFake(caps) < 0) {\n        virCapabilitiesHostNUMAUnref(caps);\n        return NULL;\n    }\n\n    return caps;\n}"
  },
  {
    "function_name": "virCapabilitiesHostNUMANew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1700-1711",
    "snippet": "virCapsHostNUMAPtr\nvirCapabilitiesHostNUMANew(void)\n{\n    virCapsHostNUMAPtr caps = NULL;\n\n    caps = g_new0(virCapsHostNUMA, 1);\n    caps->refs = 1;\n    caps->cells = g_ptr_array_new_with_free_func(\n        (GDestroyNotify)virCapabilitiesFreeHostNUMACell);\n\n    return caps;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_ptr_array_new_with_free_func",
          "args": [
            "(GDestroyNotify)virCapabilitiesFreeHostNUMACell"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virCapsHostNUMA",
            "1"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsHostNUMAPtr\nvirCapabilitiesHostNUMANew(void)\n{\n    virCapsHostNUMAPtr caps = NULL;\n\n    caps = g_new0(virCapsHostNUMA, 1);\n    caps->refs = 1;\n    caps->cells = g_ptr_array_new_with_free_func(\n        (GDestroyNotify)virCapabilitiesFreeHostNUMACell);\n\n    return caps;\n}"
  },
  {
    "function_name": "virCapabilitiesHostNUMAInitReal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1627-1697",
    "snippet": "static int\nvirCapabilitiesHostNUMAInitReal(virCapsHostNUMAPtr caps)\n{\n    int n;\n    unsigned long long memory;\n    virCapsHostNUMACellCPUPtr cpus = NULL;\n    virBitmapPtr cpumap = NULL;\n    virCapsHostNUMACellSiblingInfoPtr siblings = NULL;\n    int nsiblings = 0;\n    virCapsHostNUMACellPageInfoPtr pageinfo = NULL;\n    int npageinfo;\n    int ret = -1;\n    int ncpus = 0;\n    int cpu;\n    int max_node;\n\n    if ((max_node = virNumaGetMaxNode()) < 0)\n        goto cleanup;\n\n    for (n = 0; n <= max_node; n++) {\n        size_t i;\n\n        if ((ncpus = virNumaGetNodeCPUs(n, &cpumap)) < 0) {\n            if (ncpus == -2)\n                continue;\n\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC_N(cpus, ncpus) < 0)\n            goto cleanup;\n        cpu = 0;\n\n        for (i = 0; i < virBitmapSize(cpumap); i++) {\n            if (virBitmapIsBitSet(cpumap, i)) {\n                if (virCapabilitiesFillCPUInfo(i, cpus + cpu++) < 0)\n                    goto cleanup;\n            }\n        }\n\n        if (virCapabilitiesGetNUMASiblingInfo(n, &siblings, &nsiblings) < 0)\n            goto cleanup;\n\n        if (virCapabilitiesGetNUMAPagesInfo(n, &pageinfo, &npageinfo) < 0)\n            goto cleanup;\n\n        /* Detect the amount of memory in the numa cell in KiB */\n        virNumaGetNodeMemory(n, &memory, NULL);\n        memory >>= 10;\n\n        virCapabilitiesHostNUMAAddCell(caps, n, memory,\n                                       ncpus, cpus,\n                                       nsiblings, siblings,\n                                       npageinfo, pageinfo);\n\n        cpus = NULL;\n        siblings = NULL;\n        pageinfo = NULL;\n        virBitmapFree(cpumap);\n        cpumap = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virBitmapFree(cpumap);\n    VIR_FREE(cpus);\n    VIR_FREE(siblings);\n    VIR_FREE(pageinfo);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pageinfo"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "siblings"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpus"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "cpumap"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMAAddCell",
          "args": [
            "caps",
            "n",
            "memory",
            "ncpus",
            "cpus",
            "nsiblings",
            "siblings",
            "npageinfo",
            "pageinfo"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMAAddCell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "346-369",
          "snippet": "void\nvirCapabilitiesHostNUMAAddCell(virCapsHostNUMAPtr caps,\n                               int num,\n                               unsigned long long mem,\n                               int ncpus,\n                               virCapsHostNUMACellCPUPtr cpus,\n                               int nsiblings,\n                               virCapsHostNUMACellSiblingInfoPtr siblings,\n                               int npageinfo,\n                               virCapsHostNUMACellPageInfoPtr pageinfo)\n{\n    virCapsHostNUMACellPtr cell = g_new0(virCapsHostNUMACell, 1);\n\n    cell->num = num;\n    cell->mem = mem;\n    cell->ncpus = ncpus;\n    cell->cpus = cpus;\n    cell->nsiblings = nsiblings;\n    cell->siblings = siblings;\n    cell->npageinfo = npageinfo;\n    cell->pageinfo = pageinfo;\n\n    g_ptr_array_add(caps->cells, cell);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesHostNUMAAddCell(virCapsHostNUMAPtr caps,\n                               int num,\n                               unsigned long long mem,\n                               int ncpus,\n                               virCapsHostNUMACellCPUPtr cpus,\n                               int nsiblings,\n                               virCapsHostNUMACellSiblingInfoPtr siblings,\n                               int npageinfo,\n                               virCapsHostNUMACellPageInfoPtr pageinfo)\n{\n    virCapsHostNUMACellPtr cell = g_new0(virCapsHostNUMACell, 1);\n\n    cell->num = num;\n    cell->mem = mem;\n    cell->ncpus = ncpus;\n    cell->cpus = cpus;\n    cell->nsiblings = nsiblings;\n    cell->siblings = siblings;\n    cell->npageinfo = npageinfo;\n    cell->pageinfo = pageinfo;\n\n    g_ptr_array_add(caps->cells, cell);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaGetNodeMemory",
          "args": [
            "n",
            "&memory",
            "NULL"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetNodeMemory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "371-384",
          "snippet": "int\nvirNumaGetNodeMemory(int node G_GNUC_UNUSED,\n                     unsigned long long *memsize,\n                     unsigned long long *memfree)\n{\n    if (memsize)\n        *memsize = 0;\n\n    if (memfree)\n        *memfree = 0;\n\n    VIR_DEBUG(\"NUMA isn't available on this host\");\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetNodeMemory(int node G_GNUC_UNUSED,\n                     unsigned long long *memsize,\n                     unsigned long long *memfree)\n{\n    if (memsize)\n        *memsize = 0;\n\n    if (memfree)\n        *memfree = 0;\n\n    VIR_DEBUG(\"NUMA isn't available on this host\");\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesGetNUMAPagesInfo",
          "args": [
            "n",
            "&pageinfo",
            "&npageinfo"
          ],
          "line": 1670
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesGetNUMAPagesInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1529-1557",
          "snippet": "static int\nvirCapabilitiesGetNUMAPagesInfo(int node,\n                                virCapsHostNUMACellPageInfoPtr *pageinfo,\n                                int *npageinfo)\n{\n    int ret = -1;\n    unsigned int *pages_size = NULL;\n    unsigned long long *pages_avail = NULL;\n    size_t npages, i;\n\n    if (virNumaGetPages(node, &pages_size, &pages_avail, NULL, &npages) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(*pageinfo, npages) < 0)\n        goto cleanup;\n    *npageinfo = npages;\n\n    for (i = 0; i < npages; i++) {\n        (*pageinfo)[i].size = pages_size[i];\n        (*pageinfo)[i].avail = pages_avail[i];\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(pages_avail);\n    VIR_FREE(pages_size);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesGetNUMAPagesInfo(int node,\n                                virCapsHostNUMACellPageInfoPtr *pageinfo,\n                                int *npageinfo)\n{\n    int ret = -1;\n    unsigned int *pages_size = NULL;\n    unsigned long long *pages_avail = NULL;\n    size_t npages, i;\n\n    if (virNumaGetPages(node, &pages_size, &pages_avail, NULL, &npages) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(*pageinfo, npages) < 0)\n        goto cleanup;\n    *npageinfo = npages;\n\n    for (i = 0; i < npages; i++) {\n        (*pageinfo)[i].size = pages_size[i];\n        (*pageinfo)[i].avail = pages_avail[i];\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(pages_avail);\n    VIR_FREE(pages_size);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesGetNUMASiblingInfo",
          "args": [
            "n",
            "&siblings",
            "&nsiblings"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesGetNUMASiblingInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1482-1527",
          "snippet": "static int\nvirCapabilitiesGetNUMASiblingInfo(int node,\n                                  virCapsHostNUMACellSiblingInfoPtr *siblings,\n                                  int *nsiblings)\n{\n    virCapsHostNUMACellSiblingInfoPtr tmp = NULL;\n    int tmp_size = 0;\n    int ret = -1;\n    int *distances = NULL;\n    int ndistances = 0;\n    size_t i;\n\n    if (virNumaGetDistances(node, &distances, &ndistances) < 0)\n        goto cleanup;\n\n    if (!distances) {\n        *siblings = NULL;\n        *nsiblings = 0;\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(tmp, ndistances) < 0)\n        goto cleanup;\n\n    for (i = 0; i < ndistances; i++) {\n        if (!distances[i])\n            continue;\n\n        tmp[tmp_size].node = i;\n        tmp[tmp_size].distance = distances[i];\n        tmp_size++;\n    }\n\n    if (VIR_REALLOC_N(tmp, tmp_size) < 0)\n        goto cleanup;\n\n    *siblings = tmp;\n    *nsiblings = tmp_size;\n    tmp = NULL;\n    tmp_size = 0;\n    ret = 0;\n cleanup:\n    VIR_FREE(distances);\n    VIR_FREE(tmp);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesGetNUMASiblingInfo(int node,\n                                  virCapsHostNUMACellSiblingInfoPtr *siblings,\n                                  int *nsiblings)\n{\n    virCapsHostNUMACellSiblingInfoPtr tmp = NULL;\n    int tmp_size = 0;\n    int ret = -1;\n    int *distances = NULL;\n    int ndistances = 0;\n    size_t i;\n\n    if (virNumaGetDistances(node, &distances, &ndistances) < 0)\n        goto cleanup;\n\n    if (!distances) {\n        *siblings = NULL;\n        *nsiblings = 0;\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(tmp, ndistances) < 0)\n        goto cleanup;\n\n    for (i = 0; i < ndistances; i++) {\n        if (!distances[i])\n            continue;\n\n        tmp[tmp_size].node = i;\n        tmp[tmp_size].distance = distances[i];\n        tmp_size++;\n    }\n\n    if (VIR_REALLOC_N(tmp, tmp_size) < 0)\n        goto cleanup;\n\n    *siblings = tmp;\n    *nsiblings = tmp_size;\n    tmp = NULL;\n    tmp_size = 0;\n    ret = 0;\n cleanup:\n    VIR_FREE(distances);\n    VIR_FREE(tmp);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFillCPUInfo",
          "args": [
            "i",
            "cpus + cpu++"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFillCPUInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1459-1480",
          "snippet": "static int\nvirCapabilitiesFillCPUInfo(int cpu_id G_GNUC_UNUSED,\n                           virCapsHostNUMACellCPUPtr cpu G_GNUC_UNUSED)\n{\n#ifdef __linux__\n    cpu->id = cpu_id;\n\n    if (virHostCPUGetSocket(cpu_id, &cpu->socket_id) < 0 ||\n        virHostCPUGetDie(cpu_id, &cpu->die_id) < 0 ||\n        virHostCPUGetCore(cpu_id, &cpu->core_id) < 0)\n        return -1;\n\n    if (!(cpu->siblings = virHostCPUGetSiblingsList(cpu_id)))\n        return -1;\n\n    return 0;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node cpu info not implemented on this platform\"));\n    return -1;\n#endif\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesFillCPUInfo(int cpu_id G_GNUC_UNUSED,\n                           virCapsHostNUMACellCPUPtr cpu G_GNUC_UNUSED)\n{\n#ifdef __linux__\n    cpu->id = cpu_id;\n\n    if (virHostCPUGetSocket(cpu_id, &cpu->socket_id) < 0 ||\n        virHostCPUGetDie(cpu_id, &cpu->die_id) < 0 ||\n        virHostCPUGetCore(cpu_id, &cpu->core_id) < 0)\n        return -1;\n\n    if (!(cpu->siblings = virHostCPUGetSiblingsList(cpu_id)))\n        return -1;\n\n    return 0;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node cpu info not implemented on this platform\"));\n    return -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapIsBitSet",
          "args": [
            "cpumap",
            "i"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapIsBitSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "298-306",
          "snippet": "bool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapSize",
          "args": [
            "cpumap"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "882-886",
          "snippet": "size_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nsize_t\nvirBitmapSize(virBitmapPtr bitmap)\n{\n    return bitmap->nbits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "cpus",
            "ncpus"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNumaGetNodeCPUs",
          "args": [
            "n",
            "&cpumap"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetNodeCPUs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "387-396",
          "snippet": "int\nvirNumaGetNodeCPUs(int node G_GNUC_UNUSED,\n                   virBitmapPtr *cpus)\n{\n    *cpus = NULL;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetNodeCPUs(int node G_GNUC_UNUSED,\n                   virBitmapPtr *cpus)\n{\n    *cpus = NULL;\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNumaGetMaxNode",
          "args": [],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetMaxNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "362-368",
          "snippet": "int\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetMaxNode(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"NUMA isn't available on this host\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesHostNUMAInitReal(virCapsHostNUMAPtr caps)\n{\n    int n;\n    unsigned long long memory;\n    virCapsHostNUMACellCPUPtr cpus = NULL;\n    virBitmapPtr cpumap = NULL;\n    virCapsHostNUMACellSiblingInfoPtr siblings = NULL;\n    int nsiblings = 0;\n    virCapsHostNUMACellPageInfoPtr pageinfo = NULL;\n    int npageinfo;\n    int ret = -1;\n    int ncpus = 0;\n    int cpu;\n    int max_node;\n\n    if ((max_node = virNumaGetMaxNode()) < 0)\n        goto cleanup;\n\n    for (n = 0; n <= max_node; n++) {\n        size_t i;\n\n        if ((ncpus = virNumaGetNodeCPUs(n, &cpumap)) < 0) {\n            if (ncpus == -2)\n                continue;\n\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC_N(cpus, ncpus) < 0)\n            goto cleanup;\n        cpu = 0;\n\n        for (i = 0; i < virBitmapSize(cpumap); i++) {\n            if (virBitmapIsBitSet(cpumap, i)) {\n                if (virCapabilitiesFillCPUInfo(i, cpus + cpu++) < 0)\n                    goto cleanup;\n            }\n        }\n\n        if (virCapabilitiesGetNUMASiblingInfo(n, &siblings, &nsiblings) < 0)\n            goto cleanup;\n\n        if (virCapabilitiesGetNUMAPagesInfo(n, &pageinfo, &npageinfo) < 0)\n            goto cleanup;\n\n        /* Detect the amount of memory in the numa cell in KiB */\n        virNumaGetNodeMemory(n, &memory, NULL);\n        memory >>= 10;\n\n        virCapabilitiesHostNUMAAddCell(caps, n, memory,\n                                       ncpus, cpus,\n                                       nsiblings, siblings,\n                                       npageinfo, pageinfo);\n\n        cpus = NULL;\n        siblings = NULL;\n        pageinfo = NULL;\n        virBitmapFree(cpumap);\n        cpumap = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virBitmapFree(cpumap);\n    VIR_FREE(cpus);\n    VIR_FREE(siblings);\n    VIR_FREE(pageinfo);\n    return ret;\n}"
  },
  {
    "function_name": "virCapabilitiesHostNUMAInitFake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1560-1624",
    "snippet": "static int\nvirCapabilitiesHostNUMAInitFake(virCapsHostNUMAPtr caps)\n{\n    virNodeInfo nodeinfo;\n    virCapsHostNUMACellCPUPtr cpus;\n    int ncpus;\n    int n, s, c, t;\n    int id, cid;\n    int onlinecpus G_GNUC_UNUSED;\n    bool tmp;\n\n    if (virCapabilitiesGetNodeInfo(&nodeinfo) < 0)\n        return -1;\n\n    ncpus = VIR_NODEINFO_MAXCPUS(nodeinfo);\n\n\n    id = 0;\n    for (n = 0; n < nodeinfo.nodes; n++) {\n        int nodecpus = nodeinfo.sockets * nodeinfo.cores * nodeinfo.threads;\n        cid = 0;\n\n        if (VIR_ALLOC_N(cpus, nodecpus) < 0)\n            return -1;\n\n        for (s = 0; s < nodeinfo.sockets; s++) {\n            for (c = 0; c < nodeinfo.cores; c++) {\n                g_autoptr(virBitmap) siblings = virBitmapNew(ncpus);\n                for (t = 0; t < nodeinfo.threads; t++)\n                    ignore_value(virBitmapSetBit(siblings, id + t));\n\n                for (t = 0; t < nodeinfo.threads; t++) {\n                    if (virHostCPUGetOnline(id, &tmp) < 0)\n                        goto error;\n                    if (tmp) {\n                        cpus[cid].id = id;\n                        cpus[cid].die_id = 0;\n                        cpus[cid].socket_id = s;\n                        cpus[cid].core_id = c;\n                        if (!(cpus[cid].siblings = virBitmapNew(ncpus)))\n                            goto error;\n                        virBitmapCopy(cpus[cid].siblings, siblings);\n                        cid++;\n                    }\n\n                    id++;\n                }\n            }\n        }\n\n        virCapabilitiesHostNUMAAddCell(caps, 0,\n                                       nodeinfo.memory,\n                                       cid, cpus,\n                                       0, NULL,\n                                       0, NULL);\n    }\n\n    return 0;\n\n error:\n    for (; cid >= 0; cid--)\n        virBitmapFree(cpus[cid].siblings);\n    VIR_FREE(cpus);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpus"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "cpus[cid].siblings"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMAAddCell",
          "args": [
            "caps",
            "0",
            "nodeinfo.memory",
            "cid",
            "cpus",
            "0",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMAAddCell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "346-369",
          "snippet": "void\nvirCapabilitiesHostNUMAAddCell(virCapsHostNUMAPtr caps,\n                               int num,\n                               unsigned long long mem,\n                               int ncpus,\n                               virCapsHostNUMACellCPUPtr cpus,\n                               int nsiblings,\n                               virCapsHostNUMACellSiblingInfoPtr siblings,\n                               int npageinfo,\n                               virCapsHostNUMACellPageInfoPtr pageinfo)\n{\n    virCapsHostNUMACellPtr cell = g_new0(virCapsHostNUMACell, 1);\n\n    cell->num = num;\n    cell->mem = mem;\n    cell->ncpus = ncpus;\n    cell->cpus = cpus;\n    cell->nsiblings = nsiblings;\n    cell->siblings = siblings;\n    cell->npageinfo = npageinfo;\n    cell->pageinfo = pageinfo;\n\n    g_ptr_array_add(caps->cells, cell);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesHostNUMAAddCell(virCapsHostNUMAPtr caps,\n                               int num,\n                               unsigned long long mem,\n                               int ncpus,\n                               virCapsHostNUMACellCPUPtr cpus,\n                               int nsiblings,\n                               virCapsHostNUMACellSiblingInfoPtr siblings,\n                               int npageinfo,\n                               virCapsHostNUMACellPageInfoPtr pageinfo)\n{\n    virCapsHostNUMACellPtr cell = g_new0(virCapsHostNUMACell, 1);\n\n    cell->num = num;\n    cell->mem = mem;\n    cell->ncpus = ncpus;\n    cell->cpus = cpus;\n    cell->nsiblings = nsiblings;\n    cell->siblings = siblings;\n    cell->npageinfo = npageinfo;\n    cell->pageinfo = pageinfo;\n\n    g_ptr_array_add(caps->cells, cell);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapCopy",
          "args": [
            "cpus[cid].siblings",
            "siblings"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "146-158",
          "snippet": "int\nvirBitmapCopy(virBitmapPtr dst,\n              virBitmapPtr src)\n{\n    if (dst->nbits != src->nbits) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    memcpy(dst->map, src->map, src->map_len * sizeof(src->map[0]));\n\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapCopy(virBitmapPtr dst,\n              virBitmapPtr src)\n{\n    if (dst->nbits != src->nbits) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    memcpy(dst->map, src->map, src->map_len * sizeof(src->map[0]));\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "ncpus"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetOnline",
          "args": [
            "id",
            "&tmp"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetOnline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "889-906",
          "snippet": "int\nvirHostCPUGetOnline(unsigned int cpu, bool *online)\n{\n    unsigned int tmp = 0;\n    int ret = virFileReadValueUint(&tmp,\n                                   \"%s/cpu/cpu%u/online\",\n                                   SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's online (doesn't support offlining) */\n    if (ret == -2)\n        tmp = 1;\n    else if (ret < 0)\n        return -1;\n\n    *online = tmp;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirHostCPUGetOnline(unsigned int cpu, bool *online)\n{\n    unsigned int tmp = 0;\n    int ret = virFileReadValueUint(&tmp,\n                                   \"%s/cpu/cpu%u/online\",\n                                   SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's online (doesn't support offlining) */\n    if (ret == -2)\n        tmp = 1;\n    else if (ret < 0)\n        return -1;\n\n    *online = tmp;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(siblings, id + t)"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "siblings",
            "id + t"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "cpus",
            "nodecpus"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_NODEINFO_MAXCPUS",
          "args": [
            "nodeinfo"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesGetNodeInfo",
          "args": [
            "&nodeinfo"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesGetNodeInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1434-1456",
          "snippet": "int\nvirCapabilitiesGetNodeInfo(virNodeInfoPtr nodeinfo)\n{\n    virArch hostarch = virArchFromHost();\n    unsigned long long memorybytes;\n\n    memset(nodeinfo, 0, sizeof(*nodeinfo));\n\n    if (virStrcpyStatic(nodeinfo->model, virArchToString(hostarch)) < 0)\n        return -1;\n\n    if (virHostMemGetInfo(&memorybytes, NULL) < 0)\n        return -1;\n    nodeinfo->memory = memorybytes / 1024;\n\n    if (virHostCPUGetInfo(hostarch,\n                          &nodeinfo->cpus, &nodeinfo->mhz,\n                          &nodeinfo->nodes, &nodeinfo->sockets,\n                          &nodeinfo->cores, &nodeinfo->threads) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirCapabilitiesGetNodeInfo(virNodeInfoPtr nodeinfo)\n{\n    virArch hostarch = virArchFromHost();\n    unsigned long long memorybytes;\n\n    memset(nodeinfo, 0, sizeof(*nodeinfo));\n\n    if (virStrcpyStatic(nodeinfo->model, virArchToString(hostarch)) < 0)\n        return -1;\n\n    if (virHostMemGetInfo(&memorybytes, NULL) < 0)\n        return -1;\n    nodeinfo->memory = memorybytes / 1024;\n\n    if (virHostCPUGetInfo(hostarch,\n                          &nodeinfo->cpus, &nodeinfo->mhz,\n                          &nodeinfo->nodes, &nodeinfo->sockets,\n                          &nodeinfo->cores, &nodeinfo->threads) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesHostNUMAInitFake(virCapsHostNUMAPtr caps)\n{\n    virNodeInfo nodeinfo;\n    virCapsHostNUMACellCPUPtr cpus;\n    int ncpus;\n    int n, s, c, t;\n    int id, cid;\n    int onlinecpus G_GNUC_UNUSED;\n    bool tmp;\n\n    if (virCapabilitiesGetNodeInfo(&nodeinfo) < 0)\n        return -1;\n\n    ncpus = VIR_NODEINFO_MAXCPUS(nodeinfo);\n\n\n    id = 0;\n    for (n = 0; n < nodeinfo.nodes; n++) {\n        int nodecpus = nodeinfo.sockets * nodeinfo.cores * nodeinfo.threads;\n        cid = 0;\n\n        if (VIR_ALLOC_N(cpus, nodecpus) < 0)\n            return -1;\n\n        for (s = 0; s < nodeinfo.sockets; s++) {\n            for (c = 0; c < nodeinfo.cores; c++) {\n                g_autoptr(virBitmap) siblings = virBitmapNew(ncpus);\n                for (t = 0; t < nodeinfo.threads; t++)\n                    ignore_value(virBitmapSetBit(siblings, id + t));\n\n                for (t = 0; t < nodeinfo.threads; t++) {\n                    if (virHostCPUGetOnline(id, &tmp) < 0)\n                        goto error;\n                    if (tmp) {\n                        cpus[cid].id = id;\n                        cpus[cid].die_id = 0;\n                        cpus[cid].socket_id = s;\n                        cpus[cid].core_id = c;\n                        if (!(cpus[cid].siblings = virBitmapNew(ncpus)))\n                            goto error;\n                        virBitmapCopy(cpus[cid].siblings, siblings);\n                        cid++;\n                    }\n\n                    id++;\n                }\n            }\n        }\n\n        virCapabilitiesHostNUMAAddCell(caps, 0,\n                                       nodeinfo.memory,\n                                       cid, cpus,\n                                       0, NULL,\n                                       0, NULL);\n    }\n\n    return 0;\n\n error:\n    for (; cid >= 0; cid--)\n        virBitmapFree(cpus[cid].siblings);\n    VIR_FREE(cpus);\n    return -1;\n}"
  },
  {
    "function_name": "virCapabilitiesGetNUMAPagesInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1529-1557",
    "snippet": "static int\nvirCapabilitiesGetNUMAPagesInfo(int node,\n                                virCapsHostNUMACellPageInfoPtr *pageinfo,\n                                int *npageinfo)\n{\n    int ret = -1;\n    unsigned int *pages_size = NULL;\n    unsigned long long *pages_avail = NULL;\n    size_t npages, i;\n\n    if (virNumaGetPages(node, &pages_size, &pages_avail, NULL, &npages) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(*pageinfo, npages) < 0)\n        goto cleanup;\n    *npageinfo = npages;\n\n    for (i = 0; i < npages; i++) {\n        (*pageinfo)[i].size = pages_size[i];\n        (*pageinfo)[i].avail = pages_avail[i];\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(pages_avail);\n    VIR_FREE(pages_size);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pages_size"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pages_avail"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*pageinfo",
            "npages"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNumaGetPages",
          "args": [
            "node",
            "&pages_size",
            "&pages_avail",
            "NULL",
            "&npages"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetPages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "968-978",
          "snippet": "int\nvirNumaGetPages(int node G_GNUC_UNUSED,\n                unsigned int **pages_size G_GNUC_UNUSED,\n                unsigned long long **pages_avail G_GNUC_UNUSED,\n                unsigned long long **pages_free G_GNUC_UNUSED,\n                size_t *npages G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page info is not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetPages(int node G_GNUC_UNUSED,\n                unsigned int **pages_size G_GNUC_UNUSED,\n                unsigned long long **pages_avail G_GNUC_UNUSED,\n                unsigned long long **pages_free G_GNUC_UNUSED,\n                size_t *npages G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                   _(\"page info is not supported on this platform\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesGetNUMAPagesInfo(int node,\n                                virCapsHostNUMACellPageInfoPtr *pageinfo,\n                                int *npageinfo)\n{\n    int ret = -1;\n    unsigned int *pages_size = NULL;\n    unsigned long long *pages_avail = NULL;\n    size_t npages, i;\n\n    if (virNumaGetPages(node, &pages_size, &pages_avail, NULL, &npages) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(*pageinfo, npages) < 0)\n        goto cleanup;\n    *npageinfo = npages;\n\n    for (i = 0; i < npages; i++) {\n        (*pageinfo)[i].size = pages_size[i];\n        (*pageinfo)[i].avail = pages_avail[i];\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(pages_avail);\n    VIR_FREE(pages_size);\n    return ret;\n}"
  },
  {
    "function_name": "virCapabilitiesGetNUMASiblingInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1482-1527",
    "snippet": "static int\nvirCapabilitiesGetNUMASiblingInfo(int node,\n                                  virCapsHostNUMACellSiblingInfoPtr *siblings,\n                                  int *nsiblings)\n{\n    virCapsHostNUMACellSiblingInfoPtr tmp = NULL;\n    int tmp_size = 0;\n    int ret = -1;\n    int *distances = NULL;\n    int ndistances = 0;\n    size_t i;\n\n    if (virNumaGetDistances(node, &distances, &ndistances) < 0)\n        goto cleanup;\n\n    if (!distances) {\n        *siblings = NULL;\n        *nsiblings = 0;\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(tmp, ndistances) < 0)\n        goto cleanup;\n\n    for (i = 0; i < ndistances; i++) {\n        if (!distances[i])\n            continue;\n\n        tmp[tmp_size].node = i;\n        tmp[tmp_size].distance = distances[i];\n        tmp_size++;\n    }\n\n    if (VIR_REALLOC_N(tmp, tmp_size) < 0)\n        goto cleanup;\n\n    *siblings = tmp;\n    *nsiblings = tmp_size;\n    tmp = NULL;\n    tmp_size = 0;\n    ret = 0;\n cleanup:\n    VIR_FREE(distances);\n    VIR_FREE(tmp);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "distances"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "tmp",
            "tmp_size"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "tmp",
            "ndistances"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNumaGetDistances",
          "args": [
            "node",
            "&distances",
            "&ndistances"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "virNumaGetDistances",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnuma.c",
          "lines": "510-519",
          "snippet": "int\nvirNumaGetDistances(int node G_GNUC_UNUSED,\n                    int **distances,\n                    int *ndistances)\n{\n    *distances = NULL;\n    *ndistances = 0;\n    VIR_DEBUG(\"NUMA distance information isn't available on this host\");\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnuma.h\"",
            "#include <dirent.h>",
            "#include <sys/types.h>",
            "# include <numa.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virhostmem.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virnuma.h\"\n#include <dirent.h>\n#include <sys/types.h>\n# include <numa.h>\n#include <config.h>\n\nint\nvirNumaGetDistances(int node G_GNUC_UNUSED,\n                    int **distances,\n                    int *ndistances)\n{\n    *distances = NULL;\n    *ndistances = 0;\n    VIR_DEBUG(\"NUMA distance information isn't available on this host\");\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesGetNUMASiblingInfo(int node,\n                                  virCapsHostNUMACellSiblingInfoPtr *siblings,\n                                  int *nsiblings)\n{\n    virCapsHostNUMACellSiblingInfoPtr tmp = NULL;\n    int tmp_size = 0;\n    int ret = -1;\n    int *distances = NULL;\n    int ndistances = 0;\n    size_t i;\n\n    if (virNumaGetDistances(node, &distances, &ndistances) < 0)\n        goto cleanup;\n\n    if (!distances) {\n        *siblings = NULL;\n        *nsiblings = 0;\n        return 0;\n    }\n\n    if (VIR_ALLOC_N(tmp, ndistances) < 0)\n        goto cleanup;\n\n    for (i = 0; i < ndistances; i++) {\n        if (!distances[i])\n            continue;\n\n        tmp[tmp_size].node = i;\n        tmp[tmp_size].distance = distances[i];\n        tmp_size++;\n    }\n\n    if (VIR_REALLOC_N(tmp, tmp_size) < 0)\n        goto cleanup;\n\n    *siblings = tmp;\n    *nsiblings = tmp_size;\n    tmp = NULL;\n    tmp_size = 0;\n    ret = 0;\n cleanup:\n    VIR_FREE(distances);\n    VIR_FREE(tmp);\n    return ret;\n}"
  },
  {
    "function_name": "virCapabilitiesFillCPUInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1459-1480",
    "snippet": "static int\nvirCapabilitiesFillCPUInfo(int cpu_id G_GNUC_UNUSED,\n                           virCapsHostNUMACellCPUPtr cpu G_GNUC_UNUSED)\n{\n#ifdef __linux__\n    cpu->id = cpu_id;\n\n    if (virHostCPUGetSocket(cpu_id, &cpu->socket_id) < 0 ||\n        virHostCPUGetDie(cpu_id, &cpu->die_id) < 0 ||\n        virHostCPUGetCore(cpu_id, &cpu->core_id) < 0)\n        return -1;\n\n    if (!(cpu->siblings = virHostCPUGetSiblingsList(cpu_id)))\n        return -1;\n\n    return 0;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node cpu info not implemented on this platform\"));\n    return -1;\n#endif\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"node cpu info not implemented on this platform\")"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"node cpu info not implemented on this platform\""
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetSiblingsList",
          "args": [
            "cpu_id"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetSiblingsList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "259-276",
          "snippet": "virBitmapPtr\nvirHostCPUGetSiblingsList(unsigned int cpu)\n{\n    virBitmapPtr ret = NULL;\n    int rv = -1;\n\n    rv = virFileReadValueBitmap(&ret,\n                                \"%s/cpu/cpu%u/topology/thread_siblings_list\",\n                                SYSFS_SYSTEM_PATH, cpu);\n    if (rv == -2) {\n        /* If the file doesn't exist, the threadis its only sibling */\n        ret = virBitmapNew(cpu + 1);\n        if (ret)\n            ignore_value(virBitmapSetBit(ret, cpu));\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nvirBitmapPtr\nvirHostCPUGetSiblingsList(unsigned int cpu)\n{\n    virBitmapPtr ret = NULL;\n    int rv = -1;\n\n    rv = virFileReadValueBitmap(&ret,\n                                \"%s/cpu/cpu%u/topology/thread_siblings_list\",\n                                SYSFS_SYSTEM_PATH, cpu);\n    if (rv == -2) {\n        /* If the file doesn't exist, the threadis its only sibling */\n        ret = virBitmapNew(cpu + 1);\n        if (ret)\n            ignore_value(virBitmapSetBit(ret, cpu));\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetCore",
          "args": [
            "cpu_id",
            "&cpu->core_id"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetCore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "243-257",
          "snippet": "int\nvirHostCPUGetCore(unsigned int cpu, unsigned int *core)\n{\n    int ret = virFileReadValueUint(core,\n                                   \"%s/cpu/cpu%u/topology/core_id\",\n                                   SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's 0 */\n    if (ret == -2)\n        *core = 0;\n    else if (ret < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirHostCPUGetCore(unsigned int cpu, unsigned int *core)\n{\n    int ret = virFileReadValueUint(core,\n                                   \"%s/cpu/cpu%u/topology/core_id\",\n                                   SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's 0 */\n    if (ret == -2)\n        *core = 0;\n    else if (ret < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetDie",
          "args": [
            "cpu_id",
            "&cpu->die_id"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetDie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "220-241",
          "snippet": "int\nvirHostCPUGetDie(unsigned int cpu, unsigned int *die)\n{\n    int die_id;\n    int ret = virFileReadValueInt(&die_id,\n                                  \"%s/cpu/cpu%u/topology/die_id\",\n                                  SYSFS_SYSTEM_PATH, cpu);\n\n    if (ret == -1)\n        return -1;\n\n    /* If the file is not there, it's 0.\n     * Another alternative is die_id set to -1, meaning that\n     * the arch does not have die_id support. Set @die to\n     * 0 in this case too. */\n    if (ret == -2 || die_id < 0)\n        *die = 0;\n    else\n        *die = die_id;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirHostCPUGetDie(unsigned int cpu, unsigned int *die)\n{\n    int die_id;\n    int ret = virFileReadValueInt(&die_id,\n                                  \"%s/cpu/cpu%u/topology/die_id\",\n                                  SYSFS_SYSTEM_PATH, cpu);\n\n    if (ret == -1)\n        return -1;\n\n    /* If the file is not there, it's 0.\n     * Another alternative is die_id set to -1, meaning that\n     * the arch does not have die_id support. Set @die to\n     * 0 in this case too. */\n    if (ret == -2 || die_id < 0)\n        *die = 0;\n    else\n        *die = die_id;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostCPUGetSocket",
          "args": [
            "cpu_id",
            "&cpu->socket_id"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetSocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "195-218",
          "snippet": "int\nvirHostCPUGetSocket(unsigned int cpu, unsigned int *socket)\n{\n    int tmp;\n    int ret = virFileReadValueInt(&tmp,\n                                  \"%s/cpu/cpu%u/topology/physical_package_id\",\n                                  SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's 0 */\n    if (ret == -2)\n        tmp = 0;\n    else if (ret < 0)\n        return -1;\n\n    /* Some architectures might have '-1' validly in the file, but that actually\n     * means there are no sockets, so from our point of view it's all one socket,\n     * i.e. socket 0.  Similarly when the file does not exist. */\n    if (tmp < 0)\n        tmp = 0;\n\n    *socket = tmp;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirHostCPUGetSocket(unsigned int cpu, unsigned int *socket)\n{\n    int tmp;\n    int ret = virFileReadValueInt(&tmp,\n                                  \"%s/cpu/cpu%u/topology/physical_package_id\",\n                                  SYSFS_SYSTEM_PATH, cpu);\n\n    /* If the file is not there, it's 0 */\n    if (ret == -2)\n        tmp = 0;\n    else if (ret < 0)\n        return -1;\n\n    /* Some architectures might have '-1' validly in the file, but that actually\n     * means there are no sockets, so from our point of view it's all one socket,\n     * i.e. socket 0.  Similarly when the file does not exist. */\n    if (tmp < 0)\n        tmp = 0;\n\n    *socket = tmp;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesFillCPUInfo(int cpu_id G_GNUC_UNUSED,\n                           virCapsHostNUMACellCPUPtr cpu G_GNUC_UNUSED)\n{\n#ifdef __linux__\n    cpu->id = cpu_id;\n\n    if (virHostCPUGetSocket(cpu_id, &cpu->socket_id) < 0 ||\n        virHostCPUGetDie(cpu_id, &cpu->die_id) < 0 ||\n        virHostCPUGetCore(cpu_id, &cpu->core_id) < 0)\n        return -1;\n\n    if (!(cpu->siblings = virHostCPUGetSiblingsList(cpu_id)))\n        return -1;\n\n    return 0;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node cpu info not implemented on this platform\"));\n    return -1;\n#endif\n}"
  },
  {
    "function_name": "virCapabilitiesGetNodeInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1434-1456",
    "snippet": "int\nvirCapabilitiesGetNodeInfo(virNodeInfoPtr nodeinfo)\n{\n    virArch hostarch = virArchFromHost();\n    unsigned long long memorybytes;\n\n    memset(nodeinfo, 0, sizeof(*nodeinfo));\n\n    if (virStrcpyStatic(nodeinfo->model, virArchToString(hostarch)) < 0)\n        return -1;\n\n    if (virHostMemGetInfo(&memorybytes, NULL) < 0)\n        return -1;\n    nodeinfo->memory = memorybytes / 1024;\n\n    if (virHostCPUGetInfo(hostarch,\n                          &nodeinfo->cpus, &nodeinfo->mhz,\n                          &nodeinfo->nodes, &nodeinfo->sockets,\n                          &nodeinfo->cores, &nodeinfo->threads) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostCPUGetInfo",
          "args": [
            "hostarch",
            "&nodeinfo->cpus",
            "&nodeinfo->mhz",
            "&nodeinfo->nodes",
            "&nodeinfo->sockets",
            "&nodeinfo->cores",
            "&nodeinfo->threads"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "virHostCPUGetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostcpu.c",
          "lines": "924-995",
          "snippet": "int\nvirHostCPUGetInfo(virArch hostarch G_GNUC_UNUSED,\n                  unsigned int *cpus G_GNUC_UNUSED,\n                  unsigned int *mhz G_GNUC_UNUSED,\n                  unsigned int *nodes G_GNUC_UNUSED,\n                  unsigned int *sockets G_GNUC_UNUSED,\n                  unsigned int *cores G_GNUC_UNUSED,\n                  unsigned int *threads G_GNUC_UNUSED)\n{\n#ifdef __linux__\n    int ret = -1;\n    FILE *cpuinfo = fopen(CPUINFO_PATH, \"r\");\n\n    if (!cpuinfo) {\n        virReportSystemError(errno,\n                             _(\"cannot open %s\"), CPUINFO_PATH);\n        return -1;\n    }\n\n    ret = virHostCPUGetInfoPopulateLinux(cpuinfo, hostarch,\n                                         cpus, mhz, nodes,\n                                         sockets, cores, threads);\n    if (ret < 0)\n        goto cleanup;\n\n cleanup:\n    VIR_FORCE_FCLOSE(cpuinfo);\n    return ret;\n#elif defined(__FreeBSD__) || defined(__APPLE__)\n    unsigned long cpu_freq;\n    size_t cpu_freq_len = sizeof(cpu_freq);\n\n    *cpus = virHostCPUGetCountAppleFreeBSD();\n    if (*cpus == -1)\n        return -1;\n\n    *nodes = 1;\n    *sockets = 1;\n    *cores = *cpus;\n    *threads = 1;\n\n# ifdef __FreeBSD__\n    /* dev.cpu.%d.freq reports current active CPU frequency. It is provided by\n     * the cpufreq(4) framework. However, it might be disabled or no driver\n     * available. In this case fallback to \"hw.clockrate\" which reports boot time\n     * CPU frequency. */\n\n    if (sysctlbyname(\"dev.cpu.0.freq\", &cpu_freq, &cpu_freq_len, NULL, 0) < 0) {\n        if (sysctlbyname(\"hw.clockrate\", &cpu_freq, &cpu_freq_len, NULL, 0) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"cannot obtain CPU freq\"));\n            return -1;\n        }\n    }\n\n    *mhz = cpu_freq;\n# else\n    if (sysctlbyname(\"hw.cpufrequency\", &cpu_freq, &cpu_freq_len, NULL, 0) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"cannot obtain CPU freq\"));\n        return -1;\n    }\n\n    *mhz = cpu_freq / 1000000;\n# endif\n\n    return 0;\n#else\n    /* XXX Solaris will need an impl later if they port QEMU driver */\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node info not implemented on this platform\"));\n    return -1;\n#endif\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostcpupriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "# include <linux/kvm.h>",
            "#include <unistd.h>",
            "# include <sys/ioctl.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostcpupriv.h\"\n#include \"viralloc.h\"\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n# include <linux/kvm.h>\n#include <unistd.h>\n# include <sys/ioctl.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirHostCPUGetInfo(virArch hostarch G_GNUC_UNUSED,\n                  unsigned int *cpus G_GNUC_UNUSED,\n                  unsigned int *mhz G_GNUC_UNUSED,\n                  unsigned int *nodes G_GNUC_UNUSED,\n                  unsigned int *sockets G_GNUC_UNUSED,\n                  unsigned int *cores G_GNUC_UNUSED,\n                  unsigned int *threads G_GNUC_UNUSED)\n{\n#ifdef __linux__\n    int ret = -1;\n    FILE *cpuinfo = fopen(CPUINFO_PATH, \"r\");\n\n    if (!cpuinfo) {\n        virReportSystemError(errno,\n                             _(\"cannot open %s\"), CPUINFO_PATH);\n        return -1;\n    }\n\n    ret = virHostCPUGetInfoPopulateLinux(cpuinfo, hostarch,\n                                         cpus, mhz, nodes,\n                                         sockets, cores, threads);\n    if (ret < 0)\n        goto cleanup;\n\n cleanup:\n    VIR_FORCE_FCLOSE(cpuinfo);\n    return ret;\n#elif defined(__FreeBSD__) || defined(__APPLE__)\n    unsigned long cpu_freq;\n    size_t cpu_freq_len = sizeof(cpu_freq);\n\n    *cpus = virHostCPUGetCountAppleFreeBSD();\n    if (*cpus == -1)\n        return -1;\n\n    *nodes = 1;\n    *sockets = 1;\n    *cores = *cpus;\n    *threads = 1;\n\n# ifdef __FreeBSD__\n    /* dev.cpu.%d.freq reports current active CPU frequency. It is provided by\n     * the cpufreq(4) framework. However, it might be disabled or no driver\n     * available. In this case fallback to \"hw.clockrate\" which reports boot time\n     * CPU frequency. */\n\n    if (sysctlbyname(\"dev.cpu.0.freq\", &cpu_freq, &cpu_freq_len, NULL, 0) < 0) {\n        if (sysctlbyname(\"hw.clockrate\", &cpu_freq, &cpu_freq_len, NULL, 0) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"cannot obtain CPU freq\"));\n            return -1;\n        }\n    }\n\n    *mhz = cpu_freq;\n# else\n    if (sysctlbyname(\"hw.cpufrequency\", &cpu_freq, &cpu_freq_len, NULL, 0) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"cannot obtain CPU freq\"));\n        return -1;\n    }\n\n    *mhz = cpu_freq / 1000000;\n# endif\n\n    return 0;\n#else\n    /* XXX Solaris will need an impl later if they port QEMU driver */\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"node info not implemented on this platform\"));\n    return -1;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostMemGetInfo",
          "args": [
            "&memorybytes",
            "NULL"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemGetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "790-826",
          "snippet": "int\nvirHostMemGetInfo(unsigned long long *mem,\n                  unsigned long long *freeMem)\n{\n    int max_node;\n    int n;\n\n    if (mem)\n        *mem = 0;\n\n    if (freeMem)\n        *freeMem = 0;\n\n    if (!virNumaIsAvailable())\n        return virHostMemGetInfoFake(mem, freeMem);\n\n    if ((max_node = virNumaGetMaxNode()) < 0)\n        return -1;\n\n    for (n = 0; n <= max_node; n++) {\n        unsigned long long tmp_mem = 0, tmp_freeMem = 0;\n\n        if (!virNumaNodeIsAvailable(n))\n            continue;\n\n        if (virNumaGetNodeMemory(n, &tmp_mem, &tmp_freeMem) < 0)\n            return -1;\n\n        if (mem)\n            *mem += tmp_mem;\n\n        if (freeMem)\n            *freeMem += tmp_freeMem;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostMemGetInfo(unsigned long long *mem,\n                  unsigned long long *freeMem)\n{\n    int max_node;\n    int n;\n\n    if (mem)\n        *mem = 0;\n\n    if (freeMem)\n        *freeMem = 0;\n\n    if (!virNumaIsAvailable())\n        return virHostMemGetInfoFake(mem, freeMem);\n\n    if ((max_node = virNumaGetMaxNode()) < 0)\n        return -1;\n\n    for (n = 0; n <= max_node; n++) {\n        unsigned long long tmp_mem = 0, tmp_freeMem = 0;\n\n        if (!virNumaNodeIsAvailable(n))\n            continue;\n\n        if (virNumaGetNodeMemory(n, &tmp_mem, &tmp_freeMem) < 0)\n            return -1;\n\n        if (mem)\n            *mem += tmp_mem;\n\n        if (freeMem)\n            *freeMem += tmp_freeMem;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "nodeinfo->model",
            "virArchToString(hostarch)"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "hostarch"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "nodeinfo",
            "0",
            "sizeof(*nodeinfo)"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchFromHost",
          "args": [],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "206-235",
          "snippet": "virArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nvirArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirCapabilitiesGetNodeInfo(virNodeInfoPtr nodeinfo)\n{\n    virArch hostarch = virArchFromHost();\n    unsigned long long memorybytes;\n\n    memset(nodeinfo, 0, sizeof(*nodeinfo));\n\n    if (virStrcpyStatic(nodeinfo->model, virArchToString(hostarch)) < 0)\n        return -1;\n\n    if (virHostMemGetInfo(&memorybytes, NULL) < 0)\n        return -1;\n    nodeinfo->memory = memorybytes / 1024;\n\n    if (virHostCPUGetInfo(hostarch,\n                          &nodeinfo->cpus, &nodeinfo->mhz,\n                          &nodeinfo->nodes, &nodeinfo->sockets,\n                          &nodeinfo->cores, &nodeinfo->threads) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virCapabilitiesHostNUMAGetCpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1411-1431",
    "snippet": "virBitmapPtr\nvirCapabilitiesHostNUMAGetCpus(virCapsHostNUMAPtr caps,\n                               virBitmapPtr nodemask)\n{\n    virBitmapPtr ret = NULL;\n    unsigned int maxcpu = virCapabilitiesHostNUMAGetMaxcpu(caps);\n    ssize_t node = -1;\n\n    if (!(ret = virBitmapNew(maxcpu + 1)))\n        return NULL;\n\n\n    while ((node = virBitmapNextSetBit(nodemask, node)) >= 0) {\n        if (virCapabilitiesHostNUMAGetCellCpus(caps, node, ret) < 0) {\n            virBitmapFree(ret);\n            return NULL;\n        }\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "ret"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMAGetCellCpus",
          "args": [
            "caps",
            "node",
            "ret"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMAGetCellCpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1382-1409",
          "snippet": "static int\nvirCapabilitiesHostNUMAGetCellCpus(virCapsHostNUMAPtr caps,\n                                   size_t node,\n                                   virBitmapPtr cpumask)\n{\n    virCapsHostNUMACellPtr cell = NULL;\n    size_t cpu;\n    size_t i;\n    /* The numa node numbers can be non-contiguous. Ex: 0,1,16,17. */\n    for (i = 0; i < caps->cells->len; i++) {\n        cell = g_ptr_array_index(caps->cells, i);\n        if (cell->num == node)\n            break;\n        cell = NULL;\n    }\n\n    for (cpu = 0; cell && cpu < cell->ncpus; cpu++) {\n        if (virBitmapSetBit(cpumask, cell->cpus[cpu].id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cpu '%u' in node '%zu' is out of range \"\n                             \"of the provided bitmap\"),\n                           cell->cpus[cpu].id, node);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesHostNUMAGetCellCpus(virCapsHostNUMAPtr caps,\n                                   size_t node,\n                                   virBitmapPtr cpumask)\n{\n    virCapsHostNUMACellPtr cell = NULL;\n    size_t cpu;\n    size_t i;\n    /* The numa node numbers can be non-contiguous. Ex: 0,1,16,17. */\n    for (i = 0; i < caps->cells->len; i++) {\n        cell = g_ptr_array_index(caps->cells, i);\n        if (cell->num == node)\n            break;\n        cell = NULL;\n    }\n\n    for (cpu = 0; cell && cpu < cell->ncpus; cpu++) {\n        if (virBitmapSetBit(cpumask, cell->cpus[cpu].id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cpu '%u' in node '%zu' is out of range \"\n                             \"of the provided bitmap\"),\n                           cell->cpus[cpu].id, node);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNextSetBit",
          "args": [
            "nodemask",
            "node"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextSetBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "986-1014",
          "snippet": "ssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "maxcpu + 1"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMAGetMaxcpu",
          "args": [
            "caps"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMAGetMaxcpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1361-1379",
          "snippet": "static unsigned int\nvirCapabilitiesHostNUMAGetMaxcpu(virCapsHostNUMAPtr caps)\n{\n    unsigned int maxcpu = 0;\n    size_t node;\n    size_t cpu;\n\n    for (node = 0; node < caps->cells->len; node++) {\n        virCapsHostNUMACellPtr cell =\n            g_ptr_array_index(caps->cells, node);\n\n        for (cpu = 0; cpu < cell->ncpus; cpu++) {\n            if (cell->cpus[cpu].id > maxcpu)\n                maxcpu = cell->cpus[cpu].id;\n        }\n    }\n\n    return maxcpu;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic unsigned int\nvirCapabilitiesHostNUMAGetMaxcpu(virCapsHostNUMAPtr caps)\n{\n    unsigned int maxcpu = 0;\n    size_t node;\n    size_t cpu;\n\n    for (node = 0; node < caps->cells->len; node++) {\n        virCapsHostNUMACellPtr cell =\n            g_ptr_array_index(caps->cells, node);\n\n        for (cpu = 0; cpu < cell->ncpus; cpu++) {\n            if (cell->cpus[cpu].id > maxcpu)\n                maxcpu = cell->cpus[cpu].id;\n        }\n    }\n\n    return maxcpu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirBitmapPtr\nvirCapabilitiesHostNUMAGetCpus(virCapsHostNUMAPtr caps,\n                               virBitmapPtr nodemask)\n{\n    virBitmapPtr ret = NULL;\n    unsigned int maxcpu = virCapabilitiesHostNUMAGetMaxcpu(caps);\n    ssize_t node = -1;\n\n    if (!(ret = virBitmapNew(maxcpu + 1)))\n        return NULL;\n\n\n    while ((node = virBitmapNextSetBit(nodemask, node)) >= 0) {\n        if (virCapabilitiesHostNUMAGetCellCpus(caps, node, ret) < 0) {\n            virBitmapFree(ret);\n            return NULL;\n        }\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virCapabilitiesHostNUMAGetCellCpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1382-1409",
    "snippet": "static int\nvirCapabilitiesHostNUMAGetCellCpus(virCapsHostNUMAPtr caps,\n                                   size_t node,\n                                   virBitmapPtr cpumask)\n{\n    virCapsHostNUMACellPtr cell = NULL;\n    size_t cpu;\n    size_t i;\n    /* The numa node numbers can be non-contiguous. Ex: 0,1,16,17. */\n    for (i = 0; i < caps->cells->len; i++) {\n        cell = g_ptr_array_index(caps->cells, i);\n        if (cell->num == node)\n            break;\n        cell = NULL;\n    }\n\n    for (cpu = 0; cell && cpu < cell->ncpus; cpu++) {\n        if (virBitmapSetBit(cpumask, cell->cpus[cpu].id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cpu '%u' in node '%zu' is out of range \"\n                             \"of the provided bitmap\"),\n                           cell->cpus[cpu].id, node);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Cpu '%u' in node '%zu' is out of range \"\n                             \"of the provided bitmap\")",
            "cell->cpus[cpu].id",
            "node"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cpu '%u' in node '%zu' is out of range \"\n                             \"of the provided bitmap\""
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "cpumask",
            "cell->cpus[cpu].id"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_ptr_array_index",
          "args": [
            "caps->cells",
            "i"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesHostNUMAGetCellCpus(virCapsHostNUMAPtr caps,\n                                   size_t node,\n                                   virBitmapPtr cpumask)\n{\n    virCapsHostNUMACellPtr cell = NULL;\n    size_t cpu;\n    size_t i;\n    /* The numa node numbers can be non-contiguous. Ex: 0,1,16,17. */\n    for (i = 0; i < caps->cells->len; i++) {\n        cell = g_ptr_array_index(caps->cells, i);\n        if (cell->num == node)\n            break;\n        cell = NULL;\n    }\n\n    for (cpu = 0; cell && cpu < cell->ncpus; cpu++) {\n        if (virBitmapSetBit(cpumask, cell->cpus[cpu].id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Cpu '%u' in node '%zu' is out of range \"\n                             \"of the provided bitmap\"),\n                           cell->cpus[cpu].id, node);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virCapabilitiesHostNUMAGetMaxcpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1361-1379",
    "snippet": "static unsigned int\nvirCapabilitiesHostNUMAGetMaxcpu(virCapsHostNUMAPtr caps)\n{\n    unsigned int maxcpu = 0;\n    size_t node;\n    size_t cpu;\n\n    for (node = 0; node < caps->cells->len; node++) {\n        virCapsHostNUMACellPtr cell =\n            g_ptr_array_index(caps->cells, node);\n\n        for (cpu = 0; cpu < cell->ncpus; cpu++) {\n            if (cell->cpus[cpu].id > maxcpu)\n                maxcpu = cell->cpus[cpu].id;\n        }\n    }\n\n    return maxcpu;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_ptr_array_index",
          "args": [
            "caps->cells",
            "node"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic unsigned int\nvirCapabilitiesHostNUMAGetMaxcpu(virCapsHostNUMAPtr caps)\n{\n    unsigned int maxcpu = 0;\n    size_t node;\n    size_t cpu;\n\n    for (node = 0; node < caps->cells->len; node++) {\n        virCapsHostNUMACellPtr cell =\n            g_ptr_array_index(caps->cells, node);\n\n        for (cpu = 0; cpu < cell->ncpus; cpu++) {\n            if (cell->cpus[cpu].id > maxcpu)\n                maxcpu = cell->cpus[cpu].id;\n        }\n    }\n\n    return maxcpu;\n}"
  },
  {
    "function_name": "virCapabilitiesFormatXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1335-1358",
    "snippet": "char *\nvirCapabilitiesFormatXML(virCapsPtr caps)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAddLit(&buf, \"<capabilities>\\n\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    if (virCapabilitiesFormatHostXML(&caps->host, &buf) < 0)\n        goto error;\n\n    virCapabilitiesFormatGuestXML(caps->guests, caps->nguests, &buf);\n\n    virCapabilitiesFormatStoragePoolXML(caps->pools, caps->npools, &buf);\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</capabilities>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"</capabilities>\\n\""
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "&buf",
            "-2"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFormatStoragePoolXML",
          "args": [
            "caps->pools",
            "caps->npools",
            "&buf"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFormatStoragePoolXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1301-1324",
          "snippet": "static void\nvirCapabilitiesFormatStoragePoolXML(virCapsStoragePoolPtr *pools,\n                                    size_t npools,\n                                    virBufferPtr buf)\n{\n    size_t i;\n\n    if (npools == 0)\n        return;\n\n    virBufferAddLit(buf, \"<pool>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferAddLit(buf, \"<enum name='type'>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < npools; i++)\n        virBufferAsprintf(buf, \"<value>%s</value>\\n\",\n                          virStoragePoolTypeToString(pools[i]->type));\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</enum>\\n\");\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</pool>\\n\\n\");\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesFormatStoragePoolXML(virCapsStoragePoolPtr *pools,\n                                    size_t npools,\n                                    virBufferPtr buf)\n{\n    size_t i;\n\n    if (npools == 0)\n        return;\n\n    virBufferAddLit(buf, \"<pool>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferAddLit(buf, \"<enum name='type'>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < npools; i++)\n        virBufferAsprintf(buf, \"<value>%s</value>\\n\",\n                          virStoragePoolTypeToString(pools[i]->type));\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</enum>\\n\");\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</pool>\\n\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFormatGuestXML",
          "args": [
            "caps->guests",
            "caps->nguests",
            "&buf"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFormatGuestXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1224-1298",
          "snippet": "static void\nvirCapabilitiesFormatGuestXML(virCapsGuestPtr *guests,\n                              size_t nguests,\n                              virBufferPtr buf)\n{\n    size_t i, j, k;\n\n    for (i = 0; i < nguests; i++) {\n        virBufferAddLit(buf, \"<guest>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<os_type>%s</os_type>\\n\",\n                          virDomainOSTypeToString(guests[i]->ostype));\n        if (guests[i]->arch.id)\n            virBufferAsprintf(buf, \"<arch name='%s'>\\n\",\n                              virArchToString(guests[i]->arch.id));\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<wordsize>%d</wordsize>\\n\",\n                          guests[i]->arch.wordsize);\n        if (guests[i]->arch.defaultInfo.emulator)\n            virBufferAsprintf(buf, \"<emulator>%s</emulator>\\n\",\n                              guests[i]->arch.defaultInfo.emulator);\n        if (guests[i]->arch.defaultInfo.loader)\n            virBufferAsprintf(buf, \"<loader>%s</loader>\\n\",\n                              guests[i]->arch.defaultInfo.loader);\n\n        for (j = 0; j < guests[i]->arch.defaultInfo.nmachines; j++) {\n            virCapsGuestMachinePtr machine = guests[i]->arch.defaultInfo.machines[j];\n            virBufferAddLit(buf, \"<machine\");\n            if (machine->canonical)\n                virBufferAsprintf(buf, \" canonical='%s'\", machine->canonical);\n            if (machine->maxCpus > 0)\n                virBufferAsprintf(buf, \" maxCpus='%d'\", machine->maxCpus);\n            virBufferAsprintf(buf, \">%s</machine>\\n\", machine->name);\n        }\n\n        for (j = 0; j < guests[i]->arch.ndomains; j++) {\n            virBufferAsprintf(buf, \"<domain type='%s'\",\n                virDomainVirtTypeToString(guests[i]->arch.domains[j]->type));\n            if (!guests[i]->arch.domains[j]->info.emulator &&\n                !guests[i]->arch.domains[j]->info.loader &&\n                !guests[i]->arch.domains[j]->info.nmachines) {\n                virBufferAddLit(buf, \"/>\\n\");\n                continue;\n            }\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            if (guests[i]->arch.domains[j]->info.emulator)\n                virBufferAsprintf(buf, \"<emulator>%s</emulator>\\n\",\n                                  guests[i]->arch.domains[j]->info.emulator);\n            if (guests[i]->arch.domains[j]->info.loader)\n                virBufferAsprintf(buf, \"<loader>%s</loader>\\n\",\n                                  guests[i]->arch.domains[j]->info.loader);\n\n            for (k = 0; k < guests[i]->arch.domains[j]->info.nmachines; k++) {\n                virCapsGuestMachinePtr machine = guests[i]->arch.domains[j]->info.machines[k];\n                virBufferAddLit(buf, \"<machine\");\n                if (machine->canonical)\n                    virBufferAsprintf(buf, \" canonical='%s'\", machine->canonical);\n                if (machine->maxCpus > 0)\n                    virBufferAsprintf(buf, \" maxCpus='%d'\", machine->maxCpus);\n                virBufferAsprintf(buf, \">%s</machine>\\n\", machine->name);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</domain>\\n\");\n        }\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</arch>\\n\");\n\n        virCapabilitiesFormatGuestFeatures(guests[i], buf);\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</guest>\\n\\n\");\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesFormatGuestXML(virCapsGuestPtr *guests,\n                              size_t nguests,\n                              virBufferPtr buf)\n{\n    size_t i, j, k;\n\n    for (i = 0; i < nguests; i++) {\n        virBufferAddLit(buf, \"<guest>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<os_type>%s</os_type>\\n\",\n                          virDomainOSTypeToString(guests[i]->ostype));\n        if (guests[i]->arch.id)\n            virBufferAsprintf(buf, \"<arch name='%s'>\\n\",\n                              virArchToString(guests[i]->arch.id));\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<wordsize>%d</wordsize>\\n\",\n                          guests[i]->arch.wordsize);\n        if (guests[i]->arch.defaultInfo.emulator)\n            virBufferAsprintf(buf, \"<emulator>%s</emulator>\\n\",\n                              guests[i]->arch.defaultInfo.emulator);\n        if (guests[i]->arch.defaultInfo.loader)\n            virBufferAsprintf(buf, \"<loader>%s</loader>\\n\",\n                              guests[i]->arch.defaultInfo.loader);\n\n        for (j = 0; j < guests[i]->arch.defaultInfo.nmachines; j++) {\n            virCapsGuestMachinePtr machine = guests[i]->arch.defaultInfo.machines[j];\n            virBufferAddLit(buf, \"<machine\");\n            if (machine->canonical)\n                virBufferAsprintf(buf, \" canonical='%s'\", machine->canonical);\n            if (machine->maxCpus > 0)\n                virBufferAsprintf(buf, \" maxCpus='%d'\", machine->maxCpus);\n            virBufferAsprintf(buf, \">%s</machine>\\n\", machine->name);\n        }\n\n        for (j = 0; j < guests[i]->arch.ndomains; j++) {\n            virBufferAsprintf(buf, \"<domain type='%s'\",\n                virDomainVirtTypeToString(guests[i]->arch.domains[j]->type));\n            if (!guests[i]->arch.domains[j]->info.emulator &&\n                !guests[i]->arch.domains[j]->info.loader &&\n                !guests[i]->arch.domains[j]->info.nmachines) {\n                virBufferAddLit(buf, \"/>\\n\");\n                continue;\n            }\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            if (guests[i]->arch.domains[j]->info.emulator)\n                virBufferAsprintf(buf, \"<emulator>%s</emulator>\\n\",\n                                  guests[i]->arch.domains[j]->info.emulator);\n            if (guests[i]->arch.domains[j]->info.loader)\n                virBufferAsprintf(buf, \"<loader>%s</loader>\\n\",\n                                  guests[i]->arch.domains[j]->info.loader);\n\n            for (k = 0; k < guests[i]->arch.domains[j]->info.nmachines; k++) {\n                virCapsGuestMachinePtr machine = guests[i]->arch.domains[j]->info.machines[k];\n                virBufferAddLit(buf, \"<machine\");\n                if (machine->canonical)\n                    virBufferAsprintf(buf, \" canonical='%s'\", machine->canonical);\n                if (machine->maxCpus > 0)\n                    virBufferAsprintf(buf, \" maxCpus='%d'\", machine->maxCpus);\n                virBufferAsprintf(buf, \">%s</machine>\\n\", machine->name);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</domain>\\n\");\n        }\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</arch>\\n\");\n\n        virCapabilitiesFormatGuestFeatures(guests[i], buf);\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</guest>\\n\\n\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFormatHostXML",
          "args": [
            "&caps->host",
            "&buf"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFormatHostXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1069-1189",
          "snippet": "static int\nvirCapabilitiesFormatHostXML(virCapsHostPtr host,\n                             virBufferPtr buf)\n{\n    size_t i, j;\n    char host_uuid[VIR_UUID_STRING_BUFLEN];\n\n    /* The lack of some data means we have nothing\n     * minimally to format, so just return. */\n    if (!virUUIDIsValid(host->host_uuid) &&\n        !host->arch && !host->powerMgmt && !host->iommu)\n        return 0;\n\n    virBufferAddLit(buf, \"<host>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (virUUIDIsValid(host->host_uuid)) {\n        virUUIDFormat(host->host_uuid, host_uuid);\n        virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", host_uuid);\n    }\n    virBufferAddLit(buf, \"<cpu>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (host->arch)\n        virBufferAsprintf(buf, \"<arch>%s</arch>\\n\",\n                          virArchToString(host->arch));\n    if (host->nfeatures) {\n        virBufferAddLit(buf, \"<features>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < host->nfeatures; i++) {\n            virBufferAsprintf(buf, \"<%s/>\\n\",\n                              host->features[i]);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</features>\\n\");\n    }\n    virCPUDefFormatBuf(buf, host->cpu);\n\n    for (i = 0; i < host->nPagesSize; i++) {\n        virBufferAsprintf(buf, \"<pages unit='KiB' size='%u'/>\\n\",\n                          host->pagesSize[i]);\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</cpu>\\n\");\n\n    /* The PM query was successful. */\n    if (host->powerMgmt) {\n        /* The host supports some PM features. */\n        unsigned int pm = host->powerMgmt;\n        virBufferAddLit(buf, \"<power_management>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        while (pm) {\n            int bit = __builtin_ffs(pm) - 1;\n            virBufferAsprintf(buf, \"<%s/>\\n\",\n                              virCapsHostPMTargetTypeToString(bit));\n            pm &= ~(1U << bit);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</power_management>\\n\");\n    } else {\n        /* The host does not support any PM feature. */\n        virBufferAddLit(buf, \"<power_management/>\\n\");\n    }\n\n    virBufferAsprintf(buf, \"<iommu support='%s'/>\\n\",\n                      host->iommu  ? \"yes\" : \"no\");\n\n    if (host->offlineMigrate) {\n        virBufferAddLit(buf, \"<migration_features>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        if (host->liveMigrate)\n            virBufferAddLit(buf, \"<live/>\\n\");\n        if (host->nmigrateTrans) {\n            virBufferAddLit(buf, \"<uri_transports>\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (i = 0; i < host->nmigrateTrans; i++) {\n                virBufferAsprintf(buf, \"<uri_transport>%s</uri_transport>\\n\",\n                                  host->migrateTrans[i]);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</uri_transports>\\n\");\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</migration_features>\\n\");\n    }\n\n    if (host->netprefix)\n        virBufferAsprintf(buf, \"<netprefix>%s</netprefix>\\n\",\n                          host->netprefix);\n\n    if (host->numa &&\n        virCapabilitiesHostNUMAFormat(host->numa, buf) < 0)\n        return -1;\n\n    if (virCapabilitiesFormatCaches(buf, &host->cache) < 0)\n        return -1;\n\n    if (virCapabilitiesFormatMemoryBandwidth(buf, &host->memBW) < 0)\n        return -1;\n\n    for (i = 0; i < host->nsecModels; i++) {\n        virBufferAddLit(buf, \"<secmodel>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<model>%s</model>\\n\",\n                          host->secModels[i].model);\n        virBufferAsprintf(buf, \"<doi>%s</doi>\\n\",\n                          host->secModels[i].doi);\n        for (j = 0; j < host->secModels[i].nlabels; j++) {\n            virBufferAsprintf(buf, \"<baselabel type='%s'>%s</baselabel>\\n\",\n                              host->secModels[i].labels[j].type,\n                              host->secModels[i].labels[j].label);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</secmodel>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</host>\\n\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesFormatHostXML(virCapsHostPtr host,\n                             virBufferPtr buf)\n{\n    size_t i, j;\n    char host_uuid[VIR_UUID_STRING_BUFLEN];\n\n    /* The lack of some data means we have nothing\n     * minimally to format, so just return. */\n    if (!virUUIDIsValid(host->host_uuid) &&\n        !host->arch && !host->powerMgmt && !host->iommu)\n        return 0;\n\n    virBufferAddLit(buf, \"<host>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (virUUIDIsValid(host->host_uuid)) {\n        virUUIDFormat(host->host_uuid, host_uuid);\n        virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", host_uuid);\n    }\n    virBufferAddLit(buf, \"<cpu>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (host->arch)\n        virBufferAsprintf(buf, \"<arch>%s</arch>\\n\",\n                          virArchToString(host->arch));\n    if (host->nfeatures) {\n        virBufferAddLit(buf, \"<features>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < host->nfeatures; i++) {\n            virBufferAsprintf(buf, \"<%s/>\\n\",\n                              host->features[i]);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</features>\\n\");\n    }\n    virCPUDefFormatBuf(buf, host->cpu);\n\n    for (i = 0; i < host->nPagesSize; i++) {\n        virBufferAsprintf(buf, \"<pages unit='KiB' size='%u'/>\\n\",\n                          host->pagesSize[i]);\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</cpu>\\n\");\n\n    /* The PM query was successful. */\n    if (host->powerMgmt) {\n        /* The host supports some PM features. */\n        unsigned int pm = host->powerMgmt;\n        virBufferAddLit(buf, \"<power_management>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        while (pm) {\n            int bit = __builtin_ffs(pm) - 1;\n            virBufferAsprintf(buf, \"<%s/>\\n\",\n                              virCapsHostPMTargetTypeToString(bit));\n            pm &= ~(1U << bit);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</power_management>\\n\");\n    } else {\n        /* The host does not support any PM feature. */\n        virBufferAddLit(buf, \"<power_management/>\\n\");\n    }\n\n    virBufferAsprintf(buf, \"<iommu support='%s'/>\\n\",\n                      host->iommu  ? \"yes\" : \"no\");\n\n    if (host->offlineMigrate) {\n        virBufferAddLit(buf, \"<migration_features>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        if (host->liveMigrate)\n            virBufferAddLit(buf, \"<live/>\\n\");\n        if (host->nmigrateTrans) {\n            virBufferAddLit(buf, \"<uri_transports>\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (i = 0; i < host->nmigrateTrans; i++) {\n                virBufferAsprintf(buf, \"<uri_transport>%s</uri_transport>\\n\",\n                                  host->migrateTrans[i]);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</uri_transports>\\n\");\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</migration_features>\\n\");\n    }\n\n    if (host->netprefix)\n        virBufferAsprintf(buf, \"<netprefix>%s</netprefix>\\n\",\n                          host->netprefix);\n\n    if (host->numa &&\n        virCapabilitiesHostNUMAFormat(host->numa, buf) < 0)\n        return -1;\n\n    if (virCapabilitiesFormatCaches(buf, &host->cache) < 0)\n        return -1;\n\n    if (virCapabilitiesFormatMemoryBandwidth(buf, &host->memBW) < 0)\n        return -1;\n\n    for (i = 0; i < host->nsecModels; i++) {\n        virBufferAddLit(buf, \"<secmodel>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<model>%s</model>\\n\",\n                          host->secModels[i].model);\n        virBufferAsprintf(buf, \"<doi>%s</doi>\\n\",\n                          host->secModels[i].doi);\n        for (j = 0; j < host->secModels[i].nlabels; j++) {\n            virBufferAsprintf(buf, \"<baselabel type='%s'>%s</baselabel>\\n\",\n                              host->secModels[i].labels[j].type,\n                              host->secModels[i].labels[j].label);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</secmodel>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</host>\\n\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"<capabilities>\\n\\n\""
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirCapabilitiesFormatXML(virCapsPtr caps)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAddLit(&buf, \"<capabilities>\\n\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    if (virCapabilitiesFormatHostXML(&caps->host, &buf) < 0)\n        goto error;\n\n    virCapabilitiesFormatGuestXML(caps->guests, caps->nguests, &buf);\n\n    virCapabilitiesFormatStoragePoolXML(caps->pools, caps->npools, &buf);\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</capabilities>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
  },
  {
    "function_name": "virCapabilitiesFormatStoragePoolXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1301-1324",
    "snippet": "static void\nvirCapabilitiesFormatStoragePoolXML(virCapsStoragePoolPtr *pools,\n                                    size_t npools,\n                                    virBufferPtr buf)\n{\n    size_t i;\n\n    if (npools == 0)\n        return;\n\n    virBufferAddLit(buf, \"<pool>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferAddLit(buf, \"<enum name='type'>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < npools; i++)\n        virBufferAsprintf(buf, \"<value>%s</value>\\n\",\n                          virStoragePoolTypeToString(pools[i]->type));\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</enum>\\n\");\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</pool>\\n\\n\");\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</pool>\\n\\n\""
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</enum>\\n\""
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<value>%s</value>\\n\"",
            "virStoragePoolTypeToString(pools[i]->type)"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolTypeToString",
          "args": [
            "pools[i]->type"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<enum name='type'>\\n\""
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<pool>\\n\""
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesFormatStoragePoolXML(virCapsStoragePoolPtr *pools,\n                                    size_t npools,\n                                    virBufferPtr buf)\n{\n    size_t i;\n\n    if (npools == 0)\n        return;\n\n    virBufferAddLit(buf, \"<pool>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferAddLit(buf, \"<enum name='type'>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < npools; i++)\n        virBufferAsprintf(buf, \"<value>%s</value>\\n\",\n                          virStoragePoolTypeToString(pools[i]->type));\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</enum>\\n\");\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</pool>\\n\\n\");\n}"
  },
  {
    "function_name": "virCapabilitiesFormatGuestXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1224-1298",
    "snippet": "static void\nvirCapabilitiesFormatGuestXML(virCapsGuestPtr *guests,\n                              size_t nguests,\n                              virBufferPtr buf)\n{\n    size_t i, j, k;\n\n    for (i = 0; i < nguests; i++) {\n        virBufferAddLit(buf, \"<guest>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<os_type>%s</os_type>\\n\",\n                          virDomainOSTypeToString(guests[i]->ostype));\n        if (guests[i]->arch.id)\n            virBufferAsprintf(buf, \"<arch name='%s'>\\n\",\n                              virArchToString(guests[i]->arch.id));\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<wordsize>%d</wordsize>\\n\",\n                          guests[i]->arch.wordsize);\n        if (guests[i]->arch.defaultInfo.emulator)\n            virBufferAsprintf(buf, \"<emulator>%s</emulator>\\n\",\n                              guests[i]->arch.defaultInfo.emulator);\n        if (guests[i]->arch.defaultInfo.loader)\n            virBufferAsprintf(buf, \"<loader>%s</loader>\\n\",\n                              guests[i]->arch.defaultInfo.loader);\n\n        for (j = 0; j < guests[i]->arch.defaultInfo.nmachines; j++) {\n            virCapsGuestMachinePtr machine = guests[i]->arch.defaultInfo.machines[j];\n            virBufferAddLit(buf, \"<machine\");\n            if (machine->canonical)\n                virBufferAsprintf(buf, \" canonical='%s'\", machine->canonical);\n            if (machine->maxCpus > 0)\n                virBufferAsprintf(buf, \" maxCpus='%d'\", machine->maxCpus);\n            virBufferAsprintf(buf, \">%s</machine>\\n\", machine->name);\n        }\n\n        for (j = 0; j < guests[i]->arch.ndomains; j++) {\n            virBufferAsprintf(buf, \"<domain type='%s'\",\n                virDomainVirtTypeToString(guests[i]->arch.domains[j]->type));\n            if (!guests[i]->arch.domains[j]->info.emulator &&\n                !guests[i]->arch.domains[j]->info.loader &&\n                !guests[i]->arch.domains[j]->info.nmachines) {\n                virBufferAddLit(buf, \"/>\\n\");\n                continue;\n            }\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            if (guests[i]->arch.domains[j]->info.emulator)\n                virBufferAsprintf(buf, \"<emulator>%s</emulator>\\n\",\n                                  guests[i]->arch.domains[j]->info.emulator);\n            if (guests[i]->arch.domains[j]->info.loader)\n                virBufferAsprintf(buf, \"<loader>%s</loader>\\n\",\n                                  guests[i]->arch.domains[j]->info.loader);\n\n            for (k = 0; k < guests[i]->arch.domains[j]->info.nmachines; k++) {\n                virCapsGuestMachinePtr machine = guests[i]->arch.domains[j]->info.machines[k];\n                virBufferAddLit(buf, \"<machine\");\n                if (machine->canonical)\n                    virBufferAsprintf(buf, \" canonical='%s'\", machine->canonical);\n                if (machine->maxCpus > 0)\n                    virBufferAsprintf(buf, \" maxCpus='%d'\", machine->maxCpus);\n                virBufferAsprintf(buf, \">%s</machine>\\n\", machine->name);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</domain>\\n\");\n        }\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</arch>\\n\");\n\n        virCapabilitiesFormatGuestFeatures(guests[i], buf);\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</guest>\\n\\n\");\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</guest>\\n\\n\""
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFormatGuestFeatures",
          "args": [
            "guests[i]",
            "buf"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFormatGuestFeatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1192-1221",
          "snippet": "static void\nvirCapabilitiesFormatGuestFeatures(virCapsGuestPtr guest,\n                                   virBufferPtr buf)\n{\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n    size_t i;\n\n    for (i = 0; i < VIR_CAPS_GUEST_FEATURE_TYPE_LAST; i++) {\n        virCapsGuestFeaturePtr feature = guest->features + i;\n\n        if (!feature->present)\n            continue;\n\n        virBufferAsprintf(&childBuf, \"<%s\", virCapsGuestFeatureInfos[i].name);\n\n        if (feature->defaultOn) {\n            virBufferAsprintf(&childBuf, \" default='%s'\",\n                              virTristateSwitchTypeToString(feature->defaultOn));\n        }\n\n        if (feature->toggle) {\n            virBufferAsprintf(&childBuf, \" toggle='%s'\",\n                              virTristateBoolTypeToString(feature->toggle));\n        }\n\n        virBufferAddLit(&childBuf, \"/>\\n\");\n    }\n\n    virXMLFormatElement(buf, \"features\", NULL, &childBuf);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virCapsGuestFeatureInfo virCapsGuestFeatureInfos[VIR_CAPS_GUEST_FEATURE_TYPE_LAST] = {\n    [VIR_CAPS_GUEST_FEATURE_TYPE_PAE] = { \"pae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE] = { \"nonpae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_IA64_BE] = { \"ia64_be\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_ACPI] = { \"acpi\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_APIC] = { \"apic\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION] = { \"cpuselection\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT] = { \"deviceboot\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT] = { \"disksnapshot\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_HAP] = { \"hap\", true },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic const struct virCapsGuestFeatureInfo virCapsGuestFeatureInfos[VIR_CAPS_GUEST_FEATURE_TYPE_LAST] = {\n    [VIR_CAPS_GUEST_FEATURE_TYPE_PAE] = { \"pae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE] = { \"nonpae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_IA64_BE] = { \"ia64_be\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_ACPI] = { \"acpi\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_APIC] = { \"apic\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION] = { \"cpuselection\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT] = { \"deviceboot\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT] = { \"disksnapshot\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_HAP] = { \"hap\", true },\n};\n\nstatic void\nvirCapabilitiesFormatGuestFeatures(virCapsGuestPtr guest,\n                                   virBufferPtr buf)\n{\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n    size_t i;\n\n    for (i = 0; i < VIR_CAPS_GUEST_FEATURE_TYPE_LAST; i++) {\n        virCapsGuestFeaturePtr feature = guest->features + i;\n\n        if (!feature->present)\n            continue;\n\n        virBufferAsprintf(&childBuf, \"<%s\", virCapsGuestFeatureInfos[i].name);\n\n        if (feature->defaultOn) {\n            virBufferAsprintf(&childBuf, \" default='%s'\",\n                              virTristateSwitchTypeToString(feature->defaultOn));\n        }\n\n        if (feature->toggle) {\n            virBufferAsprintf(&childBuf, \" toggle='%s'\",\n                              virTristateBoolTypeToString(feature->toggle));\n        }\n\n        virBufferAddLit(&childBuf, \"/>\\n\");\n    }\n\n    virXMLFormatElement(buf, \"features\", NULL, &childBuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</arch>\\n\""
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</domain>\\n\""
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\">%s</machine>\\n\"",
            "machine->name"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<machine\""
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\">\\n\""
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainVirtTypeToString",
          "args": [
            "guests[i]->arch.domains[j]->type"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<machine\""
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "guests[i]->arch.id"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainOSTypeToString",
          "args": [
            "guests[i]->ostype"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<guest>\\n\""
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesFormatGuestXML(virCapsGuestPtr *guests,\n                              size_t nguests,\n                              virBufferPtr buf)\n{\n    size_t i, j, k;\n\n    for (i = 0; i < nguests; i++) {\n        virBufferAddLit(buf, \"<guest>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<os_type>%s</os_type>\\n\",\n                          virDomainOSTypeToString(guests[i]->ostype));\n        if (guests[i]->arch.id)\n            virBufferAsprintf(buf, \"<arch name='%s'>\\n\",\n                              virArchToString(guests[i]->arch.id));\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<wordsize>%d</wordsize>\\n\",\n                          guests[i]->arch.wordsize);\n        if (guests[i]->arch.defaultInfo.emulator)\n            virBufferAsprintf(buf, \"<emulator>%s</emulator>\\n\",\n                              guests[i]->arch.defaultInfo.emulator);\n        if (guests[i]->arch.defaultInfo.loader)\n            virBufferAsprintf(buf, \"<loader>%s</loader>\\n\",\n                              guests[i]->arch.defaultInfo.loader);\n\n        for (j = 0; j < guests[i]->arch.defaultInfo.nmachines; j++) {\n            virCapsGuestMachinePtr machine = guests[i]->arch.defaultInfo.machines[j];\n            virBufferAddLit(buf, \"<machine\");\n            if (machine->canonical)\n                virBufferAsprintf(buf, \" canonical='%s'\", machine->canonical);\n            if (machine->maxCpus > 0)\n                virBufferAsprintf(buf, \" maxCpus='%d'\", machine->maxCpus);\n            virBufferAsprintf(buf, \">%s</machine>\\n\", machine->name);\n        }\n\n        for (j = 0; j < guests[i]->arch.ndomains; j++) {\n            virBufferAsprintf(buf, \"<domain type='%s'\",\n                virDomainVirtTypeToString(guests[i]->arch.domains[j]->type));\n            if (!guests[i]->arch.domains[j]->info.emulator &&\n                !guests[i]->arch.domains[j]->info.loader &&\n                !guests[i]->arch.domains[j]->info.nmachines) {\n                virBufferAddLit(buf, \"/>\\n\");\n                continue;\n            }\n            virBufferAddLit(buf, \">\\n\");\n            virBufferAdjustIndent(buf, 2);\n            if (guests[i]->arch.domains[j]->info.emulator)\n                virBufferAsprintf(buf, \"<emulator>%s</emulator>\\n\",\n                                  guests[i]->arch.domains[j]->info.emulator);\n            if (guests[i]->arch.domains[j]->info.loader)\n                virBufferAsprintf(buf, \"<loader>%s</loader>\\n\",\n                                  guests[i]->arch.domains[j]->info.loader);\n\n            for (k = 0; k < guests[i]->arch.domains[j]->info.nmachines; k++) {\n                virCapsGuestMachinePtr machine = guests[i]->arch.domains[j]->info.machines[k];\n                virBufferAddLit(buf, \"<machine\");\n                if (machine->canonical)\n                    virBufferAsprintf(buf, \" canonical='%s'\", machine->canonical);\n                if (machine->maxCpus > 0)\n                    virBufferAsprintf(buf, \" maxCpus='%d'\", machine->maxCpus);\n                virBufferAsprintf(buf, \">%s</machine>\\n\", machine->name);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</domain>\\n\");\n        }\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</arch>\\n\");\n\n        virCapabilitiesFormatGuestFeatures(guests[i], buf);\n\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</guest>\\n\\n\");\n    }\n}"
  },
  {
    "function_name": "virCapabilitiesFormatGuestFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1192-1221",
    "snippet": "static void\nvirCapabilitiesFormatGuestFeatures(virCapsGuestPtr guest,\n                                   virBufferPtr buf)\n{\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n    size_t i;\n\n    for (i = 0; i < VIR_CAPS_GUEST_FEATURE_TYPE_LAST; i++) {\n        virCapsGuestFeaturePtr feature = guest->features + i;\n\n        if (!feature->present)\n            continue;\n\n        virBufferAsprintf(&childBuf, \"<%s\", virCapsGuestFeatureInfos[i].name);\n\n        if (feature->defaultOn) {\n            virBufferAsprintf(&childBuf, \" default='%s'\",\n                              virTristateSwitchTypeToString(feature->defaultOn));\n        }\n\n        if (feature->toggle) {\n            virBufferAsprintf(&childBuf, \" toggle='%s'\",\n                              virTristateBoolTypeToString(feature->toggle));\n        }\n\n        virBufferAddLit(&childBuf, \"/>\\n\");\n    }\n\n    virXMLFormatElement(buf, \"features\", NULL, &childBuf);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct virCapsGuestFeatureInfo virCapsGuestFeatureInfos[VIR_CAPS_GUEST_FEATURE_TYPE_LAST] = {\n    [VIR_CAPS_GUEST_FEATURE_TYPE_PAE] = { \"pae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE] = { \"nonpae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_IA64_BE] = { \"ia64_be\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_ACPI] = { \"acpi\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_APIC] = { \"apic\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION] = { \"cpuselection\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT] = { \"deviceboot\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT] = { \"disksnapshot\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_HAP] = { \"hap\", true },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXMLFormatElement",
          "args": [
            "buf",
            "\"features\"",
            "NULL",
            "&childBuf"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLFormatElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1374-1399",
          "snippet": "void\nvirXMLFormatElement(virBufferPtr buf,\n                    const char *name,\n                    virBufferPtr attrBuf,\n                    virBufferPtr childBuf)\n{\n    if ((!attrBuf || virBufferUse(attrBuf) == 0) &&\n        (!childBuf || virBufferUse(childBuf) == 0))\n        return;\n\n    virBufferAsprintf(buf, \"<%s\", name);\n\n    if (attrBuf && virBufferUse(attrBuf) > 0)\n        virBufferAddBuffer(buf, attrBuf);\n\n    if (childBuf && virBufferUse(childBuf) > 0) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAddBuffer(buf, childBuf);\n        virBufferAsprintf(buf, \"</%s>\\n\", name);\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferFreeAndReset(attrBuf);\n    virBufferFreeAndReset(childBuf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirXMLFormatElement(virBufferPtr buf,\n                    const char *name,\n                    virBufferPtr attrBuf,\n                    virBufferPtr childBuf)\n{\n    if ((!attrBuf || virBufferUse(attrBuf) == 0) &&\n        (!childBuf || virBufferUse(childBuf) == 0))\n        return;\n\n    virBufferAsprintf(buf, \"<%s\", name);\n\n    if (attrBuf && virBufferUse(attrBuf) > 0)\n        virBufferAddBuffer(buf, attrBuf);\n\n    if (childBuf && virBufferUse(childBuf) > 0) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAddBuffer(buf, childBuf);\n        virBufferAsprintf(buf, \"</%s>\\n\", name);\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferFreeAndReset(attrBuf);\n    virBufferFreeAndReset(childBuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&childBuf",
            "\"/>\\n\""
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&childBuf",
            "\" toggle='%s'\"",
            "virTristateBoolTypeToString(feature->toggle)"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeToString",
          "args": [
            "feature->toggle"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateSwitchTypeToString",
          "args": [
            "feature->defaultOn"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_BUFFER_INIT_CHILD",
          "args": [
            "buf"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic const struct virCapsGuestFeatureInfo virCapsGuestFeatureInfos[VIR_CAPS_GUEST_FEATURE_TYPE_LAST] = {\n    [VIR_CAPS_GUEST_FEATURE_TYPE_PAE] = { \"pae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE] = { \"nonpae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_IA64_BE] = { \"ia64_be\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_ACPI] = { \"acpi\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_APIC] = { \"apic\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION] = { \"cpuselection\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT] = { \"deviceboot\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT] = { \"disksnapshot\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_HAP] = { \"hap\", true },\n};\n\nstatic void\nvirCapabilitiesFormatGuestFeatures(virCapsGuestPtr guest,\n                                   virBufferPtr buf)\n{\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n    size_t i;\n\n    for (i = 0; i < VIR_CAPS_GUEST_FEATURE_TYPE_LAST; i++) {\n        virCapsGuestFeaturePtr feature = guest->features + i;\n\n        if (!feature->present)\n            continue;\n\n        virBufferAsprintf(&childBuf, \"<%s\", virCapsGuestFeatureInfos[i].name);\n\n        if (feature->defaultOn) {\n            virBufferAsprintf(&childBuf, \" default='%s'\",\n                              virTristateSwitchTypeToString(feature->defaultOn));\n        }\n\n        if (feature->toggle) {\n            virBufferAsprintf(&childBuf, \" toggle='%s'\",\n                              virTristateBoolTypeToString(feature->toggle));\n        }\n\n        virBufferAddLit(&childBuf, \"/>\\n\");\n    }\n\n    virXMLFormatElement(buf, \"features\", NULL, &childBuf);\n}"
  },
  {
    "function_name": "virCapabilitiesFormatHostXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1069-1189",
    "snippet": "static int\nvirCapabilitiesFormatHostXML(virCapsHostPtr host,\n                             virBufferPtr buf)\n{\n    size_t i, j;\n    char host_uuid[VIR_UUID_STRING_BUFLEN];\n\n    /* The lack of some data means we have nothing\n     * minimally to format, so just return. */\n    if (!virUUIDIsValid(host->host_uuid) &&\n        !host->arch && !host->powerMgmt && !host->iommu)\n        return 0;\n\n    virBufferAddLit(buf, \"<host>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (virUUIDIsValid(host->host_uuid)) {\n        virUUIDFormat(host->host_uuid, host_uuid);\n        virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", host_uuid);\n    }\n    virBufferAddLit(buf, \"<cpu>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (host->arch)\n        virBufferAsprintf(buf, \"<arch>%s</arch>\\n\",\n                          virArchToString(host->arch));\n    if (host->nfeatures) {\n        virBufferAddLit(buf, \"<features>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < host->nfeatures; i++) {\n            virBufferAsprintf(buf, \"<%s/>\\n\",\n                              host->features[i]);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</features>\\n\");\n    }\n    virCPUDefFormatBuf(buf, host->cpu);\n\n    for (i = 0; i < host->nPagesSize; i++) {\n        virBufferAsprintf(buf, \"<pages unit='KiB' size='%u'/>\\n\",\n                          host->pagesSize[i]);\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</cpu>\\n\");\n\n    /* The PM query was successful. */\n    if (host->powerMgmt) {\n        /* The host supports some PM features. */\n        unsigned int pm = host->powerMgmt;\n        virBufferAddLit(buf, \"<power_management>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        while (pm) {\n            int bit = __builtin_ffs(pm) - 1;\n            virBufferAsprintf(buf, \"<%s/>\\n\",\n                              virCapsHostPMTargetTypeToString(bit));\n            pm &= ~(1U << bit);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</power_management>\\n\");\n    } else {\n        /* The host does not support any PM feature. */\n        virBufferAddLit(buf, \"<power_management/>\\n\");\n    }\n\n    virBufferAsprintf(buf, \"<iommu support='%s'/>\\n\",\n                      host->iommu  ? \"yes\" : \"no\");\n\n    if (host->offlineMigrate) {\n        virBufferAddLit(buf, \"<migration_features>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        if (host->liveMigrate)\n            virBufferAddLit(buf, \"<live/>\\n\");\n        if (host->nmigrateTrans) {\n            virBufferAddLit(buf, \"<uri_transports>\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (i = 0; i < host->nmigrateTrans; i++) {\n                virBufferAsprintf(buf, \"<uri_transport>%s</uri_transport>\\n\",\n                                  host->migrateTrans[i]);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</uri_transports>\\n\");\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</migration_features>\\n\");\n    }\n\n    if (host->netprefix)\n        virBufferAsprintf(buf, \"<netprefix>%s</netprefix>\\n\",\n                          host->netprefix);\n\n    if (host->numa &&\n        virCapabilitiesHostNUMAFormat(host->numa, buf) < 0)\n        return -1;\n\n    if (virCapabilitiesFormatCaches(buf, &host->cache) < 0)\n        return -1;\n\n    if (virCapabilitiesFormatMemoryBandwidth(buf, &host->memBW) < 0)\n        return -1;\n\n    for (i = 0; i < host->nsecModels; i++) {\n        virBufferAddLit(buf, \"<secmodel>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<model>%s</model>\\n\",\n                          host->secModels[i].model);\n        virBufferAsprintf(buf, \"<doi>%s</doi>\\n\",\n                          host->secModels[i].doi);\n        for (j = 0; j < host->secModels[i].nlabels; j++) {\n            virBufferAsprintf(buf, \"<baselabel type='%s'>%s</baselabel>\\n\",\n                              host->secModels[i].labels[j].type,\n                              host->secModels[i].labels[j].label);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</secmodel>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</host>\\n\\n\");\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</host>\\n\\n\""
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</secmodel>\\n\""
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<baselabel type='%s'>%s</baselabel>\\n\"",
            "host->secModels[i].labels[j].type",
            "host->secModels[i].labels[j].label"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<secmodel>\\n\""
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFormatMemoryBandwidth",
          "args": [
            "buf",
            "&host->memBW"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFormatMemoryBandwidth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1024-1066",
          "snippet": "static int\nvirCapabilitiesFormatMemoryBandwidth(virBufferPtr buf,\n                                     virCapsHostMemBWPtr memBW)\n{\n    size_t i = 0;\n\n    if (!memBW->nnodes && !memBW->monitor)\n        return 0;\n\n    virBufferAddLit(buf, \"<memory_bandwidth>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < memBW->nnodes; i++) {\n        g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n        g_auto(virBuffer) childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n        virCapsHostMemBWNodePtr node = memBW->nodes[i];\n        virResctrlInfoMemBWPerNodePtr control = &node->control;\n        g_autofree char *cpus_str = virBitmapFormat(node->cpus);\n\n        if (!cpus_str)\n            return -1;\n\n        virBufferAsprintf(&attrBuf,\n                          \" id='%u' cpus='%s'\",\n                          node->id, cpus_str);\n\n        virBufferAsprintf(&childrenBuf,\n                          \"<control granularity='%u' min ='%u' \"\n                          \"maxAllocs='%u'/>\\n\",\n                          control->granularity, control->min,\n                          control->max_allocation);\n\n        virXMLFormatElement(buf, \"node\", &attrBuf, &childrenBuf);\n    }\n\n    if (virCapabilitiesFormatResctrlMonitor(buf, memBW->monitor) < 0)\n        return -1;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</memory_bandwidth>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesFormatMemoryBandwidth(virBufferPtr buf,\n                                     virCapsHostMemBWPtr memBW)\n{\n    size_t i = 0;\n\n    if (!memBW->nnodes && !memBW->monitor)\n        return 0;\n\n    virBufferAddLit(buf, \"<memory_bandwidth>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < memBW->nnodes; i++) {\n        g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n        g_auto(virBuffer) childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n        virCapsHostMemBWNodePtr node = memBW->nodes[i];\n        virResctrlInfoMemBWPerNodePtr control = &node->control;\n        g_autofree char *cpus_str = virBitmapFormat(node->cpus);\n\n        if (!cpus_str)\n            return -1;\n\n        virBufferAsprintf(&attrBuf,\n                          \" id='%u' cpus='%s'\",\n                          node->id, cpus_str);\n\n        virBufferAsprintf(&childrenBuf,\n                          \"<control granularity='%u' min ='%u' \"\n                          \"maxAllocs='%u'/>\\n\",\n                          control->granularity, control->min,\n                          control->max_allocation);\n\n        virXMLFormatElement(buf, \"node\", &attrBuf, &childrenBuf);\n    }\n\n    if (virCapabilitiesFormatResctrlMonitor(buf, memBW->monitor) < 0)\n        return -1;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</memory_bandwidth>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFormatCaches",
          "args": [
            "buf",
            "&host->cache"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFormatCaches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "938-1022",
          "snippet": "static int\nvirCapabilitiesFormatCaches(virBufferPtr buf,\n                            virCapsHostCachePtr cache)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!cache->nbanks && !cache->monitor)\n        return 0;\n\n    virBufferAddLit(buf, \"<cache>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < cache->nbanks; i++) {\n        g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n        g_auto(virBuffer) childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n        virCapsHostCacheBankPtr bank = cache->banks[i];\n        g_autofree char *cpus_str = virBitmapFormat(bank->cpus);\n        const char *unit = NULL;\n        unsigned long long short_size = virFormatIntPretty(bank->size, &unit);\n\n        if (!cpus_str)\n            return -1;\n\n        /*\n         * Let's just *hope* the size is aligned to KiBs so that it does not\n         * bite is back in the future\n         */\n        virBufferAsprintf(&attrBuf,\n                          \" id='%u' level='%u' type='%s' \"\n                          \"size='%llu' unit='%s' cpus='%s'\",\n                          bank->id, bank->level,\n                          virCacheTypeToString(bank->type),\n                          short_size, unit, cpus_str);\n\n        for (j = 0; j < bank->ncontrols; j++) {\n            const char *min_unit;\n            virResctrlInfoPerCachePtr controls = bank->controls[j];\n            unsigned long long gran_short_size = controls->granularity;\n            unsigned long long min_short_size = controls->min;\n\n            gran_short_size = virFormatIntPretty(gran_short_size, &unit);\n            min_short_size = virFormatIntPretty(min_short_size, &min_unit);\n\n            /* Only use the smaller unit if they are different */\n            if (min_short_size) {\n                unsigned long long gran_div;\n                unsigned long long min_div;\n\n                gran_div = controls->granularity / gran_short_size;\n                min_div = controls->min / min_short_size;\n\n                if (min_div > gran_div) {\n                    min_short_size *= min_div / gran_div;\n                } else if (min_div < gran_div) {\n                    unit = min_unit;\n                    gran_short_size *= gran_div / min_div;\n                }\n            }\n\n            virBufferAsprintf(&childrenBuf,\n                              \"<control granularity='%llu'\",\n                              gran_short_size);\n\n            if (min_short_size)\n                virBufferAsprintf(&childrenBuf, \" min='%llu'\", min_short_size);\n\n            virBufferAsprintf(&childrenBuf,\n                              \" unit='%s' type='%s' maxAllocs='%u'/>\\n\",\n                              unit,\n                              virCacheTypeToString(controls->scope),\n                              controls->max_allocation);\n        }\n\n        virXMLFormatElement(buf, \"bank\", &attrBuf, &childrenBuf);\n    }\n\n    if (virCapabilitiesFormatResctrlMonitor(buf, cache->monitor) < 0)\n        return -1;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</cache>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesFormatCaches(virBufferPtr buf,\n                            virCapsHostCachePtr cache)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!cache->nbanks && !cache->monitor)\n        return 0;\n\n    virBufferAddLit(buf, \"<cache>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < cache->nbanks; i++) {\n        g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n        g_auto(virBuffer) childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n        virCapsHostCacheBankPtr bank = cache->banks[i];\n        g_autofree char *cpus_str = virBitmapFormat(bank->cpus);\n        const char *unit = NULL;\n        unsigned long long short_size = virFormatIntPretty(bank->size, &unit);\n\n        if (!cpus_str)\n            return -1;\n\n        /*\n         * Let's just *hope* the size is aligned to KiBs so that it does not\n         * bite is back in the future\n         */\n        virBufferAsprintf(&attrBuf,\n                          \" id='%u' level='%u' type='%s' \"\n                          \"size='%llu' unit='%s' cpus='%s'\",\n                          bank->id, bank->level,\n                          virCacheTypeToString(bank->type),\n                          short_size, unit, cpus_str);\n\n        for (j = 0; j < bank->ncontrols; j++) {\n            const char *min_unit;\n            virResctrlInfoPerCachePtr controls = bank->controls[j];\n            unsigned long long gran_short_size = controls->granularity;\n            unsigned long long min_short_size = controls->min;\n\n            gran_short_size = virFormatIntPretty(gran_short_size, &unit);\n            min_short_size = virFormatIntPretty(min_short_size, &min_unit);\n\n            /* Only use the smaller unit if they are different */\n            if (min_short_size) {\n                unsigned long long gran_div;\n                unsigned long long min_div;\n\n                gran_div = controls->granularity / gran_short_size;\n                min_div = controls->min / min_short_size;\n\n                if (min_div > gran_div) {\n                    min_short_size *= min_div / gran_div;\n                } else if (min_div < gran_div) {\n                    unit = min_unit;\n                    gran_short_size *= gran_div / min_div;\n                }\n            }\n\n            virBufferAsprintf(&childrenBuf,\n                              \"<control granularity='%llu'\",\n                              gran_short_size);\n\n            if (min_short_size)\n                virBufferAsprintf(&childrenBuf, \" min='%llu'\", min_short_size);\n\n            virBufferAsprintf(&childrenBuf,\n                              \" unit='%s' type='%s' maxAllocs='%u'/>\\n\",\n                              unit,\n                              virCacheTypeToString(controls->scope),\n                              controls->max_allocation);\n        }\n\n        virXMLFormatElement(buf, \"bank\", &attrBuf, &childrenBuf);\n    }\n\n    if (virCapabilitiesFormatResctrlMonitor(buf, cache->monitor) < 0)\n        return -1;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</cache>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMAFormat",
          "args": [
            "host->numa",
            "buf"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMAFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "827-896",
          "snippet": "static int\nvirCapabilitiesHostNUMAFormat(virCapsHostNUMAPtr caps,\n                              virBufferPtr buf)\n{\n    size_t i;\n    size_t j;\n    char *siblings;\n\n    virBufferAddLit(buf, \"<topology>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferAsprintf(buf, \"<cells num='%d'>\\n\", caps->cells->len);\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < caps->cells->len; i++) {\n        virCapsHostNUMACellPtr cell = g_ptr_array_index(caps->cells, i);\n        virBufferAsprintf(buf, \"<cell id='%d'>\\n\", cell->num);\n        virBufferAdjustIndent(buf, 2);\n\n        /* Print out the numacell memory total if it is available */\n        if (cell->mem)\n            virBufferAsprintf(buf, \"<memory unit='KiB'>%llu</memory>\\n\",\n                              cell->mem);\n\n        for (j = 0; j < cell->npageinfo; j++) {\n            virBufferAsprintf(buf, \"<pages unit='KiB' size='%u'>%llu</pages>\\n\",\n                              cell->pageinfo[j].size,\n                              cell->pageinfo[j].avail);\n        }\n\n        if (cell->nsiblings) {\n            virBufferAddLit(buf, \"<distances>\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (j = 0; j < cell->nsiblings; j++) {\n                virBufferAsprintf(buf, \"<sibling id='%d' value='%d'/>\\n\",\n                                  cell->siblings[j].node,\n                                  cell->siblings[j].distance);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</distances>\\n\");\n        }\n\n        virBufferAsprintf(buf, \"<cpus num='%d'>\\n\", cell->ncpus);\n        virBufferAdjustIndent(buf, 2);\n        for (j = 0; j < cell->ncpus; j++) {\n            virBufferAsprintf(buf, \"<cpu id='%d'\", cell->cpus[j].id);\n\n            if (cell->cpus[j].siblings) {\n                if (!(siblings = virBitmapFormat(cell->cpus[j].siblings)))\n                    return -1;\n\n                virBufferAsprintf(buf,\n                                  \" socket_id='%d' die_id='%d' core_id='%d' siblings='%s'\",\n                                  cell->cpus[j].socket_id,\n                                  cell->cpus[j].die_id,\n                                  cell->cpus[j].core_id,\n                                  siblings);\n                VIR_FREE(siblings);\n            }\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</cpus>\\n\");\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</cell>\\n\");\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</cells>\\n\");\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</topology>\\n\");\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesHostNUMAFormat(virCapsHostNUMAPtr caps,\n                              virBufferPtr buf)\n{\n    size_t i;\n    size_t j;\n    char *siblings;\n\n    virBufferAddLit(buf, \"<topology>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferAsprintf(buf, \"<cells num='%d'>\\n\", caps->cells->len);\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < caps->cells->len; i++) {\n        virCapsHostNUMACellPtr cell = g_ptr_array_index(caps->cells, i);\n        virBufferAsprintf(buf, \"<cell id='%d'>\\n\", cell->num);\n        virBufferAdjustIndent(buf, 2);\n\n        /* Print out the numacell memory total if it is available */\n        if (cell->mem)\n            virBufferAsprintf(buf, \"<memory unit='KiB'>%llu</memory>\\n\",\n                              cell->mem);\n\n        for (j = 0; j < cell->npageinfo; j++) {\n            virBufferAsprintf(buf, \"<pages unit='KiB' size='%u'>%llu</pages>\\n\",\n                              cell->pageinfo[j].size,\n                              cell->pageinfo[j].avail);\n        }\n\n        if (cell->nsiblings) {\n            virBufferAddLit(buf, \"<distances>\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (j = 0; j < cell->nsiblings; j++) {\n                virBufferAsprintf(buf, \"<sibling id='%d' value='%d'/>\\n\",\n                                  cell->siblings[j].node,\n                                  cell->siblings[j].distance);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</distances>\\n\");\n        }\n\n        virBufferAsprintf(buf, \"<cpus num='%d'>\\n\", cell->ncpus);\n        virBufferAdjustIndent(buf, 2);\n        for (j = 0; j < cell->ncpus; j++) {\n            virBufferAsprintf(buf, \"<cpu id='%d'\", cell->cpus[j].id);\n\n            if (cell->cpus[j].siblings) {\n                if (!(siblings = virBitmapFormat(cell->cpus[j].siblings)))\n                    return -1;\n\n                virBufferAsprintf(buf,\n                                  \" socket_id='%d' die_id='%d' core_id='%d' siblings='%s'\",\n                                  cell->cpus[j].socket_id,\n                                  cell->cpus[j].die_id,\n                                  cell->cpus[j].core_id,\n                                  siblings);\n                VIR_FREE(siblings);\n            }\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</cpus>\\n\");\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</cell>\\n\");\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</cells>\\n\");\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</topology>\\n\");\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</migration_features>\\n\""
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</uri_transports>\\n\""
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<uri_transports>\\n\""
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<live/>\\n\""
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<migration_features>\\n\""
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<power_management/>\\n\""
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</power_management>\\n\""
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapsHostPMTargetTypeToString",
          "args": [
            "bit"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_ffs",
          "args": [
            "pm"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<power_management>\\n\""
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</cpu>\\n\""
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefFormatBuf",
          "args": [
            "buf",
            "host->cpu"
          ],
          "line": 1104
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFormatBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "775-882",
          "snippet": "int\nvirCPUDefFormatBuf(virBufferPtr buf,\n                   virCPUDefPtr def)\n{\n    size_t i;\n    bool formatModel;\n\n    if (!def)\n        return 0;\n\n    formatModel = (def->mode == VIR_CPU_MODE_CUSTOM ||\n                   def->mode == VIR_CPU_MODE_HOST_MODEL);\n\n    if (!def->model && def->mode == VIR_CPU_MODE_CUSTOM && def->nfeatures) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Non-empty feature list specified without CPU model\"));\n        return -1;\n    }\n\n    if (formatModel && (def->model || def->vendor_id)) {\n        virBufferAddLit(buf, \"<model\");\n\n        if (def->type == VIR_CPU_TYPE_GUEST && def->model) {\n            const char *fallback;\n\n            fallback = virCPUFallbackTypeToString(def->fallback);\n            if (!fallback) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU fallback value: %d\"),\n                               def->fallback);\n                return -1;\n            }\n            virBufferAsprintf(buf, \" fallback='%s'\", fallback);\n        }\n\n        if (def->type == VIR_CPU_TYPE_GUEST)\n            virBufferEscapeString(buf, \" vendor_id='%s'\", def->vendor_id);\n\n        if (def->model)\n            virBufferEscapeString(buf, \">%s</model>\\n\", def->model);\n        else\n            virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (formatModel && def->vendor)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\", def->vendor);\n\n    if (def->type == VIR_CPU_TYPE_HOST && def->microcodeVersion)\n        virBufferAsprintf(buf, \"<microcode version='%u'/>\\n\",\n                          def->microcodeVersion);\n\n    if (def->type == VIR_CPU_TYPE_HOST && def->tsc) {\n        virBufferAddLit(buf, \"<counter name='tsc'\");\n        virBufferAsprintf(buf, \" frequency='%llu'\", def->tsc->frequency);\n        if (def->tsc->scaling) {\n            virBufferAsprintf(buf, \" scaling='%s'\",\n                              virTristateBoolTypeToString(def->tsc->scaling));\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->sockets && def->dies && def->cores && def->threads) {\n        virBufferAddLit(buf, \"<topology\");\n        virBufferAsprintf(buf, \" sockets='%u'\", def->sockets);\n        virBufferAsprintf(buf, \" dies='%u'\", def->dies);\n        virBufferAsprintf(buf, \" cores='%u'\", def->cores);\n        virBufferAsprintf(buf, \" threads='%u'\", def->threads);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->cache) {\n        virBufferAddLit(buf, \"<cache \");\n        if (def->cache->level != -1)\n            virBufferAsprintf(buf, \"level='%d' \", def->cache->level);\n        virBufferAsprintf(buf, \"mode='%s'\",\n                          virCPUCacheModeTypeToString(def->cache->mode));\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    for (i = 0; i < def->nfeatures; i++) {\n        virCPUFeatureDefPtr feature = def->features + i;\n\n        if (!feature->name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing CPU feature name\"));\n            return -1;\n        }\n\n        if (def->type == VIR_CPU_TYPE_GUEST) {\n            const char *policy;\n\n            policy = virCPUFeaturePolicyTypeToString(feature->policy);\n            if (!policy) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU feature policy %d\"),\n                               feature->policy);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<feature policy='%s' name='%s'/>\\n\",\n                              policy, feature->name);\n        } else {\n            virBufferAsprintf(buf, \"<feature name='%s'/>\\n\",\n                              feature->name);\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefFormatBuf(virBufferPtr buf,\n                   virCPUDefPtr def)\n{\n    size_t i;\n    bool formatModel;\n\n    if (!def)\n        return 0;\n\n    formatModel = (def->mode == VIR_CPU_MODE_CUSTOM ||\n                   def->mode == VIR_CPU_MODE_HOST_MODEL);\n\n    if (!def->model && def->mode == VIR_CPU_MODE_CUSTOM && def->nfeatures) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Non-empty feature list specified without CPU model\"));\n        return -1;\n    }\n\n    if (formatModel && (def->model || def->vendor_id)) {\n        virBufferAddLit(buf, \"<model\");\n\n        if (def->type == VIR_CPU_TYPE_GUEST && def->model) {\n            const char *fallback;\n\n            fallback = virCPUFallbackTypeToString(def->fallback);\n            if (!fallback) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU fallback value: %d\"),\n                               def->fallback);\n                return -1;\n            }\n            virBufferAsprintf(buf, \" fallback='%s'\", fallback);\n        }\n\n        if (def->type == VIR_CPU_TYPE_GUEST)\n            virBufferEscapeString(buf, \" vendor_id='%s'\", def->vendor_id);\n\n        if (def->model)\n            virBufferEscapeString(buf, \">%s</model>\\n\", def->model);\n        else\n            virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (formatModel && def->vendor)\n        virBufferEscapeString(buf, \"<vendor>%s</vendor>\\n\", def->vendor);\n\n    if (def->type == VIR_CPU_TYPE_HOST && def->microcodeVersion)\n        virBufferAsprintf(buf, \"<microcode version='%u'/>\\n\",\n                          def->microcodeVersion);\n\n    if (def->type == VIR_CPU_TYPE_HOST && def->tsc) {\n        virBufferAddLit(buf, \"<counter name='tsc'\");\n        virBufferAsprintf(buf, \" frequency='%llu'\", def->tsc->frequency);\n        if (def->tsc->scaling) {\n            virBufferAsprintf(buf, \" scaling='%s'\",\n                              virTristateBoolTypeToString(def->tsc->scaling));\n        }\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->sockets && def->dies && def->cores && def->threads) {\n        virBufferAddLit(buf, \"<topology\");\n        virBufferAsprintf(buf, \" sockets='%u'\", def->sockets);\n        virBufferAsprintf(buf, \" dies='%u'\", def->dies);\n        virBufferAsprintf(buf, \" cores='%u'\", def->cores);\n        virBufferAsprintf(buf, \" threads='%u'\", def->threads);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->cache) {\n        virBufferAddLit(buf, \"<cache \");\n        if (def->cache->level != -1)\n            virBufferAsprintf(buf, \"level='%d' \", def->cache->level);\n        virBufferAsprintf(buf, \"mode='%s'\",\n                          virCPUCacheModeTypeToString(def->cache->mode));\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    for (i = 0; i < def->nfeatures; i++) {\n        virCPUFeatureDefPtr feature = def->features + i;\n\n        if (!feature->name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing CPU feature name\"));\n            return -1;\n        }\n\n        if (def->type == VIR_CPU_TYPE_GUEST) {\n            const char *policy;\n\n            policy = virCPUFeaturePolicyTypeToString(feature->policy);\n            if (!policy) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unexpected CPU feature policy %d\"),\n                               feature->policy);\n                return -1;\n            }\n            virBufferAsprintf(buf, \"<feature policy='%s' name='%s'/>\\n\",\n                              policy, feature->name);\n        } else {\n            virBufferAsprintf(buf, \"<feature name='%s'/>\\n\",\n                              feature->name);\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</features>\\n\""
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<features>\\n\""
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "host->arch"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<cpu>\\n\""
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "host->host_uuid",
            "host_uuid"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDIsValid",
          "args": [
            "host->host_uuid"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDIsValid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "173-190",
          "snippet": "int\nvirUUIDIsValid(unsigned char *uuid)\n{\n    size_t i;\n    unsigned int ctr = 1;\n    unsigned char c;\n\n    if (!uuid)\n        return 0;\n\n    c = uuid[0];\n\n    for (i = 1; i < VIR_UUID_BUFLEN; i++)\n        if (uuid[i] == c)\n            ctr++;\n\n    return ctr != VIR_UUID_BUFLEN;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDIsValid(unsigned char *uuid)\n{\n    size_t i;\n    unsigned int ctr = 1;\n    unsigned char c;\n\n    if (!uuid)\n        return 0;\n\n    c = uuid[0];\n\n    for (i = 1; i < VIR_UUID_BUFLEN; i++)\n        if (uuid[i] == c)\n            ctr++;\n\n    return ctr != VIR_UUID_BUFLEN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<host>\\n\""
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesFormatHostXML(virCapsHostPtr host,\n                             virBufferPtr buf)\n{\n    size_t i, j;\n    char host_uuid[VIR_UUID_STRING_BUFLEN];\n\n    /* The lack of some data means we have nothing\n     * minimally to format, so just return. */\n    if (!virUUIDIsValid(host->host_uuid) &&\n        !host->arch && !host->powerMgmt && !host->iommu)\n        return 0;\n\n    virBufferAddLit(buf, \"<host>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    if (virUUIDIsValid(host->host_uuid)) {\n        virUUIDFormat(host->host_uuid, host_uuid);\n        virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", host_uuid);\n    }\n    virBufferAddLit(buf, \"<cpu>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (host->arch)\n        virBufferAsprintf(buf, \"<arch>%s</arch>\\n\",\n                          virArchToString(host->arch));\n    if (host->nfeatures) {\n        virBufferAddLit(buf, \"<features>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < host->nfeatures; i++) {\n            virBufferAsprintf(buf, \"<%s/>\\n\",\n                              host->features[i]);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</features>\\n\");\n    }\n    virCPUDefFormatBuf(buf, host->cpu);\n\n    for (i = 0; i < host->nPagesSize; i++) {\n        virBufferAsprintf(buf, \"<pages unit='KiB' size='%u'/>\\n\",\n                          host->pagesSize[i]);\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</cpu>\\n\");\n\n    /* The PM query was successful. */\n    if (host->powerMgmt) {\n        /* The host supports some PM features. */\n        unsigned int pm = host->powerMgmt;\n        virBufferAddLit(buf, \"<power_management>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        while (pm) {\n            int bit = __builtin_ffs(pm) - 1;\n            virBufferAsprintf(buf, \"<%s/>\\n\",\n                              virCapsHostPMTargetTypeToString(bit));\n            pm &= ~(1U << bit);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</power_management>\\n\");\n    } else {\n        /* The host does not support any PM feature. */\n        virBufferAddLit(buf, \"<power_management/>\\n\");\n    }\n\n    virBufferAsprintf(buf, \"<iommu support='%s'/>\\n\",\n                      host->iommu  ? \"yes\" : \"no\");\n\n    if (host->offlineMigrate) {\n        virBufferAddLit(buf, \"<migration_features>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        if (host->liveMigrate)\n            virBufferAddLit(buf, \"<live/>\\n\");\n        if (host->nmigrateTrans) {\n            virBufferAddLit(buf, \"<uri_transports>\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (i = 0; i < host->nmigrateTrans; i++) {\n                virBufferAsprintf(buf, \"<uri_transport>%s</uri_transport>\\n\",\n                                  host->migrateTrans[i]);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</uri_transports>\\n\");\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</migration_features>\\n\");\n    }\n\n    if (host->netprefix)\n        virBufferAsprintf(buf, \"<netprefix>%s</netprefix>\\n\",\n                          host->netprefix);\n\n    if (host->numa &&\n        virCapabilitiesHostNUMAFormat(host->numa, buf) < 0)\n        return -1;\n\n    if (virCapabilitiesFormatCaches(buf, &host->cache) < 0)\n        return -1;\n\n    if (virCapabilitiesFormatMemoryBandwidth(buf, &host->memBW) < 0)\n        return -1;\n\n    for (i = 0; i < host->nsecModels; i++) {\n        virBufferAddLit(buf, \"<secmodel>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<model>%s</model>\\n\",\n                          host->secModels[i].model);\n        virBufferAsprintf(buf, \"<doi>%s</doi>\\n\",\n                          host->secModels[i].doi);\n        for (j = 0; j < host->secModels[i].nlabels; j++) {\n            virBufferAsprintf(buf, \"<baselabel type='%s'>%s</baselabel>\\n\",\n                              host->secModels[i].labels[j].type,\n                              host->secModels[i].labels[j].label);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</secmodel>\\n\");\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</host>\\n\\n\");\n\n    return 0;\n}"
  },
  {
    "function_name": "virCapabilitiesFormatMemoryBandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "1024-1066",
    "snippet": "static int\nvirCapabilitiesFormatMemoryBandwidth(virBufferPtr buf,\n                                     virCapsHostMemBWPtr memBW)\n{\n    size_t i = 0;\n\n    if (!memBW->nnodes && !memBW->monitor)\n        return 0;\n\n    virBufferAddLit(buf, \"<memory_bandwidth>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < memBW->nnodes; i++) {\n        g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n        g_auto(virBuffer) childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n        virCapsHostMemBWNodePtr node = memBW->nodes[i];\n        virResctrlInfoMemBWPerNodePtr control = &node->control;\n        g_autofree char *cpus_str = virBitmapFormat(node->cpus);\n\n        if (!cpus_str)\n            return -1;\n\n        virBufferAsprintf(&attrBuf,\n                          \" id='%u' cpus='%s'\",\n                          node->id, cpus_str);\n\n        virBufferAsprintf(&childrenBuf,\n                          \"<control granularity='%u' min ='%u' \"\n                          \"maxAllocs='%u'/>\\n\",\n                          control->granularity, control->min,\n                          control->max_allocation);\n\n        virXMLFormatElement(buf, \"node\", &attrBuf, &childrenBuf);\n    }\n\n    if (virCapabilitiesFormatResctrlMonitor(buf, memBW->monitor) < 0)\n        return -1;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</memory_bandwidth>\\n\");\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</memory_bandwidth>\\n\""
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFormatResctrlMonitor",
          "args": [
            "buf",
            "memBW->monitor"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFormatResctrlMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "899-936",
          "snippet": "static int\nvirCapabilitiesFormatResctrlMonitor(virBufferPtr buf,\n                                    virResctrlInfoMonPtr monitor)\n{\n    size_t i = 0;\n    virBuffer childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    /* monitor not supported, no capability */\n    if (!monitor)\n        return 0;\n\n    /* no feature found in monitor means no capability, return */\n    if (monitor->nfeatures == 0)\n        return 0;\n\n    virBufferAddLit(buf, \"<monitor \");\n\n    /* CMT might not enabled, if enabled show related attributes. */\n    if (monitor->type == VIR_RESCTRL_MONITOR_TYPE_CACHE)\n        virBufferAsprintf(buf,\n                          \"level='%u' reuseThreshold='%u' \",\n                          monitor->cache_level,\n                          monitor->cache_reuse_threshold);\n    virBufferAsprintf(buf,\n                      \"maxMonitors='%u'>\\n\",\n                      monitor->max_monitor);\n\n    for (i = 0; i < monitor->nfeatures; i++) {\n        virBufferAsprintf(&childrenBuf,\n                          \"<feature name='%s'/>\\n\",\n                          monitor->features[i]);\n    }\n\n    virBufferAddBuffer(buf, &childrenBuf);\n    virBufferAddLit(buf, \"</monitor>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesFormatResctrlMonitor(virBufferPtr buf,\n                                    virResctrlInfoMonPtr monitor)\n{\n    size_t i = 0;\n    virBuffer childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    /* monitor not supported, no capability */\n    if (!monitor)\n        return 0;\n\n    /* no feature found in monitor means no capability, return */\n    if (monitor->nfeatures == 0)\n        return 0;\n\n    virBufferAddLit(buf, \"<monitor \");\n\n    /* CMT might not enabled, if enabled show related attributes. */\n    if (monitor->type == VIR_RESCTRL_MONITOR_TYPE_CACHE)\n        virBufferAsprintf(buf,\n                          \"level='%u' reuseThreshold='%u' \",\n                          monitor->cache_level,\n                          monitor->cache_reuse_threshold);\n    virBufferAsprintf(buf,\n                      \"maxMonitors='%u'>\\n\",\n                      monitor->max_monitor);\n\n    for (i = 0; i < monitor->nfeatures; i++) {\n        virBufferAsprintf(&childrenBuf,\n                          \"<feature name='%s'/>\\n\",\n                          monitor->features[i]);\n    }\n\n    virBufferAddBuffer(buf, &childrenBuf);\n    virBufferAddLit(buf, \"</monitor>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLFormatElement",
          "args": [
            "buf",
            "\"node\"",
            "&attrBuf",
            "&childrenBuf"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLFormatElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1374-1399",
          "snippet": "void\nvirXMLFormatElement(virBufferPtr buf,\n                    const char *name,\n                    virBufferPtr attrBuf,\n                    virBufferPtr childBuf)\n{\n    if ((!attrBuf || virBufferUse(attrBuf) == 0) &&\n        (!childBuf || virBufferUse(childBuf) == 0))\n        return;\n\n    virBufferAsprintf(buf, \"<%s\", name);\n\n    if (attrBuf && virBufferUse(attrBuf) > 0)\n        virBufferAddBuffer(buf, attrBuf);\n\n    if (childBuf && virBufferUse(childBuf) > 0) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAddBuffer(buf, childBuf);\n        virBufferAsprintf(buf, \"</%s>\\n\", name);\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferFreeAndReset(attrBuf);\n    virBufferFreeAndReset(childBuf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirXMLFormatElement(virBufferPtr buf,\n                    const char *name,\n                    virBufferPtr attrBuf,\n                    virBufferPtr childBuf)\n{\n    if ((!attrBuf || virBufferUse(attrBuf) == 0) &&\n        (!childBuf || virBufferUse(childBuf) == 0))\n        return;\n\n    virBufferAsprintf(buf, \"<%s\", name);\n\n    if (attrBuf && virBufferUse(attrBuf) > 0)\n        virBufferAddBuffer(buf, attrBuf);\n\n    if (childBuf && virBufferUse(childBuf) > 0) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAddBuffer(buf, childBuf);\n        virBufferAsprintf(buf, \"</%s>\\n\", name);\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferFreeAndReset(attrBuf);\n    virBufferFreeAndReset(childBuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&childrenBuf",
            "\"<control granularity='%u' min ='%u' \"\n                          \"maxAllocs='%u'/>\\n\"",
            "control->granularity",
            "control->min",
            "control->max_allocation"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapFormat",
          "args": [
            "node->cpus"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "404-442",
          "snippet": "char *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_BUFFER_INIT_CHILD",
          "args": [
            "buf"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<memory_bandwidth>\\n\""
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesFormatMemoryBandwidth(virBufferPtr buf,\n                                     virCapsHostMemBWPtr memBW)\n{\n    size_t i = 0;\n\n    if (!memBW->nnodes && !memBW->monitor)\n        return 0;\n\n    virBufferAddLit(buf, \"<memory_bandwidth>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < memBW->nnodes; i++) {\n        g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n        g_auto(virBuffer) childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n        virCapsHostMemBWNodePtr node = memBW->nodes[i];\n        virResctrlInfoMemBWPerNodePtr control = &node->control;\n        g_autofree char *cpus_str = virBitmapFormat(node->cpus);\n\n        if (!cpus_str)\n            return -1;\n\n        virBufferAsprintf(&attrBuf,\n                          \" id='%u' cpus='%s'\",\n                          node->id, cpus_str);\n\n        virBufferAsprintf(&childrenBuf,\n                          \"<control granularity='%u' min ='%u' \"\n                          \"maxAllocs='%u'/>\\n\",\n                          control->granularity, control->min,\n                          control->max_allocation);\n\n        virXMLFormatElement(buf, \"node\", &attrBuf, &childrenBuf);\n    }\n\n    if (virCapabilitiesFormatResctrlMonitor(buf, memBW->monitor) < 0)\n        return -1;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</memory_bandwidth>\\n\");\n\n    return 0;\n}"
  },
  {
    "function_name": "virCapabilitiesFormatCaches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "938-1022",
    "snippet": "static int\nvirCapabilitiesFormatCaches(virBufferPtr buf,\n                            virCapsHostCachePtr cache)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!cache->nbanks && !cache->monitor)\n        return 0;\n\n    virBufferAddLit(buf, \"<cache>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < cache->nbanks; i++) {\n        g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n        g_auto(virBuffer) childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n        virCapsHostCacheBankPtr bank = cache->banks[i];\n        g_autofree char *cpus_str = virBitmapFormat(bank->cpus);\n        const char *unit = NULL;\n        unsigned long long short_size = virFormatIntPretty(bank->size, &unit);\n\n        if (!cpus_str)\n            return -1;\n\n        /*\n         * Let's just *hope* the size is aligned to KiBs so that it does not\n         * bite is back in the future\n         */\n        virBufferAsprintf(&attrBuf,\n                          \" id='%u' level='%u' type='%s' \"\n                          \"size='%llu' unit='%s' cpus='%s'\",\n                          bank->id, bank->level,\n                          virCacheTypeToString(bank->type),\n                          short_size, unit, cpus_str);\n\n        for (j = 0; j < bank->ncontrols; j++) {\n            const char *min_unit;\n            virResctrlInfoPerCachePtr controls = bank->controls[j];\n            unsigned long long gran_short_size = controls->granularity;\n            unsigned long long min_short_size = controls->min;\n\n            gran_short_size = virFormatIntPretty(gran_short_size, &unit);\n            min_short_size = virFormatIntPretty(min_short_size, &min_unit);\n\n            /* Only use the smaller unit if they are different */\n            if (min_short_size) {\n                unsigned long long gran_div;\n                unsigned long long min_div;\n\n                gran_div = controls->granularity / gran_short_size;\n                min_div = controls->min / min_short_size;\n\n                if (min_div > gran_div) {\n                    min_short_size *= min_div / gran_div;\n                } else if (min_div < gran_div) {\n                    unit = min_unit;\n                    gran_short_size *= gran_div / min_div;\n                }\n            }\n\n            virBufferAsprintf(&childrenBuf,\n                              \"<control granularity='%llu'\",\n                              gran_short_size);\n\n            if (min_short_size)\n                virBufferAsprintf(&childrenBuf, \" min='%llu'\", min_short_size);\n\n            virBufferAsprintf(&childrenBuf,\n                              \" unit='%s' type='%s' maxAllocs='%u'/>\\n\",\n                              unit,\n                              virCacheTypeToString(controls->scope),\n                              controls->max_allocation);\n        }\n\n        virXMLFormatElement(buf, \"bank\", &attrBuf, &childrenBuf);\n    }\n\n    if (virCapabilitiesFormatResctrlMonitor(buf, cache->monitor) < 0)\n        return -1;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</cache>\\n\");\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</cache>\\n\""
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFormatResctrlMonitor",
          "args": [
            "buf",
            "cache->monitor"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFormatResctrlMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "899-936",
          "snippet": "static int\nvirCapabilitiesFormatResctrlMonitor(virBufferPtr buf,\n                                    virResctrlInfoMonPtr monitor)\n{\n    size_t i = 0;\n    virBuffer childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    /* monitor not supported, no capability */\n    if (!monitor)\n        return 0;\n\n    /* no feature found in monitor means no capability, return */\n    if (monitor->nfeatures == 0)\n        return 0;\n\n    virBufferAddLit(buf, \"<monitor \");\n\n    /* CMT might not enabled, if enabled show related attributes. */\n    if (monitor->type == VIR_RESCTRL_MONITOR_TYPE_CACHE)\n        virBufferAsprintf(buf,\n                          \"level='%u' reuseThreshold='%u' \",\n                          monitor->cache_level,\n                          monitor->cache_reuse_threshold);\n    virBufferAsprintf(buf,\n                      \"maxMonitors='%u'>\\n\",\n                      monitor->max_monitor);\n\n    for (i = 0; i < monitor->nfeatures; i++) {\n        virBufferAsprintf(&childrenBuf,\n                          \"<feature name='%s'/>\\n\",\n                          monitor->features[i]);\n    }\n\n    virBufferAddBuffer(buf, &childrenBuf);\n    virBufferAddLit(buf, \"</monitor>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesFormatResctrlMonitor(virBufferPtr buf,\n                                    virResctrlInfoMonPtr monitor)\n{\n    size_t i = 0;\n    virBuffer childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    /* monitor not supported, no capability */\n    if (!monitor)\n        return 0;\n\n    /* no feature found in monitor means no capability, return */\n    if (monitor->nfeatures == 0)\n        return 0;\n\n    virBufferAddLit(buf, \"<monitor \");\n\n    /* CMT might not enabled, if enabled show related attributes. */\n    if (monitor->type == VIR_RESCTRL_MONITOR_TYPE_CACHE)\n        virBufferAsprintf(buf,\n                          \"level='%u' reuseThreshold='%u' \",\n                          monitor->cache_level,\n                          monitor->cache_reuse_threshold);\n    virBufferAsprintf(buf,\n                      \"maxMonitors='%u'>\\n\",\n                      monitor->max_monitor);\n\n    for (i = 0; i < monitor->nfeatures; i++) {\n        virBufferAsprintf(&childrenBuf,\n                          \"<feature name='%s'/>\\n\",\n                          monitor->features[i]);\n    }\n\n    virBufferAddBuffer(buf, &childrenBuf);\n    virBufferAddLit(buf, \"</monitor>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLFormatElement",
          "args": [
            "buf",
            "\"bank\"",
            "&attrBuf",
            "&childrenBuf"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLFormatElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1374-1399",
          "snippet": "void\nvirXMLFormatElement(virBufferPtr buf,\n                    const char *name,\n                    virBufferPtr attrBuf,\n                    virBufferPtr childBuf)\n{\n    if ((!attrBuf || virBufferUse(attrBuf) == 0) &&\n        (!childBuf || virBufferUse(childBuf) == 0))\n        return;\n\n    virBufferAsprintf(buf, \"<%s\", name);\n\n    if (attrBuf && virBufferUse(attrBuf) > 0)\n        virBufferAddBuffer(buf, attrBuf);\n\n    if (childBuf && virBufferUse(childBuf) > 0) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAddBuffer(buf, childBuf);\n        virBufferAsprintf(buf, \"</%s>\\n\", name);\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferFreeAndReset(attrBuf);\n    virBufferFreeAndReset(childBuf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirXMLFormatElement(virBufferPtr buf,\n                    const char *name,\n                    virBufferPtr attrBuf,\n                    virBufferPtr childBuf)\n{\n    if ((!attrBuf || virBufferUse(attrBuf) == 0) &&\n        (!childBuf || virBufferUse(childBuf) == 0))\n        return;\n\n    virBufferAsprintf(buf, \"<%s\", name);\n\n    if (attrBuf && virBufferUse(attrBuf) > 0)\n        virBufferAddBuffer(buf, attrBuf);\n\n    if (childBuf && virBufferUse(childBuf) > 0) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAddBuffer(buf, childBuf);\n        virBufferAsprintf(buf, \"</%s>\\n\", name);\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferFreeAndReset(attrBuf);\n    virBufferFreeAndReset(childBuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&childrenBuf",
            "\" unit='%s' type='%s' maxAllocs='%u'/>\\n\"",
            "unit",
            "virCacheTypeToString(controls->scope)",
            "controls->max_allocation"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCacheTypeToString",
          "args": [
            "controls->scope"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFormatIntPretty",
          "args": [
            "min_short_size",
            "&min_unit"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "virFormatIntPretty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "327-360",
          "snippet": "unsigned long long\nvirFormatIntPretty(unsigned long long val,\n                   const char **unit)\n{\n    unsigned long long limit = 1024;\n\n    if (val % limit || val == 0) {\n        *unit = \"B\";\n        return val;\n    }\n    limit *= 1024;\n    if (val % limit) {\n        *unit = \"KiB\";\n        return val / (limit / 1024);\n    }\n    limit *= 1024;\n    if (val % limit) {\n        *unit = \"MiB\";\n        return val / (limit / 1024);\n    }\n    limit *= 1024;\n    if (val % limit) {\n        *unit = \"GiB\";\n        return val / (limit / 1024);\n    }\n    limit *= 1024;\n    if (val % limit) {\n        *unit = \"TiB\";\n        return val / (limit / 1024);\n    }\n    limit *= 1024;\n    *unit = \"PiB\";\n    return val / (limit / 1024);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nunsigned long long\nvirFormatIntPretty(unsigned long long val,\n                   const char **unit)\n{\n    unsigned long long limit = 1024;\n\n    if (val % limit || val == 0) {\n        *unit = \"B\";\n        return val;\n    }\n    limit *= 1024;\n    if (val % limit) {\n        *unit = \"KiB\";\n        return val / (limit / 1024);\n    }\n    limit *= 1024;\n    if (val % limit) {\n        *unit = \"MiB\";\n        return val / (limit / 1024);\n    }\n    limit *= 1024;\n    if (val % limit) {\n        *unit = \"GiB\";\n        return val / (limit / 1024);\n    }\n    limit *= 1024;\n    if (val % limit) {\n        *unit = \"TiB\";\n        return val / (limit / 1024);\n    }\n    limit *= 1024;\n    *unit = \"PiB\";\n    return val / (limit / 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCacheTypeToString",
          "args": [
            "bank->type"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFormat",
          "args": [
            "bank->cpus"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "404-442",
          "snippet": "char *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_BUFFER_INIT_CHILD",
          "args": [
            "buf"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<cache>\\n\""
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesFormatCaches(virBufferPtr buf,\n                            virCapsHostCachePtr cache)\n{\n    size_t i = 0;\n    size_t j = 0;\n\n    if (!cache->nbanks && !cache->monitor)\n        return 0;\n\n    virBufferAddLit(buf, \"<cache>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    for (i = 0; i < cache->nbanks; i++) {\n        g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n        g_auto(virBuffer) childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n        virCapsHostCacheBankPtr bank = cache->banks[i];\n        g_autofree char *cpus_str = virBitmapFormat(bank->cpus);\n        const char *unit = NULL;\n        unsigned long long short_size = virFormatIntPretty(bank->size, &unit);\n\n        if (!cpus_str)\n            return -1;\n\n        /*\n         * Let's just *hope* the size is aligned to KiBs so that it does not\n         * bite is back in the future\n         */\n        virBufferAsprintf(&attrBuf,\n                          \" id='%u' level='%u' type='%s' \"\n                          \"size='%llu' unit='%s' cpus='%s'\",\n                          bank->id, bank->level,\n                          virCacheTypeToString(bank->type),\n                          short_size, unit, cpus_str);\n\n        for (j = 0; j < bank->ncontrols; j++) {\n            const char *min_unit;\n            virResctrlInfoPerCachePtr controls = bank->controls[j];\n            unsigned long long gran_short_size = controls->granularity;\n            unsigned long long min_short_size = controls->min;\n\n            gran_short_size = virFormatIntPretty(gran_short_size, &unit);\n            min_short_size = virFormatIntPretty(min_short_size, &min_unit);\n\n            /* Only use the smaller unit if they are different */\n            if (min_short_size) {\n                unsigned long long gran_div;\n                unsigned long long min_div;\n\n                gran_div = controls->granularity / gran_short_size;\n                min_div = controls->min / min_short_size;\n\n                if (min_div > gran_div) {\n                    min_short_size *= min_div / gran_div;\n                } else if (min_div < gran_div) {\n                    unit = min_unit;\n                    gran_short_size *= gran_div / min_div;\n                }\n            }\n\n            virBufferAsprintf(&childrenBuf,\n                              \"<control granularity='%llu'\",\n                              gran_short_size);\n\n            if (min_short_size)\n                virBufferAsprintf(&childrenBuf, \" min='%llu'\", min_short_size);\n\n            virBufferAsprintf(&childrenBuf,\n                              \" unit='%s' type='%s' maxAllocs='%u'/>\\n\",\n                              unit,\n                              virCacheTypeToString(controls->scope),\n                              controls->max_allocation);\n        }\n\n        virXMLFormatElement(buf, \"bank\", &attrBuf, &childrenBuf);\n    }\n\n    if (virCapabilitiesFormatResctrlMonitor(buf, cache->monitor) < 0)\n        return -1;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</cache>\\n\");\n\n    return 0;\n}"
  },
  {
    "function_name": "virCapabilitiesFormatResctrlMonitor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "899-936",
    "snippet": "static int\nvirCapabilitiesFormatResctrlMonitor(virBufferPtr buf,\n                                    virResctrlInfoMonPtr monitor)\n{\n    size_t i = 0;\n    virBuffer childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    /* monitor not supported, no capability */\n    if (!monitor)\n        return 0;\n\n    /* no feature found in monitor means no capability, return */\n    if (monitor->nfeatures == 0)\n        return 0;\n\n    virBufferAddLit(buf, \"<monitor \");\n\n    /* CMT might not enabled, if enabled show related attributes. */\n    if (monitor->type == VIR_RESCTRL_MONITOR_TYPE_CACHE)\n        virBufferAsprintf(buf,\n                          \"level='%u' reuseThreshold='%u' \",\n                          monitor->cache_level,\n                          monitor->cache_reuse_threshold);\n    virBufferAsprintf(buf,\n                      \"maxMonitors='%u'>\\n\",\n                      monitor->max_monitor);\n\n    for (i = 0; i < monitor->nfeatures; i++) {\n        virBufferAsprintf(&childrenBuf,\n                          \"<feature name='%s'/>\\n\",\n                          monitor->features[i]);\n    }\n\n    virBufferAddBuffer(buf, &childrenBuf);\n    virBufferAddLit(buf, \"</monitor>\\n\");\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</monitor>\\n\""
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddBuffer",
          "args": [
            "buf",
            "&childrenBuf"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "182-196",
          "snippet": "void\nvirBufferAddBuffer(virBufferPtr buf, virBufferPtr toadd)\n{\n    if (!toadd || !toadd->str)\n        return;\n\n    if (!buf)\n        goto cleanup;\n\n    virBufferInitialize(buf);\n    g_string_append_len(buf->str, toadd->str->str, toadd->str->len);\n\n cleanup:\n    virBufferFreeAndReset(toadd);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddBuffer(virBufferPtr buf, virBufferPtr toadd)\n{\n    if (!toadd || !toadd->str)\n        return;\n\n    if (!buf)\n        goto cleanup;\n\n    virBufferInitialize(buf);\n    g_string_append_len(buf->str, toadd->str->str, toadd->str->len);\n\n cleanup:\n    virBufferFreeAndReset(toadd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&childrenBuf",
            "\"<feature name='%s'/>\\n\"",
            "monitor->features[i]"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<monitor \""
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_BUFFER_INIT_CHILD",
          "args": [
            "buf"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesFormatResctrlMonitor(virBufferPtr buf,\n                                    virResctrlInfoMonPtr monitor)\n{\n    size_t i = 0;\n    virBuffer childrenBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    /* monitor not supported, no capability */\n    if (!monitor)\n        return 0;\n\n    /* no feature found in monitor means no capability, return */\n    if (monitor->nfeatures == 0)\n        return 0;\n\n    virBufferAddLit(buf, \"<monitor \");\n\n    /* CMT might not enabled, if enabled show related attributes. */\n    if (monitor->type == VIR_RESCTRL_MONITOR_TYPE_CACHE)\n        virBufferAsprintf(buf,\n                          \"level='%u' reuseThreshold='%u' \",\n                          monitor->cache_level,\n                          monitor->cache_reuse_threshold);\n    virBufferAsprintf(buf,\n                      \"maxMonitors='%u'>\\n\",\n                      monitor->max_monitor);\n\n    for (i = 0; i < monitor->nfeatures; i++) {\n        virBufferAsprintf(&childrenBuf,\n                          \"<feature name='%s'/>\\n\",\n                          monitor->features[i]);\n    }\n\n    virBufferAddBuffer(buf, &childrenBuf);\n    virBufferAddLit(buf, \"</monitor>\\n\");\n\n    return 0;\n}"
  },
  {
    "function_name": "virCapabilitiesHostNUMAFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "827-896",
    "snippet": "static int\nvirCapabilitiesHostNUMAFormat(virCapsHostNUMAPtr caps,\n                              virBufferPtr buf)\n{\n    size_t i;\n    size_t j;\n    char *siblings;\n\n    virBufferAddLit(buf, \"<topology>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferAsprintf(buf, \"<cells num='%d'>\\n\", caps->cells->len);\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < caps->cells->len; i++) {\n        virCapsHostNUMACellPtr cell = g_ptr_array_index(caps->cells, i);\n        virBufferAsprintf(buf, \"<cell id='%d'>\\n\", cell->num);\n        virBufferAdjustIndent(buf, 2);\n\n        /* Print out the numacell memory total if it is available */\n        if (cell->mem)\n            virBufferAsprintf(buf, \"<memory unit='KiB'>%llu</memory>\\n\",\n                              cell->mem);\n\n        for (j = 0; j < cell->npageinfo; j++) {\n            virBufferAsprintf(buf, \"<pages unit='KiB' size='%u'>%llu</pages>\\n\",\n                              cell->pageinfo[j].size,\n                              cell->pageinfo[j].avail);\n        }\n\n        if (cell->nsiblings) {\n            virBufferAddLit(buf, \"<distances>\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (j = 0; j < cell->nsiblings; j++) {\n                virBufferAsprintf(buf, \"<sibling id='%d' value='%d'/>\\n\",\n                                  cell->siblings[j].node,\n                                  cell->siblings[j].distance);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</distances>\\n\");\n        }\n\n        virBufferAsprintf(buf, \"<cpus num='%d'>\\n\", cell->ncpus);\n        virBufferAdjustIndent(buf, 2);\n        for (j = 0; j < cell->ncpus; j++) {\n            virBufferAsprintf(buf, \"<cpu id='%d'\", cell->cpus[j].id);\n\n            if (cell->cpus[j].siblings) {\n                if (!(siblings = virBitmapFormat(cell->cpus[j].siblings)))\n                    return -1;\n\n                virBufferAsprintf(buf,\n                                  \" socket_id='%d' die_id='%d' core_id='%d' siblings='%s'\",\n                                  cell->cpus[j].socket_id,\n                                  cell->cpus[j].die_id,\n                                  cell->cpus[j].core_id,\n                                  siblings);\n                VIR_FREE(siblings);\n            }\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</cpus>\\n\");\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</cell>\\n\");\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</cells>\\n\");\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</topology>\\n\");\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</topology>\\n\""
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</cells>\\n\""
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</cell>\\n\""
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</cpus>\\n\""
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "siblings"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" socket_id='%d' die_id='%d' core_id='%d' siblings='%s'\"",
            "cell->cpus[j].socket_id",
            "cell->cpus[j].die_id",
            "cell->cpus[j].core_id",
            "siblings"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapFormat",
          "args": [
            "cell->cpus[j].siblings"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "404-442",
          "snippet": "char *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirBitmapFormat(virBitmapPtr bitmap)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool first = true;\n    int start, cur, prev;\n\n    if (!bitmap || (cur = virBitmapNextSetBit(bitmap, -1)) < 0) {\n        char *ret;\n        ret = g_strdup(\"\");\n        return ret;\n    }\n\n    start = prev = cur;\n    while (prev >= 0) {\n        cur = virBitmapNextSetBit(bitmap, prev);\n\n        if (cur == prev + 1) {\n            prev = cur;\n            continue;\n        }\n\n        /* cur < 0 or cur > prev + 1 */\n\n        if (!first)\n            virBufferAddLit(&buf, \",\");\n        else\n            first = false;\n\n        if (prev == start)\n            virBufferAsprintf(&buf, \"%d\", start);\n        else\n            virBufferAsprintf(&buf, \"%d-%d\", start, prev);\n\n        start = prev = cur;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</distances>\\n\""
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<distances>\\n\""
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ptr_array_index",
          "args": [
            "caps->cells",
            "i"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<topology>\\n\""
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvirCapabilitiesHostNUMAFormat(virCapsHostNUMAPtr caps,\n                              virBufferPtr buf)\n{\n    size_t i;\n    size_t j;\n    char *siblings;\n\n    virBufferAddLit(buf, \"<topology>\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferAsprintf(buf, \"<cells num='%d'>\\n\", caps->cells->len);\n    virBufferAdjustIndent(buf, 2);\n    for (i = 0; i < caps->cells->len; i++) {\n        virCapsHostNUMACellPtr cell = g_ptr_array_index(caps->cells, i);\n        virBufferAsprintf(buf, \"<cell id='%d'>\\n\", cell->num);\n        virBufferAdjustIndent(buf, 2);\n\n        /* Print out the numacell memory total if it is available */\n        if (cell->mem)\n            virBufferAsprintf(buf, \"<memory unit='KiB'>%llu</memory>\\n\",\n                              cell->mem);\n\n        for (j = 0; j < cell->npageinfo; j++) {\n            virBufferAsprintf(buf, \"<pages unit='KiB' size='%u'>%llu</pages>\\n\",\n                              cell->pageinfo[j].size,\n                              cell->pageinfo[j].avail);\n        }\n\n        if (cell->nsiblings) {\n            virBufferAddLit(buf, \"<distances>\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (j = 0; j < cell->nsiblings; j++) {\n                virBufferAsprintf(buf, \"<sibling id='%d' value='%d'/>\\n\",\n                                  cell->siblings[j].node,\n                                  cell->siblings[j].distance);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</distances>\\n\");\n        }\n\n        virBufferAsprintf(buf, \"<cpus num='%d'>\\n\", cell->ncpus);\n        virBufferAdjustIndent(buf, 2);\n        for (j = 0; j < cell->ncpus; j++) {\n            virBufferAsprintf(buf, \"<cpu id='%d'\", cell->cpus[j].id);\n\n            if (cell->cpus[j].siblings) {\n                if (!(siblings = virBitmapFormat(cell->cpus[j].siblings)))\n                    return -1;\n\n                virBufferAsprintf(buf,\n                                  \" socket_id='%d' die_id='%d' core_id='%d' siblings='%s'\",\n                                  cell->cpus[j].socket_id,\n                                  cell->cpus[j].die_id,\n                                  cell->cpus[j].core_id,\n                                  siblings);\n                VIR_FREE(siblings);\n            }\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</cpus>\\n\");\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</cell>\\n\");\n    }\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</cells>\\n\");\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</topology>\\n\");\n    return 0;\n}"
  },
  {
    "function_name": "virCapabilitiesAddStoragePool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "804-824",
    "snippet": "int\nvirCapabilitiesAddStoragePool(virCapsPtr caps,\n                              int poolType)\n{\n    virCapsStoragePoolPtr pool;\n\n    if (VIR_ALLOC(pool) < 0)\n        goto error;\n\n    pool->type = poolType;\n\n    if (VIR_RESIZE_N(caps->pools, caps->npools_max, caps->npools, 1) < 0)\n        goto error;\n    caps->pools[caps->npools++] = pool;\n\n    return 0;\n\n error:\n    virCapabilitiesFreeStoragePool(pool);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapabilitiesFreeStoragePool",
          "args": [
            "pool"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFreeStoragePool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "174-181",
          "snippet": "static void\nvirCapabilitiesFreeStoragePool(virCapsStoragePoolPtr pool)\n{\n    if (!pool)\n        return;\n\n    VIR_FREE(pool);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesFreeStoragePool(virCapsStoragePoolPtr pool)\n{\n    if (!pool)\n        return;\n\n    VIR_FREE(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "caps->pools",
            "caps->npools_max",
            "caps->npools",
            "1"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "pool"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirCapabilitiesAddStoragePool(virCapsPtr caps,\n                              int poolType)\n{\n    virCapsStoragePoolPtr pool;\n\n    if (VIR_ALLOC(pool) < 0)\n        goto error;\n\n    pool->type = poolType;\n\n    if (VIR_RESIZE_N(caps->pools, caps->npools_max, caps->npools, 1) < 0)\n        goto error;\n    caps->pools[caps->npools++] = pool;\n\n    return 0;\n\n error:\n    virCapabilitiesFreeStoragePool(pool);\n    return -1;\n}"
  },
  {
    "function_name": "virCapabilitiesDomainSupported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "787-801",
    "snippet": "bool\nvirCapabilitiesDomainSupported(virCapsPtr caps,\n                               int ostype,\n                               virArch arch,\n                               int virttype)\n{\n    g_autofree virCapsDomainDataPtr capsdata = NULL;\n\n    capsdata = virCapabilitiesDomainDataLookup(caps, ostype,\n                                               arch,\n                                               virttype,\n                                               NULL, NULL);\n\n    return capsdata != NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapabilitiesDomainDataLookup",
          "args": [
            "caps",
            "ostype",
            "arch",
            "virttype",
            "NULL",
            "NULL"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesDomainDataLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "761-784",
          "snippet": "virCapsDomainDataPtr\nvirCapabilitiesDomainDataLookup(virCapsPtr caps,\n                                int ostype,\n                                virArch arch,\n                                int domaintype,\n                                const char *emulator,\n                                const char *machinetype)\n{\n    virCapsDomainDataPtr ret;\n\n    if (arch == VIR_ARCH_NONE) {\n        /* Prefer host arch if its available */\n        ret = virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                      caps->host.arch,\n                                                      domaintype,\n                                                      emulator, machinetype);\n        if (ret)\n            return ret;\n    }\n\n    return virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                   arch, domaintype,\n                                                   emulator, machinetype);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsDomainDataPtr\nvirCapabilitiesDomainDataLookup(virCapsPtr caps,\n                                int ostype,\n                                virArch arch,\n                                int domaintype,\n                                const char *emulator,\n                                const char *machinetype)\n{\n    virCapsDomainDataPtr ret;\n\n    if (arch == VIR_ARCH_NONE) {\n        /* Prefer host arch if its available */\n        ret = virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                      caps->host.arch,\n                                                      domaintype,\n                                                      emulator, machinetype);\n        if (ret)\n            return ret;\n    }\n\n    return virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                   arch, domaintype,\n                                                   emulator, machinetype);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirCapabilitiesDomainSupported(virCapsPtr caps,\n                               int ostype,\n                               virArch arch,\n                               int virttype)\n{\n    g_autofree virCapsDomainDataPtr capsdata = NULL;\n\n    capsdata = virCapabilitiesDomainDataLookup(caps, ostype,\n                                               arch,\n                                               virttype,\n                                               NULL, NULL);\n\n    return capsdata != NULL;\n}"
  },
  {
    "function_name": "virCapabilitiesDomainDataLookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "761-784",
    "snippet": "virCapsDomainDataPtr\nvirCapabilitiesDomainDataLookup(virCapsPtr caps,\n                                int ostype,\n                                virArch arch,\n                                int domaintype,\n                                const char *emulator,\n                                const char *machinetype)\n{\n    virCapsDomainDataPtr ret;\n\n    if (arch == VIR_ARCH_NONE) {\n        /* Prefer host arch if its available */\n        ret = virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                      caps->host.arch,\n                                                      domaintype,\n                                                      emulator, machinetype);\n        if (ret)\n            return ret;\n    }\n\n    return virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                   arch, domaintype,\n                                                   emulator, machinetype);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapabilitiesDomainDataLookupInternal",
          "args": [
            "caps",
            "ostype",
            "arch",
            "domaintype",
            "emulator",
            "machinetype"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesDomainDataLookupInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "614-747",
          "snippet": "static virCapsDomainDataPtr\nvirCapabilitiesDomainDataLookupInternal(virCapsPtr caps,\n                                        int ostype,\n                                        virArch arch,\n                                        virDomainVirtType domaintype,\n                                        const char *emulator,\n                                        const char *machinetype)\n{\n    virCapsGuestPtr foundguest = NULL;\n    virCapsGuestDomainPtr founddomain = NULL;\n    virCapsGuestMachinePtr foundmachine = NULL;\n    virCapsDomainDataPtr ret = NULL;\n    size_t i, j, k;\n\n    VIR_DEBUG(\"Lookup ostype=%d arch=%d domaintype=%d emulator=%s machine=%s\",\n              ostype, arch, domaintype, NULLSTR(emulator), NULLSTR(machinetype));\n    for (i = 0; i < caps->nguests; i++) {\n        virCapsGuestPtr guest = caps->guests[i];\n\n        if (ostype != -1 && guest->ostype != ostype) {\n            VIR_DEBUG(\"Skip os type want=%d vs got=%d\", ostype, guest->ostype);\n            continue;\n        }\n        VIR_DEBUG(\"Match os type %d\", ostype);\n\n        if ((arch != VIR_ARCH_NONE) && (guest->arch.id != arch)) {\n            VIR_DEBUG(\"Skip arch want=%d vs got=%d\", arch, guest->arch.id);\n            continue;\n        }\n        VIR_DEBUG(\"Match arch %d\", arch);\n\n        for (j = 0; j < guest->arch.ndomains; j++) {\n            virCapsGuestDomainPtr domain = guest->arch.domains[j];\n            virCapsGuestMachinePtr *machinelist;\n            int nmachines;\n            const char *check_emulator = NULL;\n\n            if (domaintype != VIR_DOMAIN_VIRT_NONE &&\n                (domain->type != domaintype)) {\n                VIR_DEBUG(\"Skip domain type want=%d vs got=%d\", domaintype, domain->type);\n                continue;\n            }\n            VIR_DEBUG(\"Match domain type %d\", domaintype);\n\n            check_emulator = domain->info.emulator;\n            if (!check_emulator)\n                check_emulator = guest->arch.defaultInfo.emulator;\n            if (emulator && STRNEQ_NULLABLE(check_emulator, emulator)) {\n                VIR_DEBUG(\"Skip emulator got=%s vs want=%s\",\n                          emulator, NULLSTR(check_emulator));\n                continue;\n            }\n            VIR_DEBUG(\"Match emulator %s\", NULLSTR(emulator));\n\n            if (domain->info.nmachines) {\n                nmachines = domain->info.nmachines;\n                machinelist = domain->info.machines;\n            } else {\n                nmachines = guest->arch.defaultInfo.nmachines;\n                machinelist = guest->arch.defaultInfo.machines;\n            }\n\n            for (k = 0; k < nmachines; k++) {\n                virCapsGuestMachinePtr machine = machinelist[k];\n\n                if (machinetype &&\n                    STRNEQ(machine->name, machinetype) &&\n                    STRNEQ_NULLABLE(machine->canonical, machinetype)) {\n                    VIR_DEBUG(\"Skip machine type want=%s vs got=%s got=%s\",\n                              machinetype, machine->name, NULLSTR(machine->canonical));\n                    continue;\n                }\n                VIR_DEBUG(\"Match machine type machine %s\", NULLSTR(machinetype));\n\n                foundmachine = machine;\n                break;\n            }\n\n            if (!foundmachine && nmachines)\n                continue;\n\n            founddomain = domain;\n            break;\n        }\n\n        if (!founddomain)\n            continue;\n\n        foundguest = guest;\n        break;\n    }\n\n    /* XXX check default_emulator, see how it uses this */\n    if (!foundguest) {\n        virBuffer buf = VIR_BUFFER_INITIALIZER;\n        if (ostype)\n            virBufferAsprintf(&buf, \"ostype=%s \",\n                              virDomainOSTypeToString(ostype));\n        if (arch)\n            virBufferAsprintf(&buf, \"arch=%s \", virArchToString(arch));\n        if (domaintype > VIR_DOMAIN_VIRT_NONE)\n            virBufferAsprintf(&buf, \"domaintype=%s \",\n                              virDomainVirtTypeToString(domaintype));\n        if (emulator)\n            virBufferEscapeString(&buf, \"emulator=%s \", emulator);\n        if (machinetype)\n            virBufferEscapeString(&buf, \"machine=%s \", machinetype);\n        if (virBufferCurrentContent(&buf) &&\n            !virBufferCurrentContent(&buf)[0])\n            virBufferAsprintf(&buf, \"%s\", _(\"any configuration\"));\n\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"could not find capabilities for %s\"),\n                       virBufferCurrentContent(&buf));\n        virBufferFreeAndReset(&buf);\n        return ret;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        return ret;\n\n    ret->ostype = foundguest->ostype;\n    ret->arch = foundguest->arch.id;\n    if (founddomain) {\n        ret->domaintype = founddomain->type;\n        ret->emulator = founddomain->info.emulator;\n    }\n    if (!ret->emulator)\n        ret->emulator = foundguest->arch.defaultInfo.emulator;\n    if (foundmachine)\n        ret->machinetype = foundmachine->name;\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virCapsDomainDataPtr\nvirCapabilitiesDomainDataLookupInternal(virCapsPtr caps,\n                                        int ostype,\n                                        virArch arch,\n                                        virDomainVirtType domaintype,\n                                        const char *emulator,\n                                        const char *machinetype)\n{\n    virCapsGuestPtr foundguest = NULL;\n    virCapsGuestDomainPtr founddomain = NULL;\n    virCapsGuestMachinePtr foundmachine = NULL;\n    virCapsDomainDataPtr ret = NULL;\n    size_t i, j, k;\n\n    VIR_DEBUG(\"Lookup ostype=%d arch=%d domaintype=%d emulator=%s machine=%s\",\n              ostype, arch, domaintype, NULLSTR(emulator), NULLSTR(machinetype));\n    for (i = 0; i < caps->nguests; i++) {\n        virCapsGuestPtr guest = caps->guests[i];\n\n        if (ostype != -1 && guest->ostype != ostype) {\n            VIR_DEBUG(\"Skip os type want=%d vs got=%d\", ostype, guest->ostype);\n            continue;\n        }\n        VIR_DEBUG(\"Match os type %d\", ostype);\n\n        if ((arch != VIR_ARCH_NONE) && (guest->arch.id != arch)) {\n            VIR_DEBUG(\"Skip arch want=%d vs got=%d\", arch, guest->arch.id);\n            continue;\n        }\n        VIR_DEBUG(\"Match arch %d\", arch);\n\n        for (j = 0; j < guest->arch.ndomains; j++) {\n            virCapsGuestDomainPtr domain = guest->arch.domains[j];\n            virCapsGuestMachinePtr *machinelist;\n            int nmachines;\n            const char *check_emulator = NULL;\n\n            if (domaintype != VIR_DOMAIN_VIRT_NONE &&\n                (domain->type != domaintype)) {\n                VIR_DEBUG(\"Skip domain type want=%d vs got=%d\", domaintype, domain->type);\n                continue;\n            }\n            VIR_DEBUG(\"Match domain type %d\", domaintype);\n\n            check_emulator = domain->info.emulator;\n            if (!check_emulator)\n                check_emulator = guest->arch.defaultInfo.emulator;\n            if (emulator && STRNEQ_NULLABLE(check_emulator, emulator)) {\n                VIR_DEBUG(\"Skip emulator got=%s vs want=%s\",\n                          emulator, NULLSTR(check_emulator));\n                continue;\n            }\n            VIR_DEBUG(\"Match emulator %s\", NULLSTR(emulator));\n\n            if (domain->info.nmachines) {\n                nmachines = domain->info.nmachines;\n                machinelist = domain->info.machines;\n            } else {\n                nmachines = guest->arch.defaultInfo.nmachines;\n                machinelist = guest->arch.defaultInfo.machines;\n            }\n\n            for (k = 0; k < nmachines; k++) {\n                virCapsGuestMachinePtr machine = machinelist[k];\n\n                if (machinetype &&\n                    STRNEQ(machine->name, machinetype) &&\n                    STRNEQ_NULLABLE(machine->canonical, machinetype)) {\n                    VIR_DEBUG(\"Skip machine type want=%s vs got=%s got=%s\",\n                              machinetype, machine->name, NULLSTR(machine->canonical));\n                    continue;\n                }\n                VIR_DEBUG(\"Match machine type machine %s\", NULLSTR(machinetype));\n\n                foundmachine = machine;\n                break;\n            }\n\n            if (!foundmachine && nmachines)\n                continue;\n\n            founddomain = domain;\n            break;\n        }\n\n        if (!founddomain)\n            continue;\n\n        foundguest = guest;\n        break;\n    }\n\n    /* XXX check default_emulator, see how it uses this */\n    if (!foundguest) {\n        virBuffer buf = VIR_BUFFER_INITIALIZER;\n        if (ostype)\n            virBufferAsprintf(&buf, \"ostype=%s \",\n                              virDomainOSTypeToString(ostype));\n        if (arch)\n            virBufferAsprintf(&buf, \"arch=%s \", virArchToString(arch));\n        if (domaintype > VIR_DOMAIN_VIRT_NONE)\n            virBufferAsprintf(&buf, \"domaintype=%s \",\n                              virDomainVirtTypeToString(domaintype));\n        if (emulator)\n            virBufferEscapeString(&buf, \"emulator=%s \", emulator);\n        if (machinetype)\n            virBufferEscapeString(&buf, \"machine=%s \", machinetype);\n        if (virBufferCurrentContent(&buf) &&\n            !virBufferCurrentContent(&buf)[0])\n            virBufferAsprintf(&buf, \"%s\", _(\"any configuration\"));\n\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"could not find capabilities for %s\"),\n                       virBufferCurrentContent(&buf));\n        virBufferFreeAndReset(&buf);\n        return ret;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        return ret;\n\n    ret->ostype = foundguest->ostype;\n    ret->arch = foundguest->arch.id;\n    if (founddomain) {\n        ret->domaintype = founddomain->type;\n        ret->emulator = founddomain->info.emulator;\n    }\n    if (!ret->emulator)\n        ret->emulator = foundguest->arch.defaultInfo.emulator;\n    if (foundmachine)\n        ret->machinetype = foundmachine->name;\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsDomainDataPtr\nvirCapabilitiesDomainDataLookup(virCapsPtr caps,\n                                int ostype,\n                                virArch arch,\n                                int domaintype,\n                                const char *emulator,\n                                const char *machinetype)\n{\n    virCapsDomainDataPtr ret;\n\n    if (arch == VIR_ARCH_NONE) {\n        /* Prefer host arch if its available */\n        ret = virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                      caps->host.arch,\n                                                      domaintype,\n                                                      emulator, machinetype);\n        if (ret)\n            return ret;\n    }\n\n    return virCapabilitiesDomainDataLookupInternal(caps, ostype,\n                                                   arch, domaintype,\n                                                   emulator, machinetype);\n}"
  },
  {
    "function_name": "virCapabilitiesDomainDataLookupInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "614-747",
    "snippet": "static virCapsDomainDataPtr\nvirCapabilitiesDomainDataLookupInternal(virCapsPtr caps,\n                                        int ostype,\n                                        virArch arch,\n                                        virDomainVirtType domaintype,\n                                        const char *emulator,\n                                        const char *machinetype)\n{\n    virCapsGuestPtr foundguest = NULL;\n    virCapsGuestDomainPtr founddomain = NULL;\n    virCapsGuestMachinePtr foundmachine = NULL;\n    virCapsDomainDataPtr ret = NULL;\n    size_t i, j, k;\n\n    VIR_DEBUG(\"Lookup ostype=%d arch=%d domaintype=%d emulator=%s machine=%s\",\n              ostype, arch, domaintype, NULLSTR(emulator), NULLSTR(machinetype));\n    for (i = 0; i < caps->nguests; i++) {\n        virCapsGuestPtr guest = caps->guests[i];\n\n        if (ostype != -1 && guest->ostype != ostype) {\n            VIR_DEBUG(\"Skip os type want=%d vs got=%d\", ostype, guest->ostype);\n            continue;\n        }\n        VIR_DEBUG(\"Match os type %d\", ostype);\n\n        if ((arch != VIR_ARCH_NONE) && (guest->arch.id != arch)) {\n            VIR_DEBUG(\"Skip arch want=%d vs got=%d\", arch, guest->arch.id);\n            continue;\n        }\n        VIR_DEBUG(\"Match arch %d\", arch);\n\n        for (j = 0; j < guest->arch.ndomains; j++) {\n            virCapsGuestDomainPtr domain = guest->arch.domains[j];\n            virCapsGuestMachinePtr *machinelist;\n            int nmachines;\n            const char *check_emulator = NULL;\n\n            if (domaintype != VIR_DOMAIN_VIRT_NONE &&\n                (domain->type != domaintype)) {\n                VIR_DEBUG(\"Skip domain type want=%d vs got=%d\", domaintype, domain->type);\n                continue;\n            }\n            VIR_DEBUG(\"Match domain type %d\", domaintype);\n\n            check_emulator = domain->info.emulator;\n            if (!check_emulator)\n                check_emulator = guest->arch.defaultInfo.emulator;\n            if (emulator && STRNEQ_NULLABLE(check_emulator, emulator)) {\n                VIR_DEBUG(\"Skip emulator got=%s vs want=%s\",\n                          emulator, NULLSTR(check_emulator));\n                continue;\n            }\n            VIR_DEBUG(\"Match emulator %s\", NULLSTR(emulator));\n\n            if (domain->info.nmachines) {\n                nmachines = domain->info.nmachines;\n                machinelist = domain->info.machines;\n            } else {\n                nmachines = guest->arch.defaultInfo.nmachines;\n                machinelist = guest->arch.defaultInfo.machines;\n            }\n\n            for (k = 0; k < nmachines; k++) {\n                virCapsGuestMachinePtr machine = machinelist[k];\n\n                if (machinetype &&\n                    STRNEQ(machine->name, machinetype) &&\n                    STRNEQ_NULLABLE(machine->canonical, machinetype)) {\n                    VIR_DEBUG(\"Skip machine type want=%s vs got=%s got=%s\",\n                              machinetype, machine->name, NULLSTR(machine->canonical));\n                    continue;\n                }\n                VIR_DEBUG(\"Match machine type machine %s\", NULLSTR(machinetype));\n\n                foundmachine = machine;\n                break;\n            }\n\n            if (!foundmachine && nmachines)\n                continue;\n\n            founddomain = domain;\n            break;\n        }\n\n        if (!founddomain)\n            continue;\n\n        foundguest = guest;\n        break;\n    }\n\n    /* XXX check default_emulator, see how it uses this */\n    if (!foundguest) {\n        virBuffer buf = VIR_BUFFER_INITIALIZER;\n        if (ostype)\n            virBufferAsprintf(&buf, \"ostype=%s \",\n                              virDomainOSTypeToString(ostype));\n        if (arch)\n            virBufferAsprintf(&buf, \"arch=%s \", virArchToString(arch));\n        if (domaintype > VIR_DOMAIN_VIRT_NONE)\n            virBufferAsprintf(&buf, \"domaintype=%s \",\n                              virDomainVirtTypeToString(domaintype));\n        if (emulator)\n            virBufferEscapeString(&buf, \"emulator=%s \", emulator);\n        if (machinetype)\n            virBufferEscapeString(&buf, \"machine=%s \", machinetype);\n        if (virBufferCurrentContent(&buf) &&\n            !virBufferCurrentContent(&buf)[0])\n            virBufferAsprintf(&buf, \"%s\", _(\"any configuration\"));\n\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"could not find capabilities for %s\"),\n                       virBufferCurrentContent(&buf));\n        virBufferFreeAndReset(&buf);\n        return ret;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        return ret;\n\n    ret->ostype = foundguest->ostype;\n    ret->arch = foundguest->arch.id;\n    if (founddomain) {\n        ret->domaintype = founddomain->type;\n        ret->emulator = founddomain->info.emulator;\n    }\n    if (!ret->emulator)\n        ret->emulator = foundguest->arch.defaultInfo.emulator;\n    if (foundmachine)\n        ret->machinetype = foundmachine->name;\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"could not find capabilities for %s\")",
            "virBufferCurrentContent(&buf)"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferCurrentContent",
          "args": [
            "&buf"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferCurrentContent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "222-233",
          "snippet": "const char *\nvirBufferCurrentContent(virBufferPtr buf)\n{\n    if (!buf)\n        return NULL;\n\n    if (!buf->str ||\n        buf->str->len == 0)\n        return \"\";\n\n    return buf->str->str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirBufferCurrentContent(virBufferPtr buf)\n{\n    if (!buf)\n        return NULL;\n\n    if (!buf->str ||\n        buf->str->len == 0)\n        return \"\";\n\n    return buf->str->str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not find capabilities for %s\""
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"%s\"",
            "_(\"any configuration\")"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "&buf",
            "\"machine=%s \"",
            "machinetype"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainVirtTypeToString",
          "args": [
            "domaintype"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainOSTypeToString",
          "args": [
            "ostype"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Match machine type machine %s\"",
            "NULLSTR(machinetype)"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "machinetype"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skip machine type want=%s vs got=%s got=%s\"",
            "machinetype",
            "machine->name",
            "NULLSTR(machine->canonical)"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "machine->canonical"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "machine->canonical",
            "machinetype"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "machine->name",
            "machinetype"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Match emulator %s\"",
            "NULLSTR(emulator)"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "emulator"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skip emulator got=%s vs want=%s\"",
            "emulator",
            "NULLSTR(check_emulator)"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "check_emulator"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "check_emulator",
            "emulator"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Match domain type %d\"",
            "domaintype"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skip domain type want=%d vs got=%d\"",
            "domaintype",
            "domain->type"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Match arch %d\"",
            "arch"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skip arch want=%d vs got=%d\"",
            "arch",
            "guest->arch.id"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Match os type %d\"",
            "ostype"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skip os type want=%d vs got=%d\"",
            "ostype",
            "guest->ostype"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Lookup ostype=%d arch=%d domaintype=%d emulator=%s machine=%s\"",
            "ostype",
            "arch",
            "domaintype",
            "NULLSTR(emulator)",
            "NULLSTR(machinetype)"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "machinetype"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "emulator"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virCapsDomainDataPtr\nvirCapabilitiesDomainDataLookupInternal(virCapsPtr caps,\n                                        int ostype,\n                                        virArch arch,\n                                        virDomainVirtType domaintype,\n                                        const char *emulator,\n                                        const char *machinetype)\n{\n    virCapsGuestPtr foundguest = NULL;\n    virCapsGuestDomainPtr founddomain = NULL;\n    virCapsGuestMachinePtr foundmachine = NULL;\n    virCapsDomainDataPtr ret = NULL;\n    size_t i, j, k;\n\n    VIR_DEBUG(\"Lookup ostype=%d arch=%d domaintype=%d emulator=%s machine=%s\",\n              ostype, arch, domaintype, NULLSTR(emulator), NULLSTR(machinetype));\n    for (i = 0; i < caps->nguests; i++) {\n        virCapsGuestPtr guest = caps->guests[i];\n\n        if (ostype != -1 && guest->ostype != ostype) {\n            VIR_DEBUG(\"Skip os type want=%d vs got=%d\", ostype, guest->ostype);\n            continue;\n        }\n        VIR_DEBUG(\"Match os type %d\", ostype);\n\n        if ((arch != VIR_ARCH_NONE) && (guest->arch.id != arch)) {\n            VIR_DEBUG(\"Skip arch want=%d vs got=%d\", arch, guest->arch.id);\n            continue;\n        }\n        VIR_DEBUG(\"Match arch %d\", arch);\n\n        for (j = 0; j < guest->arch.ndomains; j++) {\n            virCapsGuestDomainPtr domain = guest->arch.domains[j];\n            virCapsGuestMachinePtr *machinelist;\n            int nmachines;\n            const char *check_emulator = NULL;\n\n            if (domaintype != VIR_DOMAIN_VIRT_NONE &&\n                (domain->type != domaintype)) {\n                VIR_DEBUG(\"Skip domain type want=%d vs got=%d\", domaintype, domain->type);\n                continue;\n            }\n            VIR_DEBUG(\"Match domain type %d\", domaintype);\n\n            check_emulator = domain->info.emulator;\n            if (!check_emulator)\n                check_emulator = guest->arch.defaultInfo.emulator;\n            if (emulator && STRNEQ_NULLABLE(check_emulator, emulator)) {\n                VIR_DEBUG(\"Skip emulator got=%s vs want=%s\",\n                          emulator, NULLSTR(check_emulator));\n                continue;\n            }\n            VIR_DEBUG(\"Match emulator %s\", NULLSTR(emulator));\n\n            if (domain->info.nmachines) {\n                nmachines = domain->info.nmachines;\n                machinelist = domain->info.machines;\n            } else {\n                nmachines = guest->arch.defaultInfo.nmachines;\n                machinelist = guest->arch.defaultInfo.machines;\n            }\n\n            for (k = 0; k < nmachines; k++) {\n                virCapsGuestMachinePtr machine = machinelist[k];\n\n                if (machinetype &&\n                    STRNEQ(machine->name, machinetype) &&\n                    STRNEQ_NULLABLE(machine->canonical, machinetype)) {\n                    VIR_DEBUG(\"Skip machine type want=%s vs got=%s got=%s\",\n                              machinetype, machine->name, NULLSTR(machine->canonical));\n                    continue;\n                }\n                VIR_DEBUG(\"Match machine type machine %s\", NULLSTR(machinetype));\n\n                foundmachine = machine;\n                break;\n            }\n\n            if (!foundmachine && nmachines)\n                continue;\n\n            founddomain = domain;\n            break;\n        }\n\n        if (!founddomain)\n            continue;\n\n        foundguest = guest;\n        break;\n    }\n\n    /* XXX check default_emulator, see how it uses this */\n    if (!foundguest) {\n        virBuffer buf = VIR_BUFFER_INITIALIZER;\n        if (ostype)\n            virBufferAsprintf(&buf, \"ostype=%s \",\n                              virDomainOSTypeToString(ostype));\n        if (arch)\n            virBufferAsprintf(&buf, \"arch=%s \", virArchToString(arch));\n        if (domaintype > VIR_DOMAIN_VIRT_NONE)\n            virBufferAsprintf(&buf, \"domaintype=%s \",\n                              virDomainVirtTypeToString(domaintype));\n        if (emulator)\n            virBufferEscapeString(&buf, \"emulator=%s \", emulator);\n        if (machinetype)\n            virBufferEscapeString(&buf, \"machine=%s \", machinetype);\n        if (virBufferCurrentContent(&buf) &&\n            !virBufferCurrentContent(&buf)[0])\n            virBufferAsprintf(&buf, \"%s\", _(\"any configuration\"));\n\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"could not find capabilities for %s\"),\n                       virBufferCurrentContent(&buf));\n        virBufferFreeAndReset(&buf);\n        return ret;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        return ret;\n\n    ret->ostype = foundguest->ostype;\n    ret->arch = foundguest->arch.id;\n    if (founddomain) {\n        ret->domaintype = founddomain->type;\n        ret->emulator = founddomain->info.emulator;\n    }\n    if (!ret->emulator)\n        ret->emulator = foundguest->arch.defaultInfo.emulator;\n    if (foundmachine)\n        ret->machinetype = foundmachine->name;\n\n    return ret;\n}"
  },
  {
    "function_name": "virCapabilitiesHostSecModelAddBaseLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "596-611",
    "snippet": "extern int\nvirCapabilitiesHostSecModelAddBaseLabel(virCapsHostSecModelPtr secmodel,\n                                        const char *type,\n                                        const char *label)\n{\n    if (type == NULL || label == NULL)\n        return -1;\n\n    if (VIR_EXPAND_N(secmodel->labels, secmodel->nlabels, 1) < 0)\n        return -1;\n\n    secmodel->labels[secmodel->nlabels - 1].type = g_strdup(type);\n    secmodel->labels[secmodel->nlabels - 1].label = g_strdup(label);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "label"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "secmodel->labels",
            "secmodel->nlabels",
            "1"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nextern int\nvirCapabilitiesHostSecModelAddBaseLabel(virCapsHostSecModelPtr secmodel,\n                                        const char *type,\n                                        const char *label)\n{\n    if (type == NULL || label == NULL)\n        return -1;\n\n    if (VIR_EXPAND_N(secmodel->labels, secmodel->nlabels, 1) < 0)\n        return -1;\n\n    secmodel->labels[secmodel->nlabels - 1].type = g_strdup(type);\n    secmodel->labels[secmodel->nlabels - 1].label = g_strdup(label);\n\n    return 0;\n}"
  },
  {
    "function_name": "virCapabilitiesAddGuestFeatureWithToggle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "578-585",
    "snippet": "void\nvirCapabilitiesAddGuestFeatureWithToggle(virCapsGuestPtr guest,\n                                         virCapsGuestFeatureType feature,\n                                         bool defaultOn,\n                                         bool toggle)\n{\n    virCapabilitiesAddGuestFeatureInternal(guest, feature, defaultOn, toggle);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuestFeatureInternal",
          "args": [
            "guest",
            "feature",
            "defaultOn",
            "toggle"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuestFeatureInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "539-551",
          "snippet": "static void\nvirCapabilitiesAddGuestFeatureInternal(virCapsGuestPtr guest,\n                                       virCapsGuestFeatureType feature,\n                                       bool defaultOn,\n                                       bool toggle)\n{\n    guest->features[feature].present = true;\n\n    if (virCapsGuestFeatureInfos[feature].togglesRequired) {\n        guest->features[feature].defaultOn = virTristateSwitchFromBool(defaultOn);\n        guest->features[feature].toggle = virTristateBoolFromBool(toggle);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virCapsGuestFeatureInfo virCapsGuestFeatureInfos[VIR_CAPS_GUEST_FEATURE_TYPE_LAST] = {\n    [VIR_CAPS_GUEST_FEATURE_TYPE_PAE] = { \"pae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE] = { \"nonpae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_IA64_BE] = { \"ia64_be\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_ACPI] = { \"acpi\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_APIC] = { \"apic\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION] = { \"cpuselection\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT] = { \"deviceboot\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT] = { \"disksnapshot\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_HAP] = { \"hap\", true },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic const struct virCapsGuestFeatureInfo virCapsGuestFeatureInfos[VIR_CAPS_GUEST_FEATURE_TYPE_LAST] = {\n    [VIR_CAPS_GUEST_FEATURE_TYPE_PAE] = { \"pae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE] = { \"nonpae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_IA64_BE] = { \"ia64_be\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_ACPI] = { \"acpi\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_APIC] = { \"apic\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION] = { \"cpuselection\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT] = { \"deviceboot\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT] = { \"disksnapshot\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_HAP] = { \"hap\", true },\n};\n\nstatic void\nvirCapabilitiesAddGuestFeatureInternal(virCapsGuestPtr guest,\n                                       virCapsGuestFeatureType feature,\n                                       bool defaultOn,\n                                       bool toggle)\n{\n    guest->features[feature].present = true;\n\n    if (virCapsGuestFeatureInfos[feature].togglesRequired) {\n        guest->features[feature].defaultOn = virTristateSwitchFromBool(defaultOn);\n        guest->features[feature].toggle = virTristateBoolFromBool(toggle);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesAddGuestFeatureWithToggle(virCapsGuestPtr guest,\n                                         virCapsGuestFeatureType feature,\n                                         bool defaultOn,\n                                         bool toggle)\n{\n    virCapabilitiesAddGuestFeatureInternal(guest, feature, defaultOn, toggle);\n}"
  },
  {
    "function_name": "virCapabilitiesAddGuestFeature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "561-566",
    "snippet": "void\nvirCapabilitiesAddGuestFeature(virCapsGuestPtr guest,\n                               virCapsGuestFeatureType feature)\n{\n    virCapabilitiesAddGuestFeatureInternal(guest, feature, false, false);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuestFeatureInternal",
          "args": [
            "guest",
            "feature",
            "false",
            "false"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuestFeatureInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "539-551",
          "snippet": "static void\nvirCapabilitiesAddGuestFeatureInternal(virCapsGuestPtr guest,\n                                       virCapsGuestFeatureType feature,\n                                       bool defaultOn,\n                                       bool toggle)\n{\n    guest->features[feature].present = true;\n\n    if (virCapsGuestFeatureInfos[feature].togglesRequired) {\n        guest->features[feature].defaultOn = virTristateSwitchFromBool(defaultOn);\n        guest->features[feature].toggle = virTristateBoolFromBool(toggle);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virCapsGuestFeatureInfo virCapsGuestFeatureInfos[VIR_CAPS_GUEST_FEATURE_TYPE_LAST] = {\n    [VIR_CAPS_GUEST_FEATURE_TYPE_PAE] = { \"pae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE] = { \"nonpae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_IA64_BE] = { \"ia64_be\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_ACPI] = { \"acpi\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_APIC] = { \"apic\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION] = { \"cpuselection\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT] = { \"deviceboot\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT] = { \"disksnapshot\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_HAP] = { \"hap\", true },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic const struct virCapsGuestFeatureInfo virCapsGuestFeatureInfos[VIR_CAPS_GUEST_FEATURE_TYPE_LAST] = {\n    [VIR_CAPS_GUEST_FEATURE_TYPE_PAE] = { \"pae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE] = { \"nonpae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_IA64_BE] = { \"ia64_be\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_ACPI] = { \"acpi\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_APIC] = { \"apic\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION] = { \"cpuselection\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT] = { \"deviceboot\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT] = { \"disksnapshot\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_HAP] = { \"hap\", true },\n};\n\nstatic void\nvirCapabilitiesAddGuestFeatureInternal(virCapsGuestPtr guest,\n                                       virCapsGuestFeatureType feature,\n                                       bool defaultOn,\n                                       bool toggle)\n{\n    guest->features[feature].present = true;\n\n    if (virCapsGuestFeatureInfos[feature].togglesRequired) {\n        guest->features[feature].defaultOn = virTristateSwitchFromBool(defaultOn);\n        guest->features[feature].toggle = virTristateBoolFromBool(toggle);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesAddGuestFeature(virCapsGuestPtr guest,\n                               virCapsGuestFeatureType feature)\n{\n    virCapabilitiesAddGuestFeatureInternal(guest, feature, false, false);\n}"
  },
  {
    "function_name": "virCapabilitiesAddGuestFeatureInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "539-551",
    "snippet": "static void\nvirCapabilitiesAddGuestFeatureInternal(virCapsGuestPtr guest,\n                                       virCapsGuestFeatureType feature,\n                                       bool defaultOn,\n                                       bool toggle)\n{\n    guest->features[feature].present = true;\n\n    if (virCapsGuestFeatureInfos[feature].togglesRequired) {\n        guest->features[feature].defaultOn = virTristateSwitchFromBool(defaultOn);\n        guest->features[feature].toggle = virTristateBoolFromBool(toggle);\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct virCapsGuestFeatureInfo virCapsGuestFeatureInfos[VIR_CAPS_GUEST_FEATURE_TYPE_LAST] = {\n    [VIR_CAPS_GUEST_FEATURE_TYPE_PAE] = { \"pae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE] = { \"nonpae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_IA64_BE] = { \"ia64_be\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_ACPI] = { \"acpi\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_APIC] = { \"apic\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION] = { \"cpuselection\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT] = { \"deviceboot\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT] = { \"disksnapshot\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_HAP] = { \"hap\", true },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virTristateBoolFromBool",
          "args": [
            "toggle"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "virTristateBoolFromBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virenum.c",
          "lines": "40-47",
          "snippet": "virTristateBool\nvirTristateBoolFromBool(bool val)\n{\n    if (val)\n        return VIR_TRISTATE_BOOL_YES;\n    else\n        return VIR_TRISTATE_BOOL_NO;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virenum.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virenum.h\"\n#include <config.h>\n\nvirTristateBool\nvirTristateBoolFromBool(bool val)\n{\n    if (val)\n        return VIR_TRISTATE_BOOL_YES;\n    else\n        return VIR_TRISTATE_BOOL_NO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTristateSwitchFromBool",
          "args": [
            "defaultOn"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "virTristateSwitchFromBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virenum.c",
          "lines": "50-57",
          "snippet": "virTristateSwitch\nvirTristateSwitchFromBool(bool val)\n{\n    if (val)\n        return VIR_TRISTATE_SWITCH_ON;\n    else\n        return VIR_TRISTATE_SWITCH_OFF;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virenum.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virenum.h\"\n#include <config.h>\n\nvirTristateSwitch\nvirTristateSwitchFromBool(bool val)\n{\n    if (val)\n        return VIR_TRISTATE_SWITCH_ON;\n    else\n        return VIR_TRISTATE_SWITCH_OFF;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic const struct virCapsGuestFeatureInfo virCapsGuestFeatureInfos[VIR_CAPS_GUEST_FEATURE_TYPE_LAST] = {\n    [VIR_CAPS_GUEST_FEATURE_TYPE_PAE] = { \"pae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE] = { \"nonpae\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_IA64_BE] = { \"ia64_be\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_ACPI] = { \"acpi\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_APIC] = { \"apic\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_CPUSELECTION] = { \"cpuselection\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DEVICEBOOT] = { \"deviceboot\", false },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_DISKSNAPSHOT] = { \"disksnapshot\", true },\n    [VIR_CAPS_GUEST_FEATURE_TYPE_HAP] = { \"hap\", true },\n};\n\nstatic void\nvirCapabilitiesAddGuestFeatureInternal(virCapsGuestPtr guest,\n                                       virCapsGuestFeatureType feature,\n                                       bool defaultOn,\n                                       bool toggle)\n{\n    guest->features[feature].present = true;\n\n    if (virCapsGuestFeatureInfos[feature].togglesRequired) {\n        guest->features[feature].defaultOn = virTristateSwitchFromBool(defaultOn);\n        guest->features[feature].toggle = virTristateBoolFromBool(toggle);\n    }\n}"
  },
  {
    "function_name": "virCapabilitiesAddGuestDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "485-518",
    "snippet": "virCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapabilitiesFreeGuestDomain",
          "args": [
            "dom"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFreeGuestDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "137-151",
          "snippet": "static void\nvirCapabilitiesFreeGuestDomain(virCapsGuestDomainPtr dom)\n{\n    size_t i;\n    if (dom == NULL)\n        return;\n\n    VIR_FREE(dom->info.emulator);\n    VIR_FREE(dom->info.loader);\n    for (i = 0; i < dom->info.nmachines; i++)\n        virCapabilitiesFreeGuestMachine(dom->info.machines[i]);\n    VIR_FREE(dom->info.machines);\n\n    VIR_FREE(dom);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesFreeGuestDomain(virCapsGuestDomainPtr dom)\n{\n    size_t i;\n    if (dom == NULL)\n        return;\n\n    VIR_FREE(dom->info.emulator);\n    VIR_FREE(dom->info.loader);\n    for (i = 0; i < dom->info.nmachines; i++)\n        virCapabilitiesFreeGuestMachine(dom->info.machines[i]);\n    VIR_FREE(dom->info.machines);\n\n    VIR_FREE(dom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "guest->arch.domains",
            "guest->arch.ndomains_max",
            "guest->arch.ndomains",
            "1"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "loader"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "dom"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}"
  },
  {
    "function_name": "virCapabilitiesAddGuest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "434-470",
    "snippet": "virCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapabilitiesFreeGuest",
          "args": [
            "guest"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFreeGuest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "153-171",
          "snippet": "void\nvirCapabilitiesFreeGuest(virCapsGuestPtr guest)\n{\n    size_t i;\n    if (guest == NULL)\n        return;\n\n    VIR_FREE(guest->arch.defaultInfo.emulator);\n    VIR_FREE(guest->arch.defaultInfo.loader);\n    for (i = 0; i < guest->arch.defaultInfo.nmachines; i++)\n        virCapabilitiesFreeGuestMachine(guest->arch.defaultInfo.machines[i]);\n    VIR_FREE(guest->arch.defaultInfo.machines);\n\n    for (i = 0; i < guest->arch.ndomains; i++)\n        virCapabilitiesFreeGuestDomain(guest->arch.domains[i]);\n    VIR_FREE(guest->arch.domains);\n\n    VIR_FREE(guest);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesFreeGuest(virCapsGuestPtr guest)\n{\n    size_t i;\n    if (guest == NULL)\n        return;\n\n    VIR_FREE(guest->arch.defaultInfo.emulator);\n    VIR_FREE(guest->arch.defaultInfo.loader);\n    for (i = 0; i < guest->arch.defaultInfo.nmachines; i++)\n        virCapabilitiesFreeGuestMachine(guest->arch.defaultInfo.machines[i]);\n    VIR_FREE(guest->arch.defaultInfo.machines);\n\n    for (i = 0; i < guest->arch.ndomains; i++)\n        virCapabilitiesFreeGuestDomain(guest->arch.domains[i]);\n    VIR_FREE(guest->arch.domains);\n\n    VIR_FREE(guest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "caps->guests",
            "caps->nguests_max",
            "caps->nguests",
            "1"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "loader"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virArchGetWordSize",
          "args": [
            "arch"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "virArchGetWordSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "97-103",
          "snippet": "unsigned int virArchGetWordSize(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].wordsize;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nunsigned int virArchGetWordSize(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].wordsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "guest"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}"
  },
  {
    "function_name": "virCapabilitiesFreeMachines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "405-417",
    "snippet": "void\nvirCapabilitiesFreeMachines(virCapsGuestMachinePtr *machines,\n                            int nmachines)\n{\n    size_t i;\n    if (!machines)\n        return;\n    for (i = 0; i < nmachines && machines[i]; i++) {\n        virCapabilitiesFreeGuestMachine(machines[i]);\n        machines[i] = NULL;\n    }\n    VIR_FREE(machines);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machines"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFreeGuestMachine",
          "args": [
            "machines[i]"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFreeGuestMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "127-135",
          "snippet": "static void\nvirCapabilitiesFreeGuestMachine(virCapsGuestMachinePtr machine)\n{\n    if (machine == NULL)\n        return;\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->canonical);\n    VIR_FREE(machine);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesFreeGuestMachine(virCapsGuestMachinePtr machine)\n{\n    if (machine == NULL)\n        return;\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->canonical);\n    VIR_FREE(machine);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesFreeMachines(virCapsGuestMachinePtr *machines,\n                            int nmachines)\n{\n    size_t i;\n    if (!machines)\n        return;\n    for (i = 0; i < nmachines && machines[i]; i++) {\n        virCapabilitiesFreeGuestMachine(machines[i]);\n        machines[i] = NULL;\n    }\n    VIR_FREE(machines);\n}"
  },
  {
    "function_name": "virCapabilitiesAllocMachines",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "379-397",
    "snippet": "virCapsGuestMachinePtr *\nvirCapabilitiesAllocMachines(const char *const *names, int nnames)\n{\n    virCapsGuestMachinePtr *machines;\n    size_t i;\n\n    if (VIR_ALLOC_N(machines, nnames) < 0)\n        return NULL;\n\n    for (i = 0; i < nnames; i++) {\n        if (VIR_ALLOC(machines[i]) < 0) {\n            virCapabilitiesFreeMachines(machines, nnames);\n            return NULL;\n        }\n        machines[i]->name = g_strdup(names[i]);\n    }\n\n    return machines;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "names[i]"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFreeMachines",
          "args": [
            "machines",
            "nnames"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFreeMachines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "405-417",
          "snippet": "void\nvirCapabilitiesFreeMachines(virCapsGuestMachinePtr *machines,\n                            int nmachines)\n{\n    size_t i;\n    if (!machines)\n        return;\n    for (i = 0; i < nmachines && machines[i]; i++) {\n        virCapabilitiesFreeGuestMachine(machines[i]);\n        machines[i] = NULL;\n    }\n    VIR_FREE(machines);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesFreeMachines(virCapsGuestMachinePtr *machines,\n                            int nmachines)\n{\n    size_t i;\n    if (!machines)\n        return;\n    for (i = 0; i < nmachines && machines[i]; i++) {\n        virCapabilitiesFreeGuestMachine(machines[i]);\n        machines[i] = NULL;\n    }\n    VIR_FREE(machines);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "machines[i]"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "machines",
            "nnames"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestMachinePtr *\nvirCapabilitiesAllocMachines(const char *const *names, int nnames)\n{\n    virCapsGuestMachinePtr *machines;\n    size_t i;\n\n    if (VIR_ALLOC_N(machines, nnames) < 0)\n        return NULL;\n\n    for (i = 0; i < nnames; i++) {\n        if (VIR_ALLOC(machines[i]) < 0) {\n            virCapabilitiesFreeMachines(machines, nnames);\n            return NULL;\n        }\n        machines[i]->name = g_strdup(names[i]);\n    }\n\n    return machines;\n}"
  },
  {
    "function_name": "virCapabilitiesHostNUMAAddCell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "346-369",
    "snippet": "void\nvirCapabilitiesHostNUMAAddCell(virCapsHostNUMAPtr caps,\n                               int num,\n                               unsigned long long mem,\n                               int ncpus,\n                               virCapsHostNUMACellCPUPtr cpus,\n                               int nsiblings,\n                               virCapsHostNUMACellSiblingInfoPtr siblings,\n                               int npageinfo,\n                               virCapsHostNUMACellPageInfoPtr pageinfo)\n{\n    virCapsHostNUMACellPtr cell = g_new0(virCapsHostNUMACell, 1);\n\n    cell->num = num;\n    cell->mem = mem;\n    cell->ncpus = ncpus;\n    cell->cpus = cpus;\n    cell->nsiblings = nsiblings;\n    cell->siblings = siblings;\n    cell->npageinfo = npageinfo;\n    cell->pageinfo = pageinfo;\n\n    g_ptr_array_add(caps->cells, cell);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_ptr_array_add",
          "args": [
            "caps->cells",
            "cell"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virCapsHostNUMACell",
            "1"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesHostNUMAAddCell(virCapsHostNUMAPtr caps,\n                               int num,\n                               unsigned long long mem,\n                               int ncpus,\n                               virCapsHostNUMACellCPUPtr cpus,\n                               int nsiblings,\n                               virCapsHostNUMACellSiblingInfoPtr siblings,\n                               int npageinfo,\n                               virCapsHostNUMACellPageInfoPtr pageinfo)\n{\n    virCapsHostNUMACellPtr cell = g_new0(virCapsHostNUMACell, 1);\n\n    cell->num = num;\n    cell->mem = mem;\n    cell->ncpus = ncpus;\n    cell->cpus = cpus;\n    cell->nsiblings = nsiblings;\n    cell->siblings = siblings;\n    cell->npageinfo = npageinfo;\n    cell->pageinfo = pageinfo;\n\n    g_ptr_array_add(caps->cells, cell);\n}"
  },
  {
    "function_name": "virCapabilitiesSetNetPrefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "321-328",
    "snippet": "int\nvirCapabilitiesSetNetPrefix(virCapsPtr caps,\n                            const char *prefix)\n{\n    caps->host.netprefix = g_strdup(prefix);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "prefix"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirCapabilitiesSetNetPrefix(virCapsPtr caps,\n                            const char *prefix)\n{\n    caps->host.netprefix = g_strdup(prefix);\n\n    return 0;\n}"
  },
  {
    "function_name": "virCapabilitiesAddHostMigrateTransport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "300-312",
    "snippet": "int\nvirCapabilitiesAddHostMigrateTransport(virCapsPtr caps,\n                                       const char *name)\n{\n    if (VIR_RESIZE_N(caps->host.migrateTrans, caps->host.nmigrateTrans_max,\n                     caps->host.nmigrateTrans, 1) < 0)\n        return -1;\n\n    caps->host.migrateTrans[caps->host.nmigrateTrans] = g_strdup(name);\n    caps->host.nmigrateTrans++;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "name"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "caps->host.migrateTrans",
            "caps->host.nmigrateTrans_max",
            "caps->host.nmigrateTrans",
            "1"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirCapabilitiesAddHostMigrateTransport(virCapsPtr caps,\n                                       const char *name)\n{\n    if (VIR_RESIZE_N(caps->host.migrateTrans, caps->host.nmigrateTrans_max,\n                     caps->host.nmigrateTrans, 1) < 0)\n        return -1;\n\n    caps->host.migrateTrans[caps->host.nmigrateTrans] = g_strdup(name);\n    caps->host.nmigrateTrans++;\n\n    return 0;\n}"
  },
  {
    "function_name": "virCapabilitiesAddHostFeature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "279-291",
    "snippet": "int\nvirCapabilitiesAddHostFeature(virCapsPtr caps,\n                              const char *name)\n{\n    if (VIR_RESIZE_N(caps->host.features, caps->host.nfeatures_max,\n                     caps->host.nfeatures, 1) < 0)\n        return -1;\n\n    caps->host.features[caps->host.nfeatures] = g_strdup(name);\n    caps->host.nfeatures++;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "name"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "caps->host.features",
            "caps->host.nfeatures_max",
            "caps->host.nfeatures",
            "1"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirCapabilitiesAddHostFeature(virCapsPtr caps,\n                              const char *name)\n{\n    if (VIR_RESIZE_N(caps->host.features, caps->host.nfeatures_max,\n                     caps->host.nfeatures, 1) < 0)\n        return -1;\n\n    caps->host.features[caps->host.nfeatures] = g_strdup(name);\n    caps->host.nfeatures++;\n\n    return 0;\n}"
  },
  {
    "function_name": "virCapsDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "227-270",
    "snippet": "static void\nvirCapsDispose(void *object)\n{\n    virCapsPtr caps = object;\n    size_t i;\n\n    for (i = 0; i < caps->npools; i++)\n        virCapabilitiesFreeStoragePool(caps->pools[i]);\n    VIR_FREE(caps->pools);\n\n    for (i = 0; i < caps->nguests; i++)\n        virCapabilitiesFreeGuest(caps->guests[i]);\n    VIR_FREE(caps->guests);\n\n    for (i = 0; i < caps->host.nfeatures; i++)\n        VIR_FREE(caps->host.features[i]);\n    VIR_FREE(caps->host.features);\n\n    if (caps->host.numa)\n        virCapabilitiesHostNUMAUnref(caps->host.numa);\n\n    for (i = 0; i < caps->host.nmigrateTrans; i++)\n        VIR_FREE(caps->host.migrateTrans[i]);\n    VIR_FREE(caps->host.migrateTrans);\n\n    for (i = 0; i < caps->host.nsecModels; i++)\n        virCapabilitiesClearSecModel(&caps->host.secModels[i]);\n    VIR_FREE(caps->host.secModels);\n\n    for (i = 0; i < caps->host.cache.nbanks; i++)\n        virCapsHostCacheBankFree(caps->host.cache.banks[i]);\n    virResctrlInfoMonFree(caps->host.cache.monitor);\n    VIR_FREE(caps->host.cache.banks);\n\n    for (i = 0; i < caps->host.memBW.nnodes; i++)\n        virCapsHostMemBWNodeFree(caps->host.memBW.nodes[i]);\n    virResctrlInfoMonFree(caps->host.memBW.monitor);\n    VIR_FREE(caps->host.memBW.nodes);\n\n    VIR_FREE(caps->host.netprefix);\n    VIR_FREE(caps->host.pagesSize);\n    virCPUDefFree(caps->host.cpu);\n    virObjectUnref(caps->host.resctrl);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "caps->host.resctrl"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "caps->host.cpu"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps->host.pagesSize"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps->host.netprefix"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps->host.memBW.nodes"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResctrlInfoMonFree",
          "args": [
            "caps->host.memBW.monitor"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "virResctrlInfoMonFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virresctrl.c",
          "lines": "227-235",
          "snippet": "void\nvirResctrlInfoMonFree(virResctrlInfoMonPtr mon)\n{\n    if (!mon)\n        return;\n\n    virStringListFree(mon->features);\n    VIR_FREE(mon);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virresctrlpriv.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virresctrlpriv.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#include <config.h>\n\nvoid\nvirResctrlInfoMonFree(virResctrlInfoMonPtr mon)\n{\n    if (!mon)\n        return;\n\n    virStringListFree(mon->features);\n    VIR_FREE(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapsHostMemBWNodeFree",
          "args": [
            "caps->host.memBW.nodes[i]"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "virCapsHostMemBWNodeFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "203-211",
          "snippet": "static void\nvirCapsHostMemBWNodeFree(virCapsHostMemBWNodePtr ptr)\n{\n    if (!ptr)\n        return;\n\n    virBitmapFree(ptr->cpus);\n    VIR_FREE(ptr);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapsHostMemBWNodeFree(virCapsHostMemBWNodePtr ptr)\n{\n    if (!ptr)\n        return;\n\n    virBitmapFree(ptr->cpus);\n    VIR_FREE(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps->host.cache.banks"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapsHostCacheBankFree",
          "args": [
            "caps->host.cache.banks[i]"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "virCapsHostCacheBankFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1771-1784",
          "snippet": "void\nvirCapsHostCacheBankFree(virCapsHostCacheBankPtr ptr)\n{\n    size_t i;\n\n    if (!ptr)\n        return;\n\n    virBitmapFree(ptr->cpus);\n    for (i = 0; i < ptr->ncontrols; i++)\n        VIR_FREE(ptr->controls[i]);\n    VIR_FREE(ptr->controls);\n    VIR_FREE(ptr);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapsHostCacheBankFree(virCapsHostCacheBankPtr ptr)\n{\n    size_t i;\n\n    if (!ptr)\n        return;\n\n    virBitmapFree(ptr->cpus);\n    for (i = 0; i < ptr->ncontrols; i++)\n        VIR_FREE(ptr->controls[i]);\n    VIR_FREE(ptr->controls);\n    VIR_FREE(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps->host.secModels"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesClearSecModel",
          "args": [
            "&caps->host.secModels[i]"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesClearSecModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "213-225",
          "snippet": "static void\nvirCapabilitiesClearSecModel(virCapsHostSecModelPtr secmodel)\n{\n    size_t i;\n    for (i = 0; i < secmodel->nlabels; i++) {\n        VIR_FREE(secmodel->labels[i].type);\n        VIR_FREE(secmodel->labels[i].label);\n    }\n\n    VIR_FREE(secmodel->labels);\n    VIR_FREE(secmodel->model);\n    VIR_FREE(secmodel->doi);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesClearSecModel(virCapsHostSecModelPtr secmodel)\n{\n    size_t i;\n    for (i = 0; i < secmodel->nlabels; i++) {\n        VIR_FREE(secmodel->labels[i].type);\n        VIR_FREE(secmodel->labels[i].label);\n    }\n\n    VIR_FREE(secmodel->labels);\n    VIR_FREE(secmodel->model);\n    VIR_FREE(secmodel->doi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps->host.migrateTrans"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps->host.migrateTrans[i]"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMAUnref",
          "args": [
            "caps->host.numa"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMAUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "184-195",
          "snippet": "void\nvirCapabilitiesHostNUMAUnref(virCapsHostNUMAPtr caps)\n{\n    if (!caps)\n        return;\n\n    if (g_atomic_int_dec_and_test(&caps->refs)) {\n        g_ptr_array_unref(caps->cells);\n\n        VIR_FREE(caps);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesHostNUMAUnref(virCapsHostNUMAPtr caps)\n{\n    if (!caps)\n        return;\n\n    if (g_atomic_int_dec_and_test(&caps->refs)) {\n        g_ptr_array_unref(caps->cells);\n\n        VIR_FREE(caps);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps->host.features"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps->host.features[i]"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps->guests"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFreeGuest",
          "args": [
            "caps->guests[i]"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFreeGuest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "153-171",
          "snippet": "void\nvirCapabilitiesFreeGuest(virCapsGuestPtr guest)\n{\n    size_t i;\n    if (guest == NULL)\n        return;\n\n    VIR_FREE(guest->arch.defaultInfo.emulator);\n    VIR_FREE(guest->arch.defaultInfo.loader);\n    for (i = 0; i < guest->arch.defaultInfo.nmachines; i++)\n        virCapabilitiesFreeGuestMachine(guest->arch.defaultInfo.machines[i]);\n    VIR_FREE(guest->arch.defaultInfo.machines);\n\n    for (i = 0; i < guest->arch.ndomains; i++)\n        virCapabilitiesFreeGuestDomain(guest->arch.domains[i]);\n    VIR_FREE(guest->arch.domains);\n\n    VIR_FREE(guest);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesFreeGuest(virCapsGuestPtr guest)\n{\n    size_t i;\n    if (guest == NULL)\n        return;\n\n    VIR_FREE(guest->arch.defaultInfo.emulator);\n    VIR_FREE(guest->arch.defaultInfo.loader);\n    for (i = 0; i < guest->arch.defaultInfo.nmachines; i++)\n        virCapabilitiesFreeGuestMachine(guest->arch.defaultInfo.machines[i]);\n    VIR_FREE(guest->arch.defaultInfo.machines);\n\n    for (i = 0; i < guest->arch.ndomains; i++)\n        virCapabilitiesFreeGuestDomain(guest->arch.domains[i]);\n    VIR_FREE(guest->arch.domains);\n\n    VIR_FREE(guest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps->pools"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFreeStoragePool",
          "args": [
            "caps->pools[i]"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFreeStoragePool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "174-181",
          "snippet": "static void\nvirCapabilitiesFreeStoragePool(virCapsStoragePoolPtr pool)\n{\n    if (!pool)\n        return;\n\n    VIR_FREE(pool);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesFreeStoragePool(virCapsStoragePoolPtr pool)\n{\n    if (!pool)\n        return;\n\n    VIR_FREE(pool);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapsDispose(void *object)\n{\n    virCapsPtr caps = object;\n    size_t i;\n\n    for (i = 0; i < caps->npools; i++)\n        virCapabilitiesFreeStoragePool(caps->pools[i]);\n    VIR_FREE(caps->pools);\n\n    for (i = 0; i < caps->nguests; i++)\n        virCapabilitiesFreeGuest(caps->guests[i]);\n    VIR_FREE(caps->guests);\n\n    for (i = 0; i < caps->host.nfeatures; i++)\n        VIR_FREE(caps->host.features[i]);\n    VIR_FREE(caps->host.features);\n\n    if (caps->host.numa)\n        virCapabilitiesHostNUMAUnref(caps->host.numa);\n\n    for (i = 0; i < caps->host.nmigrateTrans; i++)\n        VIR_FREE(caps->host.migrateTrans[i]);\n    VIR_FREE(caps->host.migrateTrans);\n\n    for (i = 0; i < caps->host.nsecModels; i++)\n        virCapabilitiesClearSecModel(&caps->host.secModels[i]);\n    VIR_FREE(caps->host.secModels);\n\n    for (i = 0; i < caps->host.cache.nbanks; i++)\n        virCapsHostCacheBankFree(caps->host.cache.banks[i]);\n    virResctrlInfoMonFree(caps->host.cache.monitor);\n    VIR_FREE(caps->host.cache.banks);\n\n    for (i = 0; i < caps->host.memBW.nnodes; i++)\n        virCapsHostMemBWNodeFree(caps->host.memBW.nodes[i]);\n    virResctrlInfoMonFree(caps->host.memBW.monitor);\n    VIR_FREE(caps->host.memBW.nodes);\n\n    VIR_FREE(caps->host.netprefix);\n    VIR_FREE(caps->host.pagesSize);\n    virCPUDefFree(caps->host.cpu);\n    virObjectUnref(caps->host.resctrl);\n}"
  },
  {
    "function_name": "virCapabilitiesClearSecModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "213-225",
    "snippet": "static void\nvirCapabilitiesClearSecModel(virCapsHostSecModelPtr secmodel)\n{\n    size_t i;\n    for (i = 0; i < secmodel->nlabels; i++) {\n        VIR_FREE(secmodel->labels[i].type);\n        VIR_FREE(secmodel->labels[i].label);\n    }\n\n    VIR_FREE(secmodel->labels);\n    VIR_FREE(secmodel->model);\n    VIR_FREE(secmodel->doi);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "secmodel->doi"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "secmodel->model"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "secmodel->labels"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "secmodel->labels[i].label"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "secmodel->labels[i].type"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesClearSecModel(virCapsHostSecModelPtr secmodel)\n{\n    size_t i;\n    for (i = 0; i < secmodel->nlabels; i++) {\n        VIR_FREE(secmodel->labels[i].type);\n        VIR_FREE(secmodel->labels[i].label);\n    }\n\n    VIR_FREE(secmodel->labels);\n    VIR_FREE(secmodel->model);\n    VIR_FREE(secmodel->doi);\n}"
  },
  {
    "function_name": "virCapsHostMemBWNodeFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "203-211",
    "snippet": "static void\nvirCapsHostMemBWNodeFree(virCapsHostMemBWNodePtr ptr)\n{\n    if (!ptr)\n        return;\n\n    virBitmapFree(ptr->cpus);\n    VIR_FREE(ptr);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ptr"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "ptr->cpus"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapsHostMemBWNodeFree(virCapsHostMemBWNodePtr ptr)\n{\n    if (!ptr)\n        return;\n\n    virBitmapFree(ptr->cpus);\n    VIR_FREE(ptr);\n}"
  },
  {
    "function_name": "virCapabilitiesHostNUMARef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "197-201",
    "snippet": "void\nvirCapabilitiesHostNUMARef(virCapsHostNUMAPtr caps)\n{\n    g_atomic_int_inc(&caps->refs);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_atomic_int_inc",
          "args": [
            "&caps->refs"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesHostNUMARef(virCapsHostNUMAPtr caps)\n{\n    g_atomic_int_inc(&caps->refs);\n}"
  },
  {
    "function_name": "virCapabilitiesHostNUMAUnref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "184-195",
    "snippet": "void\nvirCapabilitiesHostNUMAUnref(virCapsHostNUMAPtr caps)\n{\n    if (!caps)\n        return;\n\n    if (g_atomic_int_dec_and_test(&caps->refs)) {\n        g_ptr_array_unref(caps->cells);\n\n        VIR_FREE(caps);\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "caps"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ptr_array_unref",
          "args": [
            "caps->cells"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_atomic_int_dec_and_test",
          "args": [
            "&caps->refs"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesHostNUMAUnref(virCapsHostNUMAPtr caps)\n{\n    if (!caps)\n        return;\n\n    if (g_atomic_int_dec_and_test(&caps->refs)) {\n        g_ptr_array_unref(caps->cells);\n\n        VIR_FREE(caps);\n    }\n}"
  },
  {
    "function_name": "virCapabilitiesFreeStoragePool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "174-181",
    "snippet": "static void\nvirCapabilitiesFreeStoragePool(virCapsStoragePoolPtr pool)\n{\n    if (!pool)\n        return;\n\n    VIR_FREE(pool);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pool"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesFreeStoragePool(virCapsStoragePoolPtr pool)\n{\n    if (!pool)\n        return;\n\n    VIR_FREE(pool);\n}"
  },
  {
    "function_name": "virCapabilitiesFreeGuest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "153-171",
    "snippet": "void\nvirCapabilitiesFreeGuest(virCapsGuestPtr guest)\n{\n    size_t i;\n    if (guest == NULL)\n        return;\n\n    VIR_FREE(guest->arch.defaultInfo.emulator);\n    VIR_FREE(guest->arch.defaultInfo.loader);\n    for (i = 0; i < guest->arch.defaultInfo.nmachines; i++)\n        virCapabilitiesFreeGuestMachine(guest->arch.defaultInfo.machines[i]);\n    VIR_FREE(guest->arch.defaultInfo.machines);\n\n    for (i = 0; i < guest->arch.ndomains; i++)\n        virCapabilitiesFreeGuestDomain(guest->arch.domains[i]);\n    VIR_FREE(guest->arch.domains);\n\n    VIR_FREE(guest);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "guest"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "guest->arch.domains"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFreeGuestDomain",
          "args": [
            "guest->arch.domains[i]"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFreeGuestDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "137-151",
          "snippet": "static void\nvirCapabilitiesFreeGuestDomain(virCapsGuestDomainPtr dom)\n{\n    size_t i;\n    if (dom == NULL)\n        return;\n\n    VIR_FREE(dom->info.emulator);\n    VIR_FREE(dom->info.loader);\n    for (i = 0; i < dom->info.nmachines; i++)\n        virCapabilitiesFreeGuestMachine(dom->info.machines[i]);\n    VIR_FREE(dom->info.machines);\n\n    VIR_FREE(dom);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesFreeGuestDomain(virCapsGuestDomainPtr dom)\n{\n    size_t i;\n    if (dom == NULL)\n        return;\n\n    VIR_FREE(dom->info.emulator);\n    VIR_FREE(dom->info.loader);\n    for (i = 0; i < dom->info.nmachines; i++)\n        virCapabilitiesFreeGuestMachine(dom->info.machines[i]);\n    VIR_FREE(dom->info.machines);\n\n    VIR_FREE(dom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "guest->arch.defaultInfo.machines"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFreeGuestMachine",
          "args": [
            "guest->arch.defaultInfo.machines[i]"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFreeGuestMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "127-135",
          "snippet": "static void\nvirCapabilitiesFreeGuestMachine(virCapsGuestMachinePtr machine)\n{\n    if (machine == NULL)\n        return;\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->canonical);\n    VIR_FREE(machine);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesFreeGuestMachine(virCapsGuestMachinePtr machine)\n{\n    if (machine == NULL)\n        return;\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->canonical);\n    VIR_FREE(machine);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "guest->arch.defaultInfo.loader"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "guest->arch.defaultInfo.emulator"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesFreeGuest(virCapsGuestPtr guest)\n{\n    size_t i;\n    if (guest == NULL)\n        return;\n\n    VIR_FREE(guest->arch.defaultInfo.emulator);\n    VIR_FREE(guest->arch.defaultInfo.loader);\n    for (i = 0; i < guest->arch.defaultInfo.nmachines; i++)\n        virCapabilitiesFreeGuestMachine(guest->arch.defaultInfo.machines[i]);\n    VIR_FREE(guest->arch.defaultInfo.machines);\n\n    for (i = 0; i < guest->arch.ndomains; i++)\n        virCapabilitiesFreeGuestDomain(guest->arch.domains[i]);\n    VIR_FREE(guest->arch.domains);\n\n    VIR_FREE(guest);\n}"
  },
  {
    "function_name": "virCapabilitiesFreeGuestDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "137-151",
    "snippet": "static void\nvirCapabilitiesFreeGuestDomain(virCapsGuestDomainPtr dom)\n{\n    size_t i;\n    if (dom == NULL)\n        return;\n\n    VIR_FREE(dom->info.emulator);\n    VIR_FREE(dom->info.loader);\n    for (i = 0; i < dom->info.nmachines; i++)\n        virCapabilitiesFreeGuestMachine(dom->info.machines[i]);\n    VIR_FREE(dom->info.machines);\n\n    VIR_FREE(dom);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dom"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dom->info.machines"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFreeGuestMachine",
          "args": [
            "dom->info.machines[i]"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFreeGuestMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "127-135",
          "snippet": "static void\nvirCapabilitiesFreeGuestMachine(virCapsGuestMachinePtr machine)\n{\n    if (machine == NULL)\n        return;\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->canonical);\n    VIR_FREE(machine);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesFreeGuestMachine(virCapsGuestMachinePtr machine)\n{\n    if (machine == NULL)\n        return;\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->canonical);\n    VIR_FREE(machine);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dom->info.loader"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dom->info.emulator"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesFreeGuestDomain(virCapsGuestDomainPtr dom)\n{\n    size_t i;\n    if (dom == NULL)\n        return;\n\n    VIR_FREE(dom->info.emulator);\n    VIR_FREE(dom->info.loader);\n    for (i = 0; i < dom->info.nmachines; i++)\n        virCapabilitiesFreeGuestMachine(dom->info.machines[i]);\n    VIR_FREE(dom->info.machines);\n\n    VIR_FREE(dom);\n}"
  },
  {
    "function_name": "virCapabilitiesFreeGuestMachine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "127-135",
    "snippet": "static void\nvirCapabilitiesFreeGuestMachine(virCapsGuestMachinePtr machine)\n{\n    if (machine == NULL)\n        return;\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->canonical);\n    VIR_FREE(machine);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine->canonical"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machine->name"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesFreeGuestMachine(virCapsGuestMachinePtr machine)\n{\n    if (machine == NULL)\n        return;\n    VIR_FREE(machine->name);\n    VIR_FREE(machine->canonical);\n    VIR_FREE(machine);\n}"
  },
  {
    "function_name": "virCapabilitiesFreeHostNUMACell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "113-125",
    "snippet": "static void\nvirCapabilitiesFreeHostNUMACell(virCapsHostNUMACellPtr cell)\n{\n    if (cell == NULL)\n        return;\n\n    virCapabilitiesClearHostNUMACellCPUTopology(cell->cpus, cell->ncpus);\n\n    VIR_FREE(cell->cpus);\n    VIR_FREE(cell->siblings);\n    VIR_FREE(cell->pageinfo);\n    VIR_FREE(cell);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cell"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cell->pageinfo"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cell->siblings"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cell->cpus"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesClearHostNUMACellCPUTopology",
          "args": [
            "cell->cpus",
            "cell->ncpus"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesClearHostNUMACellCPUTopology",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "98-111",
          "snippet": "void\nvirCapabilitiesClearHostNUMACellCPUTopology(virCapsHostNUMACellCPUPtr cpus,\n                                            size_t ncpus)\n{\n    size_t i;\n\n    if (!cpus)\n        return;\n\n    for (i = 0; i < ncpus; i++) {\n        virBitmapFree(cpus[i].siblings);\n        cpus[i].siblings = NULL;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesClearHostNUMACellCPUTopology(virCapsHostNUMACellCPUPtr cpus,\n                                            size_t ncpus)\n{\n    size_t i;\n\n    if (!cpus)\n        return;\n\n    for (i = 0; i < ncpus; i++) {\n        virBitmapFree(cpus[i].siblings);\n        cpus[i].siblings = NULL;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvirCapabilitiesFreeHostNUMACell(virCapsHostNUMACellPtr cell)\n{\n    if (cell == NULL)\n        return;\n\n    virCapabilitiesClearHostNUMACellCPUTopology(cell->cpus, cell->ncpus);\n\n    VIR_FREE(cell->cpus);\n    VIR_FREE(cell->siblings);\n    VIR_FREE(cell->pageinfo);\n    VIR_FREE(cell);\n}"
  },
  {
    "function_name": "virCapabilitiesClearHostNUMACellCPUTopology",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "98-111",
    "snippet": "void\nvirCapabilitiesClearHostNUMACellCPUTopology(virCapsHostNUMACellCPUPtr cpus,\n                                            size_t ncpus)\n{\n    size_t i;\n\n    if (!cpus)\n        return;\n\n    for (i = 0; i < ncpus; i++) {\n        virBitmapFree(cpus[i].siblings);\n        cpus[i].siblings = NULL;\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "cpus[i].siblings"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesClearHostNUMACellCPUTopology(virCapsHostNUMACellCPUPtr cpus,\n                                            size_t ncpus)\n{\n    size_t i;\n\n    if (!cpus)\n        return;\n\n    for (i = 0; i < ncpus; i++) {\n        virBitmapFree(cpus[i].siblings);\n        cpus[i].siblings = NULL;\n    }\n}"
  },
  {
    "function_name": "virCapabilitiesNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "78-96",
    "snippet": "virCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virCapsClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "virCapsClass"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesInitialize",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virCapsClass;\n\nvirCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}"
  },
  {
    "function_name": "virCapabilitiesOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
    "lines": "60-66",
    "snippet": "static int virCapabilitiesOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virCaps, virClassForObject()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virenum.h\"",
      "#include \"viruuid.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virnuma.h\"",
      "#include \"virlog.h\"",
      "#include \"virhostmem.h\"",
      "#include \"virhostcpu.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virarch.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"domain_conf.h\"",
      "#include \"cpu_conf.h\"",
      "#include \"capabilities.h\"",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virCaps",
            "virClassForObject()"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObject",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectEvent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "110-116",
          "snippet": "virClassPtr\nvirClassForObjectEvent(void)\n{\n    if (virObjectEventInitialize() < 0)\n        return NULL;\n    return virObjectEventClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectEventClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectEventClass;\n\nvirClassPtr\nvirClassForObjectEvent(void)\n{\n    if (virObjectEventInitialize() < 0)\n        return NULL;\n    return virObjectEventClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic int virCapabilitiesOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virCaps, virClassForObject()))\n        return -1;\n\n    return 0;\n}"
  }
]