[
  {
    "function_name": "virStorageBackendGlusterRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
    "lines": "531-538",
    "snippet": "int\nvirStorageBackendGlusterRegister(void)\n{\n    if (virStorageBackendRegister(&virStorageBackendGluster) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_gluster.h\"",
      "#include <glusterfs/api/glfs.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virStorageBackend virStorageBackendGluster = {\n    .type = VIR_STORAGE_POOL_GLUSTER,\n\n    .checkPool = virStorageBackendGlusterCheckPool,\n    .refreshPool = virStorageBackendGlusterRefreshPool,\n    .findPoolSources = virStorageBackendGlusterFindPoolSources,\n\n    .deleteVol = virStorageBackendGlusterVolDelete,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendRegister",
          "args": [
            "&virStorageBackendGluster"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend.c",
          "lines": "153-169",
          "snippet": "int\nvirStorageBackendRegister(virStorageBackendPtr backend)\n{\n    VIR_DEBUG(\"Registering storage backend '%s'\",\n              virStoragePoolTypeToString(backend->type));\n\n    if (virStorageBackendsCount >= VIR_STORAGE_BACKENDS_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register storage backend '%s'\"),\n                       virStoragePoolTypeToString(backend->type));\n        return -1;\n    }\n\n    virStorageBackends[virStorageBackendsCount] = backend;\n    virStorageBackendsCount++;\n    return 0;\n}",
          "includes": [
            "# include \"storage_backend_vstorage.h\"",
            "# include \"storage_backend_zfs.h\"",
            "# include \"storage_backend_gluster.h\"",
            "# include \"storage_backend_sheepdog.h\"",
            "# include \"storage_backend_rbd.h\"",
            "# include \"storage_backend_fs.h\"",
            "# include \"storage_backend_disk.h\"",
            "# include \"storage_backend_mpath.h\"",
            "# include \"storage_backend_scsi.h\"",
            "# include \"storage_backend_iscsi_direct.h\"",
            "# include \"storage_backend_iscsi.h\"",
            "# include \"storage_backend_logical.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_backend.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_STORAGE_BACKENDS_MAX 20"
          ],
          "globals_used": [
            "static virStorageBackendPtr virStorageBackends[VIR_STORAGE_BACKENDS_MAX];",
            "static size_t virStorageBackendsCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include \"storage_backend_vstorage.h\"\n# include \"storage_backend_zfs.h\"\n# include \"storage_backend_gluster.h\"\n# include \"storage_backend_sheepdog.h\"\n# include \"storage_backend_rbd.h\"\n# include \"storage_backend_fs.h\"\n# include \"storage_backend_disk.h\"\n# include \"storage_backend_mpath.h\"\n# include \"storage_backend_scsi.h\"\n# include \"storage_backend_iscsi_direct.h\"\n# include \"storage_backend_iscsi.h\"\n# include \"storage_backend_logical.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"storage_backend.h\"\n#include \"virstoragefile.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\n#define VIR_STORAGE_BACKENDS_MAX 20\n\nstatic virStorageBackendPtr virStorageBackends[VIR_STORAGE_BACKENDS_MAX];\nstatic size_t virStorageBackendsCount;\n\nint\nvirStorageBackendRegister(virStorageBackendPtr backend)\n{\n    VIR_DEBUG(\"Registering storage backend '%s'\",\n              virStoragePoolTypeToString(backend->type));\n\n    if (virStorageBackendsCount >= VIR_STORAGE_BACKENDS_MAX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register storage backend '%s'\"),\n                       virStoragePoolTypeToString(backend->type));\n        return -1;\n    }\n\n    virStorageBackends[virStorageBackendsCount] = backend;\n    virStorageBackendsCount++;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nvirStorageBackend virStorageBackendGluster = {\n    .type = VIR_STORAGE_POOL_GLUSTER,\n\n    .checkPool = virStorageBackendGlusterCheckPool,\n    .refreshPool = virStorageBackendGlusterRefreshPool,\n    .findPoolSources = virStorageBackendGlusterFindPoolSources,\n\n    .deleteVol = virStorageBackendGlusterVolDelete,\n};\n\nint\nvirStorageBackendGlusterRegister(void)\n{\n    if (virStorageBackendRegister(&virStorageBackendGluster) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendGlusterCheckPool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
    "lines": "508-517",
    "snippet": "static int\nvirStorageBackendGlusterCheckPool(virStoragePoolObjPtr pool,\n                                  bool *active)\n{\n    /* Return previous state remembered by the status XML. If the pool is not\n     * available we will fail to refresh it and end up in the same situation.\n     * This will save one attempt to open the connection to the remote server */\n    *active = virStoragePoolObjIsActive(pool);\n    return 0;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_gluster.h\"",
      "#include <glusterfs/api/glfs.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStoragePoolObjIsActive",
          "args": [
            "pool"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "301-305",
          "snippet": "bool\nvirStoragePoolObjIsActive(virStoragePoolObjPtr obj)\n{\n    return obj->active;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nbool\nvirStoragePoolObjIsActive(virStoragePoolObjPtr obj)\n{\n    return obj->active;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendGlusterCheckPool(virStoragePoolObjPtr pool,\n                                  bool *active)\n{\n    /* Return previous state remembered by the status XML. If the pool is not\n     * available we will fail to refresh it and end up in the same situation.\n     * This will save one attempt to open the connection to the remote server */\n    *active = virStoragePoolObjIsActive(pool);\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendGlusterFindPoolSources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
    "lines": "453-505",
    "snippet": "static char *\nvirStorageBackendGlusterFindPoolSources(const char *srcSpec,\n                                        unsigned int flags)\n{\n    virStoragePoolSourceList list = { .type = VIR_STORAGE_POOL_GLUSTER,\n                                      .nsources = 0,\n                                      .sources = NULL\n                                    };\n    char *ret = NULL;\n    int rc;\n    size_t i;\n    g_autoptr(virStoragePoolSource) source = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (!srcSpec) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"hostname must be specified for gluster sources\"));\n        return NULL;\n    }\n\n    if (!(source = virStoragePoolDefParseSourceString(srcSpec,\n                                                      VIR_STORAGE_POOL_GLUSTER)))\n        return NULL;\n\n    if (source->nhost != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Expected exactly 1 host for the storage pool\"));\n        goto cleanup;\n    }\n\n    if ((rc = virStorageBackendFindGlusterPoolSources(source->hosts[0].name,\n                                                      VIR_STORAGE_POOL_GLUSTER,\n                                                      &list, true)) < 0)\n        goto cleanup;\n\n    if (rc == 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"no storage pools were found on host '%s'\"),\n                       source->hosts[0].name);\n        goto cleanup;\n    }\n\n    if (!(ret = virStoragePoolSourceListFormat(&list)))\n        goto cleanup;\n\n cleanup:\n    for (i = 0; i < list.nsources; i++)\n        virStoragePoolSourceClear(&list.sources[i]);\n    VIR_FREE(list.sources);\n\n    return ret;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_gluster.h\"",
      "#include <glusterfs/api/glfs.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "list.sources"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolSourceClear",
          "args": [
            "&list.sources[i]"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolSourceClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "471-493",
          "snippet": "void\nvirStoragePoolSourceClear(virStoragePoolSourcePtr source)\n{\n    size_t i;\n\n    if (!source)\n        return;\n\n    for (i = 0; i < source->nhost; i++)\n        VIR_FREE(source->hosts[i].name);\n    VIR_FREE(source->hosts);\n\n    for (i = 0; i < source->ndevice; i++)\n        virStoragePoolSourceDeviceClear(&source->devices[i]);\n    VIR_FREE(source->devices);\n    VIR_FREE(source->dir);\n    VIR_FREE(source->name);\n    virStorageAdapterClear(&source->adapter);\n    virStorageSourceInitiatorClear(&source->initiator);\n    virStorageAuthDefFree(source->auth);\n    VIR_FREE(source->vendor);\n    VIR_FREE(source->product);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirStoragePoolSourceClear(virStoragePoolSourcePtr source)\n{\n    size_t i;\n\n    if (!source)\n        return;\n\n    for (i = 0; i < source->nhost; i++)\n        VIR_FREE(source->hosts[i].name);\n    VIR_FREE(source->hosts);\n\n    for (i = 0; i < source->ndevice; i++)\n        virStoragePoolSourceDeviceClear(&source->devices[i]);\n    VIR_FREE(source->devices);\n    VIR_FREE(source->dir);\n    VIR_FREE(source->name);\n    virStorageAdapterClear(&source->adapter);\n    virStorageSourceInitiatorClear(&source->initiator);\n    virStorageAuthDefFree(source->auth);\n    VIR_FREE(source->vendor);\n    VIR_FREE(source->product);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStoragePoolSourceListFormat",
          "args": [
            "&list"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolSourceListFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "1744-1777",
          "snippet": "char *\nvirStoragePoolSourceListFormat(virStoragePoolSourceListPtr def)\n{\n    virStoragePoolOptionsPtr options;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *type;\n    size_t i;\n\n    options = virStoragePoolOptionsForPoolType(def->type);\n    if (options == NULL)\n        return NULL;\n\n    type = virStoragePoolTypeToString(def->type);\n    if (!type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unexpected pool type\"));\n        goto cleanup;\n    }\n\n    virBufferAddLit(&buf, \"<sources>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    for (i = 0; i < def->nsources; i++)\n        virStoragePoolSourceFormat(&buf, options, &def->sources[i]);\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</sources>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirStoragePoolSourceListFormat(virStoragePoolSourceListPtr def)\n{\n    virStoragePoolOptionsPtr options;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *type;\n    size_t i;\n\n    options = virStoragePoolOptionsForPoolType(def->type);\n    if (options == NULL)\n        return NULL;\n\n    type = virStoragePoolTypeToString(def->type);\n    if (!type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unexpected pool type\"));\n        goto cleanup;\n    }\n\n    virBufferAddLit(&buf, \"<sources>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    for (i = 0; i < def->nsources; i++)\n        virStoragePoolSourceFormat(&buf, options, &def->sources[i]);\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</sources>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"no storage pools were found on host '%s'\")",
            "source->hosts[0].name"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no storage pools were found on host '%s'\""
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendFindGlusterPoolSources",
          "args": [
            "source->hosts[0].name",
            "VIR_STORAGE_POOL_GLUSTER",
            "&list",
            "true"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendFindGlusterPoolSources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "2883-2919",
          "snippet": "int\nvirStorageBackendFindGlusterPoolSources(const char *host,\n                                        virStoragePoolType pooltype,\n                                        virStoragePoolSourceListPtr list,\n                                        bool report)\n{\n    int rc;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *glusterpath = NULL;\n    g_autofree char *outbuf = NULL;\n\n    if (!(glusterpath = virFindFileInPath(\"gluster\"))) {\n        if (report) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"'gluster' command line tool not found\"));\n            return -1;\n        } else {\n            return 0;\n        }\n    }\n\n    cmd = virCommandNewArgList(glusterpath,\n                               \"--xml\",\n                               \"--log-file=/dev/null\",\n                               \"volume\", \"info\", \"all\", NULL);\n\n    virCommandAddArgFormat(cmd, \"--remote-host=%s\", host);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n\n    if (virCommandRun(cmd, &rc) < 0)\n        return -1;\n\n    if (rc != 0)\n        return 0;\n\n    return virStorageUtilGlusterExtractPoolSources(host, outbuf, list, pooltype);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendFindGlusterPoolSources(const char *host,\n                                        virStoragePoolType pooltype,\n                                        virStoragePoolSourceListPtr list,\n                                        bool report)\n{\n    int rc;\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *glusterpath = NULL;\n    g_autofree char *outbuf = NULL;\n\n    if (!(glusterpath = virFindFileInPath(\"gluster\"))) {\n        if (report) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"'gluster' command line tool not found\"));\n            return -1;\n        } else {\n            return 0;\n        }\n    }\n\n    cmd = virCommandNewArgList(glusterpath,\n                               \"--xml\",\n                               \"--log-file=/dev/null\",\n                               \"volume\", \"info\", \"all\", NULL);\n\n    virCommandAddArgFormat(cmd, \"--remote-host=%s\", host);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n\n    if (virCommandRun(cmd, &rc) < 0)\n        return -1;\n\n    if (rc != 0)\n        return 0;\n\n    return virStorageUtilGlusterExtractPoolSources(host, outbuf, list, pooltype);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Expected exactly 1 host for the storage pool\")"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolDefParseSourceString",
          "args": [
            "srcSpec",
            "VIR_STORAGE_POOL_GLUSTER"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolDefParseSourceString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/storage_conf.c",
          "lines": "692-720",
          "snippet": "virStoragePoolSourcePtr\nvirStoragePoolDefParseSourceString(const char *srcSpec,\n                                   int pool_type)\n{\n    g_autoptr(xmlDoc) doc = NULL;\n    xmlNodePtr node = NULL;\n    g_autoptr(xmlXPathContext) xpath_ctxt = NULL;\n    g_autoptr(virStoragePoolSource) def = NULL;\n\n    if (!(doc = virXMLParseStringCtxt(srcSpec,\n                                      _(\"(storage_source_specification)\"),\n                                      &xpath_ctxt)))\n        return NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (!(node = virXPathNode(\"/source\", xpath_ctxt))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"root element was not source\"));\n        return NULL;\n    }\n\n    if (virStoragePoolDefParseSource(xpath_ctxt, def, pool_type,\n                                     node) < 0)\n        return NULL;\n\n    return g_steal_pointer(&def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virvhba.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_adapter_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virvhba.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"storage_adapter_conf.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirStoragePoolSourcePtr\nvirStoragePoolDefParseSourceString(const char *srcSpec,\n                                   int pool_type)\n{\n    g_autoptr(xmlDoc) doc = NULL;\n    xmlNodePtr node = NULL;\n    g_autoptr(xmlXPathContext) xpath_ctxt = NULL;\n    g_autoptr(virStoragePoolSource) def = NULL;\n\n    if (!(doc = virXMLParseStringCtxt(srcSpec,\n                                      _(\"(storage_source_specification)\"),\n                                      &xpath_ctxt)))\n        return NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (!(node = virXPathNode(\"/source\", xpath_ctxt))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"root element was not source\"));\n        return NULL;\n    }\n\n    if (virStoragePoolDefParseSource(xpath_ctxt, def, pool_type,\n                                     node) < 0)\n        return NULL;\n\n    return g_steal_pointer(&def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"hostname must be specified for gluster sources\")"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic char *\nvirStorageBackendGlusterFindPoolSources(const char *srcSpec,\n                                        unsigned int flags)\n{\n    virStoragePoolSourceList list = { .type = VIR_STORAGE_POOL_GLUSTER,\n                                      .nsources = 0,\n                                      .sources = NULL\n                                    };\n    char *ret = NULL;\n    int rc;\n    size_t i;\n    g_autoptr(virStoragePoolSource) source = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (!srcSpec) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"hostname must be specified for gluster sources\"));\n        return NULL;\n    }\n\n    if (!(source = virStoragePoolDefParseSourceString(srcSpec,\n                                                      VIR_STORAGE_POOL_GLUSTER)))\n        return NULL;\n\n    if (source->nhost != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Expected exactly 1 host for the storage pool\"));\n        goto cleanup;\n    }\n\n    if ((rc = virStorageBackendFindGlusterPoolSources(source->hosts[0].name,\n                                                      VIR_STORAGE_POOL_GLUSTER,\n                                                      &list, true)) < 0)\n        goto cleanup;\n\n    if (rc == 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"no storage pools were found on host '%s'\"),\n                       source->hosts[0].name);\n        goto cleanup;\n    }\n\n    if (!(ret = virStoragePoolSourceListFormat(&list)))\n        goto cleanup;\n\n cleanup:\n    for (i = 0; i < list.nsources; i++)\n        virStoragePoolSourceClear(&list.sources[i]);\n    VIR_FREE(list.sources);\n\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendGlusterVolDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
    "lines": "392-450",
    "snippet": "static int\nvirStorageBackendGlusterVolDelete(virStoragePoolObjPtr pool,\n                                  virStorageVolDefPtr vol,\n                                  unsigned int flags)\n{\n    virStorageBackendGlusterStatePtr state = NULL;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    switch ((virStorageVolType)vol->type) {\n    case VIR_STORAGE_VOL_FILE:\n    case VIR_STORAGE_VOL_DIR:\n    case VIR_STORAGE_VOL_BLOCK:\n    case VIR_STORAGE_VOL_PLOOP:\n    case VIR_STORAGE_VOL_LAST:\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"removing of '%s' volumes is not supported \"\n                         \"by the gluster backend: %s\"),\n                       virStorageVolTypeToString(vol->type),\n                       vol->target.path);\n        goto cleanup;\n        break;\n\n    case VIR_STORAGE_VOL_NETWORK:\n        if (!(state = virStorageBackendGlusterOpen(pool)))\n            goto cleanup;\n\n        if (glfs_unlink(state->vol, vol->name) < 0) {\n            if (errno != ENOENT) {\n                virReportSystemError(errno,\n                                     _(\"cannot remove gluster volume file '%s'\"),\n                                     vol->target.path);\n                goto cleanup;\n            }\n        }\n        break;\n\n    case VIR_STORAGE_VOL_NETDIR:\n        if (!(state = virStorageBackendGlusterOpen(pool)))\n            goto cleanup;\n\n        if (glfs_rmdir(state->vol, vol->target.path) < 0) {\n            if (errno != ENOENT) {\n                virReportSystemError(errno,\n                                     _(\"cannot remove gluster volume dir '%s'\"),\n                                     vol->target.path);\n                goto cleanup;\n            }\n        }\n        break;\n    }\n\n    ret = 0;\n\n cleanup:\n    virStorageBackendGlusterClose(state);\n    return ret;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_gluster.h\"",
      "#include <glusterfs/api/glfs.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendGlusterClose",
          "args": [
            "state"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendGlusterClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
          "lines": "53-70",
          "snippet": "static void\nvirStorageBackendGlusterClose(virStorageBackendGlusterStatePtr state)\n{\n    if (!state)\n        return;\n\n    /* Yuck - glusterfs-api-3.4.1 appears to always return -1 for\n     * glfs_fini, with errno containing random data, so there's no way\n     * to tell if it succeeded. 3.4.2 is supposed to fix this.*/\n    if (state->vol && glfs_fini(state->vol) < 0)\n        VIR_DEBUG(\"shutdown of gluster volume %s failed with errno %d\",\n                  state->volname, errno);\n\n    virURIFree(state->uri);\n    VIR_FREE(state->volname);\n    VIR_FREE(state->dir);\n    VIR_FREE(state);\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_gluster.h\"",
            "#include <glusterfs/api/glfs.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendGlusterClose(virStorageBackendGlusterStatePtr state)\n{\n    if (!state)\n        return;\n\n    /* Yuck - glusterfs-api-3.4.1 appears to always return -1 for\n     * glfs_fini, with errno containing random data, so there's no way\n     * to tell if it succeeded. 3.4.2 is supposed to fix this.*/\n    if (state->vol && glfs_fini(state->vol) < 0)\n        VIR_DEBUG(\"shutdown of gluster volume %s failed with errno %d\",\n                  state->volname, errno);\n\n    virURIFree(state->uri);\n    VIR_FREE(state->volname);\n    VIR_FREE(state->dir);\n    VIR_FREE(state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot remove gluster volume dir '%s'\")",
            "vol->target.path"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot remove gluster volume dir '%s'\""
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "glfs_rmdir",
          "args": [
            "state->vol",
            "vol->target.path"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendGlusterOpen",
          "args": [
            "pool"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendGlusterOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
          "lines": "72-142",
          "snippet": "static virStorageBackendGlusterStatePtr\nvirStorageBackendGlusterOpen(virStoragePoolObjPtr pool)\n{\n    virStorageBackendGlusterStatePtr ret = NULL;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    const char *name = def->source.name;\n    const char *dir = def->source.dir;\n    bool trailing_slash = true;\n\n    /* Volume name must not contain '/'; optional path allows use of a\n     * subdirectory within the volume name.  */\n    if (strchr(name, '/')) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"gluster pool name '%s' must not contain /\"),\n                       name);\n        return NULL;\n    }\n    if (dir) {\n        if (*dir != '/') {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"gluster pool path '%s' must start with /\"),\n                           dir);\n            return NULL;\n        }\n        if (strchr(dir, '\\0')[-1] != '/')\n            trailing_slash = false;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->volname = g_strdup(name);\n    ret->dir = g_strdup_printf(\"%s%s\", dir ? dir : \"/\", trailing_slash ? \"\" : \"/\");\n\n    /* FIXME: Currently hard-coded to tcp transport; XML needs to be\n     * extended to allow alternate transport */\n    if (VIR_ALLOC(ret->uri) < 0)\n        goto error;\n    ret->uri->scheme = g_strdup(\"gluster\");\n    ret->uri->server = g_strdup(def->source.hosts[0].name);\n    ret->uri->path = g_strdup_printf(\"/%s%s\", ret->volname, ret->dir);\n    ret->uri->port = def->source.hosts[0].port;\n\n    /* Actually connect to glfs */\n    if (!(ret->vol = glfs_new(ret->volname))) {\n        virReportOOMError();\n        goto error;\n    }\n\n    if (glfs_set_volfile_server(ret->vol, \"tcp\",\n                                ret->uri->server, ret->uri->port) < 0 ||\n        glfs_init(ret->vol) < 0) {\n        g_autofree char *uri = NULL;\n        uri = virURIFormat(ret->uri);\n        virReportSystemError(errno, _(\"failed to connect to %s\"), NULLSTR(uri));\n        goto error;\n    }\n\n    if (glfs_chdir(ret->vol, ret->dir) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to change to directory '%s' in '%s'\"),\n                             ret->dir, ret->volname);\n        goto error;\n    }\n\n    return ret;\n\n error:\n    virStorageBackendGlusterClose(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_gluster.h\"",
            "#include <glusterfs/api/glfs.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic virStorageBackendGlusterStatePtr\nvirStorageBackendGlusterOpen(virStoragePoolObjPtr pool)\n{\n    virStorageBackendGlusterStatePtr ret = NULL;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    const char *name = def->source.name;\n    const char *dir = def->source.dir;\n    bool trailing_slash = true;\n\n    /* Volume name must not contain '/'; optional path allows use of a\n     * subdirectory within the volume name.  */\n    if (strchr(name, '/')) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"gluster pool name '%s' must not contain /\"),\n                       name);\n        return NULL;\n    }\n    if (dir) {\n        if (*dir != '/') {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"gluster pool path '%s' must start with /\"),\n                           dir);\n            return NULL;\n        }\n        if (strchr(dir, '\\0')[-1] != '/')\n            trailing_slash = false;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->volname = g_strdup(name);\n    ret->dir = g_strdup_printf(\"%s%s\", dir ? dir : \"/\", trailing_slash ? \"\" : \"/\");\n\n    /* FIXME: Currently hard-coded to tcp transport; XML needs to be\n     * extended to allow alternate transport */\n    if (VIR_ALLOC(ret->uri) < 0)\n        goto error;\n    ret->uri->scheme = g_strdup(\"gluster\");\n    ret->uri->server = g_strdup(def->source.hosts[0].name);\n    ret->uri->path = g_strdup_printf(\"/%s%s\", ret->volname, ret->dir);\n    ret->uri->port = def->source.hosts[0].port;\n\n    /* Actually connect to glfs */\n    if (!(ret->vol = glfs_new(ret->volname))) {\n        virReportOOMError();\n        goto error;\n    }\n\n    if (glfs_set_volfile_server(ret->vol, \"tcp\",\n                                ret->uri->server, ret->uri->port) < 0 ||\n        glfs_init(ret->vol) < 0) {\n        g_autofree char *uri = NULL;\n        uri = virURIFormat(ret->uri);\n        virReportSystemError(errno, _(\"failed to connect to %s\"), NULLSTR(uri));\n        goto error;\n    }\n\n    if (glfs_chdir(ret->vol, ret->dir) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to change to directory '%s' in '%s'\"),\n                             ret->dir, ret->volname);\n        goto error;\n    }\n\n    return ret;\n\n error:\n    virStorageBackendGlusterClose(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot remove gluster volume file '%s'\")",
            "vol->target.path"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "glfs_unlink",
          "args": [
            "state->vol",
            "vol->name"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"removing of '%s' volumes is not supported \"\n                         \"by the gluster backend: %s\")",
            "virStorageVolTypeToString(vol->type)",
            "vol->target.path"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageVolTypeToString",
          "args": [
            "vol->type"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendGlusterVolDelete(virStoragePoolObjPtr pool,\n                                  virStorageVolDefPtr vol,\n                                  unsigned int flags)\n{\n    virStorageBackendGlusterStatePtr state = NULL;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    switch ((virStorageVolType)vol->type) {\n    case VIR_STORAGE_VOL_FILE:\n    case VIR_STORAGE_VOL_DIR:\n    case VIR_STORAGE_VOL_BLOCK:\n    case VIR_STORAGE_VOL_PLOOP:\n    case VIR_STORAGE_VOL_LAST:\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"removing of '%s' volumes is not supported \"\n                         \"by the gluster backend: %s\"),\n                       virStorageVolTypeToString(vol->type),\n                       vol->target.path);\n        goto cleanup;\n        break;\n\n    case VIR_STORAGE_VOL_NETWORK:\n        if (!(state = virStorageBackendGlusterOpen(pool)))\n            goto cleanup;\n\n        if (glfs_unlink(state->vol, vol->name) < 0) {\n            if (errno != ENOENT) {\n                virReportSystemError(errno,\n                                     _(\"cannot remove gluster volume file '%s'\"),\n                                     vol->target.path);\n                goto cleanup;\n            }\n        }\n        break;\n\n    case VIR_STORAGE_VOL_NETDIR:\n        if (!(state = virStorageBackendGlusterOpen(pool)))\n            goto cleanup;\n\n        if (glfs_rmdir(state->vol, vol->target.path) < 0) {\n            if (errno != ENOENT) {\n                virReportSystemError(errno,\n                                     _(\"cannot remove gluster volume dir '%s'\"),\n                                     vol->target.path);\n                goto cleanup;\n            }\n        }\n        break;\n    }\n\n    ret = 0;\n\n cleanup:\n    virStorageBackendGlusterClose(state);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendGlusterRefreshPool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
    "lines": "314-389",
    "snippet": "static int\nvirStorageBackendGlusterRefreshPool(virStoragePoolObjPtr pool)\n{\n    int ret = -1;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStorageBackendGlusterStatePtr state = NULL;\n    struct {\n        struct dirent ent;\n        /* See comment below about readdir_r needing padding */\n        char padding[MAX(1, 256 - (int)(sizeof(struct dirent)\n                                         - offsetof(struct dirent, d_name)))];\n    } de;\n    struct dirent *ent;\n    glfs_fd_t *dir = NULL;\n    struct stat st;\n    struct statvfs sb;\n\n    if (!(state = virStorageBackendGlusterOpen(pool)))\n        goto cleanup;\n\n    /* Why oh why did glfs 3.4 decide to expose only readdir_r rather\n     * than readdir?  POSIX admits that readdir_r is inherently a\n     * flawed design, because systems are not required to define\n     * NAME_MAX: http://austingroupbugs.net/view.php?id=696\n     * http://womble.decadent.org.uk/readdir_r-advisory.html\n     *\n     * Fortunately, gluster appears to limit its underlying bricks to\n     * only use file systems such as XFS that have a NAME_MAX of 255;\n     * so we are currently guaranteed that if we provide 256 bytes of\n     * tail padding, then we should have enough space to avoid buffer\n     * overflow no matter whether the OS used d_name[], d_name[1], or\n     * d_name[256] in its 'struct dirent'.\n     * http://lists.gnu.org/archive/html/gluster-devel/2013-10/msg00083.html\n     */\n\n    if (!(dir = glfs_opendir(state->vol, state->dir))) {\n        virReportSystemError(errno, _(\"cannot open path '%s' in '%s'\"),\n                             state->dir, state->volname);\n        goto cleanup;\n    }\n    while (!(errno = glfs_readdirplus_r(dir, &st, &de.ent, &ent)) && ent) {\n        virStorageVolDefPtr vol;\n        int okay = virStorageBackendGlusterRefreshVol(state,\n                                                      ent->d_name, &st,\n                                                      &vol);\n\n        if (okay < 0)\n            goto cleanup;\n        if (vol && virStoragePoolObjAddVol(pool, vol) < 0)\n            goto cleanup;\n    }\n    if (errno) {\n        virReportSystemError(errno, _(\"failed to read directory '%s' in '%s'\"),\n                             state->dir, state->volname);\n        goto cleanup;\n    }\n\n    if (glfs_statvfs(state->vol, state->dir, &sb) < 0) {\n        virReportSystemError(errno, _(\"cannot statvfs path '%s' in '%s'\"),\n                             state->dir, state->volname);\n        goto cleanup;\n    }\n\n    def->capacity = ((unsigned long long)sb.f_frsize *\n                     (unsigned long long)sb.f_blocks);\n    def->available = ((unsigned long long)sb.f_bfree *\n                      (unsigned long long)sb.f_frsize);\n    def->allocation = def->capacity - def->available;\n\n    ret = 0;\n cleanup:\n    if (dir)\n        glfs_closedir(dir);\n    virStorageBackendGlusterClose(state);\n    return ret;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_gluster.h\"",
      "#include <glusterfs/api/glfs.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendGlusterClose",
          "args": [
            "state"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendGlusterClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
          "lines": "53-70",
          "snippet": "static void\nvirStorageBackendGlusterClose(virStorageBackendGlusterStatePtr state)\n{\n    if (!state)\n        return;\n\n    /* Yuck - glusterfs-api-3.4.1 appears to always return -1 for\n     * glfs_fini, with errno containing random data, so there's no way\n     * to tell if it succeeded. 3.4.2 is supposed to fix this.*/\n    if (state->vol && glfs_fini(state->vol) < 0)\n        VIR_DEBUG(\"shutdown of gluster volume %s failed with errno %d\",\n                  state->volname, errno);\n\n    virURIFree(state->uri);\n    VIR_FREE(state->volname);\n    VIR_FREE(state->dir);\n    VIR_FREE(state);\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_gluster.h\"",
            "#include <glusterfs/api/glfs.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendGlusterClose(virStorageBackendGlusterStatePtr state)\n{\n    if (!state)\n        return;\n\n    /* Yuck - glusterfs-api-3.4.1 appears to always return -1 for\n     * glfs_fini, with errno containing random data, so there's no way\n     * to tell if it succeeded. 3.4.2 is supposed to fix this.*/\n    if (state->vol && glfs_fini(state->vol) < 0)\n        VIR_DEBUG(\"shutdown of gluster volume %s failed with errno %d\",\n                  state->volname, errno);\n\n    virURIFree(state->uri);\n    VIR_FREE(state->volname);\n    VIR_FREE(state->dir);\n    VIR_FREE(state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "glfs_closedir",
          "args": [
            "dir"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot statvfs path '%s' in '%s'\")",
            "state->dir",
            "state->volname"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot statvfs path '%s' in '%s'\""
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "glfs_statvfs",
          "args": [
            "state->vol",
            "state->dir",
            "&sb"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to read directory '%s' in '%s'\")",
            "state->dir",
            "state->volname"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjAddVol",
          "args": [
            "pool",
            "vol"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjAddVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "641-679",
          "snippet": "int\nvirStoragePoolObjAddVol(virStoragePoolObjPtr obj,\n                        virStorageVolDefPtr voldef)\n{\n    virStorageVolObjPtr volobj = NULL;\n    virStorageVolObjListPtr volumes = obj->volumes;\n\n    virObjectRWLockWrite(volumes);\n\n    if (!(volobj = virStorageVolObjNew()))\n        goto error;\n\n    if (virHashAddEntry(volumes->objsKey, voldef->key, volobj) < 0)\n        goto error;\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsName, voldef->name, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsPath, voldef->target.path, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        virHashRemoveEntry(volumes->objsName, voldef->name);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    volobj->voldef = voldef;\n    virObjectRWUnlock(volumes);\n    virStorageVolObjEndAPI(&volobj);\n    return 0;\n\n error:\n    virStorageVolObjEndAPI(&volobj);\n    virObjectRWUnlock(volumes);\n    return -1;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nint\nvirStoragePoolObjAddVol(virStoragePoolObjPtr obj,\n                        virStorageVolDefPtr voldef)\n{\n    virStorageVolObjPtr volobj = NULL;\n    virStorageVolObjListPtr volumes = obj->volumes;\n\n    virObjectRWLockWrite(volumes);\n\n    if (!(volobj = virStorageVolObjNew()))\n        goto error;\n\n    if (virHashAddEntry(volumes->objsKey, voldef->key, volobj) < 0)\n        goto error;\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsName, voldef->name, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    if (virHashAddEntry(volumes->objsPath, voldef->target.path, volobj) < 0) {\n        virHashRemoveEntry(volumes->objsKey, voldef->key);\n        virHashRemoveEntry(volumes->objsName, voldef->name);\n        goto error;\n    }\n    virObjectRef(volobj);\n\n    volobj->voldef = voldef;\n    virObjectRWUnlock(volumes);\n    virStorageVolObjEndAPI(&volobj);\n    return 0;\n\n error:\n    virStorageVolObjEndAPI(&volobj);\n    virObjectRWUnlock(volumes);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendGlusterRefreshVol",
          "args": [
            "state",
            "ent->d_name",
            "&st",
            "&vol"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendGlusterRefreshVol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
          "lines": "218-312",
          "snippet": "static int\nvirStorageBackendGlusterRefreshVol(virStorageBackendGlusterStatePtr state,\n                                   const char *name,\n                                   struct stat *st,\n                                   virStorageVolDefPtr *volptr)\n{\n    int ret = -1;\n    glfs_fd_t *fd = NULL;\n    ssize_t len;\n    g_autoptr(virStorageVolDef) vol = NULL;\n    g_autoptr(virStorageSource) meta = NULL;\n    g_autofree char *header = NULL;\n\n    *volptr = NULL;\n\n    /* Silently skip '.' and '..'.  */\n    if (STREQ(name, \".\") || STREQ(name, \"..\"))\n        return 0;\n\n    /* Follow symlinks; silently skip broken links and loops.  */\n    if (S_ISLNK(st->st_mode) && glfs_stat(state->vol, name, st) < 0) {\n        if (errno == ENOENT || errno == ELOOP) {\n            VIR_WARN(\"ignoring dangling symlink '%s'\", name);\n            ret = 0;\n        } else {\n            virReportSystemError(errno, _(\"cannot stat '%s'\"), name);\n        }\n        return ret;\n    }\n\n    if (VIR_ALLOC(vol) < 0)\n        goto cleanup;\n\n    if (virStorageBackendUpdateVolTargetInfoFD(&vol->target, -1, st) < 0)\n        goto cleanup;\n\n    if (virStorageBackendGlusterSetMetadata(state, vol, name) < 0)\n        goto cleanup;\n\n    if (S_ISDIR(st->st_mode)) {\n        vol->type = VIR_STORAGE_VOL_NETDIR;\n        vol->target.format = VIR_STORAGE_FILE_DIR;\n        *volptr = g_steal_pointer(&vol);\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* No need to worry about O_NONBLOCK - gluster doesn't allow creation\n     * of fifos, so there's nothing it would protect us from. */\n    if (!(fd = glfs_open(state->vol, name, O_RDONLY | O_NOCTTY))) {\n        /* A dangling symlink now implies a TOCTTOU race; report it.  */\n        virReportSystemError(errno, _(\"cannot open volume '%s'\"), name);\n        goto cleanup;\n    }\n\n    if ((len = virStorageBackendGlusterRead(fd, name, VIR_STORAGE_MAX_HEADER,\n                                            &header)) < 0)\n        goto cleanup;\n\n    if (!(meta = virStorageFileGetMetadataFromBuf(name, header, len,\n                                                  VIR_STORAGE_FILE_AUTO)))\n        goto cleanup;\n\n    if (meta->backingStoreRaw) {\n        if (!(vol->target.backingStore = virStorageSourceNew()))\n            goto cleanup;\n\n        vol->target.backingStore->type = VIR_STORAGE_TYPE_NETWORK;\n\n        vol->target.backingStore->path = g_steal_pointer(&meta->backingStoreRaw);\n        vol->target.backingStore->format = meta->backingStoreRawFormat;\n\n        if (vol->target.backingStore->format < 0)\n            vol->target.backingStore->format = VIR_STORAGE_FILE_RAW;\n    }\n\n    vol->target.format = meta->format;\n    if (meta->capacity)\n        vol->target.capacity = meta->capacity;\n    if (meta->encryption) {\n        vol->target.encryption = meta->encryption;\n        meta->encryption = NULL;\n    }\n    vol->target.features = meta->features;\n    meta->features = NULL;\n    vol->target.compat = meta->compat;\n    meta->compat = NULL;\n\n    *volptr = g_steal_pointer(&vol);\n    ret = 0;\n cleanup:\n    if (fd)\n        glfs_close(fd);\n    return ret;\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_gluster.h\"",
            "#include <glusterfs/api/glfs.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendGlusterRefreshVol(virStorageBackendGlusterStatePtr state,\n                                   const char *name,\n                                   struct stat *st,\n                                   virStorageVolDefPtr *volptr)\n{\n    int ret = -1;\n    glfs_fd_t *fd = NULL;\n    ssize_t len;\n    g_autoptr(virStorageVolDef) vol = NULL;\n    g_autoptr(virStorageSource) meta = NULL;\n    g_autofree char *header = NULL;\n\n    *volptr = NULL;\n\n    /* Silently skip '.' and '..'.  */\n    if (STREQ(name, \".\") || STREQ(name, \"..\"))\n        return 0;\n\n    /* Follow symlinks; silently skip broken links and loops.  */\n    if (S_ISLNK(st->st_mode) && glfs_stat(state->vol, name, st) < 0) {\n        if (errno == ENOENT || errno == ELOOP) {\n            VIR_WARN(\"ignoring dangling symlink '%s'\", name);\n            ret = 0;\n        } else {\n            virReportSystemError(errno, _(\"cannot stat '%s'\"), name);\n        }\n        return ret;\n    }\n\n    if (VIR_ALLOC(vol) < 0)\n        goto cleanup;\n\n    if (virStorageBackendUpdateVolTargetInfoFD(&vol->target, -1, st) < 0)\n        goto cleanup;\n\n    if (virStorageBackendGlusterSetMetadata(state, vol, name) < 0)\n        goto cleanup;\n\n    if (S_ISDIR(st->st_mode)) {\n        vol->type = VIR_STORAGE_VOL_NETDIR;\n        vol->target.format = VIR_STORAGE_FILE_DIR;\n        *volptr = g_steal_pointer(&vol);\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* No need to worry about O_NONBLOCK - gluster doesn't allow creation\n     * of fifos, so there's nothing it would protect us from. */\n    if (!(fd = glfs_open(state->vol, name, O_RDONLY | O_NOCTTY))) {\n        /* A dangling symlink now implies a TOCTTOU race; report it.  */\n        virReportSystemError(errno, _(\"cannot open volume '%s'\"), name);\n        goto cleanup;\n    }\n\n    if ((len = virStorageBackendGlusterRead(fd, name, VIR_STORAGE_MAX_HEADER,\n                                            &header)) < 0)\n        goto cleanup;\n\n    if (!(meta = virStorageFileGetMetadataFromBuf(name, header, len,\n                                                  VIR_STORAGE_FILE_AUTO)))\n        goto cleanup;\n\n    if (meta->backingStoreRaw) {\n        if (!(vol->target.backingStore = virStorageSourceNew()))\n            goto cleanup;\n\n        vol->target.backingStore->type = VIR_STORAGE_TYPE_NETWORK;\n\n        vol->target.backingStore->path = g_steal_pointer(&meta->backingStoreRaw);\n        vol->target.backingStore->format = meta->backingStoreRawFormat;\n\n        if (vol->target.backingStore->format < 0)\n            vol->target.backingStore->format = VIR_STORAGE_FILE_RAW;\n    }\n\n    vol->target.format = meta->format;\n    if (meta->capacity)\n        vol->target.capacity = meta->capacity;\n    if (meta->encryption) {\n        vol->target.encryption = meta->encryption;\n        meta->encryption = NULL;\n    }\n    vol->target.features = meta->features;\n    meta->features = NULL;\n    vol->target.compat = meta->compat;\n    meta->compat = NULL;\n\n    *volptr = g_steal_pointer(&vol);\n    ret = 0;\n cleanup:\n    if (fd)\n        glfs_close(fd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "glfs_readdirplus_r",
          "args": [
            "dir",
            "&st",
            "&de.ent",
            "&ent"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot open path '%s' in '%s'\")",
            "state->dir",
            "state->volname"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "glfs_opendir",
          "args": [
            "state->vol",
            "state->dir"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendGlusterOpen",
          "args": [
            "pool"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendGlusterOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
          "lines": "72-142",
          "snippet": "static virStorageBackendGlusterStatePtr\nvirStorageBackendGlusterOpen(virStoragePoolObjPtr pool)\n{\n    virStorageBackendGlusterStatePtr ret = NULL;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    const char *name = def->source.name;\n    const char *dir = def->source.dir;\n    bool trailing_slash = true;\n\n    /* Volume name must not contain '/'; optional path allows use of a\n     * subdirectory within the volume name.  */\n    if (strchr(name, '/')) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"gluster pool name '%s' must not contain /\"),\n                       name);\n        return NULL;\n    }\n    if (dir) {\n        if (*dir != '/') {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"gluster pool path '%s' must start with /\"),\n                           dir);\n            return NULL;\n        }\n        if (strchr(dir, '\\0')[-1] != '/')\n            trailing_slash = false;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->volname = g_strdup(name);\n    ret->dir = g_strdup_printf(\"%s%s\", dir ? dir : \"/\", trailing_slash ? \"\" : \"/\");\n\n    /* FIXME: Currently hard-coded to tcp transport; XML needs to be\n     * extended to allow alternate transport */\n    if (VIR_ALLOC(ret->uri) < 0)\n        goto error;\n    ret->uri->scheme = g_strdup(\"gluster\");\n    ret->uri->server = g_strdup(def->source.hosts[0].name);\n    ret->uri->path = g_strdup_printf(\"/%s%s\", ret->volname, ret->dir);\n    ret->uri->port = def->source.hosts[0].port;\n\n    /* Actually connect to glfs */\n    if (!(ret->vol = glfs_new(ret->volname))) {\n        virReportOOMError();\n        goto error;\n    }\n\n    if (glfs_set_volfile_server(ret->vol, \"tcp\",\n                                ret->uri->server, ret->uri->port) < 0 ||\n        glfs_init(ret->vol) < 0) {\n        g_autofree char *uri = NULL;\n        uri = virURIFormat(ret->uri);\n        virReportSystemError(errno, _(\"failed to connect to %s\"), NULLSTR(uri));\n        goto error;\n    }\n\n    if (glfs_chdir(ret->vol, ret->dir) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to change to directory '%s' in '%s'\"),\n                             ret->dir, ret->volname);\n        goto error;\n    }\n\n    return ret;\n\n error:\n    virStorageBackendGlusterClose(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_gluster.h\"",
            "#include <glusterfs/api/glfs.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic virStorageBackendGlusterStatePtr\nvirStorageBackendGlusterOpen(virStoragePoolObjPtr pool)\n{\n    virStorageBackendGlusterStatePtr ret = NULL;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    const char *name = def->source.name;\n    const char *dir = def->source.dir;\n    bool trailing_slash = true;\n\n    /* Volume name must not contain '/'; optional path allows use of a\n     * subdirectory within the volume name.  */\n    if (strchr(name, '/')) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"gluster pool name '%s' must not contain /\"),\n                       name);\n        return NULL;\n    }\n    if (dir) {\n        if (*dir != '/') {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"gluster pool path '%s' must start with /\"),\n                           dir);\n            return NULL;\n        }\n        if (strchr(dir, '\\0')[-1] != '/')\n            trailing_slash = false;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->volname = g_strdup(name);\n    ret->dir = g_strdup_printf(\"%s%s\", dir ? dir : \"/\", trailing_slash ? \"\" : \"/\");\n\n    /* FIXME: Currently hard-coded to tcp transport; XML needs to be\n     * extended to allow alternate transport */\n    if (VIR_ALLOC(ret->uri) < 0)\n        goto error;\n    ret->uri->scheme = g_strdup(\"gluster\");\n    ret->uri->server = g_strdup(def->source.hosts[0].name);\n    ret->uri->path = g_strdup_printf(\"/%s%s\", ret->volname, ret->dir);\n    ret->uri->port = def->source.hosts[0].port;\n\n    /* Actually connect to glfs */\n    if (!(ret->vol = glfs_new(ret->volname))) {\n        virReportOOMError();\n        goto error;\n    }\n\n    if (glfs_set_volfile_server(ret->vol, \"tcp\",\n                                ret->uri->server, ret->uri->port) < 0 ||\n        glfs_init(ret->vol) < 0) {\n        g_autofree char *uri = NULL;\n        uri = virURIFormat(ret->uri);\n        virReportSystemError(errno, _(\"failed to connect to %s\"), NULLSTR(uri));\n        goto error;\n    }\n\n    if (glfs_chdir(ret->vol, ret->dir) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to change to directory '%s' in '%s'\"),\n                             ret->dir, ret->volname);\n        goto error;\n    }\n\n    return ret;\n\n error:\n    virStorageBackendGlusterClose(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "1",
            "256 - (int)(sizeof(struct dirent)\n                                         - offsetof(struct dirent, d_name))"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendGlusterRefreshPool(virStoragePoolObjPtr pool)\n{\n    int ret = -1;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    virStorageBackendGlusterStatePtr state = NULL;\n    struct {\n        struct dirent ent;\n        /* See comment below about readdir_r needing padding */\n        char padding[MAX(1, 256 - (int)(sizeof(struct dirent)\n                                         - offsetof(struct dirent, d_name)))];\n    } de;\n    struct dirent *ent;\n    glfs_fd_t *dir = NULL;\n    struct stat st;\n    struct statvfs sb;\n\n    if (!(state = virStorageBackendGlusterOpen(pool)))\n        goto cleanup;\n\n    /* Why oh why did glfs 3.4 decide to expose only readdir_r rather\n     * than readdir?  POSIX admits that readdir_r is inherently a\n     * flawed design, because systems are not required to define\n     * NAME_MAX: http://austingroupbugs.net/view.php?id=696\n     * http://womble.decadent.org.uk/readdir_r-advisory.html\n     *\n     * Fortunately, gluster appears to limit its underlying bricks to\n     * only use file systems such as XFS that have a NAME_MAX of 255;\n     * so we are currently guaranteed that if we provide 256 bytes of\n     * tail padding, then we should have enough space to avoid buffer\n     * overflow no matter whether the OS used d_name[], d_name[1], or\n     * d_name[256] in its 'struct dirent'.\n     * http://lists.gnu.org/archive/html/gluster-devel/2013-10/msg00083.html\n     */\n\n    if (!(dir = glfs_opendir(state->vol, state->dir))) {\n        virReportSystemError(errno, _(\"cannot open path '%s' in '%s'\"),\n                             state->dir, state->volname);\n        goto cleanup;\n    }\n    while (!(errno = glfs_readdirplus_r(dir, &st, &de.ent, &ent)) && ent) {\n        virStorageVolDefPtr vol;\n        int okay = virStorageBackendGlusterRefreshVol(state,\n                                                      ent->d_name, &st,\n                                                      &vol);\n\n        if (okay < 0)\n            goto cleanup;\n        if (vol && virStoragePoolObjAddVol(pool, vol) < 0)\n            goto cleanup;\n    }\n    if (errno) {\n        virReportSystemError(errno, _(\"failed to read directory '%s' in '%s'\"),\n                             state->dir, state->volname);\n        goto cleanup;\n    }\n\n    if (glfs_statvfs(state->vol, state->dir, &sb) < 0) {\n        virReportSystemError(errno, _(\"cannot statvfs path '%s' in '%s'\"),\n                             state->dir, state->volname);\n        goto cleanup;\n    }\n\n    def->capacity = ((unsigned long long)sb.f_frsize *\n                     (unsigned long long)sb.f_blocks);\n    def->available = ((unsigned long long)sb.f_bfree *\n                      (unsigned long long)sb.f_frsize);\n    def->allocation = def->capacity - def->available;\n\n    ret = 0;\n cleanup:\n    if (dir)\n        glfs_closedir(dir);\n    virStorageBackendGlusterClose(state);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendGlusterRefreshVol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
    "lines": "218-312",
    "snippet": "static int\nvirStorageBackendGlusterRefreshVol(virStorageBackendGlusterStatePtr state,\n                                   const char *name,\n                                   struct stat *st,\n                                   virStorageVolDefPtr *volptr)\n{\n    int ret = -1;\n    glfs_fd_t *fd = NULL;\n    ssize_t len;\n    g_autoptr(virStorageVolDef) vol = NULL;\n    g_autoptr(virStorageSource) meta = NULL;\n    g_autofree char *header = NULL;\n\n    *volptr = NULL;\n\n    /* Silently skip '.' and '..'.  */\n    if (STREQ(name, \".\") || STREQ(name, \"..\"))\n        return 0;\n\n    /* Follow symlinks; silently skip broken links and loops.  */\n    if (S_ISLNK(st->st_mode) && glfs_stat(state->vol, name, st) < 0) {\n        if (errno == ENOENT || errno == ELOOP) {\n            VIR_WARN(\"ignoring dangling symlink '%s'\", name);\n            ret = 0;\n        } else {\n            virReportSystemError(errno, _(\"cannot stat '%s'\"), name);\n        }\n        return ret;\n    }\n\n    if (VIR_ALLOC(vol) < 0)\n        goto cleanup;\n\n    if (virStorageBackendUpdateVolTargetInfoFD(&vol->target, -1, st) < 0)\n        goto cleanup;\n\n    if (virStorageBackendGlusterSetMetadata(state, vol, name) < 0)\n        goto cleanup;\n\n    if (S_ISDIR(st->st_mode)) {\n        vol->type = VIR_STORAGE_VOL_NETDIR;\n        vol->target.format = VIR_STORAGE_FILE_DIR;\n        *volptr = g_steal_pointer(&vol);\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* No need to worry about O_NONBLOCK - gluster doesn't allow creation\n     * of fifos, so there's nothing it would protect us from. */\n    if (!(fd = glfs_open(state->vol, name, O_RDONLY | O_NOCTTY))) {\n        /* A dangling symlink now implies a TOCTTOU race; report it.  */\n        virReportSystemError(errno, _(\"cannot open volume '%s'\"), name);\n        goto cleanup;\n    }\n\n    if ((len = virStorageBackendGlusterRead(fd, name, VIR_STORAGE_MAX_HEADER,\n                                            &header)) < 0)\n        goto cleanup;\n\n    if (!(meta = virStorageFileGetMetadataFromBuf(name, header, len,\n                                                  VIR_STORAGE_FILE_AUTO)))\n        goto cleanup;\n\n    if (meta->backingStoreRaw) {\n        if (!(vol->target.backingStore = virStorageSourceNew()))\n            goto cleanup;\n\n        vol->target.backingStore->type = VIR_STORAGE_TYPE_NETWORK;\n\n        vol->target.backingStore->path = g_steal_pointer(&meta->backingStoreRaw);\n        vol->target.backingStore->format = meta->backingStoreRawFormat;\n\n        if (vol->target.backingStore->format < 0)\n            vol->target.backingStore->format = VIR_STORAGE_FILE_RAW;\n    }\n\n    vol->target.format = meta->format;\n    if (meta->capacity)\n        vol->target.capacity = meta->capacity;\n    if (meta->encryption) {\n        vol->target.encryption = meta->encryption;\n        meta->encryption = NULL;\n    }\n    vol->target.features = meta->features;\n    meta->features = NULL;\n    vol->target.compat = meta->compat;\n    meta->compat = NULL;\n\n    *volptr = g_steal_pointer(&vol);\n    ret = 0;\n cleanup:\n    if (fd)\n        glfs_close(fd);\n    return ret;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_gluster.h\"",
      "#include <glusterfs/api/glfs.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "glfs_close",
          "args": [
            "fd"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&vol"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&meta->backingStoreRaw"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceNew",
          "args": [],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2744-2751",
          "snippet": "virStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virStorageSourceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virClassPtr virStorageSourceClass;\n\nvirStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileGetMetadataFromBuf",
          "args": [
            "name",
            "header",
            "len",
            "VIR_STORAGE_FILE_AUTO"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetMetadataFromBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1128-1145",
          "snippet": "virStorageSourcePtr\nvirStorageFileGetMetadataFromBuf(const char *path,\n                                 char *buf,\n                                 size_t len,\n                                 int format)\n{\n    virStorageSourcePtr ret = NULL;\n\n    if (!(ret = virStorageFileMetadataNew(path, format)))\n        return NULL;\n\n    if (virStorageFileGetMetadataInternal(ret, buf, len) < 0) {\n        virObjectUnref(ret);\n        return NULL;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int qcow2GetFeatures(virBitmapPtr *features, int format,\n                            char *buf, ssize_t len);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvirStorageSourcePtr\nvirStorageFileGetMetadataFromBuf(const char *path,\n                                 char *buf,\n                                 size_t len,\n                                 int format)\n{\n    virStorageSourcePtr ret = NULL;\n\n    if (!(ret = virStorageFileMetadataNew(path, format)))\n        return NULL;\n\n    if (virStorageFileGetMetadataInternal(ret, buf, len) < 0) {\n        virObjectUnref(ret);\n        return NULL;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendGlusterRead",
          "args": [
            "fd",
            "name",
            "VIR_STORAGE_MAX_HEADER",
            "&header"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendGlusterRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
          "lines": "145-174",
          "snippet": "static ssize_t\nvirStorageBackendGlusterRead(glfs_fd_t *fd,\n                             const char *name,\n                             size_t len,\n                             char **buf)\n{\n    char *s;\n    size_t nread = 0;\n\n    if (VIR_ALLOC_N(*buf, len) < 0)\n        return -1;\n\n    s = *buf;\n    while (len) {\n        ssize_t r = glfs_read(fd, s, len, 0);\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0) {\n            VIR_FREE(*buf);\n            virReportSystemError(errno, _(\"unable to read '%s'\"), name);\n            return r;\n        }\n        if (r == 0)\n            return nread;\n        s += r;\n        len -= r;\n        nread += r;\n    }\n    return nread;\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_gluster.h\"",
            "#include <glusterfs/api/glfs.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic ssize_t\nvirStorageBackendGlusterRead(glfs_fd_t *fd,\n                             const char *name,\n                             size_t len,\n                             char **buf)\n{\n    char *s;\n    size_t nread = 0;\n\n    if (VIR_ALLOC_N(*buf, len) < 0)\n        return -1;\n\n    s = *buf;\n    while (len) {\n        ssize_t r = glfs_read(fd, s, len, 0);\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0) {\n            VIR_FREE(*buf);\n            virReportSystemError(errno, _(\"unable to read '%s'\"), name);\n            return r;\n        }\n        if (r == 0)\n            return nread;\n        s += r;\n        len -= r;\n        nread += r;\n    }\n    return nread;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot open volume '%s'\")",
            "name"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot open volume '%s'\""
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "glfs_open",
          "args": [
            "state->vol",
            "name",
            "O_RDONLY | O_NOCTTY"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&vol"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "st->st_mode"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageBackendGlusterSetMetadata",
          "args": [
            "state",
            "vol",
            "name"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendGlusterSetMetadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
          "lines": "177-212",
          "snippet": "static int\nvirStorageBackendGlusterSetMetadata(virStorageBackendGlusterStatePtr state,\n                                    virStorageVolDefPtr vol,\n                                    const char *name)\n{\n    char *tmp;\n    g_autofree char *path = NULL;\n\n    VIR_FREE(vol->key);\n    VIR_FREE(vol->target.path);\n\n    vol->type = VIR_STORAGE_VOL_NETWORK;\n    vol->target.format = VIR_STORAGE_FILE_RAW;\n\n    if (name) {\n        VIR_FREE(vol->name);\n        vol->name = g_strdup(name);\n    }\n\n    path = g_strdup_printf(\"%s%s%s\", state->volname, state->dir, vol->name);\n\n    tmp = state->uri->path;\n    state->uri->path = g_strdup_printf(\"/%s\", path);\n    if (!(vol->target.path = virURIFormat(state->uri))) {\n        VIR_FREE(state->uri->path);\n        state->uri->path = tmp;\n        return -1;\n    }\n    VIR_FREE(state->uri->path);\n    state->uri->path = tmp;\n\n    /* the path is unique enough to serve as a volume key */\n    vol->key = g_strdup(vol->target.path);\n\n    return 0;\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_gluster.h\"",
            "#include <glusterfs/api/glfs.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendGlusterSetMetadata(virStorageBackendGlusterStatePtr state,\n                                    virStorageVolDefPtr vol,\n                                    const char *name)\n{\n    char *tmp;\n    g_autofree char *path = NULL;\n\n    VIR_FREE(vol->key);\n    VIR_FREE(vol->target.path);\n\n    vol->type = VIR_STORAGE_VOL_NETWORK;\n    vol->target.format = VIR_STORAGE_FILE_RAW;\n\n    if (name) {\n        VIR_FREE(vol->name);\n        vol->name = g_strdup(name);\n    }\n\n    path = g_strdup_printf(\"%s%s%s\", state->volname, state->dir, vol->name);\n\n    tmp = state->uri->path;\n    state->uri->path = g_strdup_printf(\"/%s\", path);\n    if (!(vol->target.path = virURIFormat(state->uri))) {\n        VIR_FREE(state->uri->path);\n        state->uri->path = tmp;\n        return -1;\n    }\n    VIR_FREE(state->uri->path);\n    state->uri->path = tmp;\n\n    /* the path is unique enough to serve as a volume key */\n    vol->key = g_strdup(vol->target.path);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageBackendUpdateVolTargetInfoFD",
          "args": [
            "&vol->target",
            "-1",
            "st"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendUpdateVolTargetInfoFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_util.c",
          "lines": "1815-1874",
          "snippet": "int\nvirStorageBackendUpdateVolTargetInfoFD(virStorageSourcePtr target,\n                                       int fd,\n                                       struct stat *sb)\n{\n#if WITH_SELINUX\n    security_context_t filecon = NULL;\n#endif\n\n    if (virStorageSourceUpdateBackingSizes(target, fd, sb) < 0)\n        return -1;\n\n    if (!target->perms && VIR_ALLOC(target->perms) < 0)\n        return -1;\n    target->perms->mode = sb->st_mode & S_IRWXUGO;\n    target->perms->uid = sb->st_uid;\n    target->perms->gid = sb->st_gid;\n\n    if (!target->timestamps && VIR_ALLOC(target->timestamps) < 0)\n        return -1;\n\n#ifdef __APPLE__\n    target->timestamps->atime = sb->st_atimespec;\n    target->timestamps->btime = sb->st_birthtimespec;\n    target->timestamps->ctime = sb->st_ctimespec;\n    target->timestamps->mtime = sb->st_mtimespec;\n#else /* ! __APPLE__ */\n    target->timestamps->atime = sb->st_atim;\n# ifdef __linux__\n    target->timestamps->btime = (struct timespec){0, 0};\n# else /* ! __linux__ */\n    target->timestamps->btime = sb->st_birthtim;\n# endif /* ! __linux__ */\n    target->timestamps->ctime = sb->st_ctim;\n    target->timestamps->mtime = sb->st_mtim;\n#endif /* ! __APPLE__ */\n\n    target->type = VIR_STORAGE_TYPE_FILE;\n\n    VIR_FREE(target->perms->label);\n\n#if WITH_SELINUX\n    /* XXX: make this a security driver call */\n    if (fd >= 0) {\n        if (fgetfilecon_raw(fd, &filecon) == -1) {\n            if (errno != ENODATA && errno != ENOTSUP) {\n                virReportSystemError(errno,\n                                     _(\"cannot get file context of '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        } else {\n            target->perms->label = g_strdup(filecon);\n            freecon(filecon);\n        }\n    }\n#endif\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virjson.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"storage_util.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"viruuid.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virsecret.h\"",
            "#include \"secret_conf.h\"",
            "#include \"internal.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "# include <xfs/xfs.h>",
            "# include <linux/btrfs.h>",
            "# include <selinux/selinux.h>",
            "# include <blkid.h>",
            "# include <linux/fs.h>",
            "# include <sys/ioctl.h>",
            "#include <dirent.h>",
            "#include <sys/param.h>",
            "#include <sys/statvfs.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virjson.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"storage_util.h\"\n#include \"virstoragefile.h\"\n#include \"viruuid.h\"\n#include \"vircrypto.h\"\n#include \"virsecret.h\"\n#include \"secret_conf.h\"\n#include \"internal.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n# include <xfs/xfs.h>\n# include <linux/btrfs.h>\n# include <selinux/selinux.h>\n# include <blkid.h>\n# include <linux/fs.h>\n# include <sys/ioctl.h>\n#include <dirent.h>\n#include <sys/param.h>\n#include <sys/statvfs.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirStorageBackendUpdateVolTargetInfoFD(virStorageSourcePtr target,\n                                       int fd,\n                                       struct stat *sb)\n{\n#if WITH_SELINUX\n    security_context_t filecon = NULL;\n#endif\n\n    if (virStorageSourceUpdateBackingSizes(target, fd, sb) < 0)\n        return -1;\n\n    if (!target->perms && VIR_ALLOC(target->perms) < 0)\n        return -1;\n    target->perms->mode = sb->st_mode & S_IRWXUGO;\n    target->perms->uid = sb->st_uid;\n    target->perms->gid = sb->st_gid;\n\n    if (!target->timestamps && VIR_ALLOC(target->timestamps) < 0)\n        return -1;\n\n#ifdef __APPLE__\n    target->timestamps->atime = sb->st_atimespec;\n    target->timestamps->btime = sb->st_birthtimespec;\n    target->timestamps->ctime = sb->st_ctimespec;\n    target->timestamps->mtime = sb->st_mtimespec;\n#else /* ! __APPLE__ */\n    target->timestamps->atime = sb->st_atim;\n# ifdef __linux__\n    target->timestamps->btime = (struct timespec){0, 0};\n# else /* ! __linux__ */\n    target->timestamps->btime = sb->st_birthtim;\n# endif /* ! __linux__ */\n    target->timestamps->ctime = sb->st_ctim;\n    target->timestamps->mtime = sb->st_mtim;\n#endif /* ! __APPLE__ */\n\n    target->type = VIR_STORAGE_TYPE_FILE;\n\n    VIR_FREE(target->perms->label);\n\n#if WITH_SELINUX\n    /* XXX: make this a security driver call */\n    if (fd >= 0) {\n        if (fgetfilecon_raw(fd, &filecon) == -1) {\n            if (errno != ENODATA && errno != ENOTSUP) {\n                virReportSystemError(errno,\n                                     _(\"cannot get file context of '%s'\"),\n                                     target->path);\n                return -1;\n            }\n        } else {\n            target->perms->label = g_strdup(filecon);\n            freecon(filecon);\n        }\n    }\n#endif\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "vol"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot stat '%s'\")",
            "name"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"ignoring dangling symlink '%s'\"",
            "name"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "glfs_stat",
          "args": [
            "state->vol",
            "name",
            "st"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "st->st_mode"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "\"..\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "\".\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendGlusterRefreshVol(virStorageBackendGlusterStatePtr state,\n                                   const char *name,\n                                   struct stat *st,\n                                   virStorageVolDefPtr *volptr)\n{\n    int ret = -1;\n    glfs_fd_t *fd = NULL;\n    ssize_t len;\n    g_autoptr(virStorageVolDef) vol = NULL;\n    g_autoptr(virStorageSource) meta = NULL;\n    g_autofree char *header = NULL;\n\n    *volptr = NULL;\n\n    /* Silently skip '.' and '..'.  */\n    if (STREQ(name, \".\") || STREQ(name, \"..\"))\n        return 0;\n\n    /* Follow symlinks; silently skip broken links and loops.  */\n    if (S_ISLNK(st->st_mode) && glfs_stat(state->vol, name, st) < 0) {\n        if (errno == ENOENT || errno == ELOOP) {\n            VIR_WARN(\"ignoring dangling symlink '%s'\", name);\n            ret = 0;\n        } else {\n            virReportSystemError(errno, _(\"cannot stat '%s'\"), name);\n        }\n        return ret;\n    }\n\n    if (VIR_ALLOC(vol) < 0)\n        goto cleanup;\n\n    if (virStorageBackendUpdateVolTargetInfoFD(&vol->target, -1, st) < 0)\n        goto cleanup;\n\n    if (virStorageBackendGlusterSetMetadata(state, vol, name) < 0)\n        goto cleanup;\n\n    if (S_ISDIR(st->st_mode)) {\n        vol->type = VIR_STORAGE_VOL_NETDIR;\n        vol->target.format = VIR_STORAGE_FILE_DIR;\n        *volptr = g_steal_pointer(&vol);\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* No need to worry about O_NONBLOCK - gluster doesn't allow creation\n     * of fifos, so there's nothing it would protect us from. */\n    if (!(fd = glfs_open(state->vol, name, O_RDONLY | O_NOCTTY))) {\n        /* A dangling symlink now implies a TOCTTOU race; report it.  */\n        virReportSystemError(errno, _(\"cannot open volume '%s'\"), name);\n        goto cleanup;\n    }\n\n    if ((len = virStorageBackendGlusterRead(fd, name, VIR_STORAGE_MAX_HEADER,\n                                            &header)) < 0)\n        goto cleanup;\n\n    if (!(meta = virStorageFileGetMetadataFromBuf(name, header, len,\n                                                  VIR_STORAGE_FILE_AUTO)))\n        goto cleanup;\n\n    if (meta->backingStoreRaw) {\n        if (!(vol->target.backingStore = virStorageSourceNew()))\n            goto cleanup;\n\n        vol->target.backingStore->type = VIR_STORAGE_TYPE_NETWORK;\n\n        vol->target.backingStore->path = g_steal_pointer(&meta->backingStoreRaw);\n        vol->target.backingStore->format = meta->backingStoreRawFormat;\n\n        if (vol->target.backingStore->format < 0)\n            vol->target.backingStore->format = VIR_STORAGE_FILE_RAW;\n    }\n\n    vol->target.format = meta->format;\n    if (meta->capacity)\n        vol->target.capacity = meta->capacity;\n    if (meta->encryption) {\n        vol->target.encryption = meta->encryption;\n        meta->encryption = NULL;\n    }\n    vol->target.features = meta->features;\n    meta->features = NULL;\n    vol->target.compat = meta->compat;\n    meta->compat = NULL;\n\n    *volptr = g_steal_pointer(&vol);\n    ret = 0;\n cleanup:\n    if (fd)\n        glfs_close(fd);\n    return ret;\n}"
  },
  {
    "function_name": "virStorageBackendGlusterSetMetadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
    "lines": "177-212",
    "snippet": "static int\nvirStorageBackendGlusterSetMetadata(virStorageBackendGlusterStatePtr state,\n                                    virStorageVolDefPtr vol,\n                                    const char *name)\n{\n    char *tmp;\n    g_autofree char *path = NULL;\n\n    VIR_FREE(vol->key);\n    VIR_FREE(vol->target.path);\n\n    vol->type = VIR_STORAGE_VOL_NETWORK;\n    vol->target.format = VIR_STORAGE_FILE_RAW;\n\n    if (name) {\n        VIR_FREE(vol->name);\n        vol->name = g_strdup(name);\n    }\n\n    path = g_strdup_printf(\"%s%s%s\", state->volname, state->dir, vol->name);\n\n    tmp = state->uri->path;\n    state->uri->path = g_strdup_printf(\"/%s\", path);\n    if (!(vol->target.path = virURIFormat(state->uri))) {\n        VIR_FREE(state->uri->path);\n        state->uri->path = tmp;\n        return -1;\n    }\n    VIR_FREE(state->uri->path);\n    state->uri->path = tmp;\n\n    /* the path is unique enough to serve as a volume key */\n    vol->key = g_strdup(vol->target.path);\n\n    return 0;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_gluster.h\"",
      "#include <glusterfs/api/glfs.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "vol->target.path"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "state->uri->path"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "state->uri->path"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virURIFormat",
          "args": [
            "state->uri"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "virURIFormatParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "253-269",
          "snippet": "char *virURIFormatParams(virURIPtr uri)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    bool amp = false;\n\n    for (i = 0; i < uri->paramsCount; ++i) {\n        if (!uri->params[i].ignore) {\n            if (amp) virBufferAddChar(&buf, '&');\n            virBufferStrcat(&buf, uri->params[i].name, \"=\", NULL);\n            virBufferURIEncodeString(&buf, uri->params[i].value);\n            amp = true;\n        }\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nchar *virURIFormatParams(virURIPtr uri)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    bool amp = false;\n\n    for (i = 0; i < uri->paramsCount; ++i) {\n        if (!uri->params[i].ignore) {\n            if (amp) virBufferAddChar(&buf, '&');\n            virBufferStrcat(&buf, uri->params[i].name, \"=\", NULL);\n            virBufferURIEncodeString(&buf, uri->params[i].value);\n            amp = true;\n        }\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vol->name"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vol->target.path"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vol->key"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic int\nvirStorageBackendGlusterSetMetadata(virStorageBackendGlusterStatePtr state,\n                                    virStorageVolDefPtr vol,\n                                    const char *name)\n{\n    char *tmp;\n    g_autofree char *path = NULL;\n\n    VIR_FREE(vol->key);\n    VIR_FREE(vol->target.path);\n\n    vol->type = VIR_STORAGE_VOL_NETWORK;\n    vol->target.format = VIR_STORAGE_FILE_RAW;\n\n    if (name) {\n        VIR_FREE(vol->name);\n        vol->name = g_strdup(name);\n    }\n\n    path = g_strdup_printf(\"%s%s%s\", state->volname, state->dir, vol->name);\n\n    tmp = state->uri->path;\n    state->uri->path = g_strdup_printf(\"/%s\", path);\n    if (!(vol->target.path = virURIFormat(state->uri))) {\n        VIR_FREE(state->uri->path);\n        state->uri->path = tmp;\n        return -1;\n    }\n    VIR_FREE(state->uri->path);\n    state->uri->path = tmp;\n\n    /* the path is unique enough to serve as a volume key */\n    vol->key = g_strdup(vol->target.path);\n\n    return 0;\n}"
  },
  {
    "function_name": "virStorageBackendGlusterRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
    "lines": "145-174",
    "snippet": "static ssize_t\nvirStorageBackendGlusterRead(glfs_fd_t *fd,\n                             const char *name,\n                             size_t len,\n                             char **buf)\n{\n    char *s;\n    size_t nread = 0;\n\n    if (VIR_ALLOC_N(*buf, len) < 0)\n        return -1;\n\n    s = *buf;\n    while (len) {\n        ssize_t r = glfs_read(fd, s, len, 0);\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0) {\n            VIR_FREE(*buf);\n            virReportSystemError(errno, _(\"unable to read '%s'\"), name);\n            return r;\n        }\n        if (r == 0)\n            return nread;\n        s += r;\n        len -= r;\n        nread += r;\n    }\n    return nread;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_gluster.h\"",
      "#include <glusterfs/api/glfs.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to read '%s'\")",
            "name"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to read '%s'\""
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*buf"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "glfs_read",
          "args": [
            "fd",
            "s",
            "len",
            "0"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*buf",
            "len"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic ssize_t\nvirStorageBackendGlusterRead(glfs_fd_t *fd,\n                             const char *name,\n                             size_t len,\n                             char **buf)\n{\n    char *s;\n    size_t nread = 0;\n\n    if (VIR_ALLOC_N(*buf, len) < 0)\n        return -1;\n\n    s = *buf;\n    while (len) {\n        ssize_t r = glfs_read(fd, s, len, 0);\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0) {\n            VIR_FREE(*buf);\n            virReportSystemError(errno, _(\"unable to read '%s'\"), name);\n            return r;\n        }\n        if (r == 0)\n            return nread;\n        s += r;\n        len -= r;\n        nread += r;\n    }\n    return nread;\n}"
  },
  {
    "function_name": "virStorageBackendGlusterOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
    "lines": "72-142",
    "snippet": "static virStorageBackendGlusterStatePtr\nvirStorageBackendGlusterOpen(virStoragePoolObjPtr pool)\n{\n    virStorageBackendGlusterStatePtr ret = NULL;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    const char *name = def->source.name;\n    const char *dir = def->source.dir;\n    bool trailing_slash = true;\n\n    /* Volume name must not contain '/'; optional path allows use of a\n     * subdirectory within the volume name.  */\n    if (strchr(name, '/')) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"gluster pool name '%s' must not contain /\"),\n                       name);\n        return NULL;\n    }\n    if (dir) {\n        if (*dir != '/') {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"gluster pool path '%s' must start with /\"),\n                           dir);\n            return NULL;\n        }\n        if (strchr(dir, '\\0')[-1] != '/')\n            trailing_slash = false;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->volname = g_strdup(name);\n    ret->dir = g_strdup_printf(\"%s%s\", dir ? dir : \"/\", trailing_slash ? \"\" : \"/\");\n\n    /* FIXME: Currently hard-coded to tcp transport; XML needs to be\n     * extended to allow alternate transport */\n    if (VIR_ALLOC(ret->uri) < 0)\n        goto error;\n    ret->uri->scheme = g_strdup(\"gluster\");\n    ret->uri->server = g_strdup(def->source.hosts[0].name);\n    ret->uri->path = g_strdup_printf(\"/%s%s\", ret->volname, ret->dir);\n    ret->uri->port = def->source.hosts[0].port;\n\n    /* Actually connect to glfs */\n    if (!(ret->vol = glfs_new(ret->volname))) {\n        virReportOOMError();\n        goto error;\n    }\n\n    if (glfs_set_volfile_server(ret->vol, \"tcp\",\n                                ret->uri->server, ret->uri->port) < 0 ||\n        glfs_init(ret->vol) < 0) {\n        g_autofree char *uri = NULL;\n        uri = virURIFormat(ret->uri);\n        virReportSystemError(errno, _(\"failed to connect to %s\"), NULLSTR(uri));\n        goto error;\n    }\n\n    if (glfs_chdir(ret->vol, ret->dir) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to change to directory '%s' in '%s'\"),\n                             ret->dir, ret->volname);\n        goto error;\n    }\n\n    return ret;\n\n error:\n    virStorageBackendGlusterClose(ret);\n    return NULL;\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_gluster.h\"",
      "#include <glusterfs/api/glfs.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageBackendGlusterClose",
          "args": [
            "ret"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageBackendGlusterClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
          "lines": "53-70",
          "snippet": "static void\nvirStorageBackendGlusterClose(virStorageBackendGlusterStatePtr state)\n{\n    if (!state)\n        return;\n\n    /* Yuck - glusterfs-api-3.4.1 appears to always return -1 for\n     * glfs_fini, with errno containing random data, so there's no way\n     * to tell if it succeeded. 3.4.2 is supposed to fix this.*/\n    if (state->vol && glfs_fini(state->vol) < 0)\n        VIR_DEBUG(\"shutdown of gluster volume %s failed with errno %d\",\n                  state->volname, errno);\n\n    virURIFree(state->uri);\n    VIR_FREE(state->volname);\n    VIR_FREE(state->dir);\n    VIR_FREE(state);\n}",
          "includes": [
            "#include \"storage_util.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"storage_backend_gluster.h\"",
            "#include <glusterfs/api/glfs.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendGlusterClose(virStorageBackendGlusterStatePtr state)\n{\n    if (!state)\n        return;\n\n    /* Yuck - glusterfs-api-3.4.1 appears to always return -1 for\n     * glfs_fini, with errno containing random data, so there's no way\n     * to tell if it succeeded. 3.4.2 is supposed to fix this.*/\n    if (state->vol && glfs_fini(state->vol) < 0)\n        VIR_DEBUG(\"shutdown of gluster volume %s failed with errno %d\",\n                  state->volname, errno);\n\n    virURIFree(state->uri);\n    VIR_FREE(state->volname);\n    VIR_FREE(state->dir);\n    VIR_FREE(state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to change to directory '%s' in '%s'\")",
            "ret->dir",
            "ret->volname"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to change to directory '%s' in '%s'\""
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "glfs_chdir",
          "args": [
            "ret->vol",
            "ret->dir"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"failed to connect to %s\")",
            "NULLSTR(uri)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "uri"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virURIFormat",
          "args": [
            "ret->uri"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "virURIFormatParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "253-269",
          "snippet": "char *virURIFormatParams(virURIPtr uri)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    bool amp = false;\n\n    for (i = 0; i < uri->paramsCount; ++i) {\n        if (!uri->params[i].ignore) {\n            if (amp) virBufferAddChar(&buf, '&');\n            virBufferStrcat(&buf, uri->params[i].name, \"=\", NULL);\n            virBufferURIEncodeString(&buf, uri->params[i].value);\n            amp = true;\n        }\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nchar *virURIFormatParams(virURIPtr uri)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    bool amp = false;\n\n    for (i = 0; i < uri->paramsCount; ++i) {\n        if (!uri->params[i].ignore) {\n            if (amp) virBufferAddChar(&buf, '&');\n            virBufferStrcat(&buf, uri->params[i].name, \"=\", NULL);\n            virBufferURIEncodeString(&buf, uri->params[i].value);\n            amp = true;\n        }\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "glfs_init",
          "args": [
            "ret->vol"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "glfs_set_volfile_server",
          "args": [
            "ret->vol",
            "\"tcp\"",
            "ret->uri->server",
            "ret->uri->port"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "glfs_new",
          "args": [
            "ret->volname"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret->uri"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "dir",
            "'\\0'"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"gluster pool path '%s' must start with /\")",
            "dir"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"gluster pool name '%s' must not contain /\")",
            "name"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "'/'"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolObjGetDef",
          "args": [
            "pool"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virstorageobj.c",
          "lines": "246-250",
          "snippet": "virStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virvhba.h\"",
            "#include \"virstring.h\"",
            "#include \"virscsihost.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstorageobj.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virvhba.h\"\n#include \"virstring.h\"\n#include \"virscsihost.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstorageobj.h\"\n#include \"node_device_util.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <dirent.h>\n#include <config.h>\n\nvirStoragePoolDefPtr\nvirStoragePoolObjGetDef(virStoragePoolObjPtr obj)\n{\n    return obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic virStorageBackendGlusterStatePtr\nvirStorageBackendGlusterOpen(virStoragePoolObjPtr pool)\n{\n    virStorageBackendGlusterStatePtr ret = NULL;\n    virStoragePoolDefPtr def = virStoragePoolObjGetDef(pool);\n    const char *name = def->source.name;\n    const char *dir = def->source.dir;\n    bool trailing_slash = true;\n\n    /* Volume name must not contain '/'; optional path allows use of a\n     * subdirectory within the volume name.  */\n    if (strchr(name, '/')) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"gluster pool name '%s' must not contain /\"),\n                       name);\n        return NULL;\n    }\n    if (dir) {\n        if (*dir != '/') {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"gluster pool path '%s' must start with /\"),\n                           dir);\n            return NULL;\n        }\n        if (strchr(dir, '\\0')[-1] != '/')\n            trailing_slash = false;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    ret->volname = g_strdup(name);\n    ret->dir = g_strdup_printf(\"%s%s\", dir ? dir : \"/\", trailing_slash ? \"\" : \"/\");\n\n    /* FIXME: Currently hard-coded to tcp transport; XML needs to be\n     * extended to allow alternate transport */\n    if (VIR_ALLOC(ret->uri) < 0)\n        goto error;\n    ret->uri->scheme = g_strdup(\"gluster\");\n    ret->uri->server = g_strdup(def->source.hosts[0].name);\n    ret->uri->path = g_strdup_printf(\"/%s%s\", ret->volname, ret->dir);\n    ret->uri->port = def->source.hosts[0].port;\n\n    /* Actually connect to glfs */\n    if (!(ret->vol = glfs_new(ret->volname))) {\n        virReportOOMError();\n        goto error;\n    }\n\n    if (glfs_set_volfile_server(ret->vol, \"tcp\",\n                                ret->uri->server, ret->uri->port) < 0 ||\n        glfs_init(ret->vol) < 0) {\n        g_autofree char *uri = NULL;\n        uri = virURIFormat(ret->uri);\n        virReportSystemError(errno, _(\"failed to connect to %s\"), NULLSTR(uri));\n        goto error;\n    }\n\n    if (glfs_chdir(ret->vol, ret->dir) < 0) {\n        virReportSystemError(errno,\n                             _(\"failed to change to directory '%s' in '%s'\"),\n                             ret->dir, ret->volname);\n        goto error;\n    }\n\n    return ret;\n\n error:\n    virStorageBackendGlusterClose(ret);\n    return NULL;\n}"
  },
  {
    "function_name": "virStorageBackendGlusterClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/storage/storage_backend_gluster.c",
    "lines": "53-70",
    "snippet": "static void\nvirStorageBackendGlusterClose(virStorageBackendGlusterStatePtr state)\n{\n    if (!state)\n        return;\n\n    /* Yuck - glusterfs-api-3.4.1 appears to always return -1 for\n     * glfs_fini, with errno containing random data, so there's no way\n     * to tell if it succeeded. 3.4.2 is supposed to fix this.*/\n    if (state->vol && glfs_fini(state->vol) < 0)\n        VIR_DEBUG(\"shutdown of gluster volume %s failed with errno %d\",\n                  state->volname, errno);\n\n    virURIFree(state->uri);\n    VIR_FREE(state->volname);\n    VIR_FREE(state->dir);\n    VIR_FREE(state);\n}",
    "includes": [
      "#include \"storage_util.h\"",
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"storage_conf.h\"",
      "#include \"storage_backend_gluster.h\"",
      "#include <glusterfs/api/glfs.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "state"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "state->dir"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "state->volname"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virURIFree",
          "args": [
            "state->uri"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "virURIFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "277-298",
          "snippet": "void virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvoid virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"shutdown of gluster volume %s failed with errno %d\"",
            "state->volname",
            "errno"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "glfs_fini",
          "args": [
            "state->vol"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"storage_util.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"storage_backend_gluster.h\"\n#include <glusterfs/api/glfs.h>\n#include <config.h>\n\nstatic void\nvirStorageBackendGlusterClose(virStorageBackendGlusterStatePtr state)\n{\n    if (!state)\n        return;\n\n    /* Yuck - glusterfs-api-3.4.1 appears to always return -1 for\n     * glfs_fini, with errno containing random data, so there's no way\n     * to tell if it succeeded. 3.4.2 is supposed to fix this.*/\n    if (state->vol && glfs_fini(state->vol) < 0)\n        VIR_DEBUG(\"shutdown of gluster volume %s failed with errno %d\",\n                  state->volname, errno);\n\n    virURIFree(state->uri);\n    VIR_FREE(state->volname);\n    VIR_FREE(state->dir);\n    VIR_FREE(state);\n}"
  }
]