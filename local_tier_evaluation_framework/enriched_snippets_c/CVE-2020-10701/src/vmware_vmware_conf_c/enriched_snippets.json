[
  {
    "function_name": "vmwareCopyVMXFileName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
    "lines": "515-522",
    "snippet": "char *\nvmwareCopyVMXFileName(const char *datastorePath, void *opaque G_GNUC_UNUSED)\n{\n    char *path;\n\n    path = g_strdup(datastorePath);\n    return path;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"vircommand.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "datastorePath"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nchar *\nvmwareCopyVMXFileName(const char *datastorePath, void *opaque G_GNUC_UNUSED)\n{\n    char *path;\n\n    path = g_strdup(datastorePath);\n    return path;\n}"
  },
  {
    "function_name": "vmwareExtractPid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
    "lines": "469-513",
    "snippet": "int\nvmwareExtractPid(const char * vmxPath)\n{\n    char *vmxDir = NULL;\n    char *logFilePath = NULL;\n    FILE *logFile = NULL;\n    char line[1024];\n    char *tmp = NULL;\n    int pid_value = -1;\n\n    vmxDir = g_path_get_dirname(vmxPath);\n\n    logFilePath = g_strdup_printf(\"%s/vmware.log\", vmxDir);\n\n    if ((logFile = fopen(logFilePath, \"r\")) == NULL)\n        goto cleanup;\n\n    if (!fgets(line, sizeof(line), logFile)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to read vmware log file\"));\n        goto cleanup;\n    }\n\n    if ((tmp = strstr(line, \" pid=\")) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot find pid in vmware log file\"));\n        goto cleanup;\n    }\n\n    tmp += strlen(\" pid=\");\n\n    /* Although 64-bit windows allows 64-bit pid_t, a domain id has to be\n     * 32 bits.  For now, we just reject pid values that overflow int.  */\n    if (virStrToLong_i(tmp, &tmp, 10, &pid_value) < 0 || *tmp != ' ') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot parse pid in vmware log file\"));\n        goto cleanup;\n    }\n\n cleanup:\n    VIR_FREE(vmxDir);\n    VIR_FREE(logFilePath);\n    VIR_FORCE_FCLOSE(logFile);\n    return pid_value;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"vircommand.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_FCLOSE",
          "args": [
            "logFile"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "logFilePath"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vmxDir"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot parse pid in vmware log file\")"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot parse pid in vmware log file\""
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "tmp",
            "&tmp",
            "10",
            "&pid_value"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\" pid=\""
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot find pid in vmware log file\")"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "line",
            "\" pid=\""
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unable to read vmware log file\")"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "logFile"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "logFilePath",
            "\"r\""
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_path_get_dirname",
          "args": [
            "vmxPath"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareExtractPid(const char * vmxPath)\n{\n    char *vmxDir = NULL;\n    char *logFilePath = NULL;\n    FILE *logFile = NULL;\n    char line[1024];\n    char *tmp = NULL;\n    int pid_value = -1;\n\n    vmxDir = g_path_get_dirname(vmxPath);\n\n    logFilePath = g_strdup_printf(\"%s/vmware.log\", vmxDir);\n\n    if ((logFile = fopen(logFilePath, \"r\")) == NULL)\n        goto cleanup;\n\n    if (!fgets(line, sizeof(line), logFile)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to read vmware log file\"));\n        goto cleanup;\n    }\n\n    if ((tmp = strstr(line, \" pid=\")) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot find pid in vmware log file\"));\n        goto cleanup;\n    }\n\n    tmp += strlen(\" pid=\");\n\n    /* Although 64-bit windows allows 64-bit pid_t, a domain id has to be\n     * 32 bits.  For now, we just reject pid values that overflow int.  */\n    if (virStrToLong_i(tmp, &tmp, 10, &pid_value) < 0 || *tmp != ' ') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot parse pid in vmware log file\"));\n        goto cleanup;\n    }\n\n cleanup:\n    VIR_FREE(vmxDir);\n    VIR_FREE(logFilePath);\n    VIR_FORCE_FCLOSE(logFile);\n    return pid_value;\n}"
  },
  {
    "function_name": "vmwareMakePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
    "lines": "462-467",
    "snippet": "int\nvmwareMakePath(char *srcDir, char *srcName, char *srcExt, char **outpath)\n{\n    *outpath = g_strdup_printf(\"%s/%s.%s\", srcDir, srcName, srcExt);\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"vircommand.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s.%s\"",
            "srcDir",
            "srcName",
            "srcExt"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareMakePath(char *srcDir, char *srcName, char *srcExt, char **outpath)\n{\n    *outpath = g_strdup_printf(\"%s/%s.%s\", srcDir, srcName, srcExt);\n    return 0;\n}"
  },
  {
    "function_name": "vmwareMoveFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
    "lines": "436-460",
    "snippet": "int\nvmwareMoveFile(char *srcFile, char *dstFile)\n{\n    const char *cmdmv[] =\n        { \"mv\", PROGRAM_SENTINEL, PROGRAM_SENTINEL, NULL };\n\n    if (!virFileExists(srcFile)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"file %s does not exist\"),\n                       srcFile);\n        return -1;\n    }\n\n    if (STREQ(srcFile, dstFile))\n        return 0;\n\n    vmwareSetSentinal(cmdmv, srcFile);\n    vmwareSetSentinal(cmdmv, dstFile);\n    if (virRun(cmdmv, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to move file to %s \"), dstFile);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"vircommand.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to move file to %s \")",
            "dstFile"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to move file to %s \""
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virRun",
          "args": [
            "cmdmv",
            "NULL"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "virRun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "890-900",
          "snippet": "int\nvirRun(const char *const *argv G_GNUC_UNUSED,\n       int *status)\n{\n    if (status)\n        *status = ENOTSUP;\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virRun is not implemented for WIN32\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirRun(const char *const *argv G_GNUC_UNUSED,\n       int *status)\n{\n    if (status)\n        *status = ENOTSUP;\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"virRun is not implemented for WIN32\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareSetSentinal",
          "args": [
            "cmdmv",
            "dstFile"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareSetSentinal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "207-219",
          "snippet": "void\nvmwareSetSentinal(const char **prog, const char *key)\n{\n    const char **tmp = prog;\n\n    while (tmp && *tmp) {\n        if (*tmp == PROGRAM_SENTINEL) {\n            *tmp = key;\n            break;\n        }\n        tmp++;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nvoid\nvmwareSetSentinal(const char **prog, const char *key)\n{\n    const char **tmp = prog;\n\n    while (tmp && *tmp) {\n        if (*tmp == PROGRAM_SENTINEL) {\n            *tmp = key;\n            break;\n        }\n        tmp++;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "srcFile",
            "dstFile"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"file %s does not exist\")",
            "srcFile"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "srcFile"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareMoveFile(char *srcFile, char *dstFile)\n{\n    const char *cmdmv[] =\n        { \"mv\", PROGRAM_SENTINEL, PROGRAM_SENTINEL, NULL };\n\n    if (!virFileExists(srcFile)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"file %s does not exist\"),\n                       srcFile);\n        return -1;\n    }\n\n    if (STREQ(srcFile, dstFile))\n        return 0;\n\n    vmwareSetSentinal(cmdmv, srcFile);\n    vmwareSetSentinal(cmdmv, dstFile);\n    if (virRun(cmdmv, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to move file to %s \"), dstFile);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vmwareVmxPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
    "lines": "369-434",
    "snippet": "int\nvmwareVmxPath(virDomainDefPtr vmdef, char **vmxPath)\n{\n    virDomainDiskDefPtr disk = NULL;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    int ret = -1;\n    size_t i;\n    const char *src;\n\n    /*\n     * Build VMX URL. Use the source of the first file-based harddisk\n     * to deduce the path for the VMX file. Don't just use the\n     * first disk, because it may be CDROM disk and ISO images are normally not\n     * located in the virtual machine's directory. This approach\n     * isn't perfect but should work in the majority of cases.\n     */\n    if (vmdef->ndisks < 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any disks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < vmdef->ndisks; ++i) {\n        if (vmdef->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_DISK &&\n            virDomainDiskGetType(vmdef->disks[i]) == VIR_STORAGE_TYPE_FILE) {\n            disk = vmdef->disks[i];\n            break;\n        }\n    }\n\n    if (disk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any file-based harddisks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    src = virDomainDiskGetSource(disk);\n    if (!src) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"First file-based harddisk has no source, cannot \"\n                         \"deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    if (vmwareParsePath(src, &directoryName, &fileName) < 0)\n        goto cleanup;\n\n    if (!virStringHasCaseSuffix(fileName, \".vmdk\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting source '%s' of first file-based harddisk \"\n                         \"to be a VMDK image\"), src);\n        goto cleanup;\n    }\n\n    vmwareConstructVmxPath(directoryName, vmdef->name, vmxPath);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"vircommand.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileName"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryName"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmwareConstructVmxPath",
          "args": [
            "directoryName",
            "vmdef->name",
            "vmxPath"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareConstructVmxPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "360-367",
          "snippet": "void\nvmwareConstructVmxPath(char *directoryName, char *name, char **vmxPath)\n{\n    if (directoryName != NULL)\n        *vmxPath = g_strdup_printf(\"%s/%s.vmx\", directoryName, name);\n    else\n        *vmxPath = g_strdup_printf(\"%s.vmx\", name);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nvoid\nvmwareConstructVmxPath(char *directoryName, char *name, char **vmxPath)\n{\n    if (directoryName != NULL)\n        *vmxPath = g_strdup_printf(\"%s/%s.vmx\", directoryName, name);\n    else\n        *vmxPath = g_strdup_printf(\"%s.vmx\", name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting source '%s' of first file-based harddisk \"\n                         \"to be a VMDK image\")",
            "src"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Expecting source '%s' of first file-based harddisk \"\n                         \"to be a VMDK image\""
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringHasCaseSuffix",
          "args": [
            "fileName",
            "\".vmdk\""
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "virStringHasCaseSuffix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1110-1121",
          "snippet": "bool\nvirStringHasCaseSuffix(const char *str,\n                       const char *suffix)\n{\n    int len = strlen(str);\n    int suffixlen = strlen(suffix);\n\n    if (len < suffixlen)\n        return false;\n\n    return STRCASEEQ(str + len - suffixlen, suffix);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nbool\nvirStringHasCaseSuffix(const char *str,\n                       const char *suffix)\n{\n    int len = strlen(str);\n    int suffixlen = strlen(suffix);\n\n    if (len < suffixlen)\n        return false;\n\n    return STRCASEEQ(str + len - suffixlen, suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareParsePath",
          "args": [
            "src",
            "&directoryName",
            "&fileName"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareParsePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "334-358",
          "snippet": "static int\nvmwareParsePath(const char *path, char **directory, char **filename)\n{\n    char *separator;\n\n    separator = strrchr(path, '/');\n\n    if (separator != NULL) {\n        separator++;\n\n        if (*separator == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"path '%s' doesn't reference a file\"), path);\n            return -1;\n        }\n\n        *directory = g_strndup(path, separator - path - 1);\n        *filename = g_strdup(separator);\n\n    } else {\n        *filename = g_strdup(path);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nstatic int\nvmwareParsePath(const char *path, char **directory, char **filename)\n{\n    char *separator;\n\n    separator = strrchr(path, '/');\n\n    if (separator != NULL) {\n        separator++;\n\n        if (*separator == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"path '%s' doesn't reference a file\"), path);\n            return -1;\n        }\n\n        *directory = g_strndup(path, separator - path - 1);\n        *filename = g_strdup(separator);\n\n    } else {\n        *filename = g_strdup(path);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"First file-based harddisk has no source, cannot \"\n                         \"deduce datastore and path for VMX file\")"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "disk"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Domain XML doesn't contain any file-based harddisks, \"\n                         \"cannot deduce datastore and path for VMX file\")"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetType",
          "args": [
            "vmdef->disks[i]"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2141-2145",
          "snippet": "int\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Domain XML doesn't contain any disks, \"\n                         \"cannot deduce datastore and path for VMX file\")"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareVmxPath(virDomainDefPtr vmdef, char **vmxPath)\n{\n    virDomainDiskDefPtr disk = NULL;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    int ret = -1;\n    size_t i;\n    const char *src;\n\n    /*\n     * Build VMX URL. Use the source of the first file-based harddisk\n     * to deduce the path for the VMX file. Don't just use the\n     * first disk, because it may be CDROM disk and ISO images are normally not\n     * located in the virtual machine's directory. This approach\n     * isn't perfect but should work in the majority of cases.\n     */\n    if (vmdef->ndisks < 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any disks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < vmdef->ndisks; ++i) {\n        if (vmdef->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_DISK &&\n            virDomainDiskGetType(vmdef->disks[i]) == VIR_STORAGE_TYPE_FILE) {\n            disk = vmdef->disks[i];\n            break;\n        }\n    }\n\n    if (disk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any file-based harddisks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    src = virDomainDiskGetSource(disk);\n    if (!src) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"First file-based harddisk has no source, cannot \"\n                         \"deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    if (vmwareParsePath(src, &directoryName, &fileName) < 0)\n        goto cleanup;\n\n    if (!virStringHasCaseSuffix(fileName, \".vmdk\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting source '%s' of first file-based harddisk \"\n                         \"to be a VMDK image\"), src);\n        goto cleanup;\n    }\n\n    vmwareConstructVmxPath(directoryName, vmdef->name, vmxPath);\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareConstructVmxPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
    "lines": "360-367",
    "snippet": "void\nvmwareConstructVmxPath(char *directoryName, char *name, char **vmxPath)\n{\n    if (directoryName != NULL)\n        *vmxPath = g_strdup_printf(\"%s/%s.vmx\", directoryName, name);\n    else\n        *vmxPath = g_strdup_printf(\"%s.vmx\", name);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"vircommand.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s.vmx\"",
            "name"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nvoid\nvmwareConstructVmxPath(char *directoryName, char *name, char **vmxPath)\n{\n    if (directoryName != NULL)\n        *vmxPath = g_strdup_printf(\"%s/%s.vmx\", directoryName, name);\n    else\n        *vmxPath = g_strdup_printf(\"%s.vmx\", name);\n}"
  },
  {
    "function_name": "vmwareParsePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
    "lines": "334-358",
    "snippet": "static int\nvmwareParsePath(const char *path, char **directory, char **filename)\n{\n    char *separator;\n\n    separator = strrchr(path, '/');\n\n    if (separator != NULL) {\n        separator++;\n\n        if (*separator == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"path '%s' doesn't reference a file\"), path);\n            return -1;\n        }\n\n        *directory = g_strndup(path, separator - path - 1);\n        *filename = g_strdup(separator);\n\n    } else {\n        *filename = g_strdup(path);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"vircommand.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "path"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "path",
            "separator - path - 1"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"path '%s' doesn't reference a file\")",
            "path"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "path",
            "'/'"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nstatic int\nvmwareParsePath(const char *path, char **directory, char **filename)\n{\n    char *separator;\n\n    separator = strrchr(path, '/');\n\n    if (separator != NULL) {\n        separator++;\n\n        if (*separator == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"path '%s' doesn't reference a file\"), path);\n            return -1;\n        }\n\n        *directory = g_strndup(path, separator - path - 1);\n        *filename = g_strdup(separator);\n\n    } else {\n        *filename = g_strdup(path);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vmwareDomainConfigDisplay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
    "lines": "314-332",
    "snippet": "int\nvmwareDomainConfigDisplay(vmwareDomainPtr pDomain, virDomainDefPtr def)\n{\n    size_t i;\n\n    if (def->ngraphics == 0) {\n        pDomain->gui = true;\n        return 0;\n    } else {\n        pDomain->gui = false;\n        for (i = 0; i < def->ngraphics; i++) {\n            if (def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP) {\n                pDomain->gui = true;\n                return 0;\n            }\n        }\n        return 0;\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"vircommand.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareDomainConfigDisplay(vmwareDomainPtr pDomain, virDomainDefPtr def)\n{\n    size_t i;\n\n    if (def->ngraphics == 0) {\n        pDomain->gui = true;\n        return 0;\n    } else {\n        pDomain->gui = false;\n        for (i = 0; i < def->ngraphics; i++) {\n            if (def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP) {\n                pDomain->gui = true;\n                return 0;\n            }\n        }\n        return 0;\n    }\n}"
  },
  {
    "function_name": "vmwareExtractVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
    "lines": "264-312",
    "snippet": "int\nvmwareExtractVersion(struct vmware_driver *driver)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char * outbuf = NULL;\n    char *bin = NULL;\n    char *vmwarePath = NULL;\n\n    vmwarePath = g_path_get_dirname(driver->vmrun);\n\n    switch (driver->type) {\n        case VMWARE_DRIVER_PLAYER:\n            bin = g_strdup_printf(\"%s/%s\", vmwarePath, \"vmplayer\");\n            break;\n\n        case VMWARE_DRIVER_WORKSTATION:\n            bin = g_strdup_printf(\"%s/%s\", vmwarePath, \"vmware\");\n            break;\n\n        case VMWARE_DRIVER_FUSION:\n            bin = g_strdup_printf(\"%s/%s\", vmwarePath, \"vmware-vmx\");\n            break;\n\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid driver type for version detection\"));\n            goto cleanup;\n    }\n\n    cmd = virCommandNewArgList(bin, \"-v\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    virCommandSetErrorBuffer(cmd, &outbuf);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (vmwareParseVersionStr(driver->type, outbuf, &driver->version) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(bin);\n    VIR_FREE(vmwarePath);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"vircommand.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vmwarePath"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "bin"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "outbuf"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareParseVersionStr",
          "args": [
            "driver->type",
            "outbuf",
            "&driver->version"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareParseVersionStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "221-262",
          "snippet": "int\nvmwareParseVersionStr(int type, const char *verbuf, unsigned long *version)\n{\n    const char *pattern;\n    const char *tmp;\n\n    switch (type) {\n        case VMWARE_DRIVER_PLAYER:\n            pattern = \"VMware Player \";\n            break;\n        case VMWARE_DRIVER_WORKSTATION:\n            pattern = \"VMware Workstation \";\n            break;\n        case VMWARE_DRIVER_FUSION:\n            pattern = \"\\nVMware Fusion Information:\\nVMware Fusion \";\n            break;\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid driver type: %d\"), type);\n            return -1;\n    }\n\n    if ((tmp = strstr(verbuf, pattern)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot find version pattern \\\"%s\\\"\"), pattern);\n        return -1;\n    }\n\n    if ((tmp = STRSKIP(tmp, pattern)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse %sversion\"), pattern);\n        return -1;\n    }\n\n    if (virParseVersionString(tmp, version, false) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"version parsing error\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareParseVersionStr(int type, const char *verbuf, unsigned long *version)\n{\n    const char *pattern;\n    const char *tmp;\n\n    switch (type) {\n        case VMWARE_DRIVER_PLAYER:\n            pattern = \"VMware Player \";\n            break;\n        case VMWARE_DRIVER_WORKSTATION:\n            pattern = \"VMware Workstation \";\n            break;\n        case VMWARE_DRIVER_FUSION:\n            pattern = \"\\nVMware Fusion Information:\\nVMware Fusion \";\n            break;\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid driver type: %d\"), type);\n            return -1;\n    }\n\n    if ((tmp = strstr(verbuf, pattern)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot find version pattern \\\"%s\\\"\"), pattern);\n        return -1;\n    }\n\n    if ((tmp = STRSKIP(tmp, pattern)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse %sversion\"), pattern);\n        return -1;\n    }\n\n    if (virParseVersionString(tmp, version, false) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"version parsing error\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetErrorBuffer",
          "args": [
            "cmd",
            "&outbuf"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetErrorBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1903-1918",
          "snippet": "void\nvirCommandSetErrorBuffer(virCommandPtr cmd, char **errbuf)\n{\n    *errbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errbuf = errbuf;\n    cmd->errfdptr = &cmd->errfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetErrorBuffer(virCommandPtr cmd, char **errbuf)\n{\n    *errbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errbuf = errbuf;\n    cmd->errfdptr = &cmd->errfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "&outbuf"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "bin",
            "\"-v\"",
            "NULL"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"invalid driver type for version detection\")"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid driver type for version detection\""
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_path_get_dirname",
          "args": [
            "driver->vmrun"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareExtractVersion(struct vmware_driver *driver)\n{\n    int ret = -1;\n    virCommandPtr cmd = NULL;\n    char * outbuf = NULL;\n    char *bin = NULL;\n    char *vmwarePath = NULL;\n\n    vmwarePath = g_path_get_dirname(driver->vmrun);\n\n    switch (driver->type) {\n        case VMWARE_DRIVER_PLAYER:\n            bin = g_strdup_printf(\"%s/%s\", vmwarePath, \"vmplayer\");\n            break;\n\n        case VMWARE_DRIVER_WORKSTATION:\n            bin = g_strdup_printf(\"%s/%s\", vmwarePath, \"vmware\");\n            break;\n\n        case VMWARE_DRIVER_FUSION:\n            bin = g_strdup_printf(\"%s/%s\", vmwarePath, \"vmware-vmx\");\n            break;\n\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid driver type for version detection\"));\n            goto cleanup;\n    }\n\n    cmd = virCommandNewArgList(bin, \"-v\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    virCommandSetErrorBuffer(cmd, &outbuf);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (vmwareParseVersionStr(driver->type, outbuf, &driver->version) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    VIR_FREE(bin);\n    VIR_FREE(vmwarePath);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareParseVersionStr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
    "lines": "221-262",
    "snippet": "int\nvmwareParseVersionStr(int type, const char *verbuf, unsigned long *version)\n{\n    const char *pattern;\n    const char *tmp;\n\n    switch (type) {\n        case VMWARE_DRIVER_PLAYER:\n            pattern = \"VMware Player \";\n            break;\n        case VMWARE_DRIVER_WORKSTATION:\n            pattern = \"VMware Workstation \";\n            break;\n        case VMWARE_DRIVER_FUSION:\n            pattern = \"\\nVMware Fusion Information:\\nVMware Fusion \";\n            break;\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid driver type: %d\"), type);\n            return -1;\n    }\n\n    if ((tmp = strstr(verbuf, pattern)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot find version pattern \\\"%s\\\"\"), pattern);\n        return -1;\n    }\n\n    if ((tmp = STRSKIP(tmp, pattern)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse %sversion\"), pattern);\n        return -1;\n    }\n\n    if (virParseVersionString(tmp, version, false) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"version parsing error\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"vircommand.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"version parsing error\")"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"version parsing error\""
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virParseVersionString",
          "args": [
            "tmp",
            "version",
            "false"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "virParseVersionString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "254-282",
          "snippet": "int\nvirParseVersionString(const char *str, unsigned long *version,\n                      bool allowMissing)\n{\n    unsigned int major, minor = 0, micro = 0;\n    char *tmp;\n\n    if (virStrToLong_ui(str, &tmp, 10, &major) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &minor) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &micro) < 0)\n        return -1;\n\n    if (major > UINT_MAX / 1000000 || minor > 999 || micro > 999)\n        return -1;\n\n    *version = 1000000 * major + 1000 * minor + micro;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirParseVersionString(const char *str, unsigned long *version,\n                      bool allowMissing)\n{\n    unsigned int major, minor = 0, micro = 0;\n    char *tmp;\n\n    if (virStrToLong_ui(str, &tmp, 10, &major) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &minor) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &micro) < 0)\n        return -1;\n\n    if (major > UINT_MAX / 1000000 || minor > 999 || micro > 999)\n        return -1;\n\n    *version = 1000000 * major + 1000 * minor + micro;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to parse %sversion\")",
            "pattern"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "tmp",
            "pattern"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"cannot find version pattern \\\"%s\\\"\")",
            "pattern"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "verbuf",
            "pattern"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid driver type: %d\")",
            "type"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareParseVersionStr(int type, const char *verbuf, unsigned long *version)\n{\n    const char *pattern;\n    const char *tmp;\n\n    switch (type) {\n        case VMWARE_DRIVER_PLAYER:\n            pattern = \"VMware Player \";\n            break;\n        case VMWARE_DRIVER_WORKSTATION:\n            pattern = \"VMware Workstation \";\n            break;\n        case VMWARE_DRIVER_FUSION:\n            pattern = \"\\nVMware Fusion Information:\\nVMware Fusion \";\n            break;\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid driver type: %d\"), type);\n            return -1;\n    }\n\n    if ((tmp = strstr(verbuf, pattern)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot find version pattern \\\"%s\\\"\"), pattern);\n        return -1;\n    }\n\n    if ((tmp = STRSKIP(tmp, pattern)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"failed to parse %sversion\"), pattern);\n        return -1;\n    }\n\n    if (virParseVersionString(tmp, version, false) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"version parsing error\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vmwareSetSentinal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
    "lines": "207-219",
    "snippet": "void\nvmwareSetSentinal(const char **prog, const char *key)\n{\n    const char **tmp = prog;\n\n    while (tmp && *tmp) {\n        if (*tmp == PROGRAM_SENTINEL) {\n            *tmp = key;\n            break;\n        }\n        tmp++;\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"vircommand.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nvoid\nvmwareSetSentinal(const char **prog, const char *key)\n{\n    const char **tmp = prog;\n\n    while (tmp && *tmp) {\n        if (*tmp == PROGRAM_SENTINEL) {\n            *tmp = key;\n            break;\n        }\n        tmp++;\n    }\n}"
  },
  {
    "function_name": "vmwareLoadDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
    "lines": "127-205",
    "snippet": "int\nvmwareLoadDomains(struct vmware_driver *driver)\n{\n    virDomainDefPtr vmdef = NULL;\n    virDomainObjPtr vm = NULL;\n    char *vmxPath = NULL;\n    char *vmx = NULL;\n    vmwareDomainPtr pDomain;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    int ret = -1;\n    virVMXContext ctx;\n    char *outbuf = NULL;\n    char *str;\n    char *saveptr = NULL;\n    virCommandPtr cmd;\n\n    ctx.parseFileName = vmwareCopyVMXFileName;\n    ctx.formatFileName = NULL;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = NULL;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (vmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n        str = NULL) {\n\n        if (vmxPath[0] != '/')\n            continue;\n\n        if (virFileReadAll(vmxPath, 10000, &vmx) < 0)\n            goto cleanup;\n\n        if ((vmdef =\n             virVMXParseConfig(&ctx, driver->xmlopt,\n                               driver->caps, vmx)) == NULL) {\n            goto cleanup;\n        }\n\n        if (!(vm = virDomainObjListAdd(driver->domains, vmdef,\n                                       driver->xmlopt,\n                                       0, NULL)))\n            goto cleanup;\n\n        pDomain = vm->privateData;\n\n        pDomain->vmxPath = g_strdup(vmxPath);\n\n        vmwareDomainConfigDisplay(pDomain, vmdef);\n\n        if ((vm->def->id = vmwareExtractPid(vmxPath)) < 0)\n            goto cleanup;\n        /* vmrun list only reports running vms */\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_UNKNOWN);\n        vm->persistent = 1;\n\n        virDomainObjEndAPI(&vm);\n\n        vmdef = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    virDomainDefFree(vmdef);\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    VIR_FREE(vmx);\n    virObjectUnref(vm);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"vircommand.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "vm"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vmx"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fileName"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryName"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "vmdef"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "outbuf"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_RUNNING",
            "VIR_DOMAIN_RUNNING_UNKNOWN"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareExtractPid",
          "args": [
            "vmxPath"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareExtractPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "469-513",
          "snippet": "int\nvmwareExtractPid(const char * vmxPath)\n{\n    char *vmxDir = NULL;\n    char *logFilePath = NULL;\n    FILE *logFile = NULL;\n    char line[1024];\n    char *tmp = NULL;\n    int pid_value = -1;\n\n    vmxDir = g_path_get_dirname(vmxPath);\n\n    logFilePath = g_strdup_printf(\"%s/vmware.log\", vmxDir);\n\n    if ((logFile = fopen(logFilePath, \"r\")) == NULL)\n        goto cleanup;\n\n    if (!fgets(line, sizeof(line), logFile)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to read vmware log file\"));\n        goto cleanup;\n    }\n\n    if ((tmp = strstr(line, \" pid=\")) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot find pid in vmware log file\"));\n        goto cleanup;\n    }\n\n    tmp += strlen(\" pid=\");\n\n    /* Although 64-bit windows allows 64-bit pid_t, a domain id has to be\n     * 32 bits.  For now, we just reject pid values that overflow int.  */\n    if (virStrToLong_i(tmp, &tmp, 10, &pid_value) < 0 || *tmp != ' ') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot parse pid in vmware log file\"));\n        goto cleanup;\n    }\n\n cleanup:\n    VIR_FREE(vmxDir);\n    VIR_FREE(logFilePath);\n    VIR_FORCE_FCLOSE(logFile);\n    return pid_value;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareExtractPid(const char * vmxPath)\n{\n    char *vmxDir = NULL;\n    char *logFilePath = NULL;\n    FILE *logFile = NULL;\n    char line[1024];\n    char *tmp = NULL;\n    int pid_value = -1;\n\n    vmxDir = g_path_get_dirname(vmxPath);\n\n    logFilePath = g_strdup_printf(\"%s/vmware.log\", vmxDir);\n\n    if ((logFile = fopen(logFilePath, \"r\")) == NULL)\n        goto cleanup;\n\n    if (!fgets(line, sizeof(line), logFile)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to read vmware log file\"));\n        goto cleanup;\n    }\n\n    if ((tmp = strstr(line, \" pid=\")) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot find pid in vmware log file\"));\n        goto cleanup;\n    }\n\n    tmp += strlen(\" pid=\");\n\n    /* Although 64-bit windows allows 64-bit pid_t, a domain id has to be\n     * 32 bits.  For now, we just reject pid values that overflow int.  */\n    if (virStrToLong_i(tmp, &tmp, 10, &pid_value) < 0 || *tmp != ' ') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot parse pid in vmware log file\"));\n        goto cleanup;\n    }\n\n cleanup:\n    VIR_FREE(vmxDir);\n    VIR_FREE(logFilePath);\n    VIR_FORCE_FCLOSE(logFile);\n    return pid_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDomainConfigDisplay",
          "args": [
            "pDomain",
            "vmdef"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "vmwareDomainConfigDisplay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
          "lines": "314-332",
          "snippet": "int\nvmwareDomainConfigDisplay(vmwareDomainPtr pDomain, virDomainDefPtr def)\n{\n    size_t i;\n\n    if (def->ngraphics == 0) {\n        pDomain->gui = true;\n        return 0;\n    } else {\n        pDomain->gui = false;\n        for (i = 0; i < def->ngraphics; i++) {\n            if (def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP) {\n                pDomain->gui = true;\n                return 0;\n            }\n        }\n        return 0;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"vmware_conf.h\"",
            "#include \"vmx.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"vircommand.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareDomainConfigDisplay(vmwareDomainPtr pDomain, virDomainDefPtr def)\n{\n    size_t i;\n\n    if (def->ngraphics == 0) {\n        pDomain->gui = true;\n        return 0;\n    } else {\n        pDomain->gui = false;\n        for (i = 0; i < def->ngraphics; i++) {\n            if (def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP) {\n                pDomain->gui = true;\n                return 0;\n            }\n        }\n        return 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "vmxPath"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListAdd",
          "args": [
            "driver->domains",
            "vmdef",
            "driver->xmlopt",
            "0",
            "NULL"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "354-366",
          "snippet": "virDomainObjPtr virDomainObjListAdd(virDomainObjListPtr doms,\n                                    virDomainDefPtr def,\n                                    virDomainXMLOptionPtr xmlopt,\n                                    unsigned int flags,\n                                    virDomainDefPtr *oldDef)\n{\n    virDomainObjPtr ret;\n\n    virObjectRWLockWrite(doms);\n    ret = virDomainObjListAddLocked(doms, def, xmlopt, flags, oldDef);\n    virObjectRWUnlock(doms);\n    return ret;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainObjPtr virDomainObjListAdd(virDomainObjListPtr doms,\n                                    virDomainDefPtr def,\n                                    virDomainXMLOptionPtr xmlopt,\n                                    unsigned int flags,\n                                    virDomainDefPtr *oldDef)\n{\n    virDomainObjPtr ret;\n\n    virObjectRWLockWrite(doms);\n    ret = virDomainObjListAddLocked(doms, def, xmlopt, flags, oldDef);\n    virObjectRWUnlock(doms);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXParseConfig",
          "args": [
            "&ctx",
            "driver->xmlopt",
            "driver->caps",
            "vmx"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXParseConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "1275-1867",
          "snippet": "virDomainDefPtr\nvirVMXParseConfig(virVMXContext *ctx,\n                  virDomainXMLOptionPtr xmlopt,\n                  virCapsPtr caps G_GNUC_UNUSED,\n                  const char *vmx)\n{\n    bool success = false;\n    g_autoptr(virConf) conf = NULL;\n    char *encoding = NULL;\n    char *utf8;\n    virDomainDefPtr def = NULL;\n    long long config_version = 0;\n    long long virtualHW_version = 0;\n    long long memsize = 0;\n    long long sched_mem_max = 0;\n    long long sched_mem_minsize = 0;\n    long long numvcpus = 0;\n    char *sched_cpu_affinity = NULL;\n    char *sched_cpu_shares = NULL;\n    char *guestOS = NULL;\n    bool smbios_reflecthost = false;\n    int controller;\n    int bus;\n    int port;\n    bool present;\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    int unit;\n    bool hgfs_disabled = true;\n    long long sharedFolder_maxNum = 0;\n    struct virVMXConfigScanResults results = { -1 };\n    long long coresPerSocket = 0;\n    virCPUDefPtr cpu = NULL;\n    char *firmware = NULL;\n\n    if (ctx->parseFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no parseFileName function set\"));\n        return NULL;\n    }\n\n    conf = virConfReadString(vmx, VIR_CONF_FLAG_VMX_FORMAT);\n\n    if (conf == NULL)\n        return NULL;\n\n    /* vmx:.encoding */\n    if (virVMXGetConfigString(conf, \".encoding\", &encoding, true) < 0)\n        goto cleanup;\n\n    if (encoding == NULL || STRCASEEQ(encoding, \"UTF-8\")) {\n        /* nothing */\n    } else {\n        virConfFree(conf);\n        conf = NULL;\n\n        utf8 = virVMXConvertToUTF8(encoding, vmx);\n\n        if (utf8 == NULL)\n            goto cleanup;\n\n        conf = virConfReadString(utf8, VIR_CONF_FLAG_VMX_FORMAT);\n\n        VIR_FREE(utf8);\n\n        if (conf == NULL)\n            goto cleanup;\n    }\n\n    if (virConfWalk(conf, virVMXConfigScanResultsCollector, &results) < 0)\n        goto cleanup;\n\n    /* Allocate domain def */\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    def->virtType = VIR_DOMAIN_VIRT_VMWARE;\n    def->id = -1;\n\n    /* vmx:config.version */\n    if (virVMXGetConfigLong(conf, \"config.version\", &config_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (config_version != 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'config.version' to be 8 but found \"\n                         \"%lld\"), config_version);\n        goto cleanup;\n    }\n\n    /* vmx:virtualHW.version */\n    if (virVMXGetConfigLong(conf, \"virtualHW.version\", &virtualHW_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualHW_version < 4) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'virtualHW.version' to be \"\n                         \"4 or higher but found %lld\"),\n                       virtualHW_version);\n        goto cleanup;\n    }\n\n    /* vmx:uuid.bios -> def:uuid */\n    /* FIXME: Need to handle 'uuid.action = \"create\"' */\n    if (virVMXGetConfigUUID(conf, \"uuid.bios\", def->uuid, true) < 0)\n        goto cleanup;\n\n    /* vmx:displayName -> def:name */\n    if (virVMXGetConfigString(conf, \"displayName\", &def->name, true) < 0)\n        goto cleanup;\n\n    if (def->name != NULL) {\n        if (virVMXUnescapeHexPercent(def->name) < 0 ||\n            virVMXUnescapeHexPipe(def->name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'name' contains invalid escape sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:annotation -> def:description */\n    if (virVMXGetConfigString(conf, \"annotation\", &def->description,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (def->description != NULL) {\n        if (virVMXUnescapeHexPipe(def->description) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'annotation' contains invalid escape \"\n                             \"sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:memsize -> def:mem.max_balloon */\n    if (virVMXGetConfigLong(conf, \"memsize\", &memsize, 32, true) < 0)\n        goto cleanup;\n\n    if (memsize <= 0 || memsize % 4 != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'memsize' to be an unsigned \"\n                         \"integer (multiple of 4) but found %lld\"), memsize);\n        goto cleanup;\n    }\n\n    virDomainDefSetMemoryTotal(def, memsize * 1024); /* Scale from megabytes to kilobytes */\n\n    /* vmx:sched.mem.max -> def:mem.cur_balloon */\n    if (virVMXGetConfigLong(conf, \"sched.mem.max\", &sched_mem_max, memsize,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_max < 0)\n        sched_mem_max = memsize;\n\n    def->mem.cur_balloon = sched_mem_max * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.cur_balloon > virDomainDefGetMemoryTotal(def))\n        def->mem.cur_balloon = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:sched.mem.minsize -> def:mem.min_guarantee */\n    if (virVMXGetConfigLong(conf, \"sched.mem.minsize\", &sched_mem_minsize, 0,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_minsize < 0)\n        sched_mem_minsize = 0;\n\n    def->mem.min_guarantee = sched_mem_minsize * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.min_guarantee > virDomainDefGetMemoryTotal(def))\n        def->mem.min_guarantee = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:numvcpus -> def:vcpus */\n    if (virVMXGetConfigLong(conf, \"numvcpus\", &numvcpus, 1, true) < 0)\n        goto cleanup;\n\n    if (numvcpus <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'numvcpus' to be an unsigned \"\n                         \"integer greater than 0 but found %lld\"), numvcpus);\n        goto cleanup;\n    }\n\n    if (virDomainDefSetVcpusMax(def, numvcpus, xmlopt) < 0)\n        goto cleanup;\n\n    if (virDomainDefSetVcpus(def, numvcpus) < 0)\n        goto cleanup;\n\n    /* vmx:cpuid.coresPerSocket -> def:cpu */\n    if (virVMXGetConfigLong(conf, \"cpuid.coresPerSocket\", &coresPerSocket, 1,\n                            true) < 0)\n        goto cleanup;\n\n    if (coresPerSocket > 1) {\n        cpu = virCPUDefNew();\n\n        cpu->type = VIR_CPU_TYPE_GUEST;\n        cpu->mode = VIR_CPU_MODE_CUSTOM;\n\n        cpu->sockets = numvcpus / coresPerSocket;\n        if (cpu->sockets <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'cpuid.coresPerSocket' smaller than \"\n                             \"'numvcpus'\"));\n            goto cleanup;\n        }\n        cpu->dies = 1;\n        cpu->cores = coresPerSocket;\n        cpu->threads = 1;\n\n        def->cpu = g_steal_pointer(&cpu);\n    }\n\n    /* vmx:sched.cpu.affinity -> def:cpumask */\n    /* NOTE: maps to VirtualMachine:config.cpuAffinity.affinitySet */\n    if (virVMXGetConfigString(conf, \"sched.cpu.affinity\", &sched_cpu_affinity,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_affinity != NULL && STRCASENEQ(sched_cpu_affinity, \"all\")) {\n        VIR_AUTOSTRINGLIST afflist = NULL;\n        char **aff;\n        size_t naffs;\n\n        def->cpumask = virBitmapNew(VIR_DOMAIN_CPUMASK_LEN);\n        if (!def->cpumask)\n            goto cleanup;\n\n        if (!(afflist = virStringSplitCount(sched_cpu_affinity, \",\", 0, &naffs)))\n            goto cleanup;\n\n        if (naffs < numvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.affinity' to contain \"\n                             \"at least as many values as 'numvcpus' (%lld) but \"\n                             \"found only %zu value(s)\"), numvcpus, naffs);\n            goto cleanup;\n        }\n\n        for (aff = afflist; *aff; aff++) {\n            const char *current = *aff;\n            unsigned int number;\n            int rc;\n\n            virSkipSpaces(&current);\n            rc = virStrToLong_uip(current, (char **) &current, 10, &number);\n            virSkipSpaces(&current);\n\n            if (rc < 0 || *current != '\\0') {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry 'sched.cpu.affinity' to be \"\n                                 \"a comma separated list of unsigned integers but \"\n                                 \"found '%s'\"), sched_cpu_affinity);\n                goto cleanup;\n            }\n\n            if (number >= VIR_DOMAIN_CPUMASK_LEN) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"VMX entry 'sched.cpu.affinity' contains a %d, \"\n                                 \"this value is too large\"), number);\n                goto cleanup;\n            }\n\n            ignore_value(virBitmapSetBit(def->cpumask, number));\n        }\n    }\n\n    /* vmx:sched.cpu.shares -> def:cputune.shares */\n    if (virVMXGetConfigString(conf, \"sched.cpu.shares\", &sched_cpu_shares,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_shares != NULL) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (STRCASEEQ(sched_cpu_shares, \"low\")) {\n            def->cputune.shares = vcpus * 500;\n        } else if (STRCASEEQ(sched_cpu_shares, \"normal\")) {\n            def->cputune.shares = vcpus * 1000;\n        } else if (STRCASEEQ(sched_cpu_shares, \"high\")) {\n            def->cputune.shares = vcpus * 2000;\n        } else if (virStrToLong_ull(sched_cpu_shares, NULL, 10,\n                                    &def->cputune.shares) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.shares' to be an \"\n                             \"unsigned integer or 'low', 'normal' or 'high' but \"\n                             \"found '%s'\"), sched_cpu_shares);\n            goto cleanup;\n        }\n        def->cputune.sharesSpecified = true;\n    }\n\n    /* def:lifecycle */\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* def:os */\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    /* vmx:guestOS -> def:os.arch */\n    if (virVMXGetConfigString(conf, \"guestOS\", &guestOS, true) < 0)\n        goto cleanup;\n\n    if (guestOS != NULL && virStringHasSuffix(guestOS, \"-64\")) {\n        def->os.arch = VIR_ARCH_X86_64;\n    } else {\n        def->os.arch = VIR_ARCH_I686;\n    }\n\n    /* vmx:smbios.reflecthost -> def:os.smbios_mode */\n    if (virVMXGetConfigBoolean(conf, \"smbios.reflecthost\",\n                               &smbios_reflecthost, false, true) < 0) {\n        goto cleanup;\n    }\n\n    if (smbios_reflecthost)\n        def->os.smbios_mode = VIR_DOMAIN_SMBIOS_HOST;\n\n    /* def:features */\n    /* FIXME */\n\n    /* def:clock */\n    /* FIXME */\n\n    /* def:graphics */\n    if (VIR_ALLOC_N(def->graphics, 1) < 0)\n        goto cleanup;\n\n    def->ngraphics = 0;\n\n    if (virVMXParseVNC(conf, &def->graphics[def->ngraphics]) < 0)\n        goto cleanup;\n\n    if (def->graphics[def->ngraphics] != NULL)\n        ++def->ngraphics;\n\n    /* def:disks: 4 * 15 scsi + 2 * 2 ide + 2 floppy = 66 */\n    if (VIR_ALLOC_N(def->disks, 66) < 0)\n        goto cleanup;\n\n    def->ndisks = 0;\n\n    /* def:disks (scsi) */\n    for (controller = 0; controller < 4; ++controller) {\n        if (virVMXParseSCSIController(conf, controller, &present,\n                                      &scsi_virtualDev[controller]) < 0) {\n            goto cleanup;\n        }\n\n        if (! present)\n            continue;\n\n        for (unit = 0; unit < 16; ++unit) {\n            if (unit == 7) {\n                /*\n                 * SCSI unit 7 is assigned to the SCSI controller and cannot be\n                 * used for disk devices.\n                 */\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                 VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                 &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n\n    }\n\n    /* add all the SCSI controllers we've seen, up until the last one that is\n     * currently used by a disk */\n    if (def->ndisks != 0) {\n        virDomainDeviceInfoPtr info = &def->disks[def->ndisks - 1]->info;\n        for (controller = 0; controller <= info->addr.drive.controller; controller++) {\n            if (!virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_SCSI,\n                                           controller, scsi_virtualDev[controller]))\n                goto cleanup;\n        }\n    }\n\n    /* def:disks (ide) */\n    for (bus = 0; bus < 2; ++bus) {\n        for (unit = 0; unit < 2; ++unit) {\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n    }\n\n    /* def:disks (floppy) */\n    for (unit = 0; unit < 2; ++unit) {\n        if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_FLOPPY,\n                            VIR_DOMAIN_DISK_BUS_FDC, 0, unit,\n                            &def->disks[def->ndisks], def) < 0) {\n            goto cleanup;\n        }\n\n        if (def->disks[def->ndisks] != NULL)\n            ++def->ndisks;\n    }\n\n    /* def:fss */\n    if (virVMXGetConfigBoolean(conf, \"isolation.tools.hgfs.disable\",\n                               &hgfs_disabled, true, true) < 0) {\n        goto cleanup;\n    }\n\n    if (!hgfs_disabled) {\n        if (virVMXGetConfigLong(conf, \"sharedFolder.maxNum\", &sharedFolder_maxNum,\n                                0, true) < 0) {\n            goto cleanup;\n        }\n\n        if (sharedFolder_maxNum > 0) {\n            int number;\n\n            if (VIR_ALLOC_N(def->fss, sharedFolder_maxNum) < 0)\n                goto cleanup;\n\n            def->nfss = 0;\n\n            for (number = 0; number < sharedFolder_maxNum; ++number) {\n                if (virVMXParseFileSystem(conf, number,\n                                          &def->fss[def->nfss]) < 0) {\n                    goto cleanup;\n                }\n\n                if (def->fss[def->nfss] != NULL)\n                    ++def->nfss;\n            }\n        }\n    }\n\n    /* def:nets */\n    for (controller = 0; controller <= results.networks_max_index; ++controller) {\n        virDomainNetDefPtr net = NULL;\n        if (virVMXParseEthernet(conf, controller, &net) < 0)\n            goto cleanup;\n\n        if (!net)\n            continue;\n\n        if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:videos */\n    if (VIR_ALLOC_N(def->videos, 1) < 0)\n        goto cleanup;\n\n    def->nvideos = 0;\n\n    if (virVMXParseSVGA(conf, &def->videos[def->nvideos]) < 0)\n        goto cleanup;\n\n    def->nvideos = 1;\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    if (VIR_ALLOC_N(def->serials, 4) < 0)\n        goto cleanup;\n\n    def->nserials = 0;\n\n    for (port = 0; port < 4; ++port) {\n        if (virVMXParseSerial(ctx, conf, port,\n                              &def->serials[def->nserials]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->serials[def->nserials] != NULL)\n            ++def->nserials;\n    }\n\n    /* def:parallels */\n    if (VIR_ALLOC_N(def->parallels, 3) < 0)\n        goto cleanup;\n\n    def->nparallels = 0;\n\n    for (port = 0; port < 3; ++port) {\n        if (virVMXParseParallel(ctx, conf, port,\n                                &def->parallels[def->nparallels]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->parallels[def->nparallels] != NULL)\n            ++def->nparallels;\n    }\n\n    /* ctx:datacenterPath -> def:namespaceData */\n    if (ctx->datacenterPath || ctx->moref) {\n        struct virVMXDomainDefNamespaceData *nsdata = NULL;\n\n        if (VIR_ALLOC(nsdata) < 0) {\n            virVMXDomainDefNamespaceFree(nsdata);\n            goto cleanup;\n        }\n\n        nsdata->datacenterPath = g_strdup(ctx->datacenterPath);\n\n        nsdata->moref = g_strdup(ctx->moref);\n\n        def->ns = *virDomainXMLOptionGetNamespace(xmlopt);\n        def->namespaceData = nsdata;\n    }\n\n    /* vmx:firmware */\n    if (virVMXGetConfigString(conf, \"firmware\", &firmware, true) < 0)\n        goto cleanup;\n\n    if (firmware != NULL) {\n        if (STREQ(firmware, \"efi\")) {\n            def->os.firmware = VIR_DOMAIN_OS_DEF_FIRMWARE_EFI;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry 'firmware' has unknown value '%s'\"),\n                           firmware);\n            goto cleanup;\n        }\n    }\n\n    if (virDomainDefPostParse(def, VIR_DOMAIN_DEF_PARSE_ABI_UPDATE,\n                              xmlopt, NULL) < 0)\n        goto cleanup;\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        virDomainDefFree(def);\n        def = NULL;\n    }\n\n    VIR_FREE(encoding);\n    VIR_FREE(sched_cpu_affinity);\n    VIR_FREE(sched_cpu_shares);\n    VIR_FREE(guestOS);\n    virCPUDefFree(cpu);\n    VIR_FREE(firmware);\n\n    return def;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainDefPtr\nvirVMXParseConfig(virVMXContext *ctx,\n                  virDomainXMLOptionPtr xmlopt,\n                  virCapsPtr caps G_GNUC_UNUSED,\n                  const char *vmx)\n{\n    bool success = false;\n    g_autoptr(virConf) conf = NULL;\n    char *encoding = NULL;\n    char *utf8;\n    virDomainDefPtr def = NULL;\n    long long config_version = 0;\n    long long virtualHW_version = 0;\n    long long memsize = 0;\n    long long sched_mem_max = 0;\n    long long sched_mem_minsize = 0;\n    long long numvcpus = 0;\n    char *sched_cpu_affinity = NULL;\n    char *sched_cpu_shares = NULL;\n    char *guestOS = NULL;\n    bool smbios_reflecthost = false;\n    int controller;\n    int bus;\n    int port;\n    bool present;\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    int unit;\n    bool hgfs_disabled = true;\n    long long sharedFolder_maxNum = 0;\n    struct virVMXConfigScanResults results = { -1 };\n    long long coresPerSocket = 0;\n    virCPUDefPtr cpu = NULL;\n    char *firmware = NULL;\n\n    if (ctx->parseFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no parseFileName function set\"));\n        return NULL;\n    }\n\n    conf = virConfReadString(vmx, VIR_CONF_FLAG_VMX_FORMAT);\n\n    if (conf == NULL)\n        return NULL;\n\n    /* vmx:.encoding */\n    if (virVMXGetConfigString(conf, \".encoding\", &encoding, true) < 0)\n        goto cleanup;\n\n    if (encoding == NULL || STRCASEEQ(encoding, \"UTF-8\")) {\n        /* nothing */\n    } else {\n        virConfFree(conf);\n        conf = NULL;\n\n        utf8 = virVMXConvertToUTF8(encoding, vmx);\n\n        if (utf8 == NULL)\n            goto cleanup;\n\n        conf = virConfReadString(utf8, VIR_CONF_FLAG_VMX_FORMAT);\n\n        VIR_FREE(utf8);\n\n        if (conf == NULL)\n            goto cleanup;\n    }\n\n    if (virConfWalk(conf, virVMXConfigScanResultsCollector, &results) < 0)\n        goto cleanup;\n\n    /* Allocate domain def */\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    def->virtType = VIR_DOMAIN_VIRT_VMWARE;\n    def->id = -1;\n\n    /* vmx:config.version */\n    if (virVMXGetConfigLong(conf, \"config.version\", &config_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (config_version != 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'config.version' to be 8 but found \"\n                         \"%lld\"), config_version);\n        goto cleanup;\n    }\n\n    /* vmx:virtualHW.version */\n    if (virVMXGetConfigLong(conf, \"virtualHW.version\", &virtualHW_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualHW_version < 4) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'virtualHW.version' to be \"\n                         \"4 or higher but found %lld\"),\n                       virtualHW_version);\n        goto cleanup;\n    }\n\n    /* vmx:uuid.bios -> def:uuid */\n    /* FIXME: Need to handle 'uuid.action = \"create\"' */\n    if (virVMXGetConfigUUID(conf, \"uuid.bios\", def->uuid, true) < 0)\n        goto cleanup;\n\n    /* vmx:displayName -> def:name */\n    if (virVMXGetConfigString(conf, \"displayName\", &def->name, true) < 0)\n        goto cleanup;\n\n    if (def->name != NULL) {\n        if (virVMXUnescapeHexPercent(def->name) < 0 ||\n            virVMXUnescapeHexPipe(def->name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'name' contains invalid escape sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:annotation -> def:description */\n    if (virVMXGetConfigString(conf, \"annotation\", &def->description,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (def->description != NULL) {\n        if (virVMXUnescapeHexPipe(def->description) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'annotation' contains invalid escape \"\n                             \"sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:memsize -> def:mem.max_balloon */\n    if (virVMXGetConfigLong(conf, \"memsize\", &memsize, 32, true) < 0)\n        goto cleanup;\n\n    if (memsize <= 0 || memsize % 4 != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'memsize' to be an unsigned \"\n                         \"integer (multiple of 4) but found %lld\"), memsize);\n        goto cleanup;\n    }\n\n    virDomainDefSetMemoryTotal(def, memsize * 1024); /* Scale from megabytes to kilobytes */\n\n    /* vmx:sched.mem.max -> def:mem.cur_balloon */\n    if (virVMXGetConfigLong(conf, \"sched.mem.max\", &sched_mem_max, memsize,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_max < 0)\n        sched_mem_max = memsize;\n\n    def->mem.cur_balloon = sched_mem_max * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.cur_balloon > virDomainDefGetMemoryTotal(def))\n        def->mem.cur_balloon = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:sched.mem.minsize -> def:mem.min_guarantee */\n    if (virVMXGetConfigLong(conf, \"sched.mem.minsize\", &sched_mem_minsize, 0,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_minsize < 0)\n        sched_mem_minsize = 0;\n\n    def->mem.min_guarantee = sched_mem_minsize * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.min_guarantee > virDomainDefGetMemoryTotal(def))\n        def->mem.min_guarantee = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:numvcpus -> def:vcpus */\n    if (virVMXGetConfigLong(conf, \"numvcpus\", &numvcpus, 1, true) < 0)\n        goto cleanup;\n\n    if (numvcpus <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'numvcpus' to be an unsigned \"\n                         \"integer greater than 0 but found %lld\"), numvcpus);\n        goto cleanup;\n    }\n\n    if (virDomainDefSetVcpusMax(def, numvcpus, xmlopt) < 0)\n        goto cleanup;\n\n    if (virDomainDefSetVcpus(def, numvcpus) < 0)\n        goto cleanup;\n\n    /* vmx:cpuid.coresPerSocket -> def:cpu */\n    if (virVMXGetConfigLong(conf, \"cpuid.coresPerSocket\", &coresPerSocket, 1,\n                            true) < 0)\n        goto cleanup;\n\n    if (coresPerSocket > 1) {\n        cpu = virCPUDefNew();\n\n        cpu->type = VIR_CPU_TYPE_GUEST;\n        cpu->mode = VIR_CPU_MODE_CUSTOM;\n\n        cpu->sockets = numvcpus / coresPerSocket;\n        if (cpu->sockets <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'cpuid.coresPerSocket' smaller than \"\n                             \"'numvcpus'\"));\n            goto cleanup;\n        }\n        cpu->dies = 1;\n        cpu->cores = coresPerSocket;\n        cpu->threads = 1;\n\n        def->cpu = g_steal_pointer(&cpu);\n    }\n\n    /* vmx:sched.cpu.affinity -> def:cpumask */\n    /* NOTE: maps to VirtualMachine:config.cpuAffinity.affinitySet */\n    if (virVMXGetConfigString(conf, \"sched.cpu.affinity\", &sched_cpu_affinity,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_affinity != NULL && STRCASENEQ(sched_cpu_affinity, \"all\")) {\n        VIR_AUTOSTRINGLIST afflist = NULL;\n        char **aff;\n        size_t naffs;\n\n        def->cpumask = virBitmapNew(VIR_DOMAIN_CPUMASK_LEN);\n        if (!def->cpumask)\n            goto cleanup;\n\n        if (!(afflist = virStringSplitCount(sched_cpu_affinity, \",\", 0, &naffs)))\n            goto cleanup;\n\n        if (naffs < numvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.affinity' to contain \"\n                             \"at least as many values as 'numvcpus' (%lld) but \"\n                             \"found only %zu value(s)\"), numvcpus, naffs);\n            goto cleanup;\n        }\n\n        for (aff = afflist; *aff; aff++) {\n            const char *current = *aff;\n            unsigned int number;\n            int rc;\n\n            virSkipSpaces(&current);\n            rc = virStrToLong_uip(current, (char **) &current, 10, &number);\n            virSkipSpaces(&current);\n\n            if (rc < 0 || *current != '\\0') {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry 'sched.cpu.affinity' to be \"\n                                 \"a comma separated list of unsigned integers but \"\n                                 \"found '%s'\"), sched_cpu_affinity);\n                goto cleanup;\n            }\n\n            if (number >= VIR_DOMAIN_CPUMASK_LEN) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"VMX entry 'sched.cpu.affinity' contains a %d, \"\n                                 \"this value is too large\"), number);\n                goto cleanup;\n            }\n\n            ignore_value(virBitmapSetBit(def->cpumask, number));\n        }\n    }\n\n    /* vmx:sched.cpu.shares -> def:cputune.shares */\n    if (virVMXGetConfigString(conf, \"sched.cpu.shares\", &sched_cpu_shares,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_shares != NULL) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (STRCASEEQ(sched_cpu_shares, \"low\")) {\n            def->cputune.shares = vcpus * 500;\n        } else if (STRCASEEQ(sched_cpu_shares, \"normal\")) {\n            def->cputune.shares = vcpus * 1000;\n        } else if (STRCASEEQ(sched_cpu_shares, \"high\")) {\n            def->cputune.shares = vcpus * 2000;\n        } else if (virStrToLong_ull(sched_cpu_shares, NULL, 10,\n                                    &def->cputune.shares) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.shares' to be an \"\n                             \"unsigned integer or 'low', 'normal' or 'high' but \"\n                             \"found '%s'\"), sched_cpu_shares);\n            goto cleanup;\n        }\n        def->cputune.sharesSpecified = true;\n    }\n\n    /* def:lifecycle */\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* def:os */\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    /* vmx:guestOS -> def:os.arch */\n    if (virVMXGetConfigString(conf, \"guestOS\", &guestOS, true) < 0)\n        goto cleanup;\n\n    if (guestOS != NULL && virStringHasSuffix(guestOS, \"-64\")) {\n        def->os.arch = VIR_ARCH_X86_64;\n    } else {\n        def->os.arch = VIR_ARCH_I686;\n    }\n\n    /* vmx:smbios.reflecthost -> def:os.smbios_mode */\n    if (virVMXGetConfigBoolean(conf, \"smbios.reflecthost\",\n                               &smbios_reflecthost, false, true) < 0) {\n        goto cleanup;\n    }\n\n    if (smbios_reflecthost)\n        def->os.smbios_mode = VIR_DOMAIN_SMBIOS_HOST;\n\n    /* def:features */\n    /* FIXME */\n\n    /* def:clock */\n    /* FIXME */\n\n    /* def:graphics */\n    if (VIR_ALLOC_N(def->graphics, 1) < 0)\n        goto cleanup;\n\n    def->ngraphics = 0;\n\n    if (virVMXParseVNC(conf, &def->graphics[def->ngraphics]) < 0)\n        goto cleanup;\n\n    if (def->graphics[def->ngraphics] != NULL)\n        ++def->ngraphics;\n\n    /* def:disks: 4 * 15 scsi + 2 * 2 ide + 2 floppy = 66 */\n    if (VIR_ALLOC_N(def->disks, 66) < 0)\n        goto cleanup;\n\n    def->ndisks = 0;\n\n    /* def:disks (scsi) */\n    for (controller = 0; controller < 4; ++controller) {\n        if (virVMXParseSCSIController(conf, controller, &present,\n                                      &scsi_virtualDev[controller]) < 0) {\n            goto cleanup;\n        }\n\n        if (! present)\n            continue;\n\n        for (unit = 0; unit < 16; ++unit) {\n            if (unit == 7) {\n                /*\n                 * SCSI unit 7 is assigned to the SCSI controller and cannot be\n                 * used for disk devices.\n                 */\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                 VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                 &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n\n    }\n\n    /* add all the SCSI controllers we've seen, up until the last one that is\n     * currently used by a disk */\n    if (def->ndisks != 0) {\n        virDomainDeviceInfoPtr info = &def->disks[def->ndisks - 1]->info;\n        for (controller = 0; controller <= info->addr.drive.controller; controller++) {\n            if (!virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_SCSI,\n                                           controller, scsi_virtualDev[controller]))\n                goto cleanup;\n        }\n    }\n\n    /* def:disks (ide) */\n    for (bus = 0; bus < 2; ++bus) {\n        for (unit = 0; unit < 2; ++unit) {\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n    }\n\n    /* def:disks (floppy) */\n    for (unit = 0; unit < 2; ++unit) {\n        if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_FLOPPY,\n                            VIR_DOMAIN_DISK_BUS_FDC, 0, unit,\n                            &def->disks[def->ndisks], def) < 0) {\n            goto cleanup;\n        }\n\n        if (def->disks[def->ndisks] != NULL)\n            ++def->ndisks;\n    }\n\n    /* def:fss */\n    if (virVMXGetConfigBoolean(conf, \"isolation.tools.hgfs.disable\",\n                               &hgfs_disabled, true, true) < 0) {\n        goto cleanup;\n    }\n\n    if (!hgfs_disabled) {\n        if (virVMXGetConfigLong(conf, \"sharedFolder.maxNum\", &sharedFolder_maxNum,\n                                0, true) < 0) {\n            goto cleanup;\n        }\n\n        if (sharedFolder_maxNum > 0) {\n            int number;\n\n            if (VIR_ALLOC_N(def->fss, sharedFolder_maxNum) < 0)\n                goto cleanup;\n\n            def->nfss = 0;\n\n            for (number = 0; number < sharedFolder_maxNum; ++number) {\n                if (virVMXParseFileSystem(conf, number,\n                                          &def->fss[def->nfss]) < 0) {\n                    goto cleanup;\n                }\n\n                if (def->fss[def->nfss] != NULL)\n                    ++def->nfss;\n            }\n        }\n    }\n\n    /* def:nets */\n    for (controller = 0; controller <= results.networks_max_index; ++controller) {\n        virDomainNetDefPtr net = NULL;\n        if (virVMXParseEthernet(conf, controller, &net) < 0)\n            goto cleanup;\n\n        if (!net)\n            continue;\n\n        if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:videos */\n    if (VIR_ALLOC_N(def->videos, 1) < 0)\n        goto cleanup;\n\n    def->nvideos = 0;\n\n    if (virVMXParseSVGA(conf, &def->videos[def->nvideos]) < 0)\n        goto cleanup;\n\n    def->nvideos = 1;\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    if (VIR_ALLOC_N(def->serials, 4) < 0)\n        goto cleanup;\n\n    def->nserials = 0;\n\n    for (port = 0; port < 4; ++port) {\n        if (virVMXParseSerial(ctx, conf, port,\n                              &def->serials[def->nserials]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->serials[def->nserials] != NULL)\n            ++def->nserials;\n    }\n\n    /* def:parallels */\n    if (VIR_ALLOC_N(def->parallels, 3) < 0)\n        goto cleanup;\n\n    def->nparallels = 0;\n\n    for (port = 0; port < 3; ++port) {\n        if (virVMXParseParallel(ctx, conf, port,\n                                &def->parallels[def->nparallels]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->parallels[def->nparallels] != NULL)\n            ++def->nparallels;\n    }\n\n    /* ctx:datacenterPath -> def:namespaceData */\n    if (ctx->datacenterPath || ctx->moref) {\n        struct virVMXDomainDefNamespaceData *nsdata = NULL;\n\n        if (VIR_ALLOC(nsdata) < 0) {\n            virVMXDomainDefNamespaceFree(nsdata);\n            goto cleanup;\n        }\n\n        nsdata->datacenterPath = g_strdup(ctx->datacenterPath);\n\n        nsdata->moref = g_strdup(ctx->moref);\n\n        def->ns = *virDomainXMLOptionGetNamespace(xmlopt);\n        def->namespaceData = nsdata;\n    }\n\n    /* vmx:firmware */\n    if (virVMXGetConfigString(conf, \"firmware\", &firmware, true) < 0)\n        goto cleanup;\n\n    if (firmware != NULL) {\n        if (STREQ(firmware, \"efi\")) {\n            def->os.firmware = VIR_DOMAIN_OS_DEF_FIRMWARE_EFI;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry 'firmware' has unknown value '%s'\"),\n                           firmware);\n            goto cleanup;\n        }\n    }\n\n    if (virDomainDefPostParse(def, VIR_DOMAIN_DEF_PARSE_ABI_UPDATE,\n                              xmlopt, NULL) < 0)\n        goto cleanup;\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        virDomainDefFree(def);\n        def = NULL;\n    }\n\n    VIR_FREE(encoding);\n    VIR_FREE(sched_cpu_affinity);\n    VIR_FREE(sched_cpu_shares);\n    VIR_FREE(guestOS);\n    virCPUDefFree(cpu);\n    VIR_FREE(firmware);\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "vmxPath",
            "10000",
            "&vmx"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "str",
            "\"\\n\"",
            "&saveptr"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "&outbuf"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgList",
          "args": [
            "driver->vmrun",
            "\"-T\"",
            "vmwareDriverTypeToString(driver->type)",
            "\"list\"",
            "NULL"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmwareDriverTypeToString",
          "args": [
            "driver->type"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nint\nvmwareLoadDomains(struct vmware_driver *driver)\n{\n    virDomainDefPtr vmdef = NULL;\n    virDomainObjPtr vm = NULL;\n    char *vmxPath = NULL;\n    char *vmx = NULL;\n    vmwareDomainPtr pDomain;\n    char *directoryName = NULL;\n    char *fileName = NULL;\n    int ret = -1;\n    virVMXContext ctx;\n    char *outbuf = NULL;\n    char *str;\n    char *saveptr = NULL;\n    virCommandPtr cmd;\n\n    ctx.parseFileName = vmwareCopyVMXFileName;\n    ctx.formatFileName = NULL;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = NULL;\n\n    cmd = virCommandNewArgList(driver->vmrun, \"-T\",\n                               vmwareDriverTypeToString(driver->type),\n                               \"list\", NULL);\n    virCommandSetOutputBuffer(cmd, &outbuf);\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    for (str = outbuf; (vmxPath = strtok_r(str, \"\\n\", &saveptr)) != NULL;\n        str = NULL) {\n\n        if (vmxPath[0] != '/')\n            continue;\n\n        if (virFileReadAll(vmxPath, 10000, &vmx) < 0)\n            goto cleanup;\n\n        if ((vmdef =\n             virVMXParseConfig(&ctx, driver->xmlopt,\n                               driver->caps, vmx)) == NULL) {\n            goto cleanup;\n        }\n\n        if (!(vm = virDomainObjListAdd(driver->domains, vmdef,\n                                       driver->xmlopt,\n                                       0, NULL)))\n            goto cleanup;\n\n        pDomain = vm->privateData;\n\n        pDomain->vmxPath = g_strdup(vmxPath);\n\n        vmwareDomainConfigDisplay(pDomain, vmdef);\n\n        if ((vm->def->id = vmwareExtractPid(vmxPath)) < 0)\n            goto cleanup;\n        /* vmrun list only reports running vms */\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_UNKNOWN);\n        vm->persistent = 1;\n\n        virDomainObjEndAPI(&vm);\n\n        vmdef = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    virCommandFree(cmd);\n    VIR_FREE(outbuf);\n    virDomainDefFree(vmdef);\n    VIR_FREE(directoryName);\n    VIR_FREE(fileName);\n    VIR_FREE(vmx);\n    virObjectUnref(vm);\n    return ret;\n}"
  },
  {
    "function_name": "vmwareCapsInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
    "lines": "64-125",
    "snippet": "virCapsPtr\nvmwareCapsInit(void)\n{\n    virCapsPtr caps = NULL;\n    virCapsGuestPtr guest = NULL;\n\n    if ((caps = virCapabilitiesNew(virArchFromHost(),\n                                   false, false)) == NULL)\n        goto error;\n\n    if (!(caps->host.numa = virCapabilitiesHostNUMANewHost()))\n        goto error;\n\n    if (virCapabilitiesInitCaches(caps) < 0)\n        VIR_WARN(\"Failed to get host CPU cache info\");\n\n    /* i686 guests are always supported */\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_HVM,\n                                         VIR_ARCH_I686,\n                                         NULL, NULL, 0, NULL)) == NULL)\n        goto error;\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_VMWARE,\n                                      NULL, NULL, 0, NULL) == NULL)\n        goto error;\n    guest = NULL;\n\n    if (!(caps->host.cpu = virCPUProbeHost(caps->host.arch)))\n        goto error;\n\n    /* x86_64 guests are supported if\n     *  - Host arch is x86_64\n     * Or\n     *  - Host CPU is x86_64 with virtualization extensions\n     */\n    if (caps->host.arch == VIR_ARCH_X86_64 ||\n        (virCPUCheckFeature(caps->host.cpu->arch, caps->host.cpu, \"lm\") &&\n         (virCPUCheckFeature(caps->host.cpu->arch, caps->host.cpu, \"vmx\") ||\n          virCPUCheckFeature(caps->host.cpu->arch, caps->host.cpu, \"svm\")))) {\n\n        if ((guest = virCapabilitiesAddGuest(caps,\n                                             VIR_DOMAIN_OSTYPE_HVM,\n                                             VIR_ARCH_X86_64,\n                                             NULL, NULL, 0, NULL)) == NULL)\n            goto error;\n\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_VMWARE,\n                                          NULL, NULL, 0, NULL) == NULL)\n            goto error;\n        guest = NULL;\n    }\n\n    return caps;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    virObjectUnref(caps);\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"vircommand.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "caps"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFreeGuest",
          "args": [
            "guest"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFreeGuest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "153-171",
          "snippet": "void\nvirCapabilitiesFreeGuest(virCapsGuestPtr guest)\n{\n    size_t i;\n    if (guest == NULL)\n        return;\n\n    VIR_FREE(guest->arch.defaultInfo.emulator);\n    VIR_FREE(guest->arch.defaultInfo.loader);\n    for (i = 0; i < guest->arch.defaultInfo.nmachines; i++)\n        virCapabilitiesFreeGuestMachine(guest->arch.defaultInfo.machines[i]);\n    VIR_FREE(guest->arch.defaultInfo.machines);\n\n    for (i = 0; i < guest->arch.ndomains; i++)\n        virCapabilitiesFreeGuestDomain(guest->arch.domains[i]);\n    VIR_FREE(guest->arch.domains);\n\n    VIR_FREE(guest);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesFreeGuest(virCapsGuestPtr guest)\n{\n    size_t i;\n    if (guest == NULL)\n        return;\n\n    VIR_FREE(guest->arch.defaultInfo.emulator);\n    VIR_FREE(guest->arch.defaultInfo.loader);\n    for (i = 0; i < guest->arch.defaultInfo.nmachines; i++)\n        virCapabilitiesFreeGuestMachine(guest->arch.defaultInfo.machines[i]);\n    VIR_FREE(guest->arch.defaultInfo.machines);\n\n    for (i = 0; i < guest->arch.ndomains; i++)\n        virCapabilitiesFreeGuestDomain(guest->arch.domains[i]);\n    VIR_FREE(guest->arch.domains);\n\n    VIR_FREE(guest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuestDomain",
          "args": [
            "guest",
            "VIR_DOMAIN_VIRT_VMWARE",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuestDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "485-518",
          "snippet": "virCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuest",
          "args": [
            "caps",
            "VIR_DOMAIN_OSTYPE_HVM",
            "VIR_ARCH_X86_64",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "434-470",
          "snippet": "virCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUCheckFeature",
          "args": [
            "caps->host.cpu->arch",
            "caps->host.cpu",
            "\"svm\""
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUCheckFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "674-695",
          "snippet": "int\nvirCPUCheckFeature(virArch arch,\n                   const virCPUDef *cpu,\n                   const char *feature)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, feature=%s\",\n              virArchToString(arch), cpu, feature);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->checkFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot check guest CPU feature for %s architecture\"),\n                       virArchToString(arch));\n        return -1;\n    }\n\n    return driver->checkFeature(cpu, feature);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUCheckFeature(virArch arch,\n                   const virCPUDef *cpu,\n                   const char *feature)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, feature=%s\",\n              virArchToString(arch), cpu, feature);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->checkFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot check guest CPU feature for %s architecture\"),\n                       virArchToString(arch));\n        return -1;\n    }\n\n    return driver->checkFeature(cpu, feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUProbeHost",
          "args": [
            "caps->host.arch"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUProbeHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "454-463",
          "snippet": "virCPUDefPtr\nvirCPUProbeHost(virArch arch)\n{\n    virNodeInfo nodeinfo;\n\n    if (virCapabilitiesGetNodeInfo(&nodeinfo) < 0)\n        return NULL;\n\n    return virCPUGetHost(arch, VIR_CPU_TYPE_HOST, &nodeinfo, NULL);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUProbeHost(virArch arch)\n{\n    virNodeInfo nodeinfo;\n\n    if (virCapabilitiesGetNodeInfo(&nodeinfo) < 0)\n        return NULL;\n\n    return virCPUGetHost(arch, VIR_CPU_TYPE_HOST, &nodeinfo, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to get host CPU cache info\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesInitCaches",
          "args": [
            "caps"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesInitCaches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1857-2002",
          "snippet": "int\nvirCapabilitiesInitCaches(virCapsPtr caps)\n{\n    size_t i = 0;\n    virBitmapPtr cpus = NULL;\n    ssize_t pos = -1;\n    DIR *dirp = NULL;\n    int ret = -1;\n    char *path = NULL;\n    char *type = NULL;\n    struct dirent *ent = NULL;\n    virCapsHostCacheBankPtr bank = NULL;\n    const virResctrlMonitorType montype = VIR_RESCTRL_MONITOR_TYPE_CACHE;\n    const char *prefix = virResctrlMonitorPrefixTypeToString(montype);\n\n    /* Minimum level to expose in capabilities.  Can be lowered or removed (with\n     * the appropriate code below), but should not be increased, because we'd\n     * lose information. */\n    const int cache_min_level = 3;\n\n    if (virCapabilitiesInitResctrl(caps) < 0)\n        return -1;\n\n    /* offline CPUs don't provide cache info */\n    if (virFileReadValueBitmap(&cpus, \"%s/cpu/online\", SYSFS_SYSTEM_PATH) < 0)\n        return -1;\n\n    while ((pos = virBitmapNextSetBit(cpus, pos)) >= 0) {\n        int rv = -1;\n\n        VIR_FREE(path);\n        path = g_strdup_printf(\"%s/cpu/cpu%zd/cache/\", SYSFS_SYSTEM_PATH, pos);\n\n        VIR_DIR_CLOSE(dirp);\n\n        rv = virDirOpenIfExists(&dirp, path);\n        if (rv < 0)\n            goto cleanup;\n\n        if (!dirp)\n            continue;\n\n        while ((rv = virDirRead(dirp, &ent, path)) > 0) {\n            int kernel_type;\n            unsigned int level;\n\n            if (!STRPREFIX(ent->d_name, \"index\"))\n                continue;\n\n            if (virFileReadValueUint(&level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (level < cache_min_level)\n                continue;\n\n            if (VIR_ALLOC(bank) < 0)\n                goto cleanup;\n\n            bank->level = level;\n\n            if (virFileReadValueUint(&bank->id,\n                                     \"%s/cpu/cpu%zd/cache/%s/id\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueUint(&bank->level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueString(&type,\n                                       \"%s/cpu/cpu%zd/cache/%s/type\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueScaledInt(&bank->size,\n                                          \"%s/cpu/cpu%zd/cache/%s/size\",\n                                          SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueBitmap(&bank->cpus,\n                                       \"%s/cpu/cpu%zd/cache/%s/shared_cpu_list\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            kernel_type = virCacheKernelTypeFromString(type);\n            if (kernel_type < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown cache type '%s'\"), type);\n                goto cleanup;\n            }\n\n            bank->type = kernel_type;\n            VIR_FREE(type);\n\n            for (i = 0; i < caps->host.cache.nbanks; i++) {\n                if (virCapsHostCacheBankEquals(bank, caps->host.cache.banks[i]))\n                    break;\n            }\n            if (i == caps->host.cache.nbanks) {\n                /* If it is a new cache, then update its resctrl information. */\n                if (virResctrlInfoGetCache(caps->host.resctrl,\n                                           bank->level,\n                                           bank->size,\n                                           &bank->ncontrols,\n                                           &bank->controls) < 0)\n                    goto cleanup;\n\n                if (VIR_APPEND_ELEMENT(caps->host.cache.banks,\n                                       caps->host.cache.nbanks,\n                                       bank) < 0) {\n                    goto cleanup;\n                }\n            }\n\n            virCapsHostCacheBankFree(bank);\n            bank = NULL;\n        }\n        if (rv < 0)\n            goto cleanup;\n    }\n\n    /* Sort the array in order for the tests to be predictable.  This way we can\n     * still traverse the directory instead of guessing names (in case there is\n     * 'index1' and 'index3' but no 'index2'). */\n    qsort(caps->host.cache.banks, caps->host.cache.nbanks,\n          sizeof(*caps->host.cache.banks), virCapsHostCacheBankSorter);\n\n    if (virCapabilitiesInitResctrlMemory(caps) < 0)\n        goto cleanup;\n\n    if (virResctrlInfoGetMonitorPrefix(caps->host.resctrl, prefix,\n                                       &caps->host.cache.monitor) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    VIR_FREE(path);\n    VIR_DIR_CLOSE(dirp);\n    virCapsHostCacheBankFree(bank);\n    virBitmapFree(cpus);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirCapabilitiesInitCaches(virCapsPtr caps)\n{\n    size_t i = 0;\n    virBitmapPtr cpus = NULL;\n    ssize_t pos = -1;\n    DIR *dirp = NULL;\n    int ret = -1;\n    char *path = NULL;\n    char *type = NULL;\n    struct dirent *ent = NULL;\n    virCapsHostCacheBankPtr bank = NULL;\n    const virResctrlMonitorType montype = VIR_RESCTRL_MONITOR_TYPE_CACHE;\n    const char *prefix = virResctrlMonitorPrefixTypeToString(montype);\n\n    /* Minimum level to expose in capabilities.  Can be lowered or removed (with\n     * the appropriate code below), but should not be increased, because we'd\n     * lose information. */\n    const int cache_min_level = 3;\n\n    if (virCapabilitiesInitResctrl(caps) < 0)\n        return -1;\n\n    /* offline CPUs don't provide cache info */\n    if (virFileReadValueBitmap(&cpus, \"%s/cpu/online\", SYSFS_SYSTEM_PATH) < 0)\n        return -1;\n\n    while ((pos = virBitmapNextSetBit(cpus, pos)) >= 0) {\n        int rv = -1;\n\n        VIR_FREE(path);\n        path = g_strdup_printf(\"%s/cpu/cpu%zd/cache/\", SYSFS_SYSTEM_PATH, pos);\n\n        VIR_DIR_CLOSE(dirp);\n\n        rv = virDirOpenIfExists(&dirp, path);\n        if (rv < 0)\n            goto cleanup;\n\n        if (!dirp)\n            continue;\n\n        while ((rv = virDirRead(dirp, &ent, path)) > 0) {\n            int kernel_type;\n            unsigned int level;\n\n            if (!STRPREFIX(ent->d_name, \"index\"))\n                continue;\n\n            if (virFileReadValueUint(&level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (level < cache_min_level)\n                continue;\n\n            if (VIR_ALLOC(bank) < 0)\n                goto cleanup;\n\n            bank->level = level;\n\n            if (virFileReadValueUint(&bank->id,\n                                     \"%s/cpu/cpu%zd/cache/%s/id\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueUint(&bank->level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueString(&type,\n                                       \"%s/cpu/cpu%zd/cache/%s/type\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueScaledInt(&bank->size,\n                                          \"%s/cpu/cpu%zd/cache/%s/size\",\n                                          SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueBitmap(&bank->cpus,\n                                       \"%s/cpu/cpu%zd/cache/%s/shared_cpu_list\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            kernel_type = virCacheKernelTypeFromString(type);\n            if (kernel_type < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown cache type '%s'\"), type);\n                goto cleanup;\n            }\n\n            bank->type = kernel_type;\n            VIR_FREE(type);\n\n            for (i = 0; i < caps->host.cache.nbanks; i++) {\n                if (virCapsHostCacheBankEquals(bank, caps->host.cache.banks[i]))\n                    break;\n            }\n            if (i == caps->host.cache.nbanks) {\n                /* If it is a new cache, then update its resctrl information. */\n                if (virResctrlInfoGetCache(caps->host.resctrl,\n                                           bank->level,\n                                           bank->size,\n                                           &bank->ncontrols,\n                                           &bank->controls) < 0)\n                    goto cleanup;\n\n                if (VIR_APPEND_ELEMENT(caps->host.cache.banks,\n                                       caps->host.cache.nbanks,\n                                       bank) < 0) {\n                    goto cleanup;\n                }\n            }\n\n            virCapsHostCacheBankFree(bank);\n            bank = NULL;\n        }\n        if (rv < 0)\n            goto cleanup;\n    }\n\n    /* Sort the array in order for the tests to be predictable.  This way we can\n     * still traverse the directory instead of guessing names (in case there is\n     * 'index1' and 'index3' but no 'index2'). */\n    qsort(caps->host.cache.banks, caps->host.cache.nbanks,\n          sizeof(*caps->host.cache.banks), virCapsHostCacheBankSorter);\n\n    if (virCapabilitiesInitResctrlMemory(caps) < 0)\n        goto cleanup;\n\n    if (virResctrlInfoGetMonitorPrefix(caps->host.resctrl, prefix,\n                                       &caps->host.cache.monitor) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    VIR_FREE(path);\n    VIR_DIR_CLOSE(dirp);\n    virCapsHostCacheBankFree(bank);\n    virBitmapFree(cpus);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMANewHost",
          "args": [],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMANewHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1714-1734",
          "snippet": "virCapsHostNUMAPtr\nvirCapabilitiesHostNUMANewHost(void)\n{\n    virCapsHostNUMAPtr caps = virCapabilitiesHostNUMANew();\n\n    if (virNumaIsAvailable()) {\n        if (virCapabilitiesHostNUMAInitReal(caps) == 0)\n            return caps;\n\n        virCapabilitiesHostNUMAUnref(caps);\n        caps = virCapabilitiesHostNUMANew();\n        VIR_WARN(\"Failed to query host NUMA topology, faking single NUMA node\");\n    }\n\n    if (virCapabilitiesHostNUMAInitFake(caps) < 0) {\n        virCapabilitiesHostNUMAUnref(caps);\n        return NULL;\n    }\n\n    return caps;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsHostNUMAPtr\nvirCapabilitiesHostNUMANewHost(void)\n{\n    virCapsHostNUMAPtr caps = virCapabilitiesHostNUMANew();\n\n    if (virNumaIsAvailable()) {\n        if (virCapabilitiesHostNUMAInitReal(caps) == 0)\n            return caps;\n\n        virCapabilitiesHostNUMAUnref(caps);\n        caps = virCapabilitiesHostNUMANew();\n        VIR_WARN(\"Failed to query host NUMA topology, faking single NUMA node\");\n    }\n\n    if (virCapabilitiesHostNUMAInitFake(caps) < 0) {\n        virCapabilitiesHostNUMAUnref(caps);\n        return NULL;\n    }\n\n    return caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesNew",
          "args": [
            "virArchFromHost()",
            "false",
            "false"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "78-96",
          "snippet": "virCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virCapsClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virCapsClass;\n\nvirCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virArchFromHost",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "206-235",
          "snippet": "virArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nvirArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nvirCapsPtr\nvmwareCapsInit(void)\n{\n    virCapsPtr caps = NULL;\n    virCapsGuestPtr guest = NULL;\n\n    if ((caps = virCapabilitiesNew(virArchFromHost(),\n                                   false, false)) == NULL)\n        goto error;\n\n    if (!(caps->host.numa = virCapabilitiesHostNUMANewHost()))\n        goto error;\n\n    if (virCapabilitiesInitCaches(caps) < 0)\n        VIR_WARN(\"Failed to get host CPU cache info\");\n\n    /* i686 guests are always supported */\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_HVM,\n                                         VIR_ARCH_I686,\n                                         NULL, NULL, 0, NULL)) == NULL)\n        goto error;\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_VMWARE,\n                                      NULL, NULL, 0, NULL) == NULL)\n        goto error;\n    guest = NULL;\n\n    if (!(caps->host.cpu = virCPUProbeHost(caps->host.arch)))\n        goto error;\n\n    /* x86_64 guests are supported if\n     *  - Host arch is x86_64\n     * Or\n     *  - Host CPU is x86_64 with virtualization extensions\n     */\n    if (caps->host.arch == VIR_ARCH_X86_64 ||\n        (virCPUCheckFeature(caps->host.cpu->arch, caps->host.cpu, \"lm\") &&\n         (virCPUCheckFeature(caps->host.cpu->arch, caps->host.cpu, \"vmx\") ||\n          virCPUCheckFeature(caps->host.cpu->arch, caps->host.cpu, \"svm\")))) {\n\n        if ((guest = virCapabilitiesAddGuest(caps,\n                                             VIR_DOMAIN_OSTYPE_HVM,\n                                             VIR_ARCH_X86_64,\n                                             NULL, NULL, 0, NULL)) == NULL)\n            goto error;\n\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_VMWARE,\n                                          NULL, NULL, 0, NULL) == NULL)\n            goto error;\n        guest = NULL;\n    }\n\n    return caps;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    virObjectUnref(caps);\n    return NULL;\n}"
  },
  {
    "function_name": "vmwareFreeDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmware/vmware_conf.c",
    "lines": "49-61",
    "snippet": "void\nvmwareFreeDriver(struct vmware_driver *driver)\n{\n    if (!driver)\n        return;\n\n    virMutexDestroy(&driver->lock);\n    virObjectUnref(driver->domains);\n    virObjectUnref(driver->caps);\n    virObjectUnref(driver->xmlopt);\n    VIR_FREE(driver->vmrun);\n    VIR_FREE(driver);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virstring.h\"",
      "#include \"vmware_conf.h\"",
      "#include \"vmx.h\"",
      "#include \"virerror.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"cpu/cpu.h\"",
      "#include \"vircommand.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver->vmrun"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "driver->xmlopt"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&driver->lock"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"vmware_conf.h\"\n#include \"vmx.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"cpu/cpu.h\"\n#include \"vircommand.h\"\n#include <config.h>\n\nvoid\nvmwareFreeDriver(struct vmware_driver *driver)\n{\n    if (!driver)\n        return;\n\n    virMutexDestroy(&driver->lock);\n    virObjectUnref(driver->domains);\n    virObjectUnref(driver->caps);\n    virObjectUnref(driver->xmlopt);\n    VIR_FREE(driver->vmrun);\n    VIR_FREE(driver);\n}"
  }
]