[
  {
    "function_name": "halNodeRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "835-843",
    "snippet": "int\nhalNodeRegister(void)\n{\n    if (virRegisterConnectDriver(&halConnectDriver, false) < 0)\n        return -1;\n    if (virSetSharedNodeDeviceDriver(&halNodeDeviceDriver) < 0)\n        return -1;\n    return virRegisterStateDriver(&halStateDriver);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virNodeDeviceDriver halNodeDeviceDriver = {\n    .name = \"HAL\",\n    .nodeNumOfDevices = nodeNumOfDevices, /* 0.5.0 */\n    .nodeListDevices = nodeListDevices, /* 0.5.0 */\n    .connectListAllNodeDevices = nodeConnectListAllNodeDevices, /* 0.10.2 */\n    .nodeDeviceLookupByName = nodeDeviceLookupByName, /* 0.5.0 */\n    .nodeDeviceLookupSCSIHostByWWN = nodeDeviceLookupSCSIHostByWWN, /* 1.0.2 */\n    .nodeDeviceGetXMLDesc = nodeDeviceGetXMLDesc, /* 0.5.0 */\n    .nodeDeviceGetParent = nodeDeviceGetParent, /* 0.5.0 */\n    .nodeDeviceNumOfCaps = nodeDeviceNumOfCaps, /* 0.5.0 */\n    .nodeDeviceListCaps = nodeDeviceListCaps, /* 0.5.0 */\n    .nodeDeviceCreateXML = nodeDeviceCreateXML, /* 0.6.5 */\n    .nodeDeviceDestroy = nodeDeviceDestroy, /* 0.6.5 */\n};",
      "static virConnectDriver halConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"nodedev\", NULL },\n    .hypervisorDriver = &halHypervisorDriver,\n    .nodeDeviceDriver = &halNodeDeviceDriver,\n};",
      "static virStateDriver halStateDriver = {\n    .name = \"HAL\",\n    .stateInitialize = nodeStateInitialize, /* 0.5.0 */\n    .stateCleanup = nodeStateCleanup, /* 0.5.0 */\n    .stateReload = nodeStateReload, /* 0.5.0 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virRegisterStateDriver",
          "args": [
            "&halStateDriver"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "virRegisterStateDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "588-602",
          "snippet": "int\nvirRegisterStateDriver(virStateDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virStateDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->name);\n        return -1;\n    }\n\n    virStateDriverTab[virStateDriverTabCount] = driver;\n    return virStateDriverTabCount++;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_DRIVERS 21"
          ],
          "globals_used": [
            "static virStateDriverPtr virStateDriverTab[MAX_DRIVERS];",
            "static int virStateDriverTabCount;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virStateDriverPtr virStateDriverTab[MAX_DRIVERS];\nstatic int virStateDriverTabCount;\n\nint\nvirRegisterStateDriver(virStateDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virStateDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->name);\n        return -1;\n    }\n\n    virStateDriverTab[virStateDriverTabCount] = driver;\n    return virStateDriverTabCount++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetSharedNodeDeviceDriver",
          "args": [
            "&halNodeDeviceDriver"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "virSetSharedNodeDeviceDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "435-450",
          "snippet": "int\nvirSetSharedNodeDeviceDriver(virNodeDeviceDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedNodeDeviceDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A node device driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as device driver\", driver->name);\n\n    virSharedNodeDeviceDriver = driver;\n    return 0;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virNodeDeviceDriverPtr virSharedNodeDeviceDriver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virNodeDeviceDriverPtr virSharedNodeDeviceDriver;\n\nint\nvirSetSharedNodeDeviceDriver(virNodeDeviceDriverPtr driver)\n{\n    virCheckNonNullArgReturn(driver, -1);\n\n    if (virSharedNodeDeviceDriver) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"A node device driver is already registered\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as device driver\", driver->name);\n\n    virSharedNodeDeviceDriver = driver;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virRegisterConnectDriver",
          "args": [
            "&halConnectDriver",
            "false"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "virRegisterConnectDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "515-550",
          "snippet": "int\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_DRIVERS 21"
          ],
          "globals_used": [
            "static virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];",
            "static int virConnectDriverTabCount;",
            "static virNetworkDriverPtr virSharedNetworkDriver;",
            "static virInterfaceDriverPtr virSharedInterfaceDriver;",
            "static virStorageDriverPtr virSharedStorageDriver;",
            "static virNodeDeviceDriverPtr virSharedNodeDeviceDriver;",
            "static virSecretDriverPtr virSharedSecretDriver;",
            "static virNWFilterDriverPtr virSharedNWFilterDriver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];\nstatic int virConnectDriverTabCount;\nstatic virNetworkDriverPtr virSharedNetworkDriver;\nstatic virInterfaceDriverPtr virSharedInterfaceDriver;\nstatic virStorageDriverPtr virSharedStorageDriver;\nstatic virNodeDeviceDriverPtr virSharedNodeDeviceDriver;\nstatic virSecretDriverPtr virSharedSecretDriver;\nstatic virNWFilterDriverPtr virSharedNWFilterDriver;\n\nint\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic virNodeDeviceDriver halNodeDeviceDriver = {\n    .name = \"HAL\",\n    .nodeNumOfDevices = nodeNumOfDevices, /* 0.5.0 */\n    .nodeListDevices = nodeListDevices, /* 0.5.0 */\n    .connectListAllNodeDevices = nodeConnectListAllNodeDevices, /* 0.10.2 */\n    .nodeDeviceLookupByName = nodeDeviceLookupByName, /* 0.5.0 */\n    .nodeDeviceLookupSCSIHostByWWN = nodeDeviceLookupSCSIHostByWWN, /* 1.0.2 */\n    .nodeDeviceGetXMLDesc = nodeDeviceGetXMLDesc, /* 0.5.0 */\n    .nodeDeviceGetParent = nodeDeviceGetParent, /* 0.5.0 */\n    .nodeDeviceNumOfCaps = nodeDeviceNumOfCaps, /* 0.5.0 */\n    .nodeDeviceListCaps = nodeDeviceListCaps, /* 0.5.0 */\n    .nodeDeviceCreateXML = nodeDeviceCreateXML, /* 0.6.5 */\n    .nodeDeviceDestroy = nodeDeviceDestroy, /* 0.6.5 */\n};\nstatic virConnectDriver halConnectDriver = {\n    .localOnly = true,\n    .uriSchemes = (const char *[]){ \"nodedev\", NULL },\n    .hypervisorDriver = &halHypervisorDriver,\n    .nodeDeviceDriver = &halNodeDeviceDriver,\n};\nstatic virStateDriver halStateDriver = {\n    .name = \"HAL\",\n    .stateInitialize = nodeStateInitialize, /* 0.5.0 */\n    .stateCleanup = nodeStateCleanup, /* 0.5.0 */\n    .stateReload = nodeStateReload, /* 0.5.0 */\n};\n\nint\nhalNodeRegister(void)\n{\n    if (virRegisterConnectDriver(&halConnectDriver, false) < 0)\n        return -1;\n    if (virSetSharedNodeDeviceDriver(&halNodeDeviceDriver) < 0)\n        return -1;\n    return virRegisterStateDriver(&halStateDriver);\n}"
  },
  {
    "function_name": "nodeStateReload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "759-791",
    "snippet": "static int\nnodeStateReload(void)\n{\n    DBusError err;\n    char **udi = NULL;\n    int num_devs;\n    size_t i;\n    LibHalContext *hal_ctx;\n\n    VIR_INFO(\"Reloading HAL device state\");\n    nodeDeviceLock();\n    VIR_INFO(\"Removing existing objects\");\n    virNodeDeviceObjListFree(driver->devs);\n    nodeDeviceUnlock();\n\n    hal_ctx = DRV_STATE_HAL_CTX(driver);\n    VIR_INFO(\"Creating new objects\");\n    dbus_error_init(&err);\n    udi = libhal_get_all_devices(hal_ctx, &num_devs, &err);\n    if (udi == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libhal_get_all_devices failed\"));\n        return -1;\n    }\n    for (i = 0; i < num_devs; i++) {\n        dev_create(udi[i]);\n        VIR_FREE(udi[i]);\n    }\n    VIR_FREE(udi);\n    VIR_INFO(\"HAL device reload complete\");\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"HAL device reload complete\""
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "udi"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "udi[i]"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_create",
          "args": [
            "udi[i]"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "dev_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "439-491",
          "snippet": "static void\ndev_create(const char *udi)\n{\n    LibHalContext *ctx;\n    char *parent_key = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceDefPtr objdef;\n    const char *name = hal_name(udi);\n    int rv;\n    char *devicePath = NULL;\n\n    nodeDeviceLock();\n    ctx = DRV_STATE_HAL_CTX(driver);\n\n    if (VIR_ALLOC(def) < 0)\n        goto failure;\n\n    def->name = g_strdup(name);\n\n    if (get_str_prop(ctx, udi, \"info.parent\", &parent_key) == 0) {\n        def->parent = g_strdup(hal_name(parent_key));\n        VIR_FREE(parent_key);\n    }\n\n    rv = gather_capabilities(ctx, udi, &def->caps);\n    if (rv != 0) goto failure;\n\n    if (def->caps == NULL)\n        goto cleanup;\n\n    /* Some devices don't have a path in sysfs, so ignore failure */\n    (void)get_str_prop(ctx, udi, \"linux.sysfs_path\", &devicePath);\n\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def))) {\n        VIR_FREE(devicePath);\n        goto failure;\n    }\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    objdef->sysfs_path = devicePath;\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    nodeDeviceUnlock();\n    return;\n\n failure:\n    VIR_DEBUG(\"FAILED TO ADD dev %s\", name);\n cleanup:\n    virNodeDeviceDefFree(def);\n    nodeDeviceUnlock();\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_create(const char *udi)\n{\n    LibHalContext *ctx;\n    char *parent_key = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceDefPtr objdef;\n    const char *name = hal_name(udi);\n    int rv;\n    char *devicePath = NULL;\n\n    nodeDeviceLock();\n    ctx = DRV_STATE_HAL_CTX(driver);\n\n    if (VIR_ALLOC(def) < 0)\n        goto failure;\n\n    def->name = g_strdup(name);\n\n    if (get_str_prop(ctx, udi, \"info.parent\", &parent_key) == 0) {\n        def->parent = g_strdup(hal_name(parent_key));\n        VIR_FREE(parent_key);\n    }\n\n    rv = gather_capabilities(ctx, udi, &def->caps);\n    if (rv != 0) goto failure;\n\n    if (def->caps == NULL)\n        goto cleanup;\n\n    /* Some devices don't have a path in sysfs, so ignore failure */\n    (void)get_str_prop(ctx, udi, \"linux.sysfs_path\", &devicePath);\n\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def))) {\n        VIR_FREE(devicePath);\n        goto failure;\n    }\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    objdef->sysfs_path = devicePath;\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    nodeDeviceUnlock();\n    return;\n\n failure:\n    VIR_DEBUG(\"FAILED TO ADD dev %s\", name);\n cleanup:\n    virNodeDeviceDefFree(def);\n    nodeDeviceUnlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"libhal_get_all_devices failed\")"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"libhal_get_all_devices failed\""
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "libhal_get_all_devices",
          "args": [
            "hal_ctx",
            "&num_devs",
            "&err"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_error_init",
          "args": [
            "&err"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Creating new objects\""
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DRV_STATE_HAL_CTX",
          "args": [
            "driver"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeDeviceUnlock",
          "args": [],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "nodeDeviceUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_driver.c",
          "lines": "152-156",
          "snippet": "void\nnodeDeviceUnlock(void)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virvhba.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virNodeDeviceDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"viraccessapicheck.h\"\n#include \"virvhba.h\"\n#include \"node_device_util.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <time.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDriverStatePtr driver;\n\nvoid\nnodeDeviceUnlock(void)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListFree",
          "args": [
            "driver->devs"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "432-436",
          "snippet": "void\nvirNodeDeviceObjListFree(virNodeDeviceObjListPtr devs)\n{\n    virObjectUnref(devs);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirNodeDeviceObjListFree(virNodeDeviceObjListPtr devs)\n{\n    virObjectUnref(devs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Removing existing objects\""
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeDeviceLock",
          "args": [],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "nodeDeviceLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_driver.c",
          "lines": "145-149",
          "snippet": "void\nnodeDeviceLock(void)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virvhba.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virNodeDeviceDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"viraccessapicheck.h\"\n#include \"virvhba.h\"\n#include \"node_device_util.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <time.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDriverStatePtr driver;\n\nvoid\nnodeDeviceLock(void)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Reloading HAL device state\""
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nnodeStateReload(void)\n{\n    DBusError err;\n    char **udi = NULL;\n    int num_devs;\n    size_t i;\n    LibHalContext *hal_ctx;\n\n    VIR_INFO(\"Reloading HAL device state\");\n    nodeDeviceLock();\n    VIR_INFO(\"Removing existing objects\");\n    virNodeDeviceObjListFree(driver->devs);\n    nodeDeviceUnlock();\n\n    hal_ctx = DRV_STATE_HAL_CTX(driver);\n    VIR_INFO(\"Creating new objects\");\n    dbus_error_init(&err);\n    udi = libhal_get_all_devices(hal_ctx, &num_devs, &err);\n    if (udi == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libhal_get_all_devices failed\"));\n        return -1;\n    }\n    for (i = 0; i < num_devs; i++) {\n        dev_create(udi[i]);\n        VIR_FREE(udi[i]);\n    }\n    VIR_FREE(udi);\n    VIR_INFO(\"HAL device reload complete\");\n\n    return 0;\n}"
  },
  {
    "function_name": "nodeStateCleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "736-756",
    "snippet": "static int\nnodeStateCleanup(void)\n{\n    if (driver) {\n        nodeDeviceLock();\n        LibHalContext *hal_ctx = DRV_STATE_HAL_CTX(driver);\n        virNodeDeviceObjListFree(driver->devs);\n        (void)libhal_ctx_shutdown(hal_ctx, NULL);\n        (void)libhal_ctx_free(hal_ctx);\n        if (driver->lockFD != -1)\n            virPidFileRelease(driver->stateDir, \"driver\", driver->lockFD);\n\n        VIR_FREE(driver->stateDir);\n        nodeDeviceUnlock();\n        virCondDestroy(&driver->initCond);\n        virMutexDestroy(&driver->lock);\n        VIR_FREE(driver);\n        return 0;\n    }\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&driver->lock"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCondDestroy",
          "args": [
            "&driver->initCond"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "virCondDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "135-143",
          "snippet": "int virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondDestroy(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_destroy(&c->cond)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeDeviceUnlock",
          "args": [],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "nodeDeviceUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_driver.c",
          "lines": "152-156",
          "snippet": "void\nnodeDeviceUnlock(void)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virvhba.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virNodeDeviceDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"viraccessapicheck.h\"\n#include \"virvhba.h\"\n#include \"node_device_util.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <time.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDriverStatePtr driver;\n\nvoid\nnodeDeviceUnlock(void)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver->stateDir"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileRelease",
          "args": [
            "driver->stateDir",
            "\"driver\"",
            "driver->lockFD"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "453-466",
          "snippet": "int virPidFileRelease(const char *dir,\n                      const char *name,\n                      int fd)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileReleasePath(pidfile, fd);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileRelease(const char *dir,\n                      const char *name,\n                      int fd)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileReleasePath(pidfile, fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libhal_ctx_free",
          "args": [
            "hal_ctx"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_ctx_shutdown",
          "args": [
            "hal_ctx",
            "NULL"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListFree",
          "args": [
            "driver->devs"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "432-436",
          "snippet": "void\nvirNodeDeviceObjListFree(virNodeDeviceObjListPtr devs)\n{\n    virObjectUnref(devs);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirNodeDeviceObjListFree(virNodeDeviceObjListPtr devs)\n{\n    virObjectUnref(devs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DRV_STATE_HAL_CTX",
          "args": [
            "driver"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeDeviceLock",
          "args": [],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "nodeDeviceLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_driver.c",
          "lines": "145-149",
          "snippet": "void\nnodeDeviceLock(void)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virvhba.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virNodeDeviceDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"viraccessapicheck.h\"\n#include \"virvhba.h\"\n#include \"node_device_util.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <time.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDriverStatePtr driver;\n\nvoid\nnodeDeviceLock(void)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nnodeStateCleanup(void)\n{\n    if (driver) {\n        nodeDeviceLock();\n        LibHalContext *hal_ctx = DRV_STATE_HAL_CTX(driver);\n        virNodeDeviceObjListFree(driver->devs);\n        (void)libhal_ctx_shutdown(hal_ctx, NULL);\n        (void)libhal_ctx_free(hal_ctx);\n        if (driver->lockFD != -1)\n            virPidFileRelease(driver->stateDir, \"driver\", driver->lockFD);\n\n        VIR_FREE(driver->stateDir);\n        nodeDeviceUnlock();\n        virCondDestroy(&driver->initCond);\n        virMutexDestroy(&driver->lock);\n        VIR_FREE(driver);\n        return 0;\n    }\n    return -1;\n}"
  },
  {
    "function_name": "nodeStateInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "582-733",
    "snippet": "static int\nnodeStateInitialize(bool privileged G_GNUC_UNUSED,\n                    const char *root,\n                    virStateInhibitCallback callback G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    LibHalContext *hal_ctx = NULL;\n    char **udi = NULL;\n    int num_devs;\n    size_t i;\n    int ret = VIR_DRV_STATE_INIT_ERROR;\n    DBusConnection *sysbus;\n    DBusError err;\n\n    if (root != NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Driver does not support embedded mode\"));\n        return -1;\n    }\n\n    /* Ensure caps_tbl is sorted by capability name */\n    qsort(caps_tbl, G_N_ELEMENTS(caps_tbl), sizeof(caps_tbl[0]),\n          cmpstringp);\n\n    if (VIR_ALLOC(driver) < 0)\n        return VIR_DRV_STATE_INIT_ERROR;\n\n    driver->lockFD = -1;\n    if (virMutexInit(&driver->lock) < 0) {\n        VIR_FREE(driver);\n        return VIR_DRV_STATE_INIT_ERROR;\n    }\n\n    if (virCondInit(&driver->initCond) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to initialize condition variable\"));\n        virMutexDestroy(&driver->lock);\n        VIR_FREE(driver);\n        return VIR_DRV_STATE_INIT_ERROR;\n    }\n\n    nodeDeviceLock();\n\n    if (privileged) {\n        driver->stateDir = g_strdup_printf(\"%s/libvirt/nodedev\", RUNSTATEDIR);\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n        driver->stateDir = g_strdup_printf(\"%s/nodedev/run\", rundir);\n    }\n\n    if (virFileMakePathWithMode(driver->stateDir, S_IRWXU) < 0) {\n        virReportSystemError(errno, _(\"cannot create state directory '%s'\"),\n                             driver->stateDir);\n        goto failure;\n    }\n\n    if ((driver->lockFD =\n         virPidFileAcquire(driver->stateDir, \"driver\", false, getpid())) < 0)\n        goto failure;\n\n    if (!(driver->devs = virNodeDeviceObjListNew()))\n        goto failure;\n\n    dbus_error_init(&err);\n    if (!(sysbus = virDBusGetSystemBus())) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"DBus not available, disabling HAL driver: %s\"),\n                       virGetLastErrorMessage());\n        ret = VIR_DRV_STATE_INIT_SKIPPED;\n        goto failure;\n    }\n\n    hal_ctx = libhal_ctx_new();\n    if (hal_ctx == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libhal_ctx_new returned NULL\"));\n        goto failure;\n    }\n\n    if (!libhal_ctx_set_dbus_connection(hal_ctx, sysbus)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libhal_ctx_set_dbus_connection failed\"));\n        goto failure;\n    }\n    if (!libhal_ctx_init(hal_ctx, &err)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libhal_ctx_init failed, haldaemon is probably \"\n                         \"not running\"));\n        /* We don't want to show a fatal error here,\n           otherwise entire libvirtd shuts down when\n           hald isn't running */\n        ret = VIR_DRV_STATE_INIT_SKIPPED;\n        goto failure;\n    }\n\n    /* Populate with known devices */\n    driver->privateData = hal_ctx;\n\n    /* We need to unlock state now, since setting these callbacks cause\n     * a dbus RPC call, and while this call is waiting for the reply,\n     * a signal may already arrive, triggering the callback and thus\n     * requiring the lock !\n     */\n    nodeDeviceUnlock();\n\n    /* Register HAL event callbacks */\n    if (!libhal_ctx_set_device_added(hal_ctx, device_added) ||\n        !libhal_ctx_set_device_removed(hal_ctx, device_removed) ||\n        !libhal_ctx_set_device_new_capability(hal_ctx, device_cap_added) ||\n        !libhal_ctx_set_device_lost_capability(hal_ctx, device_cap_lost) ||\n        !libhal_ctx_set_device_property_modified(hal_ctx, device_prop_modified) ||\n        !libhal_device_property_watch_all(hal_ctx, &err)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"setting up HAL callbacks failed\"));\n        goto failure;\n    }\n\n    udi = libhal_get_all_devices(hal_ctx, &num_devs, &err);\n    if (udi == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libhal_get_all_devices failed\"));\n        goto failure;\n    }\n    for (i = 0; i < num_devs; i++) {\n        dev_create(udi[i]);\n        VIR_FREE(udi[i]);\n    }\n    VIR_FREE(udi);\n\n    nodeDeviceLock();\n    driver->initialized = true;\n    nodeDeviceUnlock();\n    virCondBroadcast(&driver->initCond);\n\n    return VIR_DRV_STATE_INIT_COMPLETE;\n\n failure:\n    if (dbus_error_is_set(&err)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: %s\"), err.name, err.message);\n        dbus_error_free(&err);\n    }\n    virNodeDeviceObjListFree(driver->devs);\n    if (hal_ctx)\n        (void)libhal_ctx_free(hal_ctx);\n    nodeDeviceUnlock();\n    VIR_FREE(driver);\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static caps_tbl_entry caps_tbl[] = {\n    { \"system\",     VIR_NODE_DEV_CAP_SYSTEM,        gather_system_cap },\n    { \"pci\",        VIR_NODE_DEV_CAP_PCI_DEV,       gather_pci_cap },\n    { \"usb\",        VIR_NODE_DEV_CAP_USB_INTERFACE, gather_usb_cap },\n    { \"usb_device\", VIR_NODE_DEV_CAP_USB_DEV,       gather_usb_device_cap },\n    { \"net\",        VIR_NODE_DEV_CAP_NET,           gather_net_cap },\n    { \"scsi_host\",  VIR_NODE_DEV_CAP_SCSI_HOST,     gather_scsi_host_cap },\n    { \"scsi\",       VIR_NODE_DEV_CAP_SCSI,          gather_scsi_cap },\n    { \"storage\",    VIR_NODE_DEV_CAP_STORAGE,       gather_storage_cap },\n    { \"scsi_generic\", VIR_NODE_DEV_CAP_SCSI_GENERIC, gather_scsi_generic_cap },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeDeviceUnlock",
          "args": [],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "nodeDeviceUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_driver.c",
          "lines": "152-156",
          "snippet": "void\nnodeDeviceUnlock(void)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virvhba.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virNodeDeviceDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"viraccessapicheck.h\"\n#include \"virvhba.h\"\n#include \"node_device_util.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <time.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDriverStatePtr driver;\n\nvoid\nnodeDeviceUnlock(void)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libhal_ctx_free",
          "args": [
            "hal_ctx"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListFree",
          "args": [
            "driver->devs"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "432-436",
          "snippet": "void\nvirNodeDeviceObjListFree(virNodeDeviceObjListPtr devs)\n{\n    virObjectUnref(devs);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirNodeDeviceObjListFree(virNodeDeviceObjListPtr devs)\n{\n    virObjectUnref(devs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_error_free",
          "args": [
            "&err"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"%s: %s\")",
            "err.name",
            "err.message"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s: %s\""
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_error_is_set",
          "args": [
            "&err"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondBroadcast",
          "args": [
            "&driver->initCond"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "virCondBroadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "175-178",
          "snippet": "void virCondBroadcast(virCondPtr c)\n{\n    pthread_cond_broadcast(&c->cond);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virCondBroadcast(virCondPtr c)\n{\n    pthread_cond_broadcast(&c->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nodeDeviceLock",
          "args": [],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "nodeDeviceLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_driver.c",
          "lines": "145-149",
          "snippet": "void\nnodeDeviceLock(void)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virvhba.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virNodeDeviceDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"viraccessapicheck.h\"\n#include \"virvhba.h\"\n#include \"node_device_util.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <time.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDriverStatePtr driver;\n\nvoid\nnodeDeviceLock(void)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "udi"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "udi[i]"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_create",
          "args": [
            "udi[i]"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "dev_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "439-491",
          "snippet": "static void\ndev_create(const char *udi)\n{\n    LibHalContext *ctx;\n    char *parent_key = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceDefPtr objdef;\n    const char *name = hal_name(udi);\n    int rv;\n    char *devicePath = NULL;\n\n    nodeDeviceLock();\n    ctx = DRV_STATE_HAL_CTX(driver);\n\n    if (VIR_ALLOC(def) < 0)\n        goto failure;\n\n    def->name = g_strdup(name);\n\n    if (get_str_prop(ctx, udi, \"info.parent\", &parent_key) == 0) {\n        def->parent = g_strdup(hal_name(parent_key));\n        VIR_FREE(parent_key);\n    }\n\n    rv = gather_capabilities(ctx, udi, &def->caps);\n    if (rv != 0) goto failure;\n\n    if (def->caps == NULL)\n        goto cleanup;\n\n    /* Some devices don't have a path in sysfs, so ignore failure */\n    (void)get_str_prop(ctx, udi, \"linux.sysfs_path\", &devicePath);\n\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def))) {\n        VIR_FREE(devicePath);\n        goto failure;\n    }\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    objdef->sysfs_path = devicePath;\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    nodeDeviceUnlock();\n    return;\n\n failure:\n    VIR_DEBUG(\"FAILED TO ADD dev %s\", name);\n cleanup:\n    virNodeDeviceDefFree(def);\n    nodeDeviceUnlock();\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_create(const char *udi)\n{\n    LibHalContext *ctx;\n    char *parent_key = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceDefPtr objdef;\n    const char *name = hal_name(udi);\n    int rv;\n    char *devicePath = NULL;\n\n    nodeDeviceLock();\n    ctx = DRV_STATE_HAL_CTX(driver);\n\n    if (VIR_ALLOC(def) < 0)\n        goto failure;\n\n    def->name = g_strdup(name);\n\n    if (get_str_prop(ctx, udi, \"info.parent\", &parent_key) == 0) {\n        def->parent = g_strdup(hal_name(parent_key));\n        VIR_FREE(parent_key);\n    }\n\n    rv = gather_capabilities(ctx, udi, &def->caps);\n    if (rv != 0) goto failure;\n\n    if (def->caps == NULL)\n        goto cleanup;\n\n    /* Some devices don't have a path in sysfs, so ignore failure */\n    (void)get_str_prop(ctx, udi, \"linux.sysfs_path\", &devicePath);\n\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def))) {\n        VIR_FREE(devicePath);\n        goto failure;\n    }\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    objdef->sysfs_path = devicePath;\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    nodeDeviceUnlock();\n    return;\n\n failure:\n    VIR_DEBUG(\"FAILED TO ADD dev %s\", name);\n cleanup:\n    virNodeDeviceDefFree(def);\n    nodeDeviceUnlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"libhal_get_all_devices failed\")"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_get_all_devices",
          "args": [
            "hal_ctx",
            "&num_devs",
            "&err"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"setting up HAL callbacks failed\")"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_device_property_watch_all",
          "args": [
            "hal_ctx",
            "&err"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_ctx_set_device_property_modified",
          "args": [
            "hal_ctx",
            "device_prop_modified"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_ctx_set_device_lost_capability",
          "args": [
            "hal_ctx",
            "device_cap_lost"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_ctx_set_device_new_capability",
          "args": [
            "hal_ctx",
            "device_cap_added"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_ctx_set_device_removed",
          "args": [
            "hal_ctx",
            "device_removed"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_ctx_set_device_added",
          "args": [
            "hal_ctx",
            "device_added"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"libhal_ctx_init failed, haldaemon is probably \"\n                         \"not running\")"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_ctx_init",
          "args": [
            "hal_ctx",
            "&err"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"libhal_ctx_set_dbus_connection failed\")"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_ctx_set_dbus_connection",
          "args": [
            "hal_ctx",
            "sysbus"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"libhal_ctx_new returned NULL\")"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_ctx_new",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"DBus not available, disabling HAL driver: %s\")",
            "virGetLastErrorMessage()"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDBusGetSystemBus",
          "args": [],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusGetSystemBus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1744-1749",
          "snippet": "DBusConnection *virDBusGetSystemBus(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return NULL;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nDBusConnection *virDBusGetSystemBus(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_error_init",
          "args": [
            "&err"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListNew",
          "args": [],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "412-429",
          "snippet": "virNodeDeviceObjListPtr\nvirNodeDeviceObjListNew(void)\n{\n    virNodeDeviceObjListPtr devs;\n\n    if (virNodeDeviceObjInitialize() < 0)\n        return NULL;\n\n    if (!(devs = virObjectRWLockableNew(virNodeDeviceObjListClass)))\n        return NULL;\n\n    if (!(devs->objs = virHashCreate(50, virObjectFreeHashData))) {\n        virObjectUnref(devs);\n        return NULL;\n    }\n\n    return devs;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNodeDeviceObjListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nstatic virClassPtr virNodeDeviceObjListClass;\n\nvirNodeDeviceObjListPtr\nvirNodeDeviceObjListNew(void)\n{\n    virNodeDeviceObjListPtr devs;\n\n    if (virNodeDeviceObjInitialize() < 0)\n        return NULL;\n\n    if (!(devs = virObjectRWLockableNew(virNodeDeviceObjListClass)))\n        return NULL;\n\n    if (!(devs->objs = virHashCreate(50, virObjectFreeHashData))) {\n        virObjectUnref(devs);\n        return NULL;\n    }\n\n    return devs;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileAcquire",
          "args": [
            "driver->stateDir",
            "\"driver\"",
            "false",
            "getpid()"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileAcquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "413-427",
          "snippet": "int virPidFileAcquire(const char *dir,\n                      const char *name,\n                      bool waitForLock,\n                      pid_t pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileAcquirePath(pidfile, waitForLock, pid);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileAcquire(const char *dir,\n                      const char *name,\n                      bool waitForLock,\n                      pid_t pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileAcquirePath(pidfile, waitForLock, pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"cannot create state directory '%s'\")",
            "driver->stateDir"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileMakePathWithMode",
          "args": [
            "driver->stateDir",
            "S_IRWXU"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePathWithMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3082-3091",
          "snippet": "int\nvirFileMakePathWithMode(const char *path,\n                        mode_t mode)\n{\n    g_autofree char *tmp = NULL;\n\n    tmp = g_strdup(path);\n\n    return virFileMakePathHelper(tmp, mode);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePathWithMode(const char *path,\n                        mode_t mode)\n{\n    g_autofree char *tmp = NULL;\n\n    tmp = g_strdup(path);\n\n    return virFileMakePathHelper(tmp, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/nodedev/run\"",
            "rundir"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserRuntimeDirectory",
          "args": [],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserRuntimeDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "594-601",
          "snippet": "char *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexDestroy",
          "args": [
            "&driver->lock"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "76-79",
          "snippet": "void virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexDestroy(virMutexPtr m)\n{\n    pthread_mutex_destroy(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to initialize condition variable\")"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCondInit",
          "args": [
            "&driver->initCond"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "virCondInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "125-133",
          "snippet": "int virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virCondInit(virCondPtr c)\n{\n    int ret;\n    if ((ret = pthread_cond_init(&c->cond, NULL)) != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMutexInit",
          "args": [
            "&driver->lock"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexInitRecursive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "61-74",
          "snippet": "int virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virMutexInitRecursive(virMutexPtr m)\n{\n    int ret;\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);\n    ret = pthread_mutex_init(&m->lock, &attr);\n    pthread_mutexattr_destroy(&attr);\n    if (ret != 0) {\n        errno = ret;\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "driver"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "caps_tbl",
            "G_N_ELEMENTS(caps_tbl)",
            "sizeof(caps_tbl[0])",
            "cmpstringp"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "caps_tbl"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Driver does not support embedded mode\")"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic caps_tbl_entry caps_tbl[] = {\n    { \"system\",     VIR_NODE_DEV_CAP_SYSTEM,        gather_system_cap },\n    { \"pci\",        VIR_NODE_DEV_CAP_PCI_DEV,       gather_pci_cap },\n    { \"usb\",        VIR_NODE_DEV_CAP_USB_INTERFACE, gather_usb_cap },\n    { \"usb_device\", VIR_NODE_DEV_CAP_USB_DEV,       gather_usb_device_cap },\n    { \"net\",        VIR_NODE_DEV_CAP_NET,           gather_net_cap },\n    { \"scsi_host\",  VIR_NODE_DEV_CAP_SCSI_HOST,     gather_scsi_host_cap },\n    { \"scsi\",       VIR_NODE_DEV_CAP_SCSI,          gather_scsi_cap },\n    { \"storage\",    VIR_NODE_DEV_CAP_STORAGE,       gather_storage_cap },\n    { \"scsi_generic\", VIR_NODE_DEV_CAP_SCSI_GENERIC, gather_scsi_generic_cap },\n};\n\nstatic int\nnodeStateInitialize(bool privileged G_GNUC_UNUSED,\n                    const char *root,\n                    virStateInhibitCallback callback G_GNUC_UNUSED,\n                    void *opaque G_GNUC_UNUSED)\n{\n    LibHalContext *hal_ctx = NULL;\n    char **udi = NULL;\n    int num_devs;\n    size_t i;\n    int ret = VIR_DRV_STATE_INIT_ERROR;\n    DBusConnection *sysbus;\n    DBusError err;\n\n    if (root != NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Driver does not support embedded mode\"));\n        return -1;\n    }\n\n    /* Ensure caps_tbl is sorted by capability name */\n    qsort(caps_tbl, G_N_ELEMENTS(caps_tbl), sizeof(caps_tbl[0]),\n          cmpstringp);\n\n    if (VIR_ALLOC(driver) < 0)\n        return VIR_DRV_STATE_INIT_ERROR;\n\n    driver->lockFD = -1;\n    if (virMutexInit(&driver->lock) < 0) {\n        VIR_FREE(driver);\n        return VIR_DRV_STATE_INIT_ERROR;\n    }\n\n    if (virCondInit(&driver->initCond) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to initialize condition variable\"));\n        virMutexDestroy(&driver->lock);\n        VIR_FREE(driver);\n        return VIR_DRV_STATE_INIT_ERROR;\n    }\n\n    nodeDeviceLock();\n\n    if (privileged) {\n        driver->stateDir = g_strdup_printf(\"%s/libvirt/nodedev\", RUNSTATEDIR);\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n        driver->stateDir = g_strdup_printf(\"%s/nodedev/run\", rundir);\n    }\n\n    if (virFileMakePathWithMode(driver->stateDir, S_IRWXU) < 0) {\n        virReportSystemError(errno, _(\"cannot create state directory '%s'\"),\n                             driver->stateDir);\n        goto failure;\n    }\n\n    if ((driver->lockFD =\n         virPidFileAcquire(driver->stateDir, \"driver\", false, getpid())) < 0)\n        goto failure;\n\n    if (!(driver->devs = virNodeDeviceObjListNew()))\n        goto failure;\n\n    dbus_error_init(&err);\n    if (!(sysbus = virDBusGetSystemBus())) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"DBus not available, disabling HAL driver: %s\"),\n                       virGetLastErrorMessage());\n        ret = VIR_DRV_STATE_INIT_SKIPPED;\n        goto failure;\n    }\n\n    hal_ctx = libhal_ctx_new();\n    if (hal_ctx == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libhal_ctx_new returned NULL\"));\n        goto failure;\n    }\n\n    if (!libhal_ctx_set_dbus_connection(hal_ctx, sysbus)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libhal_ctx_set_dbus_connection failed\"));\n        goto failure;\n    }\n    if (!libhal_ctx_init(hal_ctx, &err)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libhal_ctx_init failed, haldaemon is probably \"\n                         \"not running\"));\n        /* We don't want to show a fatal error here,\n           otherwise entire libvirtd shuts down when\n           hald isn't running */\n        ret = VIR_DRV_STATE_INIT_SKIPPED;\n        goto failure;\n    }\n\n    /* Populate with known devices */\n    driver->privateData = hal_ctx;\n\n    /* We need to unlock state now, since setting these callbacks cause\n     * a dbus RPC call, and while this call is waiting for the reply,\n     * a signal may already arrive, triggering the callback and thus\n     * requiring the lock !\n     */\n    nodeDeviceUnlock();\n\n    /* Register HAL event callbacks */\n    if (!libhal_ctx_set_device_added(hal_ctx, device_added) ||\n        !libhal_ctx_set_device_removed(hal_ctx, device_removed) ||\n        !libhal_ctx_set_device_new_capability(hal_ctx, device_cap_added) ||\n        !libhal_ctx_set_device_lost_capability(hal_ctx, device_cap_lost) ||\n        !libhal_ctx_set_device_property_modified(hal_ctx, device_prop_modified) ||\n        !libhal_device_property_watch_all(hal_ctx, &err)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"setting up HAL callbacks failed\"));\n        goto failure;\n    }\n\n    udi = libhal_get_all_devices(hal_ctx, &num_devs, &err);\n    if (udi == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libhal_get_all_devices failed\"));\n        goto failure;\n    }\n    for (i = 0; i < num_devs; i++) {\n        dev_create(udi[i]);\n        VIR_FREE(udi[i]);\n    }\n    VIR_FREE(udi);\n\n    nodeDeviceLock();\n    driver->initialized = true;\n    nodeDeviceUnlock();\n    virCondBroadcast(&driver->initCond);\n\n    return VIR_DRV_STATE_INIT_COMPLETE;\n\n failure:\n    if (dbus_error_is_set(&err)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"%s: %s\"), err.name, err.message);\n        dbus_error_free(&err);\n    }\n    virNodeDeviceObjListFree(driver->devs);\n    if (hal_ctx)\n        (void)libhal_ctx_free(hal_ctx);\n    nodeDeviceUnlock();\n    VIR_FREE(driver);\n\n    return ret;\n}"
  },
  {
    "function_name": "device_prop_modified",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "568-579",
    "snippet": "static void\ndevice_prop_modified(LibHalContext *ctx G_GNUC_UNUSED,\n                     const char *udi,\n                     const char *key,\n                     dbus_bool_t is_removed G_GNUC_UNUSED,\n                     dbus_bool_t is_added G_GNUC_UNUSED)\n{\n    const char *name = hal_name(udi);\n    VIR_DEBUG(\"%s %s\", name, key);\n\n    dev_refresh(udi);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev_refresh",
          "args": [
            "udi"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s\"",
            "name",
            "key"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hal_name",
          "args": [
            "udi"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "hal_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "56-63",
          "snippet": "static const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndevice_prop_modified(LibHalContext *ctx G_GNUC_UNUSED,\n                     const char *udi,\n                     const char *key,\n                     dbus_bool_t is_removed G_GNUC_UNUSED,\n                     dbus_bool_t is_added G_GNUC_UNUSED)\n{\n    const char *name = hal_name(udi);\n    VIR_DEBUG(\"%s %s\", name, key);\n\n    dev_refresh(udi);\n}"
  },
  {
    "function_name": "device_cap_lost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "556-565",
    "snippet": "static void\ndevice_cap_lost(LibHalContext *ctx G_GNUC_UNUSED,\n                const char *udi,\n                const char *cap)\n{\n    const char *name = hal_name(udi);\n    VIR_DEBUG(\"%s %s\", cap, name);\n\n    dev_refresh(udi);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev_refresh",
          "args": [
            "udi"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "dev_refresh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "493-509",
          "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s\"",
            "cap",
            "name"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hal_name",
          "args": [
            "udi"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "hal_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "56-63",
          "snippet": "static const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndevice_cap_lost(LibHalContext *ctx G_GNUC_UNUSED,\n                const char *udi,\n                const char *cap)\n{\n    const char *name = hal_name(udi);\n    VIR_DEBUG(\"%s %s\", cap, name);\n\n    dev_refresh(udi);\n}"
  },
  {
    "function_name": "device_cap_added",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "537-553",
    "snippet": "static void\ndevice_cap_added(LibHalContext *ctx,\n                 const char *udi, const char *cap)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n    virNodeDeviceDefPtr def;\n\n    VIR_DEBUG(\"%s %s\", cap, name);\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        def = virNodeDeviceObjGetDef(obj);\n        (void)gather_capability(ctx, udi, cap, &def->caps);\n        virNodeDeviceObjEndAPI(&obj);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"no device named %s\"",
            "name"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "101-110",
          "snippet": "void\nvirNodeDeviceObjEndAPI(virNodeDeviceObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirNodeDeviceObjEndAPI(virNodeDeviceObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gather_capability",
          "args": [
            "ctx",
            "udi",
            "cap",
            "&def->caps"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "gather_capability",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "351-378",
          "snippet": "static int\ngather_capability(LibHalContext *ctx, const char *udi,\n                  const char *cap_name,\n                  virNodeDevCapsDefPtr *caps_p)\n{\n    caps_tbl_entry *entry;\n\n    entry = bsearch(&cap_name, caps_tbl, G_N_ELEMENTS(caps_tbl),\n                    sizeof(caps_tbl[0]), cmpstringp);\n\n    if (entry) {\n        virNodeDevCapsDefPtr caps;\n        if (VIR_ALLOC(caps) < 0)\n            return ENOMEM;\n        caps->data.type = entry->type;\n        if (entry->gather_fn) {\n            int rv = (*entry->gather_fn)(ctx, udi, &caps->data);\n            if (rv != 0) {\n                virNodeDevCapsDefFree(caps);\n                return rv;\n            }\n        }\n        caps->next = *caps_p;\n        *caps_p = caps;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static caps_tbl_entry caps_tbl[] = {\n    { \"system\",     VIR_NODE_DEV_CAP_SYSTEM,        gather_system_cap },\n    { \"pci\",        VIR_NODE_DEV_CAP_PCI_DEV,       gather_pci_cap },\n    { \"usb\",        VIR_NODE_DEV_CAP_USB_INTERFACE, gather_usb_cap },\n    { \"usb_device\", VIR_NODE_DEV_CAP_USB_DEV,       gather_usb_device_cap },\n    { \"net\",        VIR_NODE_DEV_CAP_NET,           gather_net_cap },\n    { \"scsi_host\",  VIR_NODE_DEV_CAP_SCSI_HOST,     gather_scsi_host_cap },\n    { \"scsi\",       VIR_NODE_DEV_CAP_SCSI,          gather_scsi_cap },\n    { \"storage\",    VIR_NODE_DEV_CAP_STORAGE,       gather_storage_cap },\n    { \"scsi_generic\", VIR_NODE_DEV_CAP_SCSI_GENERIC, gather_scsi_generic_cap },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic caps_tbl_entry caps_tbl[] = {\n    { \"system\",     VIR_NODE_DEV_CAP_SYSTEM,        gather_system_cap },\n    { \"pci\",        VIR_NODE_DEV_CAP_PCI_DEV,       gather_pci_cap },\n    { \"usb\",        VIR_NODE_DEV_CAP_USB_INTERFACE, gather_usb_cap },\n    { \"usb_device\", VIR_NODE_DEV_CAP_USB_DEV,       gather_usb_device_cap },\n    { \"net\",        VIR_NODE_DEV_CAP_NET,           gather_net_cap },\n    { \"scsi_host\",  VIR_NODE_DEV_CAP_SCSI_HOST,     gather_scsi_host_cap },\n    { \"scsi\",       VIR_NODE_DEV_CAP_SCSI,          gather_scsi_cap },\n    { \"storage\",    VIR_NODE_DEV_CAP_STORAGE,       gather_storage_cap },\n    { \"scsi_generic\", VIR_NODE_DEV_CAP_SCSI_GENERIC, gather_scsi_generic_cap },\n};\n\nstatic int\ngather_capability(LibHalContext *ctx, const char *udi,\n                  const char *cap_name,\n                  virNodeDevCapsDefPtr *caps_p)\n{\n    caps_tbl_entry *entry;\n\n    entry = bsearch(&cap_name, caps_tbl, G_N_ELEMENTS(caps_tbl),\n                    sizeof(caps_tbl[0]), cmpstringp);\n\n    if (entry) {\n        virNodeDevCapsDefPtr caps;\n        if (VIR_ALLOC(caps) < 0)\n            return ENOMEM;\n        caps->data.type = entry->type;\n        if (entry->gather_fn) {\n            int rv = (*entry->gather_fn)(ctx, udi, &caps->data);\n            if (rv != 0) {\n                virNodeDevCapsDefFree(caps);\n                return rv;\n            }\n        }\n        caps->next = *caps_p;\n        *caps_p = caps;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjGetDef",
          "args": [
            "obj"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "113-117",
          "snippet": "virNodeDeviceDefPtr\nvirNodeDeviceObjGetDef(virNodeDeviceObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNodeDeviceDefPtr\nvirNodeDeviceObjGetDef(virNodeDeviceObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListFindByName",
          "args": [
            "driver->devs",
            "name"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListFindByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "236-249",
          "snippet": "virNodeDeviceObjPtr\nvirNodeDeviceObjListFindByName(virNodeDeviceObjListPtr devs,\n                               const char *name)\n{\n    virNodeDeviceObjPtr obj;\n\n    virObjectRWLockRead(devs);\n    obj = virNodeDeviceObjListFindByNameLocked(devs, name);\n    virObjectRWUnlock(devs);\n    if (obj)\n        virObjectLock(obj);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNodeDeviceObjPtr\nvirNodeDeviceObjListFindByName(virNodeDeviceObjListPtr devs,\n                               const char *name)\n{\n    virNodeDeviceObjPtr obj;\n\n    virObjectRWLockRead(devs);\n    obj = virNodeDeviceObjListFindByNameLocked(devs, name);\n    virObjectRWUnlock(devs);\n    if (obj)\n        virObjectLock(obj);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s\"",
            "cap",
            "name"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hal_name",
          "args": [
            "udi"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "hal_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "56-63",
          "snippet": "static const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndevice_cap_added(LibHalContext *ctx,\n                 const char *udi, const char *cap)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n    virNodeDeviceDefPtr def;\n\n    VIR_DEBUG(\"%s %s\", cap, name);\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        def = virNodeDeviceObjGetDef(obj);\n        (void)gather_capability(ctx, udi, cap, &def->caps);\n        virNodeDeviceObjEndAPI(&obj);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
  },
  {
    "function_name": "device_removed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "520-534",
    "snippet": "static void\ndevice_removed(LibHalContext *ctx G_GNUC_UNUSED,\n               const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    obj = virNodeDeviceObjListFindByName(driver->devs, name);\n    VIR_DEBUG(\"%s\", name);\n    if (obj)\n        virNodeDeviceObjListRemove(driver->devs, obj);\n    else\n        VIR_DEBUG(\"no device named %s\", name);\n    virObjectUnref(obj);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "obj"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"no device named %s\"",
            "name"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListRemove",
          "args": [
            "driver->devs",
            "obj"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "470-488",
          "snippet": "void\nvirNodeDeviceObjListRemove(virNodeDeviceObjListPtr devs,\n                           virNodeDeviceObjPtr obj)\n{\n    virNodeDeviceDefPtr def;\n\n    if (!obj)\n        return;\n    def = obj->def;\n\n    virObjectRef(obj);\n    virObjectUnlock(obj);\n    virObjectRWLockWrite(devs);\n    virObjectLock(obj);\n    virHashRemoveEntry(devs->objs, def->name);\n    virObjectUnlock(obj);\n    virObjectUnref(obj);\n    virObjectRWUnlock(devs);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirNodeDeviceObjListRemove(virNodeDeviceObjListPtr devs,\n                           virNodeDeviceObjPtr obj)\n{\n    virNodeDeviceDefPtr def;\n\n    if (!obj)\n        return;\n    def = obj->def;\n\n    virObjectRef(obj);\n    virObjectUnlock(obj);\n    virObjectRWLockWrite(devs);\n    virObjectLock(obj);\n    virHashRemoveEntry(devs->objs, def->name);\n    virObjectUnlock(obj);\n    virObjectUnref(obj);\n    virObjectRWUnlock(devs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s\"",
            "name"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListFindByName",
          "args": [
            "driver->devs",
            "name"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListFindByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "236-249",
          "snippet": "virNodeDeviceObjPtr\nvirNodeDeviceObjListFindByName(virNodeDeviceObjListPtr devs,\n                               const char *name)\n{\n    virNodeDeviceObjPtr obj;\n\n    virObjectRWLockRead(devs);\n    obj = virNodeDeviceObjListFindByNameLocked(devs, name);\n    virObjectRWUnlock(devs);\n    if (obj)\n        virObjectLock(obj);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNodeDeviceObjPtr\nvirNodeDeviceObjListFindByName(virNodeDeviceObjListPtr devs,\n                               const char *name)\n{\n    virNodeDeviceObjPtr obj;\n\n    virObjectRWLockRead(devs);\n    obj = virNodeDeviceObjListFindByNameLocked(devs, name);\n    virObjectRWUnlock(devs);\n    if (obj)\n        virObjectLock(obj);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hal_name",
          "args": [
            "udi"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "hal_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "56-63",
          "snippet": "static const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndevice_removed(LibHalContext *ctx G_GNUC_UNUSED,\n               const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    obj = virNodeDeviceObjListFindByName(driver->devs, name);\n    VIR_DEBUG(\"%s\", name);\n    if (obj)\n        virNodeDeviceObjListRemove(driver->devs, obj);\n    else\n        VIR_DEBUG(\"no device named %s\", name);\n    virObjectUnref(obj);\n}"
  },
  {
    "function_name": "device_added",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "511-517",
    "snippet": "static void\ndevice_added(LibHalContext *ctx G_GNUC_UNUSED,\n             const char *udi)\n{\n    VIR_DEBUG(\"%s\", hal_name(udi));\n    dev_create(udi);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dev_create",
          "args": [
            "udi"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "dev_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "439-491",
          "snippet": "static void\ndev_create(const char *udi)\n{\n    LibHalContext *ctx;\n    char *parent_key = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceDefPtr objdef;\n    const char *name = hal_name(udi);\n    int rv;\n    char *devicePath = NULL;\n\n    nodeDeviceLock();\n    ctx = DRV_STATE_HAL_CTX(driver);\n\n    if (VIR_ALLOC(def) < 0)\n        goto failure;\n\n    def->name = g_strdup(name);\n\n    if (get_str_prop(ctx, udi, \"info.parent\", &parent_key) == 0) {\n        def->parent = g_strdup(hal_name(parent_key));\n        VIR_FREE(parent_key);\n    }\n\n    rv = gather_capabilities(ctx, udi, &def->caps);\n    if (rv != 0) goto failure;\n\n    if (def->caps == NULL)\n        goto cleanup;\n\n    /* Some devices don't have a path in sysfs, so ignore failure */\n    (void)get_str_prop(ctx, udi, \"linux.sysfs_path\", &devicePath);\n\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def))) {\n        VIR_FREE(devicePath);\n        goto failure;\n    }\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    objdef->sysfs_path = devicePath;\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    nodeDeviceUnlock();\n    return;\n\n failure:\n    VIR_DEBUG(\"FAILED TO ADD dev %s\", name);\n cleanup:\n    virNodeDeviceDefFree(def);\n    nodeDeviceUnlock();\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_create(const char *udi)\n{\n    LibHalContext *ctx;\n    char *parent_key = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceDefPtr objdef;\n    const char *name = hal_name(udi);\n    int rv;\n    char *devicePath = NULL;\n\n    nodeDeviceLock();\n    ctx = DRV_STATE_HAL_CTX(driver);\n\n    if (VIR_ALLOC(def) < 0)\n        goto failure;\n\n    def->name = g_strdup(name);\n\n    if (get_str_prop(ctx, udi, \"info.parent\", &parent_key) == 0) {\n        def->parent = g_strdup(hal_name(parent_key));\n        VIR_FREE(parent_key);\n    }\n\n    rv = gather_capabilities(ctx, udi, &def->caps);\n    if (rv != 0) goto failure;\n\n    if (def->caps == NULL)\n        goto cleanup;\n\n    /* Some devices don't have a path in sysfs, so ignore failure */\n    (void)get_str_prop(ctx, udi, \"linux.sysfs_path\", &devicePath);\n\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def))) {\n        VIR_FREE(devicePath);\n        goto failure;\n    }\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    objdef->sysfs_path = devicePath;\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    nodeDeviceUnlock();\n    return;\n\n failure:\n    VIR_DEBUG(\"FAILED TO ADD dev %s\", name);\n cleanup:\n    virNodeDeviceDefFree(def);\n    nodeDeviceUnlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s\"",
            "hal_name(udi)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hal_name",
          "args": [
            "udi"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "hal_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "56-63",
          "snippet": "static const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndevice_added(LibHalContext *ctx G_GNUC_UNUSED,\n             const char *udi)\n{\n    VIR_DEBUG(\"%s\", hal_name(udi));\n    dev_create(udi);\n}"
  },
  {
    "function_name": "dev_refresh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "493-509",
    "snippet": "static void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"no device named %s\"",
            "name"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_create",
          "args": [
            "udi"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "dev_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "439-491",
          "snippet": "static void\ndev_create(const char *udi)\n{\n    LibHalContext *ctx;\n    char *parent_key = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceDefPtr objdef;\n    const char *name = hal_name(udi);\n    int rv;\n    char *devicePath = NULL;\n\n    nodeDeviceLock();\n    ctx = DRV_STATE_HAL_CTX(driver);\n\n    if (VIR_ALLOC(def) < 0)\n        goto failure;\n\n    def->name = g_strdup(name);\n\n    if (get_str_prop(ctx, udi, \"info.parent\", &parent_key) == 0) {\n        def->parent = g_strdup(hal_name(parent_key));\n        VIR_FREE(parent_key);\n    }\n\n    rv = gather_capabilities(ctx, udi, &def->caps);\n    if (rv != 0) goto failure;\n\n    if (def->caps == NULL)\n        goto cleanup;\n\n    /* Some devices don't have a path in sysfs, so ignore failure */\n    (void)get_str_prop(ctx, udi, \"linux.sysfs_path\", &devicePath);\n\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def))) {\n        VIR_FREE(devicePath);\n        goto failure;\n    }\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    objdef->sysfs_path = devicePath;\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    nodeDeviceUnlock();\n    return;\n\n failure:\n    VIR_DEBUG(\"FAILED TO ADD dev %s\", name);\n cleanup:\n    virNodeDeviceDefFree(def);\n    nodeDeviceUnlock();\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_create(const char *udi)\n{\n    LibHalContext *ctx;\n    char *parent_key = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceDefPtr objdef;\n    const char *name = hal_name(udi);\n    int rv;\n    char *devicePath = NULL;\n\n    nodeDeviceLock();\n    ctx = DRV_STATE_HAL_CTX(driver);\n\n    if (VIR_ALLOC(def) < 0)\n        goto failure;\n\n    def->name = g_strdup(name);\n\n    if (get_str_prop(ctx, udi, \"info.parent\", &parent_key) == 0) {\n        def->parent = g_strdup(hal_name(parent_key));\n        VIR_FREE(parent_key);\n    }\n\n    rv = gather_capabilities(ctx, udi, &def->caps);\n    if (rv != 0) goto failure;\n\n    if (def->caps == NULL)\n        goto cleanup;\n\n    /* Some devices don't have a path in sysfs, so ignore failure */\n    (void)get_str_prop(ctx, udi, \"linux.sysfs_path\", &devicePath);\n\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def))) {\n        VIR_FREE(devicePath);\n        goto failure;\n    }\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    objdef->sysfs_path = devicePath;\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    nodeDeviceUnlock();\n    return;\n\n failure:\n    VIR_DEBUG(\"FAILED TO ADD dev %s\", name);\n cleanup:\n    virNodeDeviceDefFree(def);\n    nodeDeviceUnlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "obj"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListRemove",
          "args": [
            "driver->devs",
            "obj"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "470-488",
          "snippet": "void\nvirNodeDeviceObjListRemove(virNodeDeviceObjListPtr devs,\n                           virNodeDeviceObjPtr obj)\n{\n    virNodeDeviceDefPtr def;\n\n    if (!obj)\n        return;\n    def = obj->def;\n\n    virObjectRef(obj);\n    virObjectUnlock(obj);\n    virObjectRWLockWrite(devs);\n    virObjectLock(obj);\n    virHashRemoveEntry(devs->objs, def->name);\n    virObjectUnlock(obj);\n    virObjectUnref(obj);\n    virObjectRWUnlock(devs);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirNodeDeviceObjListRemove(virNodeDeviceObjListPtr devs,\n                           virNodeDeviceObjPtr obj)\n{\n    virNodeDeviceDefPtr def;\n\n    if (!obj)\n        return;\n    def = obj->def;\n\n    virObjectRef(obj);\n    virObjectUnlock(obj);\n    virObjectRWLockWrite(devs);\n    virObjectLock(obj);\n    virHashRemoveEntry(devs->objs, def->name);\n    virObjectUnlock(obj);\n    virObjectUnref(obj);\n    virObjectRWUnlock(devs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListFindByName",
          "args": [
            "driver->devs",
            "name"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListFindByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "236-249",
          "snippet": "virNodeDeviceObjPtr\nvirNodeDeviceObjListFindByName(virNodeDeviceObjListPtr devs,\n                               const char *name)\n{\n    virNodeDeviceObjPtr obj;\n\n    virObjectRWLockRead(devs);\n    obj = virNodeDeviceObjListFindByNameLocked(devs, name);\n    virObjectRWUnlock(devs);\n    if (obj)\n        virObjectLock(obj);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNodeDeviceObjPtr\nvirNodeDeviceObjListFindByName(virNodeDeviceObjListPtr devs,\n                               const char *name)\n{\n    virNodeDeviceObjPtr obj;\n\n    virObjectRWLockRead(devs);\n    obj = virNodeDeviceObjListFindByNameLocked(devs, name);\n    virObjectRWUnlock(devs);\n    if (obj)\n        virObjectLock(obj);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hal_name",
          "args": [
            "udi"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "hal_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "56-63",
          "snippet": "static const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_refresh(const char *udi)\n{\n    const char *name = hal_name(udi);\n    virNodeDeviceObjPtr obj;\n\n    if ((obj = virNodeDeviceObjListFindByName(driver->devs, name))) {\n        /* Simply \"rediscover\" device -- incrementally handling changes\n         * to sub-capabilities (like net.80203) is nasty ... so avoid it.\n         */\n        virNodeDeviceObjListRemove(driver->devs, obj);\n        virObjectUnref(obj);\n        dev_create(udi);\n    } else {\n        VIR_DEBUG(\"no device named %s\", name);\n    }\n}"
  },
  {
    "function_name": "dev_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "439-491",
    "snippet": "static void\ndev_create(const char *udi)\n{\n    LibHalContext *ctx;\n    char *parent_key = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceDefPtr objdef;\n    const char *name = hal_name(udi);\n    int rv;\n    char *devicePath = NULL;\n\n    nodeDeviceLock();\n    ctx = DRV_STATE_HAL_CTX(driver);\n\n    if (VIR_ALLOC(def) < 0)\n        goto failure;\n\n    def->name = g_strdup(name);\n\n    if (get_str_prop(ctx, udi, \"info.parent\", &parent_key) == 0) {\n        def->parent = g_strdup(hal_name(parent_key));\n        VIR_FREE(parent_key);\n    }\n\n    rv = gather_capabilities(ctx, udi, &def->caps);\n    if (rv != 0) goto failure;\n\n    if (def->caps == NULL)\n        goto cleanup;\n\n    /* Some devices don't have a path in sysfs, so ignore failure */\n    (void)get_str_prop(ctx, udi, \"linux.sysfs_path\", &devicePath);\n\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def))) {\n        VIR_FREE(devicePath);\n        goto failure;\n    }\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    objdef->sysfs_path = devicePath;\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    nodeDeviceUnlock();\n    return;\n\n failure:\n    VIR_DEBUG(\"FAILED TO ADD dev %s\", name);\n cleanup:\n    virNodeDeviceDefFree(def);\n    nodeDeviceUnlock();\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nodeDeviceUnlock",
          "args": [],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "nodeDeviceUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_driver.c",
          "lines": "152-156",
          "snippet": "void\nnodeDeviceUnlock(void)\n{\n    virMutexUnlock(&driver->lock);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virvhba.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virNodeDeviceDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"viraccessapicheck.h\"\n#include \"virvhba.h\"\n#include \"node_device_util.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <time.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDriverStatePtr driver;\n\nvoid\nnodeDeviceUnlock(void)\n{\n    virMutexUnlock(&driver->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceDefFree",
          "args": [
            "def"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "98-125",
          "snippet": "void\nvirNodeDeviceDefFree(virNodeDeviceDefPtr def)\n{\n    virNodeDevCapsDefPtr caps;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->parent);\n    VIR_FREE(def->parent_wwnn);\n    VIR_FREE(def->parent_wwpn);\n    VIR_FREE(def->parent_fabric_wwn);\n    VIR_FREE(def->driver);\n    VIR_FREE(def->sysfs_path);\n    VIR_FREE(def->parent_sysfs_path);\n    VIR_FREE(def->devnode);\n    virStringListFree(def->devlinks);\n\n    caps = def->caps;\n    while (caps) {\n        virNodeDevCapsDefPtr next = caps->next;\n        virNodeDevCapsDefFree(caps);\n        caps = next;\n    }\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNodeDeviceDefFree(virNodeDeviceDefPtr def)\n{\n    virNodeDevCapsDefPtr caps;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->parent);\n    VIR_FREE(def->parent_wwnn);\n    VIR_FREE(def->parent_wwpn);\n    VIR_FREE(def->parent_fabric_wwn);\n    VIR_FREE(def->driver);\n    VIR_FREE(def->sysfs_path);\n    VIR_FREE(def->parent_sysfs_path);\n    VIR_FREE(def->devnode);\n    virStringListFree(def->devlinks);\n\n    caps = def->caps;\n    while (caps) {\n        virNodeDevCapsDefPtr next = caps->next;\n        virNodeDevCapsDefFree(caps);\n        caps = next;\n    }\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"FAILED TO ADD dev %s\"",
            "name"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjEndAPI",
          "args": [
            "&obj"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "101-110",
          "snippet": "void\nvirNodeDeviceObjEndAPI(virNodeDeviceObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvoid\nvirNodeDeviceObjEndAPI(virNodeDeviceObjPtr *obj)\n{\n    if (!*obj)\n        return;\n\n    virObjectUnlock(*obj);\n    virObjectUnref(*obj);\n    *obj = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjGetDef",
          "args": [
            "obj"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "113-117",
          "snippet": "virNodeDeviceDefPtr\nvirNodeDeviceObjGetDef(virNodeDeviceObjPtr obj)\n{\n    return obj->def;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNodeDeviceDefPtr\nvirNodeDeviceObjGetDef(virNodeDeviceObjPtr obj)\n{\n    return obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "devicePath"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceObjListAssignDef",
          "args": [
            "driver->devs",
            "def"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceObjListAssignDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virnodedeviceobj.c",
          "lines": "439-467",
          "snippet": "virNodeDeviceObjPtr\nvirNodeDeviceObjListAssignDef(virNodeDeviceObjListPtr devs,\n                              virNodeDeviceDefPtr def)\n{\n    virNodeDeviceObjPtr obj;\n\n    virObjectRWLockWrite(devs);\n\n    if ((obj = virNodeDeviceObjListFindByNameLocked(devs, def->name))) {\n        virObjectLock(obj);\n        virNodeDeviceDefFree(obj->def);\n        obj->def = def;\n    } else {\n        if (!(obj = virNodeDeviceObjNew()))\n            goto cleanup;\n\n        if (virHashAddEntry(devs->objs, def->name, obj) < 0) {\n            virNodeDeviceObjEndAPI(&obj);\n            goto cleanup;\n        }\n\n        obj->def = def;\n        virObjectRef(obj);\n    }\n\n cleanup:\n    virObjectRWUnlock(devs);\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include \"virnodedeviceobj.h\"",
            "#include \"viralloc.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include \"virnodedeviceobj.h\"\n#include \"viralloc.h\"\n#include \"node_device_conf.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirNodeDeviceObjPtr\nvirNodeDeviceObjListAssignDef(virNodeDeviceObjListPtr devs,\n                              virNodeDeviceDefPtr def)\n{\n    virNodeDeviceObjPtr obj;\n\n    virObjectRWLockWrite(devs);\n\n    if ((obj = virNodeDeviceObjListFindByNameLocked(devs, def->name))) {\n        virObjectLock(obj);\n        virNodeDeviceDefFree(obj->def);\n        obj->def = def;\n    } else {\n        if (!(obj = virNodeDeviceObjNew()))\n            goto cleanup;\n\n        if (virHashAddEntry(devs->objs, def->name, obj) < 0) {\n            virNodeDeviceObjEndAPI(&obj);\n            goto cleanup;\n        }\n\n        obj->def = def;\n        virObjectRef(obj);\n    }\n\n cleanup:\n    virObjectRWUnlock(devs);\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_str_prop",
          "args": [
            "ctx",
            "udi",
            "\"linux.sysfs_path\"",
            "&devicePath"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "get_str_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "66-83",
          "snippet": "static int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gather_capabilities",
          "args": [
            "ctx",
            "udi",
            "&def->caps"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "gather_capabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "381-437",
          "snippet": "static int\ngather_capabilities(LibHalContext *ctx, const char *udi,\n                    virNodeDevCapsDefPtr *caps_p)\n{\n    char *bus_name = NULL;\n    virNodeDevCapsDefPtr caps = NULL;\n    char **hal_cap_names = NULL;\n    int rv;\n    size_t i;\n\n    if (STREQ(udi, \"/org/freedesktop/Hal/devices/computer\")) {\n        rv = gather_capability(ctx, udi, \"system\", &caps);\n        if (rv != 0)\n            goto failure;\n    }\n\n    if (get_str_prop(ctx, udi, \"info.subsystem\", &bus_name) == 0 ||\n        get_str_prop(ctx, udi, \"linux.subsystem\", &bus_name) == 0) {\n        rv = gather_capability(ctx, udi, bus_name, &caps);\n        if (rv != 0)\n            goto failure;\n    }\n\n    hal_cap_names = libhal_device_get_property_strlist(ctx, udi,\n                                                       \"info.capabilities\",\n                                                       NULL);\n    if (hal_cap_names) {\n        for (i = 0; hal_cap_names[i]; i++) {\n            if (! (bus_name && STREQ(hal_cap_names[i], bus_name))) {\n                rv = gather_capability(ctx, udi, hal_cap_names[i], &caps);\n                if (rv != 0)\n                    goto failure;\n            }\n        }\n        for (i = 0; hal_cap_names[i]; i++)\n            VIR_FREE(hal_cap_names[i]);\n        VIR_FREE(hal_cap_names);\n    }\n    VIR_FREE(bus_name);\n\n    *caps_p = caps;\n    return 0;\n\n failure:\n    VIR_FREE(bus_name);\n    if (hal_cap_names) {\n        for (i = 0; hal_cap_names[i]; i++)\n            VIR_FREE(hal_cap_names[i]);\n        VIR_FREE(hal_cap_names);\n    }\n    while (caps) {\n        virNodeDevCapsDefPtr next = caps->next;\n        virNodeDevCapsDefFree(caps);\n        caps = next;\n    }\n    return rv;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\ngather_capabilities(LibHalContext *ctx, const char *udi,\n                    virNodeDevCapsDefPtr *caps_p)\n{\n    char *bus_name = NULL;\n    virNodeDevCapsDefPtr caps = NULL;\n    char **hal_cap_names = NULL;\n    int rv;\n    size_t i;\n\n    if (STREQ(udi, \"/org/freedesktop/Hal/devices/computer\")) {\n        rv = gather_capability(ctx, udi, \"system\", &caps);\n        if (rv != 0)\n            goto failure;\n    }\n\n    if (get_str_prop(ctx, udi, \"info.subsystem\", &bus_name) == 0 ||\n        get_str_prop(ctx, udi, \"linux.subsystem\", &bus_name) == 0) {\n        rv = gather_capability(ctx, udi, bus_name, &caps);\n        if (rv != 0)\n            goto failure;\n    }\n\n    hal_cap_names = libhal_device_get_property_strlist(ctx, udi,\n                                                       \"info.capabilities\",\n                                                       NULL);\n    if (hal_cap_names) {\n        for (i = 0; hal_cap_names[i]; i++) {\n            if (! (bus_name && STREQ(hal_cap_names[i], bus_name))) {\n                rv = gather_capability(ctx, udi, hal_cap_names[i], &caps);\n                if (rv != 0)\n                    goto failure;\n            }\n        }\n        for (i = 0; hal_cap_names[i]; i++)\n            VIR_FREE(hal_cap_names[i]);\n        VIR_FREE(hal_cap_names);\n    }\n    VIR_FREE(bus_name);\n\n    *caps_p = caps;\n    return 0;\n\n failure:\n    VIR_FREE(bus_name);\n    if (hal_cap_names) {\n        for (i = 0; hal_cap_names[i]; i++)\n            VIR_FREE(hal_cap_names[i]);\n        VIR_FREE(hal_cap_names);\n    }\n    while (caps) {\n        virNodeDevCapsDefPtr next = caps->next;\n        virNodeDevCapsDefFree(caps);\n        caps = next;\n    }\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "parent_key"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "hal_name(parent_key)"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hal_name",
          "args": [
            "parent_key"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "hal_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "56-63",
          "snippet": "static const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DRV_STATE_HAL_CTX",
          "args": [
            "driver"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodeDeviceLock",
          "args": [],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "nodeDeviceLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_driver.c",
          "lines": "145-149",
          "snippet": "void\nnodeDeviceLock(void)\n{\n    virMutexLock(&driver->lock);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virnetdev.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virvhba.h\"",
            "#include \"node_device_util.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_event.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <time.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virNodeDeviceDriverStatePtr driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virnetdev.h\"\n#include \"viraccessapicheck.h\"\n#include \"virvhba.h\"\n#include \"node_device_util.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_event.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <time.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNodeDeviceDriverStatePtr driver;\n\nvoid\nnodeDeviceLock(void)\n{\n    virMutexLock(&driver->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic void\ndev_create(const char *udi)\n{\n    LibHalContext *ctx;\n    char *parent_key = NULL;\n    virNodeDeviceObjPtr obj = NULL;\n    virNodeDeviceDefPtr def = NULL;\n    virNodeDeviceDefPtr objdef;\n    const char *name = hal_name(udi);\n    int rv;\n    char *devicePath = NULL;\n\n    nodeDeviceLock();\n    ctx = DRV_STATE_HAL_CTX(driver);\n\n    if (VIR_ALLOC(def) < 0)\n        goto failure;\n\n    def->name = g_strdup(name);\n\n    if (get_str_prop(ctx, udi, \"info.parent\", &parent_key) == 0) {\n        def->parent = g_strdup(hal_name(parent_key));\n        VIR_FREE(parent_key);\n    }\n\n    rv = gather_capabilities(ctx, udi, &def->caps);\n    if (rv != 0) goto failure;\n\n    if (def->caps == NULL)\n        goto cleanup;\n\n    /* Some devices don't have a path in sysfs, so ignore failure */\n    (void)get_str_prop(ctx, udi, \"linux.sysfs_path\", &devicePath);\n\n    if (!(obj = virNodeDeviceObjListAssignDef(driver->devs, def))) {\n        VIR_FREE(devicePath);\n        goto failure;\n    }\n    objdef = virNodeDeviceObjGetDef(obj);\n\n    objdef->sysfs_path = devicePath;\n\n    virNodeDeviceObjEndAPI(&obj);\n\n    nodeDeviceUnlock();\n    return;\n\n failure:\n    VIR_DEBUG(\"FAILED TO ADD dev %s\", name);\n cleanup:\n    virNodeDeviceDefFree(def);\n    nodeDeviceUnlock();\n}"
  },
  {
    "function_name": "gather_capabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "381-437",
    "snippet": "static int\ngather_capabilities(LibHalContext *ctx, const char *udi,\n                    virNodeDevCapsDefPtr *caps_p)\n{\n    char *bus_name = NULL;\n    virNodeDevCapsDefPtr caps = NULL;\n    char **hal_cap_names = NULL;\n    int rv;\n    size_t i;\n\n    if (STREQ(udi, \"/org/freedesktop/Hal/devices/computer\")) {\n        rv = gather_capability(ctx, udi, \"system\", &caps);\n        if (rv != 0)\n            goto failure;\n    }\n\n    if (get_str_prop(ctx, udi, \"info.subsystem\", &bus_name) == 0 ||\n        get_str_prop(ctx, udi, \"linux.subsystem\", &bus_name) == 0) {\n        rv = gather_capability(ctx, udi, bus_name, &caps);\n        if (rv != 0)\n            goto failure;\n    }\n\n    hal_cap_names = libhal_device_get_property_strlist(ctx, udi,\n                                                       \"info.capabilities\",\n                                                       NULL);\n    if (hal_cap_names) {\n        for (i = 0; hal_cap_names[i]; i++) {\n            if (! (bus_name && STREQ(hal_cap_names[i], bus_name))) {\n                rv = gather_capability(ctx, udi, hal_cap_names[i], &caps);\n                if (rv != 0)\n                    goto failure;\n            }\n        }\n        for (i = 0; hal_cap_names[i]; i++)\n            VIR_FREE(hal_cap_names[i]);\n        VIR_FREE(hal_cap_names);\n    }\n    VIR_FREE(bus_name);\n\n    *caps_p = caps;\n    return 0;\n\n failure:\n    VIR_FREE(bus_name);\n    if (hal_cap_names) {\n        for (i = 0; hal_cap_names[i]; i++)\n            VIR_FREE(hal_cap_names[i]);\n        VIR_FREE(hal_cap_names);\n    }\n    while (caps) {\n        virNodeDevCapsDefPtr next = caps->next;\n        virNodeDevCapsDefFree(caps);\n        caps = next;\n    }\n    return rv;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNodeDevCapsDefFree",
          "args": [
            "caps"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2137-2220",
          "snippet": "void\nvirNodeDevCapsDefFree(virNodeDevCapsDefPtr caps)\n{\n    size_t i = 0;\n    virNodeDevCapDataPtr data = &caps->data;\n\n    switch (caps->data.type) {\n    case VIR_NODE_DEV_CAP_SYSTEM:\n        VIR_FREE(data->system.product_name);\n        VIR_FREE(data->system.hardware.vendor_name);\n        VIR_FREE(data->system.hardware.version);\n        VIR_FREE(data->system.hardware.serial);\n        VIR_FREE(data->system.firmware.vendor_name);\n        VIR_FREE(data->system.firmware.version);\n        VIR_FREE(data->system.firmware.release_date);\n        break;\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        VIR_FREE(data->pci_dev.product_name);\n        VIR_FREE(data->pci_dev.vendor_name);\n        VIR_FREE(data->pci_dev.physical_function);\n        for (i = 0; i < data->pci_dev.num_virtual_functions; i++)\n            VIR_FREE(data->pci_dev.virtual_functions[i]);\n        VIR_FREE(data->pci_dev.virtual_functions);\n        for (i = 0; i < data->pci_dev.nIommuGroupDevices; i++)\n            VIR_FREE(data->pci_dev.iommuGroupDevices[i]);\n        VIR_FREE(data->pci_dev.iommuGroupDevices);\n        virPCIEDeviceInfoFree(data->pci_dev.pci_express);\n        for (i = 0; i < data->pci_dev.nmdev_types; i++)\n            virMediatedDeviceTypeFree(data->pci_dev.mdev_types[i]);\n        VIR_FREE(data->pci_dev.mdev_types);\n        break;\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        VIR_FREE(data->usb_dev.product_name);\n        VIR_FREE(data->usb_dev.vendor_name);\n        break;\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        VIR_FREE(data->usb_if.description);\n        break;\n    case VIR_NODE_DEV_CAP_NET:\n        VIR_FREE(data->net.ifname);\n        VIR_FREE(data->net.address);\n        virBitmapFree(data->net.features);\n        data->net.features = NULL;\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        VIR_FREE(data->scsi_host.wwnn);\n        VIR_FREE(data->scsi_host.wwpn);\n        VIR_FREE(data->scsi_host.fabric_wwn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        VIR_FREE(data->scsi_target.name);\n        VIR_FREE(data->scsi_target.rport);\n        VIR_FREE(data->scsi_target.wwpn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI:\n        VIR_FREE(data->scsi.type);\n        break;\n    case VIR_NODE_DEV_CAP_STORAGE:\n        VIR_FREE(data->storage.block);\n        VIR_FREE(data->storage.bus);\n        VIR_FREE(data->storage.drive_type);\n        VIR_FREE(data->storage.model);\n        VIR_FREE(data->storage.vendor);\n        VIR_FREE(data->storage.serial);\n        VIR_FREE(data->storage.media_label);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        VIR_FREE(data->sg.path);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV:\n        VIR_FREE(data->mdev.type);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_DRM:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n    case VIR_NODE_DEV_CAP_LAST:\n        /* This case is here to shutup the compiler */\n        break;\n    }\n\n    VIR_FREE(caps);\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNodeDevCapsDefFree(virNodeDevCapsDefPtr caps)\n{\n    size_t i = 0;\n    virNodeDevCapDataPtr data = &caps->data;\n\n    switch (caps->data.type) {\n    case VIR_NODE_DEV_CAP_SYSTEM:\n        VIR_FREE(data->system.product_name);\n        VIR_FREE(data->system.hardware.vendor_name);\n        VIR_FREE(data->system.hardware.version);\n        VIR_FREE(data->system.hardware.serial);\n        VIR_FREE(data->system.firmware.vendor_name);\n        VIR_FREE(data->system.firmware.version);\n        VIR_FREE(data->system.firmware.release_date);\n        break;\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        VIR_FREE(data->pci_dev.product_name);\n        VIR_FREE(data->pci_dev.vendor_name);\n        VIR_FREE(data->pci_dev.physical_function);\n        for (i = 0; i < data->pci_dev.num_virtual_functions; i++)\n            VIR_FREE(data->pci_dev.virtual_functions[i]);\n        VIR_FREE(data->pci_dev.virtual_functions);\n        for (i = 0; i < data->pci_dev.nIommuGroupDevices; i++)\n            VIR_FREE(data->pci_dev.iommuGroupDevices[i]);\n        VIR_FREE(data->pci_dev.iommuGroupDevices);\n        virPCIEDeviceInfoFree(data->pci_dev.pci_express);\n        for (i = 0; i < data->pci_dev.nmdev_types; i++)\n            virMediatedDeviceTypeFree(data->pci_dev.mdev_types[i]);\n        VIR_FREE(data->pci_dev.mdev_types);\n        break;\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        VIR_FREE(data->usb_dev.product_name);\n        VIR_FREE(data->usb_dev.vendor_name);\n        break;\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        VIR_FREE(data->usb_if.description);\n        break;\n    case VIR_NODE_DEV_CAP_NET:\n        VIR_FREE(data->net.ifname);\n        VIR_FREE(data->net.address);\n        virBitmapFree(data->net.features);\n        data->net.features = NULL;\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        VIR_FREE(data->scsi_host.wwnn);\n        VIR_FREE(data->scsi_host.wwpn);\n        VIR_FREE(data->scsi_host.fabric_wwn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        VIR_FREE(data->scsi_target.name);\n        VIR_FREE(data->scsi_target.rport);\n        VIR_FREE(data->scsi_target.wwpn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI:\n        VIR_FREE(data->scsi.type);\n        break;\n    case VIR_NODE_DEV_CAP_STORAGE:\n        VIR_FREE(data->storage.block);\n        VIR_FREE(data->storage.bus);\n        VIR_FREE(data->storage.drive_type);\n        VIR_FREE(data->storage.model);\n        VIR_FREE(data->storage.vendor);\n        VIR_FREE(data->storage.serial);\n        VIR_FREE(data->storage.media_label);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        VIR_FREE(data->sg.path);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV:\n        VIR_FREE(data->mdev.type);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_DRM:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n    case VIR_NODE_DEV_CAP_LAST:\n        /* This case is here to shutup the compiler */\n        break;\n    }\n\n    VIR_FREE(caps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "hal_cap_names"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "hal_cap_names[i]"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "bus_name"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "bus_name"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "hal_cap_names"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "hal_cap_names[i]"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gather_capability",
          "args": [
            "ctx",
            "udi",
            "hal_cap_names[i]",
            "&caps"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "gather_capability",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "351-378",
          "snippet": "static int\ngather_capability(LibHalContext *ctx, const char *udi,\n                  const char *cap_name,\n                  virNodeDevCapsDefPtr *caps_p)\n{\n    caps_tbl_entry *entry;\n\n    entry = bsearch(&cap_name, caps_tbl, G_N_ELEMENTS(caps_tbl),\n                    sizeof(caps_tbl[0]), cmpstringp);\n\n    if (entry) {\n        virNodeDevCapsDefPtr caps;\n        if (VIR_ALLOC(caps) < 0)\n            return ENOMEM;\n        caps->data.type = entry->type;\n        if (entry->gather_fn) {\n            int rv = (*entry->gather_fn)(ctx, udi, &caps->data);\n            if (rv != 0) {\n                virNodeDevCapsDefFree(caps);\n                return rv;\n            }\n        }\n        caps->next = *caps_p;\n        *caps_p = caps;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static caps_tbl_entry caps_tbl[] = {\n    { \"system\",     VIR_NODE_DEV_CAP_SYSTEM,        gather_system_cap },\n    { \"pci\",        VIR_NODE_DEV_CAP_PCI_DEV,       gather_pci_cap },\n    { \"usb\",        VIR_NODE_DEV_CAP_USB_INTERFACE, gather_usb_cap },\n    { \"usb_device\", VIR_NODE_DEV_CAP_USB_DEV,       gather_usb_device_cap },\n    { \"net\",        VIR_NODE_DEV_CAP_NET,           gather_net_cap },\n    { \"scsi_host\",  VIR_NODE_DEV_CAP_SCSI_HOST,     gather_scsi_host_cap },\n    { \"scsi\",       VIR_NODE_DEV_CAP_SCSI,          gather_scsi_cap },\n    { \"storage\",    VIR_NODE_DEV_CAP_STORAGE,       gather_storage_cap },\n    { \"scsi_generic\", VIR_NODE_DEV_CAP_SCSI_GENERIC, gather_scsi_generic_cap },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic caps_tbl_entry caps_tbl[] = {\n    { \"system\",     VIR_NODE_DEV_CAP_SYSTEM,        gather_system_cap },\n    { \"pci\",        VIR_NODE_DEV_CAP_PCI_DEV,       gather_pci_cap },\n    { \"usb\",        VIR_NODE_DEV_CAP_USB_INTERFACE, gather_usb_cap },\n    { \"usb_device\", VIR_NODE_DEV_CAP_USB_DEV,       gather_usb_device_cap },\n    { \"net\",        VIR_NODE_DEV_CAP_NET,           gather_net_cap },\n    { \"scsi_host\",  VIR_NODE_DEV_CAP_SCSI_HOST,     gather_scsi_host_cap },\n    { \"scsi\",       VIR_NODE_DEV_CAP_SCSI,          gather_scsi_cap },\n    { \"storage\",    VIR_NODE_DEV_CAP_STORAGE,       gather_storage_cap },\n    { \"scsi_generic\", VIR_NODE_DEV_CAP_SCSI_GENERIC, gather_scsi_generic_cap },\n};\n\nstatic int\ngather_capability(LibHalContext *ctx, const char *udi,\n                  const char *cap_name,\n                  virNodeDevCapsDefPtr *caps_p)\n{\n    caps_tbl_entry *entry;\n\n    entry = bsearch(&cap_name, caps_tbl, G_N_ELEMENTS(caps_tbl),\n                    sizeof(caps_tbl[0]), cmpstringp);\n\n    if (entry) {\n        virNodeDevCapsDefPtr caps;\n        if (VIR_ALLOC(caps) < 0)\n            return ENOMEM;\n        caps->data.type = entry->type;\n        if (entry->gather_fn) {\n            int rv = (*entry->gather_fn)(ctx, udi, &caps->data);\n            if (rv != 0) {\n                virNodeDevCapsDefFree(caps);\n                return rv;\n            }\n        }\n        caps->next = *caps_p;\n        *caps_p = caps;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "hal_cap_names[i]",
            "bus_name"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_device_get_property_strlist",
          "args": [
            "ctx",
            "udi",
            "\"info.capabilities\"",
            "NULL"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_str_prop",
          "args": [
            "ctx",
            "udi",
            "\"linux.subsystem\"",
            "&bus_name"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "get_str_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "66-83",
          "snippet": "static int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "udi",
            "\"/org/freedesktop/Hal/devices/computer\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\ngather_capabilities(LibHalContext *ctx, const char *udi,\n                    virNodeDevCapsDefPtr *caps_p)\n{\n    char *bus_name = NULL;\n    virNodeDevCapsDefPtr caps = NULL;\n    char **hal_cap_names = NULL;\n    int rv;\n    size_t i;\n\n    if (STREQ(udi, \"/org/freedesktop/Hal/devices/computer\")) {\n        rv = gather_capability(ctx, udi, \"system\", &caps);\n        if (rv != 0)\n            goto failure;\n    }\n\n    if (get_str_prop(ctx, udi, \"info.subsystem\", &bus_name) == 0 ||\n        get_str_prop(ctx, udi, \"linux.subsystem\", &bus_name) == 0) {\n        rv = gather_capability(ctx, udi, bus_name, &caps);\n        if (rv != 0)\n            goto failure;\n    }\n\n    hal_cap_names = libhal_device_get_property_strlist(ctx, udi,\n                                                       \"info.capabilities\",\n                                                       NULL);\n    if (hal_cap_names) {\n        for (i = 0; hal_cap_names[i]; i++) {\n            if (! (bus_name && STREQ(hal_cap_names[i], bus_name))) {\n                rv = gather_capability(ctx, udi, hal_cap_names[i], &caps);\n                if (rv != 0)\n                    goto failure;\n            }\n        }\n        for (i = 0; hal_cap_names[i]; i++)\n            VIR_FREE(hal_cap_names[i]);\n        VIR_FREE(hal_cap_names);\n    }\n    VIR_FREE(bus_name);\n\n    *caps_p = caps;\n    return 0;\n\n failure:\n    VIR_FREE(bus_name);\n    if (hal_cap_names) {\n        for (i = 0; hal_cap_names[i]; i++)\n            VIR_FREE(hal_cap_names[i]);\n        VIR_FREE(hal_cap_names);\n    }\n    while (caps) {\n        virNodeDevCapsDefPtr next = caps->next;\n        virNodeDevCapsDefFree(caps);\n        caps = next;\n    }\n    return rv;\n}"
  },
  {
    "function_name": "gather_capability",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "351-378",
    "snippet": "static int\ngather_capability(LibHalContext *ctx, const char *udi,\n                  const char *cap_name,\n                  virNodeDevCapsDefPtr *caps_p)\n{\n    caps_tbl_entry *entry;\n\n    entry = bsearch(&cap_name, caps_tbl, G_N_ELEMENTS(caps_tbl),\n                    sizeof(caps_tbl[0]), cmpstringp);\n\n    if (entry) {\n        virNodeDevCapsDefPtr caps;\n        if (VIR_ALLOC(caps) < 0)\n            return ENOMEM;\n        caps->data.type = entry->type;\n        if (entry->gather_fn) {\n            int rv = (*entry->gather_fn)(ctx, udi, &caps->data);\n            if (rv != 0) {\n                virNodeDevCapsDefFree(caps);\n                return rv;\n            }\n        }\n        caps->next = *caps_p;\n        *caps_p = caps;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static caps_tbl_entry caps_tbl[] = {\n    { \"system\",     VIR_NODE_DEV_CAP_SYSTEM,        gather_system_cap },\n    { \"pci\",        VIR_NODE_DEV_CAP_PCI_DEV,       gather_pci_cap },\n    { \"usb\",        VIR_NODE_DEV_CAP_USB_INTERFACE, gather_usb_cap },\n    { \"usb_device\", VIR_NODE_DEV_CAP_USB_DEV,       gather_usb_device_cap },\n    { \"net\",        VIR_NODE_DEV_CAP_NET,           gather_net_cap },\n    { \"scsi_host\",  VIR_NODE_DEV_CAP_SCSI_HOST,     gather_scsi_host_cap },\n    { \"scsi\",       VIR_NODE_DEV_CAP_SCSI,          gather_scsi_cap },\n    { \"storage\",    VIR_NODE_DEV_CAP_STORAGE,       gather_storage_cap },\n    { \"scsi_generic\", VIR_NODE_DEV_CAP_SCSI_GENERIC, gather_scsi_generic_cap },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNodeDevCapsDefFree",
          "args": [
            "caps"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDevCapsDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2137-2220",
          "snippet": "void\nvirNodeDevCapsDefFree(virNodeDevCapsDefPtr caps)\n{\n    size_t i = 0;\n    virNodeDevCapDataPtr data = &caps->data;\n\n    switch (caps->data.type) {\n    case VIR_NODE_DEV_CAP_SYSTEM:\n        VIR_FREE(data->system.product_name);\n        VIR_FREE(data->system.hardware.vendor_name);\n        VIR_FREE(data->system.hardware.version);\n        VIR_FREE(data->system.hardware.serial);\n        VIR_FREE(data->system.firmware.vendor_name);\n        VIR_FREE(data->system.firmware.version);\n        VIR_FREE(data->system.firmware.release_date);\n        break;\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        VIR_FREE(data->pci_dev.product_name);\n        VIR_FREE(data->pci_dev.vendor_name);\n        VIR_FREE(data->pci_dev.physical_function);\n        for (i = 0; i < data->pci_dev.num_virtual_functions; i++)\n            VIR_FREE(data->pci_dev.virtual_functions[i]);\n        VIR_FREE(data->pci_dev.virtual_functions);\n        for (i = 0; i < data->pci_dev.nIommuGroupDevices; i++)\n            VIR_FREE(data->pci_dev.iommuGroupDevices[i]);\n        VIR_FREE(data->pci_dev.iommuGroupDevices);\n        virPCIEDeviceInfoFree(data->pci_dev.pci_express);\n        for (i = 0; i < data->pci_dev.nmdev_types; i++)\n            virMediatedDeviceTypeFree(data->pci_dev.mdev_types[i]);\n        VIR_FREE(data->pci_dev.mdev_types);\n        break;\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        VIR_FREE(data->usb_dev.product_name);\n        VIR_FREE(data->usb_dev.vendor_name);\n        break;\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        VIR_FREE(data->usb_if.description);\n        break;\n    case VIR_NODE_DEV_CAP_NET:\n        VIR_FREE(data->net.ifname);\n        VIR_FREE(data->net.address);\n        virBitmapFree(data->net.features);\n        data->net.features = NULL;\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        VIR_FREE(data->scsi_host.wwnn);\n        VIR_FREE(data->scsi_host.wwpn);\n        VIR_FREE(data->scsi_host.fabric_wwn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        VIR_FREE(data->scsi_target.name);\n        VIR_FREE(data->scsi_target.rport);\n        VIR_FREE(data->scsi_target.wwpn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI:\n        VIR_FREE(data->scsi.type);\n        break;\n    case VIR_NODE_DEV_CAP_STORAGE:\n        VIR_FREE(data->storage.block);\n        VIR_FREE(data->storage.bus);\n        VIR_FREE(data->storage.drive_type);\n        VIR_FREE(data->storage.model);\n        VIR_FREE(data->storage.vendor);\n        VIR_FREE(data->storage.serial);\n        VIR_FREE(data->storage.media_label);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        VIR_FREE(data->sg.path);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV:\n        VIR_FREE(data->mdev.type);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_DRM:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n    case VIR_NODE_DEV_CAP_LAST:\n        /* This case is here to shutup the compiler */\n        break;\n    }\n\n    VIR_FREE(caps);\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNodeDevCapsDefFree(virNodeDevCapsDefPtr caps)\n{\n    size_t i = 0;\n    virNodeDevCapDataPtr data = &caps->data;\n\n    switch (caps->data.type) {\n    case VIR_NODE_DEV_CAP_SYSTEM:\n        VIR_FREE(data->system.product_name);\n        VIR_FREE(data->system.hardware.vendor_name);\n        VIR_FREE(data->system.hardware.version);\n        VIR_FREE(data->system.hardware.serial);\n        VIR_FREE(data->system.firmware.vendor_name);\n        VIR_FREE(data->system.firmware.version);\n        VIR_FREE(data->system.firmware.release_date);\n        break;\n    case VIR_NODE_DEV_CAP_PCI_DEV:\n        VIR_FREE(data->pci_dev.product_name);\n        VIR_FREE(data->pci_dev.vendor_name);\n        VIR_FREE(data->pci_dev.physical_function);\n        for (i = 0; i < data->pci_dev.num_virtual_functions; i++)\n            VIR_FREE(data->pci_dev.virtual_functions[i]);\n        VIR_FREE(data->pci_dev.virtual_functions);\n        for (i = 0; i < data->pci_dev.nIommuGroupDevices; i++)\n            VIR_FREE(data->pci_dev.iommuGroupDevices[i]);\n        VIR_FREE(data->pci_dev.iommuGroupDevices);\n        virPCIEDeviceInfoFree(data->pci_dev.pci_express);\n        for (i = 0; i < data->pci_dev.nmdev_types; i++)\n            virMediatedDeviceTypeFree(data->pci_dev.mdev_types[i]);\n        VIR_FREE(data->pci_dev.mdev_types);\n        break;\n    case VIR_NODE_DEV_CAP_USB_DEV:\n        VIR_FREE(data->usb_dev.product_name);\n        VIR_FREE(data->usb_dev.vendor_name);\n        break;\n    case VIR_NODE_DEV_CAP_USB_INTERFACE:\n        VIR_FREE(data->usb_if.description);\n        break;\n    case VIR_NODE_DEV_CAP_NET:\n        VIR_FREE(data->net.ifname);\n        VIR_FREE(data->net.address);\n        virBitmapFree(data->net.features);\n        data->net.features = NULL;\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_HOST:\n        VIR_FREE(data->scsi_host.wwnn);\n        VIR_FREE(data->scsi_host.wwpn);\n        VIR_FREE(data->scsi_host.fabric_wwn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_TARGET:\n        VIR_FREE(data->scsi_target.name);\n        VIR_FREE(data->scsi_target.rport);\n        VIR_FREE(data->scsi_target.wwpn);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI:\n        VIR_FREE(data->scsi.type);\n        break;\n    case VIR_NODE_DEV_CAP_STORAGE:\n        VIR_FREE(data->storage.block);\n        VIR_FREE(data->storage.bus);\n        VIR_FREE(data->storage.drive_type);\n        VIR_FREE(data->storage.model);\n        VIR_FREE(data->storage.vendor);\n        VIR_FREE(data->storage.serial);\n        VIR_FREE(data->storage.media_label);\n        break;\n    case VIR_NODE_DEV_CAP_SCSI_GENERIC:\n        VIR_FREE(data->sg.path);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV:\n        VIR_FREE(data->mdev.type);\n        break;\n    case VIR_NODE_DEV_CAP_MDEV_TYPES:\n    case VIR_NODE_DEV_CAP_DRM:\n    case VIR_NODE_DEV_CAP_FC_HOST:\n    case VIR_NODE_DEV_CAP_VPORTS:\n    case VIR_NODE_DEV_CAP_CCW_DEV:\n    case VIR_NODE_DEV_CAP_LAST:\n        /* This case is here to shutup the compiler */\n        break;\n    }\n\n    VIR_FREE(caps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ctx",
            "udi",
            "&caps->data"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "caps"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bsearch",
          "args": [
            "&cap_name",
            "caps_tbl",
            "G_N_ELEMENTS(caps_tbl)",
            "sizeof(caps_tbl[0])",
            "cmpstringp"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "caps_tbl"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic caps_tbl_entry caps_tbl[] = {\n    { \"system\",     VIR_NODE_DEV_CAP_SYSTEM,        gather_system_cap },\n    { \"pci\",        VIR_NODE_DEV_CAP_PCI_DEV,       gather_pci_cap },\n    { \"usb\",        VIR_NODE_DEV_CAP_USB_INTERFACE, gather_usb_cap },\n    { \"usb_device\", VIR_NODE_DEV_CAP_USB_DEV,       gather_usb_device_cap },\n    { \"net\",        VIR_NODE_DEV_CAP_NET,           gather_net_cap },\n    { \"scsi_host\",  VIR_NODE_DEV_CAP_SCSI_HOST,     gather_scsi_host_cap },\n    { \"scsi\",       VIR_NODE_DEV_CAP_SCSI,          gather_scsi_cap },\n    { \"storage\",    VIR_NODE_DEV_CAP_STORAGE,       gather_storage_cap },\n    { \"scsi_generic\", VIR_NODE_DEV_CAP_SCSI_GENERIC, gather_scsi_generic_cap },\n};\n\nstatic int\ngather_capability(LibHalContext *ctx, const char *udi,\n                  const char *cap_name,\n                  virNodeDevCapsDefPtr *caps_p)\n{\n    caps_tbl_entry *entry;\n\n    entry = bsearch(&cap_name, caps_tbl, G_N_ELEMENTS(caps_tbl),\n                    sizeof(caps_tbl[0]), cmpstringp);\n\n    if (entry) {\n        virNodeDevCapsDefPtr caps;\n        if (VIR_ALLOC(caps) < 0)\n            return ENOMEM;\n        caps->data.type = entry->type;\n        if (entry->gather_fn) {\n            int rv = (*entry->gather_fn)(ctx, udi, &caps->data);\n            if (rv != 0) {\n                virNodeDevCapsDefFree(caps);\n                return rv;\n            }\n        }\n        caps->next = *caps_p;\n        *caps_p = caps;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "cmpstringp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "343-348",
    "snippet": "static int\ncmpstringp(const void *p1, const void *p2)\n{\n    /* from man 3 qsort */\n    return strcmp(* (char * const *) p1, * (char * const *) p2);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "* (char * const *) p1",
            "* (char * const *) p2"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\ncmpstringp(const void *p1, const void *p2)\n{\n    /* from man 3 qsort */\n    return strcmp(* (char * const *) p1, * (char * const *) p2);\n}"
  },
  {
    "function_name": "gather_system_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "292-316",
    "snippet": "static int\ngather_system_cap(LibHalContext *ctx, const char *udi,\n                  virNodeDevCapDataPtr d)\n{\n    char *uuidstr;\n\n    (void)get_str_prop(ctx, udi, \"system.product\", &d->system.product_name);\n    (void)get_str_prop(ctx, udi, \"system.hardware.vendor\",\n                       &d->system.hardware.vendor_name);\n    (void)get_str_prop(ctx, udi, \"system.hardware.version\",\n                       &d->system.hardware.version);\n    (void)get_str_prop(ctx, udi, \"system.hardware.serial\",\n                       &d->system.hardware.serial);\n    if (get_str_prop(ctx, udi, \"system.hardware.uuid\", &uuidstr) == 0) {\n        ignore_value(virUUIDParse(uuidstr, d->system.hardware.uuid));\n        VIR_FREE(uuidstr);\n    }\n    (void)get_str_prop(ctx, udi, \"system.firmware.vendor\",\n                       &d->system.firmware.vendor_name);\n    (void)get_str_prop(ctx, udi, \"system.firmware.version\",\n                       &d->system.firmware.version);\n    (void)get_str_prop(ctx, udi, \"system.firmware.release_date\",\n                       &d->system.firmware.release_date);\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_str_prop",
          "args": [
            "ctx",
            "udi",
            "\"system.firmware.release_date\"",
            "&d->system.firmware.release_date"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "get_str_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "66-83",
          "snippet": "static int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuidstr"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virUUIDParse(uuidstr, d->system.hardware.uuid)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "uuidstr",
            "d->system.hardware.uuid"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\ngather_system_cap(LibHalContext *ctx, const char *udi,\n                  virNodeDevCapDataPtr d)\n{\n    char *uuidstr;\n\n    (void)get_str_prop(ctx, udi, \"system.product\", &d->system.product_name);\n    (void)get_str_prop(ctx, udi, \"system.hardware.vendor\",\n                       &d->system.hardware.vendor_name);\n    (void)get_str_prop(ctx, udi, \"system.hardware.version\",\n                       &d->system.hardware.version);\n    (void)get_str_prop(ctx, udi, \"system.hardware.serial\",\n                       &d->system.hardware.serial);\n    if (get_str_prop(ctx, udi, \"system.hardware.uuid\", &uuidstr) == 0) {\n        ignore_value(virUUIDParse(uuidstr, d->system.hardware.uuid));\n        VIR_FREE(uuidstr);\n    }\n    (void)get_str_prop(ctx, udi, \"system.firmware.vendor\",\n                       &d->system.firmware.vendor_name);\n    (void)get_str_prop(ctx, udi, \"system.firmware.version\",\n                       &d->system.firmware.version);\n    (void)get_str_prop(ctx, udi, \"system.firmware.release_date\",\n                       &d->system.firmware.release_date);\n    return 0;\n}"
  },
  {
    "function_name": "gather_scsi_generic_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "283-289",
    "snippet": "static int\ngather_scsi_generic_cap(LibHalContext *ctx, const char *udi,\n                        virNodeDevCapDataPtr d)\n{\n    (void)get_str_prop(ctx, udi, \"scsi_generic.device\", &d->sg.path);\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_str_prop",
          "args": [
            "ctx",
            "udi",
            "\"scsi_generic.device\"",
            "&d->sg.path"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "get_str_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "66-83",
          "snippet": "static int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\ngather_scsi_generic_cap(LibHalContext *ctx, const char *udi,\n                        virNodeDevCapDataPtr d)\n{\n    (void)get_str_prop(ctx, udi, \"scsi_generic.device\", &d->sg.path);\n    return 0;\n}"
  },
  {
    "function_name": "gather_storage_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "255-281",
    "snippet": "static int\ngather_storage_cap(LibHalContext *ctx, const char *udi,\n                   virNodeDevCapDataPtr d)\n{\n    int val;\n    (void)get_str_prop(ctx, udi, \"block.device\", &d->storage.block);\n    (void)get_str_prop(ctx, udi, \"storage.bus\", &d->storage.bus);\n    (void)get_str_prop(ctx, udi, \"storage.drive_type\", &d->storage.drive_type);\n    (void)get_str_prop(ctx, udi, \"storage.model\", &d->storage.model);\n    (void)get_str_prop(ctx, udi, \"storage.vendor\", &d->storage.vendor);\n    (void)get_str_prop(ctx, udi, \"storage.serial\", &d->storage.serial);\n    if (get_bool_prop(ctx, udi, \"storage.removable\", &val) == 0 && val) {\n        d->storage.flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE;\n        if (get_bool_prop(ctx, udi, \"storage.removable.media_available\",\n                          &val) == 0 && val) {\n            d->storage.flags |=\n                VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n            (void)get_uint64_prop(ctx, udi, \"storage.removable.media_size\",\n                                  &d->storage.removable_media_size);\n        }\n    } else {\n        (void)get_uint64_prop(ctx, udi, \"storage.size\", &d->storage.size);\n    }\n    if (get_bool_prop(ctx, udi, \"storage.hotpluggable\", &val) == 0 && val)\n        d->storage.flags |= VIR_NODE_DEV_CAP_STORAGE_HOTPLUGGABLE;\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_bool_prop",
          "args": [
            "ctx",
            "udi",
            "\"storage.hotpluggable\"",
            "&val"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "get_bool_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "103-119",
          "snippet": "static int\nget_bool_prop(LibHalContext *ctxt, const char *udi,\n              const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_bool(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_bool_prop(LibHalContext *ctxt, const char *udi,\n              const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_bool(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_uint64_prop",
          "args": [
            "ctx",
            "udi",
            "\"storage.size\"",
            "&d->storage.size"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "get_uint64_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "121-137",
          "snippet": "static int\nget_uint64_prop(LibHalContext *ctxt, const char *udi,\n                const char *prop, unsigned long long *val_p)\n{\n    DBusError err;\n    unsigned long long val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_uint64(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_uint64_prop(LibHalContext *ctxt, const char *udi,\n                const char *prop, unsigned long long *val_p)\n{\n    DBusError err;\n    unsigned long long val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_uint64(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_str_prop",
          "args": [
            "ctx",
            "udi",
            "\"storage.serial\"",
            "&d->storage.serial"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "get_str_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "66-83",
          "snippet": "static int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\ngather_storage_cap(LibHalContext *ctx, const char *udi,\n                   virNodeDevCapDataPtr d)\n{\n    int val;\n    (void)get_str_prop(ctx, udi, \"block.device\", &d->storage.block);\n    (void)get_str_prop(ctx, udi, \"storage.bus\", &d->storage.bus);\n    (void)get_str_prop(ctx, udi, \"storage.drive_type\", &d->storage.drive_type);\n    (void)get_str_prop(ctx, udi, \"storage.model\", &d->storage.model);\n    (void)get_str_prop(ctx, udi, \"storage.vendor\", &d->storage.vendor);\n    (void)get_str_prop(ctx, udi, \"storage.serial\", &d->storage.serial);\n    if (get_bool_prop(ctx, udi, \"storage.removable\", &val) == 0 && val) {\n        d->storage.flags |= VIR_NODE_DEV_CAP_STORAGE_REMOVABLE;\n        if (get_bool_prop(ctx, udi, \"storage.removable.media_available\",\n                          &val) == 0 && val) {\n            d->storage.flags |=\n                VIR_NODE_DEV_CAP_STORAGE_REMOVABLE_MEDIA_AVAILABLE;\n            (void)get_uint64_prop(ctx, udi, \"storage.removable.media_size\",\n                                  &d->storage.removable_media_size);\n        }\n    } else {\n        (void)get_uint64_prop(ctx, udi, \"storage.size\", &d->storage.size);\n    }\n    if (get_bool_prop(ctx, udi, \"storage.hotpluggable\", &val) == 0 && val)\n        d->storage.flags |= VIR_NODE_DEV_CAP_STORAGE_HOTPLUGGABLE;\n    return 0;\n}"
  },
  {
    "function_name": "gather_scsi_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "242-252",
    "snippet": "static int\ngather_scsi_cap(LibHalContext *ctx, const char *udi,\n                virNodeDevCapDataPtr d)\n{\n    (void)get_int_prop(ctx, udi, \"scsi.host\", (int *)&d->scsi.host);\n    (void)get_int_prop(ctx, udi, \"scsi.bus\", (int *)&d->scsi.bus);\n    (void)get_int_prop(ctx, udi, \"scsi.target\", (int *)&d->scsi.target);\n    (void)get_int_prop(ctx, udi, \"scsi.lun\", (int *)&d->scsi.lun);\n    (void)get_str_prop(ctx, udi, \"scsi.type\", &d->scsi.type);\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_str_prop",
          "args": [
            "ctx",
            "udi",
            "\"scsi.type\"",
            "&d->scsi.type"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "get_str_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "66-83",
          "snippet": "static int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_int_prop",
          "args": [
            "ctx",
            "udi",
            "\"scsi.lun\"",
            "(int *)&d->scsi.lun"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "get_int_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "85-101",
          "snippet": "static int\nget_int_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_int(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_int_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_int(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\ngather_scsi_cap(LibHalContext *ctx, const char *udi,\n                virNodeDevCapDataPtr d)\n{\n    (void)get_int_prop(ctx, udi, \"scsi.host\", (int *)&d->scsi.host);\n    (void)get_int_prop(ctx, udi, \"scsi.bus\", (int *)&d->scsi.bus);\n    (void)get_int_prop(ctx, udi, \"scsi.target\", (int *)&d->scsi.target);\n    (void)get_int_prop(ctx, udi, \"scsi.lun\", (int *)&d->scsi.lun);\n    (void)get_str_prop(ctx, udi, \"scsi.type\", &d->scsi.type);\n    return 0;\n}"
  },
  {
    "function_name": "gather_scsi_host_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "232-239",
    "snippet": "static int\ngather_scsi_host_cap(LibHalContext *ctx, const char *udi,\n                     virNodeDevCapDataPtr d)\n{\n    (void)get_int_prop(ctx, udi, \"scsi_host.host\", (int *)&d->scsi_host.host);\n\n    return virNodeDeviceGetSCSIHostCaps(&d->scsi_host);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNodeDeviceGetSCSIHostCaps",
          "args": [
            "&d->scsi_host"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceGetSCSIHostCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2602-2606",
          "snippet": "int\nvirNodeDeviceGetSCSIHostCaps(virNodeDevCapSCSIHostPtr scsi_host G_GNUC_UNUSED)\n{\n    return -1;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNodeDeviceGetSCSIHostCaps(virNodeDevCapSCSIHostPtr scsi_host G_GNUC_UNUSED)\n{\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_int_prop",
          "args": [
            "ctx",
            "udi",
            "\"scsi_host.host\"",
            "(int *)&d->scsi_host.host"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "get_int_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "85-101",
          "snippet": "static int\nget_int_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_int(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_int_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_int(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\ngather_scsi_host_cap(LibHalContext *ctx, const char *udi,\n                     virNodeDevCapDataPtr d)\n{\n    (void)get_int_prop(ctx, udi, \"scsi_host.host\", (int *)&d->scsi_host.host);\n\n    return virNodeDeviceGetSCSIHostCaps(&d->scsi_host);\n}"
  },
  {
    "function_name": "gather_net_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "212-229",
    "snippet": "static int\ngather_net_cap(LibHalContext *ctx, const char *udi,\n               virNodeDevCapDataPtr d)\n{\n    unsigned long long dummy;\n    (void)get_str_prop(ctx, udi, \"net.interface\", &d->net.ifname);\n    (void)get_str_prop(ctx, udi, \"net.address\", &d->net.address);\n    if (get_uint64_prop(ctx, udi, \"net.80203.mac_address\",\n                        &dummy) == 0)\n        d->net.subtype = VIR_NODE_DEV_CAP_NET_80203;\n    else if (get_uint64_prop(ctx, udi, \"net.80211.mac_address\",\n                             &dummy) == 0)\n        d->net.subtype = VIR_NODE_DEV_CAP_NET_80211;\n    else\n        d->net.subtype = VIR_NODE_DEV_CAP_NET_LAST;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_uint64_prop",
          "args": [
            "ctx",
            "udi",
            "\"net.80211.mac_address\"",
            "&dummy"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "get_uint64_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "121-137",
          "snippet": "static int\nget_uint64_prop(LibHalContext *ctxt, const char *udi,\n                const char *prop, unsigned long long *val_p)\n{\n    DBusError err;\n    unsigned long long val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_uint64(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_uint64_prop(LibHalContext *ctxt, const char *udi,\n                const char *prop, unsigned long long *val_p)\n{\n    DBusError err;\n    unsigned long long val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_uint64(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_str_prop",
          "args": [
            "ctx",
            "udi",
            "\"net.address\"",
            "&d->net.address"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "get_str_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "66-83",
          "snippet": "static int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\ngather_net_cap(LibHalContext *ctx, const char *udi,\n               virNodeDevCapDataPtr d)\n{\n    unsigned long long dummy;\n    (void)get_str_prop(ctx, udi, \"net.interface\", &d->net.ifname);\n    (void)get_str_prop(ctx, udi, \"net.address\", &d->net.address);\n    if (get_uint64_prop(ctx, udi, \"net.80203.mac_address\",\n                        &dummy) == 0)\n        d->net.subtype = VIR_NODE_DEV_CAP_NET_80203;\n    else if (get_uint64_prop(ctx, udi, \"net.80211.mac_address\",\n                             &dummy) == 0)\n        d->net.subtype = VIR_NODE_DEV_CAP_NET_80211;\n    else\n        d->net.subtype = VIR_NODE_DEV_CAP_NET_LAST;\n\n    return 0;\n}"
  },
  {
    "function_name": "gather_usb_device_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "190-209",
    "snippet": "static int\ngather_usb_device_cap(LibHalContext *ctx, const char *udi,\n                      virNodeDevCapDataPtr d)\n{\n    (void)get_int_prop(ctx, udi, \"usb_device.bus_number\",\n                       (int *)&d->usb_dev.bus);\n    (void)get_int_prop(ctx, udi, \"usb_device.linux.device_number\",\n                       (int *)&d->usb_dev.device);\n    (void)get_int_prop(ctx, udi, \"usb_device.vendor_id\",\n                       (int *)&d->usb_dev.vendor);\n    if (get_str_prop(ctx, udi, \"usb_device.vendor\",\n                     &d->usb_dev.vendor_name) != 0)\n        (void)get_str_prop(ctx, udi, \"info.vendor\", &d->usb_dev.vendor_name);\n    (void)get_int_prop(ctx, udi, \"usb_device.product_id\",\n                       (int *)&d->usb_dev.product);\n    if (get_str_prop(ctx, udi, \"usb_device.product\",\n                     &d->usb_dev.product_name) != 0)\n        (void)get_str_prop(ctx, udi, \"info.product\", &d->usb_dev.product_name);\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_str_prop",
          "args": [
            "ctx",
            "udi",
            "\"info.product\"",
            "&d->usb_dev.product_name"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "get_str_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "66-83",
          "snippet": "static int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_int_prop",
          "args": [
            "ctx",
            "udi",
            "\"usb_device.product_id\"",
            "(int *)&d->usb_dev.product"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "get_int_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "85-101",
          "snippet": "static int\nget_int_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_int(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_int_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_int(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\ngather_usb_device_cap(LibHalContext *ctx, const char *udi,\n                      virNodeDevCapDataPtr d)\n{\n    (void)get_int_prop(ctx, udi, \"usb_device.bus_number\",\n                       (int *)&d->usb_dev.bus);\n    (void)get_int_prop(ctx, udi, \"usb_device.linux.device_number\",\n                       (int *)&d->usb_dev.device);\n    (void)get_int_prop(ctx, udi, \"usb_device.vendor_id\",\n                       (int *)&d->usb_dev.vendor);\n    if (get_str_prop(ctx, udi, \"usb_device.vendor\",\n                     &d->usb_dev.vendor_name) != 0)\n        (void)get_str_prop(ctx, udi, \"info.vendor\", &d->usb_dev.vendor_name);\n    (void)get_int_prop(ctx, udi, \"usb_device.product_id\",\n                       (int *)&d->usb_dev.product);\n    if (get_str_prop(ctx, udi, \"usb_device.product\",\n                     &d->usb_dev.product_name) != 0)\n        (void)get_str_prop(ctx, udi, \"info.product\", &d->usb_dev.product_name);\n    return 0;\n}"
  },
  {
    "function_name": "gather_usb_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "172-187",
    "snippet": "static int\ngather_usb_cap(LibHalContext *ctx, const char *udi,\n               virNodeDevCapDataPtr d)\n{\n    (void)get_int_prop(ctx, udi, \"usb.interface.number\",\n                       (int *)&d->usb_if.number);\n    (void)get_int_prop(ctx, udi, \"usb.interface.class\",\n                       (int *)&d->usb_if.klass);\n    (void)get_int_prop(ctx, udi, \"usb.interface.subclass\",\n                       (int *)&d->usb_if.subclass);\n    (void)get_int_prop(ctx, udi, \"usb.interface.protocol\",\n                       (int *)&d->usb_if.protocol);\n    (void)get_str_prop(ctx, udi, \"usb.interface.description\",\n                       &d->usb_if.description);\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_str_prop",
          "args": [
            "ctx",
            "udi",
            "\"usb.interface.description\"",
            "&d->usb_if.description"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "get_str_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "66-83",
          "snippet": "static int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_int_prop",
          "args": [
            "ctx",
            "udi",
            "\"usb.interface.protocol\"",
            "(int *)&d->usb_if.protocol"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "get_int_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "85-101",
          "snippet": "static int\nget_int_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_int(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_int_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_int(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\ngather_usb_cap(LibHalContext *ctx, const char *udi,\n               virNodeDevCapDataPtr d)\n{\n    (void)get_int_prop(ctx, udi, \"usb.interface.number\",\n                       (int *)&d->usb_if.number);\n    (void)get_int_prop(ctx, udi, \"usb.interface.class\",\n                       (int *)&d->usb_if.klass);\n    (void)get_int_prop(ctx, udi, \"usb.interface.subclass\",\n                       (int *)&d->usb_if.subclass);\n    (void)get_int_prop(ctx, udi, \"usb.interface.protocol\",\n                       (int *)&d->usb_if.protocol);\n    (void)get_str_prop(ctx, udi, \"usb.interface.description\",\n                       &d->usb_if.description);\n    return 0;\n}"
  },
  {
    "function_name": "gather_pci_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "139-169",
    "snippet": "static int\ngather_pci_cap(LibHalContext *ctx, const char *udi,\n               virNodeDevCapDataPtr d)\n{\n    char *sysfs_path;\n\n    if (get_str_prop(ctx, udi, \"pci.linux.sysfs_path\", &sysfs_path) == 0) {\n        char *p = strrchr(sysfs_path, '/');\n        if (p) {\n            ignore_value(virStrToLong_ui(p+1, &p, 16, &d->pci_dev.domain));\n            ignore_value(virStrToLong_ui(p+1, &p, 16, &d->pci_dev.bus));\n            ignore_value(virStrToLong_ui(p+1, &p, 16, &d->pci_dev.slot));\n            ignore_value(virStrToLong_ui(p+1, &p, 16, &d->pci_dev.function));\n        }\n\n        if (virNodeDeviceGetPCIDynamicCaps(sysfs_path, &d->pci_dev) < 0) {\n            VIR_FREE(sysfs_path);\n            return -1;\n        }\n        VIR_FREE(sysfs_path);\n    }\n\n    (void)get_int_prop(ctx, udi, \"pci.vendor_id\", (int *)&d->pci_dev.vendor);\n    if (get_str_prop(ctx, udi, \"pci.vendor\", &d->pci_dev.vendor_name) != 0)\n        (void)get_str_prop(ctx, udi, \"info.vendor\", &d->pci_dev.vendor_name);\n    (void)get_int_prop(ctx, udi, \"pci.product_id\", (int *)&d->pci_dev.product);\n    if (get_str_prop(ctx, udi, \"pci.product\", &d->pci_dev.product_name) != 0)\n        (void)get_str_prop(ctx, udi, \"info.product\", &d->pci_dev.product_name);\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_str_prop",
          "args": [
            "ctx",
            "udi",
            "\"info.product\"",
            "&d->pci_dev.product_name"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "get_str_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "66-83",
          "snippet": "static int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_int_prop",
          "args": [
            "ctx",
            "udi",
            "\"pci.product_id\"",
            "(int *)&d->pci_dev.product"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "get_int_prop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
          "lines": "85-101",
          "snippet": "static int\nget_int_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_int(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virlog.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"driver.h\"",
            "#include \"virerror.h\"",
            "#include \"node_device_hal.h\"",
            "#include \"node_device_driver.h\"",
            "#include \"node_device_conf.h\"",
            "#include <libhal.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_int_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_int(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sysfs_path"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sysfs_path"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNodeDeviceGetPCIDynamicCaps",
          "args": [
            "sysfs_path",
            "&d->pci_dev"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "virNodeDeviceGetPCIDynamicCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/node_device_conf.c",
          "lines": "2608-2613",
          "snippet": "int\nvirNodeDeviceGetPCIDynamicCaps(const char *sysfsPath G_GNUC_UNUSED,\n                               virNodeDevCapPCIDevPtr pci_dev G_GNUC_UNUSED)\n{\n    return -1;\n}",
          "includes": [
            "#include \"virfcp.h\"",
            "#include \"virlog.h\"",
            "#include \"virrandom.h\"",
            "#include \"viruuid.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"device_conf.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfcp.h\"\n#include \"virlog.h\"\n#include \"virrandom.h\"\n#include \"viruuid.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"device_conf.h\"\n#include \"node_device_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNodeDeviceGetPCIDynamicCaps(const char *sysfsPath G_GNUC_UNUSED,\n                               virNodeDevCapPCIDevPtr pci_dev G_GNUC_UNUSED)\n{\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStrToLong_ui(p+1, &p, 16, &d->pci_dev.function)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "p+1",
            "&p",
            "16",
            "&d->pci_dev.function"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStrToLong_ui(p+1, &p, 16, &d->pci_dev.slot)"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStrToLong_ui(p+1, &p, 16, &d->pci_dev.bus)"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStrToLong_ui(p+1, &p, 16, &d->pci_dev.domain)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "sysfs_path",
            "'/'"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\ngather_pci_cap(LibHalContext *ctx, const char *udi,\n               virNodeDevCapDataPtr d)\n{\n    char *sysfs_path;\n\n    if (get_str_prop(ctx, udi, \"pci.linux.sysfs_path\", &sysfs_path) == 0) {\n        char *p = strrchr(sysfs_path, '/');\n        if (p) {\n            ignore_value(virStrToLong_ui(p+1, &p, 16, &d->pci_dev.domain));\n            ignore_value(virStrToLong_ui(p+1, &p, 16, &d->pci_dev.bus));\n            ignore_value(virStrToLong_ui(p+1, &p, 16, &d->pci_dev.slot));\n            ignore_value(virStrToLong_ui(p+1, &p, 16, &d->pci_dev.function));\n        }\n\n        if (virNodeDeviceGetPCIDynamicCaps(sysfs_path, &d->pci_dev) < 0) {\n            VIR_FREE(sysfs_path);\n            return -1;\n        }\n        VIR_FREE(sysfs_path);\n    }\n\n    (void)get_int_prop(ctx, udi, \"pci.vendor_id\", (int *)&d->pci_dev.vendor);\n    if (get_str_prop(ctx, udi, \"pci.vendor\", &d->pci_dev.vendor_name) != 0)\n        (void)get_str_prop(ctx, udi, \"info.vendor\", &d->pci_dev.vendor_name);\n    (void)get_int_prop(ctx, udi, \"pci.product_id\", (int *)&d->pci_dev.product);\n    if (get_str_prop(ctx, udi, \"pci.product\", &d->pci_dev.product_name) != 0)\n        (void)get_str_prop(ctx, udi, \"info.product\", &d->pci_dev.product_name);\n\n    return 0;\n}"
  },
  {
    "function_name": "get_uint64_prop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "121-137",
    "snippet": "static int\nget_uint64_prop(LibHalContext *ctxt, const char *udi,\n                const char *prop, unsigned long long *val_p)\n{\n    DBusError err;\n    unsigned long long val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_uint64(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbus_error_free",
          "args": [
            "&err"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_error_is_set",
          "args": [
            "&err"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_device_get_property_uint64",
          "args": [
            "ctxt",
            "udi",
            "prop",
            "&err"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_error_init",
          "args": [
            "&err"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_uint64_prop(LibHalContext *ctxt, const char *udi,\n                const char *prop, unsigned long long *val_p)\n{\n    DBusError err;\n    unsigned long long val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_uint64(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}"
  },
  {
    "function_name": "get_bool_prop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "103-119",
    "snippet": "static int\nget_bool_prop(LibHalContext *ctxt, const char *udi,\n              const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_bool(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbus_error_free",
          "args": [
            "&err"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_error_is_set",
          "args": [
            "&err"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_device_get_property_bool",
          "args": [
            "ctxt",
            "udi",
            "prop",
            "&err"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_error_init",
          "args": [
            "&err"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_bool_prop(LibHalContext *ctxt, const char *udi,\n              const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_bool(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}"
  },
  {
    "function_name": "get_int_prop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "85-101",
    "snippet": "static int\nget_int_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_int(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbus_error_free",
          "args": [
            "&err"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_error_is_set",
          "args": [
            "&err"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_device_get_property_int",
          "args": [
            "ctxt",
            "udi",
            "prop",
            "&err"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_error_init",
          "args": [
            "&err"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_int_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, int *val_p)\n{\n    DBusError err;\n    int val;\n    int rv;\n\n    dbus_error_init(&err);\n    val = libhal_device_get_property_int(ctxt, udi, prop, &err);\n    rv = dbus_error_is_set(&err);\n    dbus_error_free(&err);\n    if (rv == 0)\n        *val_p = val;\n\n    return rv;\n}"
  },
  {
    "function_name": "get_str_prop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "66-83",
    "snippet": "static int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "val"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libhal_device_get_property_string",
          "args": [
            "ctxt",
            "udi",
            "prop",
            "NULL"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic int\nget_str_prop(LibHalContext *ctxt, const char *udi,\n             const char *prop, char **val_p)\n{\n    char *val = libhal_device_get_property_string(ctxt, udi, prop, NULL);\n\n    if (val) {\n        if (*val) {\n            *val_p = val;\n            return 0;\n        } else {\n            /* Treat empty strings as NULL values */\n            VIR_FREE(val);\n        }\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "hal_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/node_device/node_device_hal.c",
    "lines": "56-63",
    "snippet": "static const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virdbus.h\"",
      "#include \"virlog.h\"",
      "#include \"virpidfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"datatypes.h\"",
      "#include \"driver.h\"",
      "#include \"virerror.h\"",
      "#include \"node_device_hal.h\"",
      "#include \"node_device_driver.h\"",
      "#include \"node_device_conf.h\"",
      "#include <libhal.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "udi",
            "'/'"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virlog.h\"\n#include \"virpidfile.h\"\n#include \"virpci.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"driver.h\"\n#include \"virerror.h\"\n#include \"node_device_hal.h\"\n#include \"node_device_driver.h\"\n#include \"node_device_conf.h\"\n#include <libhal.h>\n#include <config.h>\n\nstatic const char *\nhal_name(const char *udi)\n{\n    const char *name = strrchr(udi, '/');\n    if (name)\n        return name + 1;\n    return udi;\n}"
  }
]