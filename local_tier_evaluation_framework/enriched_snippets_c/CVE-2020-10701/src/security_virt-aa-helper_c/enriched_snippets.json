[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "1441-1576",
    "snippet": "int\nmain(int argc, char **argv)\n{\n    vahControl _ctl, *ctl = &_ctl;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    char *profile = NULL;\n    char *include_file = NULL;\n\n    if (virGettextInitialize() < 0 ||\n        virErrorInitialize() < 0) {\n        fprintf(stderr, _(\"%s: initialization failed\\n\"), argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    virFileActivateDirOverrideForProg(argv[0]);\n\n    /* Initialize the log system */\n    virLogSetFromEnv();\n\n    /* clear the environment */\n    environ = NULL;\n    if (g_setenv(\"PATH\", \"/sbin:/usr/sbin\", TRUE) == FALSE)\n        vah_error(ctl, 1, _(\"could not set PATH\"));\n\n    /* ensure the traditional IFS setting */\n    if (g_setenv(\"IFS\", \" \\t\\n\", TRUE) == FALSE)\n        vah_error(ctl, 1, _(\"could not set IFS\"));\n\n    if (!(progname = strrchr(argv[0], '/')))\n        progname = argv[0];\n    else\n        progname++;\n\n    memset(ctl, 0, sizeof(vahControl));\n\n    if (vahParseArgv(ctl, argc, argv) != 0)\n        vah_error(ctl, 1, _(\"could not parse arguments\"));\n\n    profile = g_strdup_printf(\"%s/%s\", APPARMOR_DIR \"/libvirt\", ctl->uuid);\n    include_file = g_strdup_printf(\"%s/%s.files\", APPARMOR_DIR \"/libvirt\", ctl->uuid);\n\n    if (ctl->cmd == 'a') {\n        rc = parserLoad(ctl->uuid);\n    } else if (ctl->cmd == 'R' || ctl->cmd == 'D') {\n        rc = parserRemove(ctl->uuid);\n        if (ctl->cmd == 'D') {\n            unlink(include_file);\n            unlink(profile);\n        }\n    } else if (ctl->cmd == 'c' || ctl->cmd == 'r') {\n        char *included_files = NULL;\n\n        if (ctl->cmd == 'c' && virFileExists(profile))\n            vah_error(ctl, 1, _(\"profile exists\"));\n\n        if (ctl->append && ctl->newfile) {\n            if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n                goto cleanup;\n        } else {\n            if (ctl->def->virtType == VIR_DOMAIN_VIRT_QEMU ||\n                ctl->def->virtType == VIR_DOMAIN_VIRT_KQEMU ||\n                ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n                virBufferAsprintf(&buf, \"  \\\"%s/log/libvirt/**/%s.log\\\" w,\\n\",\n                                  LOCALSTATEDIR, ctl->def->name);\n                virBufferAsprintf(&buf, \"  \\\"%s/lib/libvirt/qemu/domain-%s/monitor.sock\\\" rw,\\n\",\n                                  LOCALSTATEDIR, ctl->def->name);\n                virBufferAsprintf(&buf, \"  \\\"%s/lib/libvirt/qemu/domain-%d-%.*s/*\\\" rw,\\n\",\n                                  LOCALSTATEDIR, ctl->def->id, 20, ctl->def->name);\n                virBufferAsprintf(&buf, \"  \\\"%s/libvirt/**/%s.pid\\\" rwk,\\n\",\n                                  RUNSTATEDIR, ctl->def->name);\n                virBufferAsprintf(&buf, \"  \\\"%s/libvirt/**/*.tunnelmigrate.dest.%s\\\" rw,\\n\",\n                                  RUNSTATEDIR, ctl->def->name);\n            }\n            if (ctl->files)\n                virBufferAdd(&buf, ctl->files, -1);\n        }\n\n        included_files = virBufferContentAndReset(&buf);\n\n        /* (re)create the include file using included_files */\n        if (ctl->dryrun) {\n            vah_info(include_file);\n            vah_info(included_files);\n            rc = 0;\n        } else if (ctl->def->virtType == VIR_DOMAIN_VIRT_LXC) {\n            rc = 0;\n        } else if ((rc = update_include_file(include_file,\n                                             included_files,\n                                             ctl->append)) != 0) {\n            goto cleanup;\n        }\n\n\n        /* create the profile from TEMPLATE */\n        if (ctl->cmd == 'c') {\n            char *tmp = NULL;\n            tmp = g_strdup_printf(\"  #include <libvirt/%s.files>\\n\", ctl->uuid);\n\n            if (ctl->dryrun) {\n                vah_info(profile);\n                vah_info(ctl->uuid);\n                vah_info(tmp);\n                rc = 0;\n            } else if ((rc = create_profile(profile, ctl->uuid, tmp,\n                                            ctl->def->virtType)) != 0) {\n                vah_error(ctl, 0, _(\"could not create profile\"));\n                unlink(include_file);\n            }\n            VIR_FREE(tmp);\n        }\n\n        if (rc == 0 && !ctl->dryrun) {\n            if (ctl->cmd == 'c')\n                rc = parserLoad(ctl->uuid);\n            else\n                rc = parserReplace(ctl->uuid);\n\n            /* cleanup */\n            if (rc != 0) {\n                unlink(include_file);\n                if (ctl->cmd == 'c')\n                    unlink(profile);\n            }\n        }\n      cleanup:\n        VIR_FREE(included_files);\n    }\n\n    vahDeinit(ctl);\n\n    VIR_FREE(profile);\n    VIR_FREE(include_file);\n\n    exit(rc == 0 ? EXIT_SUCCESS : EXIT_FAILURE);\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *progname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "rc == 0 ? EXIT_SUCCESS : EXIT_FAILURE"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "include_file"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "profile"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vahDeinit",
          "args": [
            "ctl"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "vahDeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "75-90",
          "snippet": "static int\nvahDeinit(vahControl * ctl)\n{\n    if (ctl == NULL)\n        return -1;\n\n    VIR_FREE(ctl->def);\n    virObjectUnref(ctl->caps);\n    virObjectUnref(ctl->xmlopt);\n    VIR_FREE(ctl->files);\n    VIR_FREE(ctl->virtType);\n    VIR_FREE(ctl->os);\n    VIR_FREE(ctl->newfile);\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvahDeinit(vahControl * ctl)\n{\n    if (ctl == NULL)\n        return -1;\n\n    VIR_FREE(ctl->def);\n    virObjectUnref(ctl->caps);\n    virObjectUnref(ctl->xmlopt);\n    VIR_FREE(ctl->files);\n    VIR_FREE(ctl->virtType);\n    VIR_FREE(ctl->os);\n    VIR_FREE(ctl->newfile);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "included_files"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "profile"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "include_file"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parserReplace",
          "args": [
            "ctl->uuid"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "parserReplace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "384-388",
          "snippet": "static int\nparserReplace(const char *profile_name)\n{\n    return parserCommand(profile_name, 'r');\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nparserReplace(const char *profile_name)\n{\n    return parserCommand(profile_name, 'r');\n}"
        }
      },
      {
        "call_info": {
          "callee": "parserLoad",
          "args": [
            "ctl->uuid"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "parserLoad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "366-370",
          "snippet": "static int\nparserLoad(const char *profile_name)\n{\n    return parserCommand(profile_name, 'a');\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nparserLoad(const char *profile_name)\n{\n    return parserCommand(profile_name, 'a');\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "include_file"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vah_error",
          "args": [
            "ctl",
            "0",
            "_(\"could not create profile\")"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "vah_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "119-129",
          "snippet": "static void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not create profile\""
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_profile",
          "args": [
            "profile",
            "ctl->uuid",
            "tmp",
            "ctl->def->virtType"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "create_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "263-361",
          "snippet": "static int\ncreate_profile(const char *profile, const char *profile_name,\n               const char *profile_files, int virtType)\n{\n    g_autofree char *template = NULL;\n    g_autofree char *tcontent = NULL;\n    g_autofree char *pcontent = NULL;\n    g_autofree char *replace_name = NULL;\n    g_autofree char *replace_files = NULL;\n    char *tmp = NULL;\n    const char *template_name = \"\\nprofile LIBVIRT_TEMPLATE\";\n    const char *template_end = \"\\n}\";\n    int tlen, plen;\n    int fd;\n    const char *driver_name = NULL;\n\n    if (virFileExists(profile)) {\n        vah_error(NULL, 0, _(\"profile exists\"));\n        return -1;\n    }\n\n    switch (virtType) {\n    case VIR_DOMAIN_VIRT_QEMU:\n    case VIR_DOMAIN_VIRT_KQEMU:\n    case VIR_DOMAIN_VIRT_KVM:\n        driver_name = \"qemu\";\n        break;\n    default:\n        driver_name = virDomainVirtTypeToString(virtType);\n    }\n\n    template = g_strdup_printf(\"%s/TEMPLATE.%s\", APPARMOR_DIR \"/libvirt\", driver_name);\n\n    if (!virFileExists(template)) {\n        vah_error(NULL, 0, _(\"template does not exist\"));\n        return -1;\n    }\n\n    if ((tlen = virFileReadAll(template, MAX_FILE_LEN, &tcontent)) < 0) {\n        vah_error(NULL, 0, _(\"failed to read AppArmor template\"));\n        return -1;\n    }\n\n    if (strstr(tcontent, template_name) == NULL) {\n        vah_error(NULL, 0, _(\"no replacement string in template\"));\n        return -1;\n    }\n\n    if (strstr(tcontent, template_end) == NULL) {\n        vah_error(NULL, 0, _(\"no replacement string in template\"));\n        return -1;\n    }\n\n    /* '\\nprofile <profile_name>\\0' */\n    replace_name = g_strdup_printf(\"\\nprofile %s\", profile_name);\n\n    /* '\\n<profile_files>\\n}\\0' */\n    if (virtType != VIR_DOMAIN_VIRT_LXC)\n    replace_files = g_strdup_printf(\"\\n%s\\n}\", profile_files);\n\n    plen = tlen + strlen(replace_name) - strlen(template_name) + 1;\n\n    if (virtType != VIR_DOMAIN_VIRT_LXC)\n        plen += strlen(replace_files) - strlen(template_end);\n\n    if (plen > MAX_FILE_LEN || plen < tlen) {\n        vah_error(NULL, 0, _(\"invalid length for new profile\"));\n        return -1;\n    }\n\n    if (!(pcontent = virStringReplace(tcontent, template_name, replace_name)))\n        return -1;\n\n    if (virtType != VIR_DOMAIN_VIRT_LXC) {\n        if (!(tmp = virStringReplace(pcontent, template_end, replace_files)))\n            return -1;\n        VIR_FREE(pcontent);\n        pcontent = g_steal_pointer(&tmp);\n    }\n\n    /* write the file */\n    if ((fd = open(profile, O_CREAT | O_EXCL | O_WRONLY, 0644)) == -1) {\n        vah_error(NULL, 0, _(\"failed to create profile\"));\n        return -1;\n    }\n\n    if (safewrite(fd, pcontent, plen - 1) < 0) { /* don't write the '\\0' */\n        VIR_FORCE_CLOSE(fd);\n        vah_error(NULL, 0, _(\"failed to write to profile\"));\n        return -1;\n    }\n\n    if (VIR_CLOSE(fd) != 0) {\n        vah_error(NULL, 0, _(\"failed to close or write to profile\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\ncreate_profile(const char *profile, const char *profile_name,\n               const char *profile_files, int virtType)\n{\n    g_autofree char *template = NULL;\n    g_autofree char *tcontent = NULL;\n    g_autofree char *pcontent = NULL;\n    g_autofree char *replace_name = NULL;\n    g_autofree char *replace_files = NULL;\n    char *tmp = NULL;\n    const char *template_name = \"\\nprofile LIBVIRT_TEMPLATE\";\n    const char *template_end = \"\\n}\";\n    int tlen, plen;\n    int fd;\n    const char *driver_name = NULL;\n\n    if (virFileExists(profile)) {\n        vah_error(NULL, 0, _(\"profile exists\"));\n        return -1;\n    }\n\n    switch (virtType) {\n    case VIR_DOMAIN_VIRT_QEMU:\n    case VIR_DOMAIN_VIRT_KQEMU:\n    case VIR_DOMAIN_VIRT_KVM:\n        driver_name = \"qemu\";\n        break;\n    default:\n        driver_name = virDomainVirtTypeToString(virtType);\n    }\n\n    template = g_strdup_printf(\"%s/TEMPLATE.%s\", APPARMOR_DIR \"/libvirt\", driver_name);\n\n    if (!virFileExists(template)) {\n        vah_error(NULL, 0, _(\"template does not exist\"));\n        return -1;\n    }\n\n    if ((tlen = virFileReadAll(template, MAX_FILE_LEN, &tcontent)) < 0) {\n        vah_error(NULL, 0, _(\"failed to read AppArmor template\"));\n        return -1;\n    }\n\n    if (strstr(tcontent, template_name) == NULL) {\n        vah_error(NULL, 0, _(\"no replacement string in template\"));\n        return -1;\n    }\n\n    if (strstr(tcontent, template_end) == NULL) {\n        vah_error(NULL, 0, _(\"no replacement string in template\"));\n        return -1;\n    }\n\n    /* '\\nprofile <profile_name>\\0' */\n    replace_name = g_strdup_printf(\"\\nprofile %s\", profile_name);\n\n    /* '\\n<profile_files>\\n}\\0' */\n    if (virtType != VIR_DOMAIN_VIRT_LXC)\n    replace_files = g_strdup_printf(\"\\n%s\\n}\", profile_files);\n\n    plen = tlen + strlen(replace_name) - strlen(template_name) + 1;\n\n    if (virtType != VIR_DOMAIN_VIRT_LXC)\n        plen += strlen(replace_files) - strlen(template_end);\n\n    if (plen > MAX_FILE_LEN || plen < tlen) {\n        vah_error(NULL, 0, _(\"invalid length for new profile\"));\n        return -1;\n    }\n\n    if (!(pcontent = virStringReplace(tcontent, template_name, replace_name)))\n        return -1;\n\n    if (virtType != VIR_DOMAIN_VIRT_LXC) {\n        if (!(tmp = virStringReplace(pcontent, template_end, replace_files)))\n            return -1;\n        VIR_FREE(pcontent);\n        pcontent = g_steal_pointer(&tmp);\n    }\n\n    /* write the file */\n    if ((fd = open(profile, O_CREAT | O_EXCL | O_WRONLY, 0644)) == -1) {\n        vah_error(NULL, 0, _(\"failed to create profile\"));\n        return -1;\n    }\n\n    if (safewrite(fd, pcontent, plen - 1) < 0) { /* don't write the '\\0' */\n        VIR_FORCE_CLOSE(fd);\n        vah_error(NULL, 0, _(\"failed to write to profile\"));\n        return -1;\n    }\n\n    if (VIR_CLOSE(fd) != 0) {\n        vah_error(NULL, 0, _(\"failed to close or write to profile\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vah_info",
          "args": [
            "tmp"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "vah_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "137-141",
          "snippet": "static void\nvah_info(const char *str)\n{\n    fprintf(stderr, _(\"%s:\\n%s%c\"), progname, str, '\\n');\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_info(const char *str)\n{\n    fprintf(stderr, _(\"%s:\\n%s%c\"), progname, str, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"  #include <libvirt/%s.files>\\n\"",
            "ctl->uuid"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_include_file",
          "args": [
            "include_file",
            "included_files",
            "ctl->append"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "update_include_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "200-258",
          "snippet": "static int\nupdate_include_file(const char *include_file, const char *included_files,\n                    bool append)\n{\n    int rc = -1;\n    int plen, flen = 0;\n    int fd;\n    char *pcontent = NULL;\n    char *existing = NULL;\n    const char *warning =\n         \"# DO NOT EDIT THIS FILE DIRECTLY. IT IS MANAGED BY LIBVIRT.\\n\";\n\n    if (virFileExists(include_file)) {\n        flen = virFileReadAll(include_file, MAX_FILE_LEN, &existing);\n        if (flen < 0)\n            return rc;\n    }\n\n    if (append && virFileExists(include_file))\n        pcontent = g_strdup_printf(\"%s%s\", existing, included_files);\n    else\n        pcontent = g_strdup_printf(\"%s%s\", warning, included_files);\n\n    plen = strlen(pcontent);\n    if (plen > MAX_FILE_LEN) {\n        vah_error(NULL, 0, _(\"invalid length for new profile\"));\n        goto cleanup;\n    }\n\n    /* only update the disk profile if it is different */\n    if (flen > 0 && flen == plen && STREQLEN(existing, pcontent, plen)) {\n        rc = 0;\n        goto cleanup;\n    }\n\n    /* write the file */\n    if ((fd = open(include_file, O_CREAT | O_TRUNC | O_WRONLY, 0644)) == -1) {\n        vah_error(NULL, 0, _(\"failed to create include file\"));\n        goto cleanup;\n    }\n\n    if (safewrite(fd, pcontent, plen) < 0) { /* don't write the '\\0' */\n        VIR_FORCE_CLOSE(fd);\n        vah_error(NULL, 0, _(\"failed to write to profile\"));\n        goto cleanup;\n    }\n\n    if (VIR_CLOSE(fd) != 0) {\n        vah_error(NULL, 0, _(\"failed to close or write to profile\"));\n        goto cleanup;\n    }\n    rc = 0;\n\n cleanup:\n    VIR_FREE(pcontent);\n    VIR_FREE(existing);\n\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nupdate_include_file(const char *include_file, const char *included_files,\n                    bool append)\n{\n    int rc = -1;\n    int plen, flen = 0;\n    int fd;\n    char *pcontent = NULL;\n    char *existing = NULL;\n    const char *warning =\n         \"# DO NOT EDIT THIS FILE DIRECTLY. IT IS MANAGED BY LIBVIRT.\\n\";\n\n    if (virFileExists(include_file)) {\n        flen = virFileReadAll(include_file, MAX_FILE_LEN, &existing);\n        if (flen < 0)\n            return rc;\n    }\n\n    if (append && virFileExists(include_file))\n        pcontent = g_strdup_printf(\"%s%s\", existing, included_files);\n    else\n        pcontent = g_strdup_printf(\"%s%s\", warning, included_files);\n\n    plen = strlen(pcontent);\n    if (plen > MAX_FILE_LEN) {\n        vah_error(NULL, 0, _(\"invalid length for new profile\"));\n        goto cleanup;\n    }\n\n    /* only update the disk profile if it is different */\n    if (flen > 0 && flen == plen && STREQLEN(existing, pcontent, plen)) {\n        rc = 0;\n        goto cleanup;\n    }\n\n    /* write the file */\n    if ((fd = open(include_file, O_CREAT | O_TRUNC | O_WRONLY, 0644)) == -1) {\n        vah_error(NULL, 0, _(\"failed to create include file\"));\n        goto cleanup;\n    }\n\n    if (safewrite(fd, pcontent, plen) < 0) { /* don't write the '\\0' */\n        VIR_FORCE_CLOSE(fd);\n        vah_error(NULL, 0, _(\"failed to write to profile\"));\n        goto cleanup;\n    }\n\n    if (VIR_CLOSE(fd) != 0) {\n        vah_error(NULL, 0, _(\"failed to close or write to profile\"));\n        goto cleanup;\n    }\n    rc = 0;\n\n cleanup:\n    VIR_FREE(pcontent);\n    VIR_FREE(existing);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "&buf",
            "ctl->files",
            "-1"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"  \\\"%s/libvirt/**/*.tunnelmigrate.dest.%s\\\" rw,\\n\"",
            "RUNSTATEDIR",
            "ctl->def->name"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vah_add_file",
          "args": [
            "&buf",
            "ctl->newfile",
            "\"rwk\""
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "vah_add_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "803-807",
          "snippet": "static int\nvah_add_file(virBufferPtr buf, const char *path, const char *perms)\n{\n    return vah_add_path(buf, path, perms, false);\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvah_add_file(virBufferPtr buf, const char *path, const char *perms)\n{\n    return vah_add_path(buf, path, perms, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "profile"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "profile"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "include_file"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parserRemove",
          "args": [
            "ctl->uuid"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "parserRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "375-379",
          "snippet": "static int\nparserRemove(const char *profile_name)\n{\n    return parserCommand(profile_name, 'R');\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nparserRemove(const char *profile_name)\n{\n    return parserCommand(profile_name, 'R');\n}"
        }
      },
      {
        "call_info": {
          "callee": "vahParseArgv",
          "args": [
            "ctl",
            "argc",
            "argv"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "vahParseArgv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "1345-1431",
          "snippet": "static int\nvahParseArgv(vahControl * ctl, int argc, char **argv)\n{\n    int arg, idx = 0;\n    struct option opt[] = {\n        {\"add\", 0, 0, 'a'},\n        {\"create\", 0, 0, 'c'},\n        {\"dryrun\", 0, 0, 'd'},\n        {\"delete\", 0, 0, 'D'},\n        {\"add-file\", 0, 0, 'f'},\n        {\"append-file\", 0, 0, 'F'},\n        {\"help\", 0, 0, 'h'},\n        {\"replace\", 0, 0, 'r'},\n        {\"remove\", 0, 0, 'R'},\n        {\"uuid\", 1, 0, 'u'},\n        {0, 0, 0, 0}\n    };\n\n    while ((arg = getopt_long(argc, argv, \"acdDhrRH:b:u:p:f:F:\", opt,\n            &idx)) != -1) {\n        switch (arg) {\n            case 'a':\n                ctl->cmd = 'a';\n                break;\n            case 'c':\n                ctl->cmd = 'c';\n                break;\n            case 'd':\n                ctl->dryrun = true;\n                break;\n            case 'D':\n                ctl->cmd = 'D';\n                break;\n            case 'f':\n            case 'F':\n                ctl->newfile = g_strdup(optarg);\n                ctl->append = arg == 'F';\n                break;\n            case 'h':\n                vah_usage();\n                exit(EXIT_SUCCESS);\n                break;\n            case 'r':\n                ctl->cmd = 'r';\n                break;\n            case 'R':\n                ctl->cmd = 'R';\n                break;\n            case 'u':\n                if (strlen(optarg) > PROFILE_NAME_SIZE - 1)\n                    vah_error(ctl, 1, _(\"invalid UUID\"));\n                if (virStrcpy((char *)ctl->uuid, optarg,\n                    PROFILE_NAME_SIZE) < 0)\n                    vah_error(ctl, 1, _(\"error copying UUID\"));\n                break;\n            default:\n                vah_error(ctl, 1, _(\"unsupported option\"));\n                break;\n        }\n    }\n    if (strchr(\"acDrR\", ctl->cmd) == NULL)\n        vah_error(ctl, 1, _(\"bad command\"));\n\n    if (valid_uuid(ctl->uuid) != 0)\n        vah_error(ctl, 1, _(\"invalid UUID\"));\n\n    if (!ctl->cmd) {\n        vah_usage();\n        exit(EXIT_FAILURE);\n    }\n\n    if (ctl->cmd == 'c' || ctl->cmd == 'r') {\n        char *xmlStr = NULL;\n        if (virFileReadLimFD(STDIN_FILENO, MAX_FILE_LEN, &xmlStr) < 0)\n            vah_error(ctl, 1, _(\"could not read xml file\"));\n\n        if (get_definition(ctl, xmlStr) != 0 || ctl->def == NULL) {\n            VIR_FREE(xmlStr);\n            vah_error(ctl, 1, _(\"could not get VM definition\"));\n        }\n        VIR_FREE(xmlStr);\n\n        if (get_files(ctl) != 0)\n            vah_error(ctl, 1, _(\"invalid VM definition\"));\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvahParseArgv(vahControl * ctl, int argc, char **argv)\n{\n    int arg, idx = 0;\n    struct option opt[] = {\n        {\"add\", 0, 0, 'a'},\n        {\"create\", 0, 0, 'c'},\n        {\"dryrun\", 0, 0, 'd'},\n        {\"delete\", 0, 0, 'D'},\n        {\"add-file\", 0, 0, 'f'},\n        {\"append-file\", 0, 0, 'F'},\n        {\"help\", 0, 0, 'h'},\n        {\"replace\", 0, 0, 'r'},\n        {\"remove\", 0, 0, 'R'},\n        {\"uuid\", 1, 0, 'u'},\n        {0, 0, 0, 0}\n    };\n\n    while ((arg = getopt_long(argc, argv, \"acdDhrRH:b:u:p:f:F:\", opt,\n            &idx)) != -1) {\n        switch (arg) {\n            case 'a':\n                ctl->cmd = 'a';\n                break;\n            case 'c':\n                ctl->cmd = 'c';\n                break;\n            case 'd':\n                ctl->dryrun = true;\n                break;\n            case 'D':\n                ctl->cmd = 'D';\n                break;\n            case 'f':\n            case 'F':\n                ctl->newfile = g_strdup(optarg);\n                ctl->append = arg == 'F';\n                break;\n            case 'h':\n                vah_usage();\n                exit(EXIT_SUCCESS);\n                break;\n            case 'r':\n                ctl->cmd = 'r';\n                break;\n            case 'R':\n                ctl->cmd = 'R';\n                break;\n            case 'u':\n                if (strlen(optarg) > PROFILE_NAME_SIZE - 1)\n                    vah_error(ctl, 1, _(\"invalid UUID\"));\n                if (virStrcpy((char *)ctl->uuid, optarg,\n                    PROFILE_NAME_SIZE) < 0)\n                    vah_error(ctl, 1, _(\"error copying UUID\"));\n                break;\n            default:\n                vah_error(ctl, 1, _(\"unsupported option\"));\n                break;\n        }\n    }\n    if (strchr(\"acDrR\", ctl->cmd) == NULL)\n        vah_error(ctl, 1, _(\"bad command\"));\n\n    if (valid_uuid(ctl->uuid) != 0)\n        vah_error(ctl, 1, _(\"invalid UUID\"));\n\n    if (!ctl->cmd) {\n        vah_usage();\n        exit(EXIT_FAILURE);\n    }\n\n    if (ctl->cmd == 'c' || ctl->cmd == 'r') {\n        char *xmlStr = NULL;\n        if (virFileReadLimFD(STDIN_FILENO, MAX_FILE_LEN, &xmlStr) < 0)\n            vah_error(ctl, 1, _(\"could not read xml file\"));\n\n        if (get_definition(ctl, xmlStr) != 0 || ctl->def == NULL) {\n            VIR_FREE(xmlStr);\n            vah_error(ctl, 1, _(\"could not get VM definition\"));\n        }\n        VIR_FREE(xmlStr);\n\n        if (get_files(ctl) != 0)\n            vah_error(ctl, 1, _(\"invalid VM definition\"));\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ctl",
            "0",
            "sizeof(vahControl)"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_setenv",
          "args": [
            "\"IFS\"",
            "\" \\t\\n\"",
            "TRUE"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_setenv",
          "args": [
            "\"PATH\"",
            "\"/sbin:/usr/sbin\"",
            "TRUE"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLogSetFromEnv",
          "args": [],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetFromEnv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1208-1225",
          "snippet": "void\nvirLogSetFromEnv(void)\n{\n    const char *debugEnv;\n\n    if (virLogInitialize() < 0)\n        return;\n\n    debugEnv = getenv(\"LIBVIRT_DEBUG\");\n    if (debugEnv && *debugEnv)\n        virLogSetDefaultPriority(virLogParseDefaultPriority(debugEnv));\n    debugEnv = getenv(\"LIBVIRT_LOG_FILTERS\");\n    if (debugEnv && *debugEnv)\n        virLogSetFilters(debugEnv);\n    debugEnv = getenv(\"LIBVIRT_LOG_OUTPUTS\");\n    if (debugEnv && *debugEnv)\n        virLogSetOutputs(debugEnv);\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirLogSetFromEnv(void)\n{\n    const char *debugEnv;\n\n    if (virLogInitialize() < 0)\n        return;\n\n    debugEnv = getenv(\"LIBVIRT_DEBUG\");\n    if (debugEnv && *debugEnv)\n        virLogSetDefaultPriority(virLogParseDefaultPriority(debugEnv));\n    debugEnv = getenv(\"LIBVIRT_LOG_FILTERS\");\n    if (debugEnv && *debugEnv)\n        virLogSetFilters(debugEnv);\n    debugEnv = getenv(\"LIBVIRT_LOG_OUTPUTS\");\n    if (debugEnv && *debugEnv)\n        virLogSetOutputs(debugEnv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileActivateDirOverrideForProg",
          "args": [
            "argv[0]"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "virFileActivateDirOverrideForProg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1788-1800",
          "snippet": "void\nvirFileActivateDirOverrideForProg(const char *argv0)\n{\n    char *file = strrchr(argv0, '/');\n    if (!file || file[1] == '\\0')\n        return;\n    file++;\n    if (STRPREFIX(file, \"lt-\") ||\n        strstr(argv0, \"/.libs/\")) {\n        useDirOverride = true;\n        VIR_DEBUG(\"Activating build dir override for %s\", argv0);\n    }\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool useDirOverride;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic bool useDirOverride;\n\nvoid\nvirFileActivateDirOverrideForProg(const char *argv0)\n{\n    char *file = strrchr(argv0, '/');\n    if (!file || file[1] == '\\0')\n        return;\n    file++;\n    if (STRPREFIX(file, \"lt-\") ||\n        strstr(argv0, \"/.libs/\")) {\n        useDirOverride = true;\n        VIR_DEBUG(\"Activating build dir override for %s\", argv0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s: initialization failed\\n\")",
            "argv[0]"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorInitialize",
          "args": [],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "172-176",
          "snippet": "int\nvirErrorInitialize(void)\n{\n    return virThreadLocalInit(&virLastErr, virLastErrFreeData);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal virLastErr;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirThreadLocal virLastErr;\n\nint\nvirErrorInitialize(void)\n{\n    return virThreadLocalInit(&virLastErr, virLastErrFreeData);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGettextInitialize",
          "args": [],
          "line": 1450
        },
        "resolved": true,
        "details": {
          "function_name": "virGettextInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virgettext.c",
          "lines": "39-59",
          "snippet": "int\nvirGettextInitialize(void)\n{\n#if HAVE_LIBINTL_H\n    if (!setlocale(LC_ALL, \"\")) {\n        perror(\"setlocale\");\n        /* failure to setup locale is not fatal */\n    }\n\n    if (!bindtextdomain(PACKAGE, LOCALEDIR)) {\n        perror(\"bindtextdomain\");\n        return -1;\n    }\n\n    if (!textdomain(PACKAGE)) {\n        perror(\"textdomain\");\n        return -1;\n    }\n#endif /* HAVE_LIBINTL_H */\n    return 0;\n}",
          "includes": [
            "#include \"virgettext.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virgettext.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <config.h>\n\nint\nvirGettextInitialize(void)\n{\n#if HAVE_LIBINTL_H\n    if (!setlocale(LC_ALL, \"\")) {\n        perror(\"setlocale\");\n        /* failure to setup locale is not fatal */\n    }\n\n    if (!bindtextdomain(PACKAGE, LOCALEDIR)) {\n        perror(\"bindtextdomain\");\n        return -1;\n    }\n\n    if (!textdomain(PACKAGE)) {\n        perror(\"textdomain\");\n        return -1;\n    }\n#endif /* HAVE_LIBINTL_H */\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nint\nmain(int argc, char **argv)\n{\n    vahControl _ctl, *ctl = &_ctl;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    char *profile = NULL;\n    char *include_file = NULL;\n\n    if (virGettextInitialize() < 0 ||\n        virErrorInitialize() < 0) {\n        fprintf(stderr, _(\"%s: initialization failed\\n\"), argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    virFileActivateDirOverrideForProg(argv[0]);\n\n    /* Initialize the log system */\n    virLogSetFromEnv();\n\n    /* clear the environment */\n    environ = NULL;\n    if (g_setenv(\"PATH\", \"/sbin:/usr/sbin\", TRUE) == FALSE)\n        vah_error(ctl, 1, _(\"could not set PATH\"));\n\n    /* ensure the traditional IFS setting */\n    if (g_setenv(\"IFS\", \" \\t\\n\", TRUE) == FALSE)\n        vah_error(ctl, 1, _(\"could not set IFS\"));\n\n    if (!(progname = strrchr(argv[0], '/')))\n        progname = argv[0];\n    else\n        progname++;\n\n    memset(ctl, 0, sizeof(vahControl));\n\n    if (vahParseArgv(ctl, argc, argv) != 0)\n        vah_error(ctl, 1, _(\"could not parse arguments\"));\n\n    profile = g_strdup_printf(\"%s/%s\", APPARMOR_DIR \"/libvirt\", ctl->uuid);\n    include_file = g_strdup_printf(\"%s/%s.files\", APPARMOR_DIR \"/libvirt\", ctl->uuid);\n\n    if (ctl->cmd == 'a') {\n        rc = parserLoad(ctl->uuid);\n    } else if (ctl->cmd == 'R' || ctl->cmd == 'D') {\n        rc = parserRemove(ctl->uuid);\n        if (ctl->cmd == 'D') {\n            unlink(include_file);\n            unlink(profile);\n        }\n    } else if (ctl->cmd == 'c' || ctl->cmd == 'r') {\n        char *included_files = NULL;\n\n        if (ctl->cmd == 'c' && virFileExists(profile))\n            vah_error(ctl, 1, _(\"profile exists\"));\n\n        if (ctl->append && ctl->newfile) {\n            if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n                goto cleanup;\n        } else {\n            if (ctl->def->virtType == VIR_DOMAIN_VIRT_QEMU ||\n                ctl->def->virtType == VIR_DOMAIN_VIRT_KQEMU ||\n                ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n                virBufferAsprintf(&buf, \"  \\\"%s/log/libvirt/**/%s.log\\\" w,\\n\",\n                                  LOCALSTATEDIR, ctl->def->name);\n                virBufferAsprintf(&buf, \"  \\\"%s/lib/libvirt/qemu/domain-%s/monitor.sock\\\" rw,\\n\",\n                                  LOCALSTATEDIR, ctl->def->name);\n                virBufferAsprintf(&buf, \"  \\\"%s/lib/libvirt/qemu/domain-%d-%.*s/*\\\" rw,\\n\",\n                                  LOCALSTATEDIR, ctl->def->id, 20, ctl->def->name);\n                virBufferAsprintf(&buf, \"  \\\"%s/libvirt/**/%s.pid\\\" rwk,\\n\",\n                                  RUNSTATEDIR, ctl->def->name);\n                virBufferAsprintf(&buf, \"  \\\"%s/libvirt/**/*.tunnelmigrate.dest.%s\\\" rw,\\n\",\n                                  RUNSTATEDIR, ctl->def->name);\n            }\n            if (ctl->files)\n                virBufferAdd(&buf, ctl->files, -1);\n        }\n\n        included_files = virBufferContentAndReset(&buf);\n\n        /* (re)create the include file using included_files */\n        if (ctl->dryrun) {\n            vah_info(include_file);\n            vah_info(included_files);\n            rc = 0;\n        } else if (ctl->def->virtType == VIR_DOMAIN_VIRT_LXC) {\n            rc = 0;\n        } else if ((rc = update_include_file(include_file,\n                                             included_files,\n                                             ctl->append)) != 0) {\n            goto cleanup;\n        }\n\n\n        /* create the profile from TEMPLATE */\n        if (ctl->cmd == 'c') {\n            char *tmp = NULL;\n            tmp = g_strdup_printf(\"  #include <libvirt/%s.files>\\n\", ctl->uuid);\n\n            if (ctl->dryrun) {\n                vah_info(profile);\n                vah_info(ctl->uuid);\n                vah_info(tmp);\n                rc = 0;\n            } else if ((rc = create_profile(profile, ctl->uuid, tmp,\n                                            ctl->def->virtType)) != 0) {\n                vah_error(ctl, 0, _(\"could not create profile\"));\n                unlink(include_file);\n            }\n            VIR_FREE(tmp);\n        }\n\n        if (rc == 0 && !ctl->dryrun) {\n            if (ctl->cmd == 'c')\n                rc = parserLoad(ctl->uuid);\n            else\n                rc = parserReplace(ctl->uuid);\n\n            /* cleanup */\n            if (rc != 0) {\n                unlink(include_file);\n                if (ctl->cmd == 'c')\n                    unlink(profile);\n            }\n        }\n      cleanup:\n        VIR_FREE(included_files);\n    }\n\n    vahDeinit(ctl);\n\n    VIR_FREE(profile);\n    VIR_FREE(include_file);\n\n    exit(rc == 0 ? EXIT_SUCCESS : EXIT_FAILURE);\n}"
  },
  {
    "function_name": "vahParseArgv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "1345-1431",
    "snippet": "static int\nvahParseArgv(vahControl * ctl, int argc, char **argv)\n{\n    int arg, idx = 0;\n    struct option opt[] = {\n        {\"add\", 0, 0, 'a'},\n        {\"create\", 0, 0, 'c'},\n        {\"dryrun\", 0, 0, 'd'},\n        {\"delete\", 0, 0, 'D'},\n        {\"add-file\", 0, 0, 'f'},\n        {\"append-file\", 0, 0, 'F'},\n        {\"help\", 0, 0, 'h'},\n        {\"replace\", 0, 0, 'r'},\n        {\"remove\", 0, 0, 'R'},\n        {\"uuid\", 1, 0, 'u'},\n        {0, 0, 0, 0}\n    };\n\n    while ((arg = getopt_long(argc, argv, \"acdDhrRH:b:u:p:f:F:\", opt,\n            &idx)) != -1) {\n        switch (arg) {\n            case 'a':\n                ctl->cmd = 'a';\n                break;\n            case 'c':\n                ctl->cmd = 'c';\n                break;\n            case 'd':\n                ctl->dryrun = true;\n                break;\n            case 'D':\n                ctl->cmd = 'D';\n                break;\n            case 'f':\n            case 'F':\n                ctl->newfile = g_strdup(optarg);\n                ctl->append = arg == 'F';\n                break;\n            case 'h':\n                vah_usage();\n                exit(EXIT_SUCCESS);\n                break;\n            case 'r':\n                ctl->cmd = 'r';\n                break;\n            case 'R':\n                ctl->cmd = 'R';\n                break;\n            case 'u':\n                if (strlen(optarg) > PROFILE_NAME_SIZE - 1)\n                    vah_error(ctl, 1, _(\"invalid UUID\"));\n                if (virStrcpy((char *)ctl->uuid, optarg,\n                    PROFILE_NAME_SIZE) < 0)\n                    vah_error(ctl, 1, _(\"error copying UUID\"));\n                break;\n            default:\n                vah_error(ctl, 1, _(\"unsupported option\"));\n                break;\n        }\n    }\n    if (strchr(\"acDrR\", ctl->cmd) == NULL)\n        vah_error(ctl, 1, _(\"bad command\"));\n\n    if (valid_uuid(ctl->uuid) != 0)\n        vah_error(ctl, 1, _(\"invalid UUID\"));\n\n    if (!ctl->cmd) {\n        vah_usage();\n        exit(EXIT_FAILURE);\n    }\n\n    if (ctl->cmd == 'c' || ctl->cmd == 'r') {\n        char *xmlStr = NULL;\n        if (virFileReadLimFD(STDIN_FILENO, MAX_FILE_LEN, &xmlStr) < 0)\n            vah_error(ctl, 1, _(\"could not read xml file\"));\n\n        if (get_definition(ctl, xmlStr) != 0 || ctl->def == NULL) {\n            VIR_FREE(xmlStr);\n            vah_error(ctl, 1, _(\"could not get VM definition\"));\n        }\n        VIR_FREE(xmlStr);\n\n        if (get_files(ctl) != 0)\n            vah_error(ctl, 1, _(\"invalid VM definition\"));\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vah_error",
          "args": [
            "ctl",
            "1",
            "_(\"invalid VM definition\")"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "vah_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "119-129",
          "snippet": "static void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid VM definition\""
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xmlStr"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xmlStr"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_definition",
          "args": [
            "ctl",
            "xmlStr"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "get_definition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "622-698",
          "snippet": "static int\nget_definition(vahControl * ctl, const char *xmlStr)\n{\n    int ostype, virtType;\n    virCapsGuestPtr guest;  /* this is freed when caps is freed */\n\n    /*\n     * mock up some capabilities. We don't currently use these explicitly,\n     * but need them for virDomainDefParseString().\n     */\n    if (caps_mockup(ctl, xmlStr) != 0)\n        return -1;\n\n    if ((ctl->caps = virCapabilitiesNew(ctl->arch, true, true)) == NULL) {\n        vah_error(ctl, 0, _(\"could not allocate memory\"));\n        return -1;\n    }\n\n    if (!(ctl->xmlopt = virDomainXMLOptionNew(&virAAHelperDomainDefParserConfig,\n                                              NULL, NULL, NULL, NULL))) {\n        vah_error(ctl, 0, _(\"Failed to create XML config object\"));\n        return -1;\n    }\n\n    if ((ostype = virDomainOSTypeFromString(ctl->os)) < 0) {\n        vah_error(ctl, 0, _(\"unknown OS type\"));\n        return -1;\n    }\n\n    if ((guest = virCapabilitiesAddGuest(ctl->caps,\n                                         ostype,\n                                         ctl->arch,\n                                         NULL,\n                                         NULL,\n                                         0,\n                                         NULL)) == NULL) {\n        vah_error(ctl, 0, _(\"could not allocate memory\"));\n        return -1;\n    }\n\n    if ((virtType = virDomainVirtTypeFromString(ctl->virtType)) < 0) {\n        vah_error(ctl, 0, _(\"unknown virtualization type\"));\n        return -1;\n    }\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      virtType,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL) {\n        vah_error(ctl, 0, _(\"could not allocate memory\"));\n        return -1;\n    }\n\n    ctl->def = virDomainDefParseString(xmlStr,\n                                       ctl->xmlopt, NULL,\n                                       VIR_DOMAIN_DEF_PARSE_SKIP_SECLABEL |\n                                       VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n\n    if (ctl->def == NULL) {\n        vah_error(ctl, 0, _(\"could not parse XML\"));\n        return -1;\n    }\n\n    if (!ctl->def->name) {\n        vah_error(ctl, 0, _(\"could not find name in XML\"));\n        return -1;\n    }\n\n    if (valid_name(ctl->def->name) != 0) {\n        vah_error(ctl, 0, _(\"bad name\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virDomainDefParserConfig virAAHelperDomainDefParserConfig = {\n    .features = VIR_DOMAIN_DEF_FEATURE_MEMORY_HOTPLUG |\n                VIR_DOMAIN_DEF_FEATURE_OFFLINE_VCPUPIN |\n                VIR_DOMAIN_DEF_FEATURE_INDIVIDUAL_VCPUS |\n                VIR_DOMAIN_DEF_FEATURE_NET_MODEL_STRING,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvirDomainDefParserConfig virAAHelperDomainDefParserConfig = {\n    .features = VIR_DOMAIN_DEF_FEATURE_MEMORY_HOTPLUG |\n                VIR_DOMAIN_DEF_FEATURE_OFFLINE_VCPUPIN |\n                VIR_DOMAIN_DEF_FEATURE_INDIVIDUAL_VCPUS |\n                VIR_DOMAIN_DEF_FEATURE_NET_MODEL_STRING,\n};\n\nstatic int\nget_definition(vahControl * ctl, const char *xmlStr)\n{\n    int ostype, virtType;\n    virCapsGuestPtr guest;  /* this is freed when caps is freed */\n\n    /*\n     * mock up some capabilities. We don't currently use these explicitly,\n     * but need them for virDomainDefParseString().\n     */\n    if (caps_mockup(ctl, xmlStr) != 0)\n        return -1;\n\n    if ((ctl->caps = virCapabilitiesNew(ctl->arch, true, true)) == NULL) {\n        vah_error(ctl, 0, _(\"could not allocate memory\"));\n        return -1;\n    }\n\n    if (!(ctl->xmlopt = virDomainXMLOptionNew(&virAAHelperDomainDefParserConfig,\n                                              NULL, NULL, NULL, NULL))) {\n        vah_error(ctl, 0, _(\"Failed to create XML config object\"));\n        return -1;\n    }\n\n    if ((ostype = virDomainOSTypeFromString(ctl->os)) < 0) {\n        vah_error(ctl, 0, _(\"unknown OS type\"));\n        return -1;\n    }\n\n    if ((guest = virCapabilitiesAddGuest(ctl->caps,\n                                         ostype,\n                                         ctl->arch,\n                                         NULL,\n                                         NULL,\n                                         0,\n                                         NULL)) == NULL) {\n        vah_error(ctl, 0, _(\"could not allocate memory\"));\n        return -1;\n    }\n\n    if ((virtType = virDomainVirtTypeFromString(ctl->virtType)) < 0) {\n        vah_error(ctl, 0, _(\"unknown virtualization type\"));\n        return -1;\n    }\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      virtType,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL) {\n        vah_error(ctl, 0, _(\"could not allocate memory\"));\n        return -1;\n    }\n\n    ctl->def = virDomainDefParseString(xmlStr,\n                                       ctl->xmlopt, NULL,\n                                       VIR_DOMAIN_DEF_PARSE_SKIP_SECLABEL |\n                                       VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n\n    if (ctl->def == NULL) {\n        vah_error(ctl, 0, _(\"could not parse XML\"));\n        return -1;\n    }\n\n    if (!ctl->def->name) {\n        vah_error(ctl, 0, _(\"could not find name in XML\"));\n        return -1;\n    }\n\n    if (valid_name(ctl->def->name) != 0) {\n        vah_error(ctl, 0, _(\"bad name\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadLimFD",
          "args": [
            "STDIN_FILENO",
            "MAX_FILE_LEN",
            "&xmlStr"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadLimFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1416-1438",
          "snippet": "int\nvirFileReadLimFD(int fd, int maxlen, char **buf)\n{\n    size_t len;\n    char *s;\n\n    if (maxlen <= 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    s = saferead_lim(fd, maxlen+1, &len);\n    if (s == NULL)\n        return -1;\n    if (len > maxlen || (int)len != len) {\n        VIR_FREE(s);\n        /* There was at least one byte more than MAXLEN.\n           Set errno accordingly. */\n        errno = EOVERFLOW;\n        return -1;\n    }\n    *buf = s;\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadLimFD(int fd, int maxlen, char **buf)\n{\n    size_t len;\n    char *s;\n\n    if (maxlen <= 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    s = saferead_lim(fd, maxlen+1, &len);\n    if (s == NULL)\n        return -1;\n    if (len > maxlen || (int)len != len) {\n        VIR_FREE(s);\n        /* There was at least one byte more than MAXLEN.\n           Set errno accordingly. */\n        errno = EOVERFLOW;\n        return -1;\n    }\n    *buf = s;\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vah_usage",
          "args": [],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "vah_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "95-117",
          "snippet": "static void\nvah_usage(void)\n{\n    printf(_(\"\\n%s mode [options] [extra file] [< def.xml]\\n\\n\"\n            \"  Modes:\\n\"\n            \"    -a | --add                     load profile\\n\"\n            \"    -c | --create                  create profile from template\\n\"\n            \"    -D | --delete                  unload and delete profile\\n\"\n            \"    -r | --replace                 reload profile\\n\"\n            \"    -R | --remove                  unload profile\\n\"\n            \"  Options:\\n\"\n            \"    -d | --dryrun                  dry run\\n\"\n            \"    -u | --uuid <uuid>             uuid (profile name)\\n\"\n            \"    -h | --help                    this help\\n\"\n            \"  Extra File:\\n\"\n            \"    -f | --add-file <file>         add file to a profile generated from XML\\n\"\n            \"    -F | --append-file <file>      append file to an existing profile\\n\"\n            \"\\n\"), progname);\n\n    puts(_(\"This command is intended to be used by libvirtd \"\n           \"and not used directly.\\n\"));\n    return;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_usage(void)\n{\n    printf(_(\"\\n%s mode [options] [extra file] [< def.xml]\\n\\n\"\n            \"  Modes:\\n\"\n            \"    -a | --add                     load profile\\n\"\n            \"    -c | --create                  create profile from template\\n\"\n            \"    -D | --delete                  unload and delete profile\\n\"\n            \"    -r | --replace                 reload profile\\n\"\n            \"    -R | --remove                  unload profile\\n\"\n            \"  Options:\\n\"\n            \"    -d | --dryrun                  dry run\\n\"\n            \"    -u | --uuid <uuid>             uuid (profile name)\\n\"\n            \"    -h | --help                    this help\\n\"\n            \"  Extra File:\\n\"\n            \"    -f | --add-file <file>         add file to a profile generated from XML\\n\"\n            \"    -F | --append-file <file>      append file to an existing profile\\n\"\n            \"\\n\"), progname);\n\n    puts(_(\"This command is intended to be used by libvirtd \"\n           \"and not used directly.\\n\"));\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_uuid",
          "args": [
            "ctl->uuid"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "valid_uuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "390-405",
          "snippet": "static int\nvalid_uuid(const char *uuid)\n{\n    unsigned char rawuuid[VIR_UUID_BUFLEN];\n\n    if (strlen(uuid) != PROFILE_NAME_SIZE - 1)\n        return -1;\n\n    if (!STRPREFIX(uuid, AA_PREFIX))\n        return -1;\n\n    if (virUUIDParse(uuid + strlen(AA_PREFIX), rawuuid) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvalid_uuid(const char *uuid)\n{\n    unsigned char rawuuid[VIR_UUID_BUFLEN];\n\n    if (strlen(uuid) != PROFILE_NAME_SIZE - 1)\n        return -1;\n\n    if (!STRPREFIX(uuid, AA_PREFIX))\n        return -1;\n\n    if (virUUIDParse(uuid + strlen(AA_PREFIX), rawuuid) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "\"acDrR\"",
            "ctl->cmd"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpy",
          "args": [
            "(char *)ctl->uuid",
            "optarg",
            "PROFILE_NAME_SIZE"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "virStrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "780-784",
          "snippet": "int\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "optarg"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_SUCCESS"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "optarg"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getopt_long",
          "args": [
            "argc",
            "argv",
            "\"acdDhrRH:b:u:p:f:F:\"",
            "opt",
            "&idx"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvahParseArgv(vahControl * ctl, int argc, char **argv)\n{\n    int arg, idx = 0;\n    struct option opt[] = {\n        {\"add\", 0, 0, 'a'},\n        {\"create\", 0, 0, 'c'},\n        {\"dryrun\", 0, 0, 'd'},\n        {\"delete\", 0, 0, 'D'},\n        {\"add-file\", 0, 0, 'f'},\n        {\"append-file\", 0, 0, 'F'},\n        {\"help\", 0, 0, 'h'},\n        {\"replace\", 0, 0, 'r'},\n        {\"remove\", 0, 0, 'R'},\n        {\"uuid\", 1, 0, 'u'},\n        {0, 0, 0, 0}\n    };\n\n    while ((arg = getopt_long(argc, argv, \"acdDhrRH:b:u:p:f:F:\", opt,\n            &idx)) != -1) {\n        switch (arg) {\n            case 'a':\n                ctl->cmd = 'a';\n                break;\n            case 'c':\n                ctl->cmd = 'c';\n                break;\n            case 'd':\n                ctl->dryrun = true;\n                break;\n            case 'D':\n                ctl->cmd = 'D';\n                break;\n            case 'f':\n            case 'F':\n                ctl->newfile = g_strdup(optarg);\n                ctl->append = arg == 'F';\n                break;\n            case 'h':\n                vah_usage();\n                exit(EXIT_SUCCESS);\n                break;\n            case 'r':\n                ctl->cmd = 'r';\n                break;\n            case 'R':\n                ctl->cmd = 'R';\n                break;\n            case 'u':\n                if (strlen(optarg) > PROFILE_NAME_SIZE - 1)\n                    vah_error(ctl, 1, _(\"invalid UUID\"));\n                if (virStrcpy((char *)ctl->uuid, optarg,\n                    PROFILE_NAME_SIZE) < 0)\n                    vah_error(ctl, 1, _(\"error copying UUID\"));\n                break;\n            default:\n                vah_error(ctl, 1, _(\"unsupported option\"));\n                break;\n        }\n    }\n    if (strchr(\"acDrR\", ctl->cmd) == NULL)\n        vah_error(ctl, 1, _(\"bad command\"));\n\n    if (valid_uuid(ctl->uuid) != 0)\n        vah_error(ctl, 1, _(\"invalid UUID\"));\n\n    if (!ctl->cmd) {\n        vah_usage();\n        exit(EXIT_FAILURE);\n    }\n\n    if (ctl->cmd == 'c' || ctl->cmd == 'r') {\n        char *xmlStr = NULL;\n        if (virFileReadLimFD(STDIN_FILENO, MAX_FILE_LEN, &xmlStr) < 0)\n            vah_error(ctl, 1, _(\"could not read xml file\"));\n\n        if (get_definition(ctl, xmlStr) != 0 || ctl->def == NULL) {\n            VIR_FREE(xmlStr);\n            vah_error(ctl, 1, _(\"could not get VM definition\"));\n        }\n        VIR_FREE(xmlStr);\n\n        if (get_files(ctl) != 0)\n            vah_error(ctl, 1, _(\"invalid VM definition\"));\n    }\n    return 0;\n}"
  },
  {
    "function_name": "get_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "911-1343",
    "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mem_path"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vah_add_file",
          "args": [
            "&buf",
            "ctl->newfile",
            "\"rwk\""
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "vah_add_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "803-807",
          "snippet": "static int\nvah_add_file(virBufferPtr buf, const char *path, const char *perms)\n{\n    return vah_add_path(buf, path, perms, false);\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvah_add_file(virBufferPtr buf, const char *path, const char *perms)\n{\n    return vah_add_path(buf, path, perms, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\""
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\""
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\""
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/dev/dri/\\\" r,\\n\""
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  # Probe DRI device attributes\\n\""
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/dev/nvidiactl\\\" rw,\\n\""
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/proc/driver/nvidia/params\\\" r,\\n\""
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/proc/modules\\\" r,\\n\""
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\""
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\""
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\""
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\""
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\""
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/etc/drirc\\\" r,\\n\""
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\""
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\""
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\""
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  # DRI/Mesa/(e)GL config and driver paths\\n\""
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\""
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/dev/vfio/vfio\\\" rw,\\n\""
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/dev/vhost-net\\\" rw,\\n\""
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetIsVirtioModel",
          "args": [
            "net"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetIsVirtioModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30344-30350",
          "snippet": "bool\nvirDomainNetIsVirtioModel(const virDomainNetDef *net)\n{\n    return (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO ||\n            net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_TRANSITIONAL ||\n            net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_NON_TRANSITIONAL);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainNetIsVirtioModel(const virDomainNetDef *net)\n{\n    return (net->model == VIR_DOMAIN_NET_MODEL_VIRTIO ||\n            net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_TRANSITIONAL ||\n            net->model == VIR_DOMAIN_NET_MODEL_VIRTIO_NON_TRANSITIONAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetModelString",
          "args": [
            "net"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetModelString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30308-30314",
          "snippet": "const char *\nvirDomainNetGetModelString(const virDomainNetDef *net)\n{\n    if (net->model)\n        return virDomainNetModelTypeToString(net->model);\n    return net->modelstr;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainNetGetModelString(const virDomainNetDef *net)\n{\n    if (net->model)\n        return virDomainNetModelTypeToString(net->model);\n    return net->modelstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"  \\\"%s/{,*}\\\" rk,\\n\"",
            "sc_db"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\""
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "shortName"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetShortName",
          "args": [
            "ctl->def"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetShortName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30900-30952",
          "snippet": "char *\nvirDomainDefGetShortName(const virDomainDef *def)\n{\n    wchar_t wshortname[VIR_DOMAIN_SHORT_NAME_MAX + 1] = {0};\n    size_t len = 0;\n    char *ret = NULL;\n    g_autofree char *shortname = NULL;\n\n    /* No need to do the whole conversion thing when there are no multibyte\n     * characters.  The same applies for illegal sequences as they can occur\n     * with incompatible locales. */\n    len = mbstowcs(NULL, def->name, 0);\n    if ((len == (size_t) -1 && errno == EILSEQ) ||\n        len == strlen(def->name)) {\n        ret = g_strdup_printf(\"%d-%.*s\", def->id, VIR_DOMAIN_SHORT_NAME_MAX, def->name);\n        return ret;\n    }\n\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    if (mbstowcs(wshortname, def->name, VIR_DOMAIN_SHORT_NAME_MAX) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    len = wcstombs(NULL, wshortname, 0);\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(shortname, len + 1) < 0)\n        return NULL;\n\n    if (wcstombs(shortname, wshortname, len) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%d-%s\", def->id, shortname);\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_SHORT_NAME_MAX 20"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_SHORT_NAME_MAX 20\n\nchar *\nvirDomainDefGetShortName(const virDomainDef *def)\n{\n    wchar_t wshortname[VIR_DOMAIN_SHORT_NAME_MAX + 1] = {0};\n    size_t len = 0;\n    char *ret = NULL;\n    g_autofree char *shortname = NULL;\n\n    /* No need to do the whole conversion thing when there are no multibyte\n     * characters.  The same applies for illegal sequences as they can occur\n     * with incompatible locales. */\n    len = mbstowcs(NULL, def->name, 0);\n    if ((len == (size_t) -1 && errno == EILSEQ) ||\n        len == strlen(def->name)) {\n        ret = g_strdup_printf(\"%d-%.*s\", def->id, VIR_DOMAIN_SHORT_NAME_MAX, def->name);\n        return ret;\n    }\n\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    if (mbstowcs(wshortname, def->name, VIR_DOMAIN_SHORT_NAME_MAX) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert domain name to \"\n                               \"wide character string\"));\n        return NULL;\n    }\n\n    len = wcstombs(NULL, wshortname, 0);\n    if (len == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    if (VIR_ALLOC_N(shortname, len + 1) < 0)\n        return NULL;\n\n    if (wcstombs(shortname, wshortname, len) == (size_t) -1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Cannot convert wide character string \"\n                               \"back to multi-byte domain name\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%d-%s\", def->id, shortname);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/var/lib/libvirt/shmem-%s-sock\"",
            "shmem->name"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vah_add_file_chardev",
          "args": [
            "&buf",
            "vhu->data.nix.path",
            "\"rw\"",
            "vhu->type"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "vah_add_file_chardev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "809-845",
          "snippet": "static int\nvah_add_file_chardev(virBufferPtr buf,\n                     const char *path,\n                     const char *perms,\n                     const int type)\n{\n    char *pipe_in;\n    char *pipe_out;\n    int rc = -1;\n\n    if (type == VIR_DOMAIN_CHR_TYPE_PIPE) {\n        /* add the pipe input */\n        pipe_in = g_strdup_printf(\"%s.in\", path);\n\n        if (vah_add_file(buf, pipe_in, perms) != 0)\n            goto clean_pipe_in;\n\n        /* add the pipe output */\n        pipe_out = g_strdup_printf(\"%s.out\", path);\n\n        if (vah_add_file(buf, pipe_out, perms) != 0)\n            goto clean_pipe_out;\n\n        rc = 0;\n      clean_pipe_out:\n        VIR_FREE(pipe_out);\n      clean_pipe_in:\n        VIR_FREE(pipe_in);\n    } else {\n        /* add the file */\n        if (vah_add_file(buf, path, perms) != 0)\n            return -1;\n        rc = 0;\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvah_add_file_chardev(virBufferPtr buf,\n                     const char *path,\n                     const char *perms,\n                     const int type)\n{\n    char *pipe_in;\n    char *pipe_out;\n    int rc = -1;\n\n    if (type == VIR_DOMAIN_CHR_TYPE_PIPE) {\n        /* add the pipe input */\n        pipe_in = g_strdup_printf(\"%s.in\", path);\n\n        if (vah_add_file(buf, pipe_in, perms) != 0)\n            goto clean_pipe_in;\n\n        /* add the pipe output */\n        pipe_out = g_strdup_printf(\"%s.out\", path);\n\n        if (vah_add_file(buf, pipe_out, perms) != 0)\n            goto clean_pipe_out;\n\n        rc = 0;\n      clean_pipe_out:\n        VIR_FREE(pipe_out);\n      clean_pipe_in:\n        VIR_FREE(pipe_in);\n    } else {\n        /* add the file */\n        if (vah_add_file(buf, path, perms) != 0)\n            return -1;\n        rc = 0;\n    }\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vah_add_path",
          "args": [
            "&buf",
            "fs->src->path",
            "fs->readonly ? \"R\" : \"rw\"",
            "true"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "vah_add_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "704-801",
          "snippet": "static int\nvah_add_path(virBufferPtr buf, const char *path, const char *perms, bool recursive)\n{\n    char *tmp = NULL;\n    int rc = -1;\n    bool readonly = true;\n    bool explicit_deny_rule = true;\n    char *sub = NULL;\n    char *perms_new = NULL;\n    char *pathdir = NULL;\n    char *pathtmp = NULL;\n    char *pathreal = NULL;\n\n    if (path == NULL)\n        return rc;\n\n    /* Skip files without an absolute path. Not having one confuses the\n     * apparmor parser and this also ensures things like tcp consoles don't\n     * get added to the profile.\n     */\n    if (STRNEQLEN(path, \"/\", 1)) {\n        vah_warning(path);\n        vah_warning(_(\"skipped non-absolute path\"));\n        return 0;\n    }\n\n    /* files might be created by qemu later on and not exist right now.\n     * But realpath needs a valid path to work on, therefore:\n     * 1. walk the path to find longest valid path\n     * 2. get the realpath of that valid path\n     * 3. re-combine the realpath with the remaining suffix\n     * Note: A totally non existent path is used as-is\n     */\n     pathdir = g_strdup(path);\n     while (!virFileExists(pathdir)) {\n         pathtmp = g_path_get_dirname(pathdir);\n         VIR_FREE(pathdir);\n         pathdir = g_steal_pointer(&pathtmp);\n     }\n\n    if (strlen(pathdir) == 1) {\n        /* nothing of the path does exist yet */\n        tmp = g_strdup(path);\n    } else {\n        pathtmp = g_strdup(path + strlen(pathdir));\n        if ((pathreal = realpath(pathdir, NULL)) == NULL) {\n            vah_error(NULL, 0, pathdir);\n            vah_error(NULL, 0, _(\"could not find realpath\"));\n            goto cleanup;\n        }\n        tmp = g_strdup_printf(\"%s%s\", pathreal, pathtmp);\n    }\n\n    perms_new = g_strdup(perms);\n\n    if (strchr(perms_new, 'w') != NULL) {\n        readonly = false;\n        explicit_deny_rule = false;\n    }\n\n    if ((sub = strchr(perms_new, 'R')) != NULL) {\n        /* Don't write the invalid R permission, replace it with 'r' */\n        sub[0] = 'r';\n        explicit_deny_rule = false;\n    }\n\n    rc = valid_path(tmp, readonly);\n    if (rc != 0) {\n        if (rc > 0) {\n            vah_error(NULL, 0, path);\n            vah_error(NULL, 0, _(\"skipped restricted file\"));\n        }\n        goto cleanup;\n    }\n\n    if (tmp[strlen(tmp) - 1] == '/')\n        tmp[strlen(tmp) - 1] = '\\0';\n\n    virBufferAsprintf(buf, \"  \\\"%s%s\\\" %s,\\n\", tmp, recursive ? \"/**\" : \"\",\n                      perms_new);\n    if (explicit_deny_rule) {\n        virBufferAddLit(buf, \"  # don't audit writes to readonly files\\n\");\n        virBufferAsprintf(buf, \"  deny \\\"%s%s\\\" w,\\n\", tmp, recursive ? \"/**\" : \"\");\n    }\n    if (recursive) {\n        /* allow reading (but not creating) the dir */\n        virBufferAsprintf(buf, \"  \\\"%s/\\\" r,\\n\", tmp);\n    }\n\n cleanup:\n    VIR_FREE(pathdir);\n    VIR_FREE(pathtmp);\n    VIR_FREE(pathreal);\n    VIR_FREE(perms_new);\n    VIR_FREE(tmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvah_add_path(virBufferPtr buf, const char *path, const char *perms, bool recursive)\n{\n    char *tmp = NULL;\n    int rc = -1;\n    bool readonly = true;\n    bool explicit_deny_rule = true;\n    char *sub = NULL;\n    char *perms_new = NULL;\n    char *pathdir = NULL;\n    char *pathtmp = NULL;\n    char *pathreal = NULL;\n\n    if (path == NULL)\n        return rc;\n\n    /* Skip files without an absolute path. Not having one confuses the\n     * apparmor parser and this also ensures things like tcp consoles don't\n     * get added to the profile.\n     */\n    if (STRNEQLEN(path, \"/\", 1)) {\n        vah_warning(path);\n        vah_warning(_(\"skipped non-absolute path\"));\n        return 0;\n    }\n\n    /* files might be created by qemu later on and not exist right now.\n     * But realpath needs a valid path to work on, therefore:\n     * 1. walk the path to find longest valid path\n     * 2. get the realpath of that valid path\n     * 3. re-combine the realpath with the remaining suffix\n     * Note: A totally non existent path is used as-is\n     */\n     pathdir = g_strdup(path);\n     while (!virFileExists(pathdir)) {\n         pathtmp = g_path_get_dirname(pathdir);\n         VIR_FREE(pathdir);\n         pathdir = g_steal_pointer(&pathtmp);\n     }\n\n    if (strlen(pathdir) == 1) {\n        /* nothing of the path does exist yet */\n        tmp = g_strdup(path);\n    } else {\n        pathtmp = g_strdup(path + strlen(pathdir));\n        if ((pathreal = realpath(pathdir, NULL)) == NULL) {\n            vah_error(NULL, 0, pathdir);\n            vah_error(NULL, 0, _(\"could not find realpath\"));\n            goto cleanup;\n        }\n        tmp = g_strdup_printf(\"%s%s\", pathreal, pathtmp);\n    }\n\n    perms_new = g_strdup(perms);\n\n    if (strchr(perms_new, 'w') != NULL) {\n        readonly = false;\n        explicit_deny_rule = false;\n    }\n\n    if ((sub = strchr(perms_new, 'R')) != NULL) {\n        /* Don't write the invalid R permission, replace it with 'r' */\n        sub[0] = 'r';\n        explicit_deny_rule = false;\n    }\n\n    rc = valid_path(tmp, readonly);\n    if (rc != 0) {\n        if (rc > 0) {\n            vah_error(NULL, 0, path);\n            vah_error(NULL, 0, _(\"skipped restricted file\"));\n        }\n        goto cleanup;\n    }\n\n    if (tmp[strlen(tmp) - 1] == '/')\n        tmp[strlen(tmp) - 1] = '\\0';\n\n    virBufferAsprintf(buf, \"  \\\"%s%s\\\" %s,\\n\", tmp, recursive ? \"/**\" : \"\",\n                      perms_new);\n    if (explicit_deny_rule) {\n        virBufferAddLit(buf, \"  # don't audit writes to readonly files\\n\");\n        virBufferAsprintf(buf, \"  deny \\\"%s%s\\\" w,\\n\", tmp, recursive ? \"/**\" : \"\");\n    }\n    if (recursive) {\n        /* allow reading (but not creating) the dir */\n        virBufferAsprintf(buf, \"  \\\"%s/\\\" r,\\n\", tmp);\n    }\n\n cleanup:\n    VIR_FREE(pathdir);\n    VIR_FREE(pathtmp);\n    VIR_FREE(pathreal);\n    VIR_FREE(perms_new);\n    VIR_FREE(tmp);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFree",
          "args": [
            "pci"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1439-1450",
          "snippet": "void\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFileIterate",
          "args": [
            "pci",
            "file_iterate_pci_cb",
            "&buf"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1720-1762",
          "snippet": "int virPCIDeviceFileIterate(virPCIDevicePtr dev,\n                            virPCIDeviceFileActor actor,\n                            void *opaque)\n{\n    g_autofree char *pcidir = NULL;\n    DIR *dir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    pcidir = g_strdup_printf(\"/sys/bus/pci/devices/\" VIR_PCI_DEVICE_ADDRESS_FMT,\n                             dev->address.domain, dev->address.bus, dev->address.slot,\n                             dev->address.function);\n\n    if (virDirOpen(&dir, pcidir) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(dir, &ent, pcidir)) > 0) {\n        g_autofree char *file = NULL;\n        /* Device assignment requires:\n         *   $PCIDIR/config, $PCIDIR/resource, $PCIDIR/resourceNNN,\n         *   $PCIDIR/rom, $PCIDIR/reset, $PCIDIR/vendor, $PCIDIR/device\n         */\n        if (STREQ(ent->d_name, \"config\") ||\n            STRPREFIX(ent->d_name, \"resource\") ||\n            STREQ(ent->d_name, \"rom\") ||\n            STREQ(ent->d_name, \"vendor\") ||\n            STREQ(ent->d_name, \"device\") ||\n            STREQ(ent->d_name, \"reset\")) {\n            file = g_strdup_printf(\"%s/%s\", pcidir, ent->d_name);\n            if ((actor)(dev, file, opaque) < 0)\n                goto cleanup;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint virPCIDeviceFileIterate(virPCIDevicePtr dev,\n                            virPCIDeviceFileActor actor,\n                            void *opaque)\n{\n    g_autofree char *pcidir = NULL;\n    DIR *dir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    pcidir = g_strdup_printf(\"/sys/bus/pci/devices/\" VIR_PCI_DEVICE_ADDRESS_FMT,\n                             dev->address.domain, dev->address.bus, dev->address.slot,\n                             dev->address.function);\n\n    if (virDirOpen(&dir, pcidir) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(dir, &ent, pcidir)) > 0) {\n        g_autofree char *file = NULL;\n        /* Device assignment requires:\n         *   $PCIDIR/config, $PCIDIR/resource, $PCIDIR/resourceNNN,\n         *   $PCIDIR/rom, $PCIDIR/reset, $PCIDIR/vendor, $PCIDIR/device\n         */\n        if (STREQ(ent->d_name, \"config\") ||\n            STRPREFIX(ent->d_name, \"resource\") ||\n            STREQ(ent->d_name, \"rom\") ||\n            STREQ(ent->d_name, \"vendor\") ||\n            STREQ(ent->d_name, \"device\") ||\n            STREQ(ent->d_name, \"reset\")) {\n            file = g_strdup_printf(\"%s/%s\", pcidir, ent->d_name);\n            if ((actor)(dev, file, opaque) < 0)\n                goto cleanup;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceNew",
          "args": [
            "dev->source.subsys.u.pci.addr.domain",
            "dev->source.subsys.u.pci.addr.bus",
            "dev->source.subsys.u.pci.addr.slot",
            "dev->source.subsys.u.pci.addr.function"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1364-1416",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nvirPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virMediatedDeviceModelType",
            "mdevsrc->model"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUSBDeviceFree",
          "args": [
            "usb"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "353-363",
          "snippet": "void\nvirUSBDeviceFree(virUSBDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirUSBDeviceFree(virUSBDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceFileIterate",
          "args": [
            "usb",
            "file_iterate_hostdev_cb",
            "&buf"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceFileIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "409-414",
          "snippet": "int virUSBDeviceFileIterate(virUSBDevicePtr dev,\n                            virUSBDeviceFileActor actor,\n                            void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint virUSBDeviceFileIterate(virUSBDevicePtr dev,\n                            virUSBDeviceFileActor actor,\n                            void *opaque)\n{\n    return (actor)(dev, dev->path, opaque);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevFindUSBDevice",
          "args": [
            "dev",
            "true",
            "&usb"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevFindUSBDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1356-1437",
          "snippet": "int\nvirHostdevFindUSBDevice(virDomainHostdevDefPtr hostdev,\n                        bool mandatory,\n                        virUSBDevicePtr *usb)\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n    unsigned vendor = usbsrc->vendor;\n    unsigned product = usbsrc->product;\n    unsigned bus = usbsrc->bus;\n    unsigned device = usbsrc->device;\n    bool autoAddress = usbsrc->autoAddress;\n    int rc;\n\n    *usb = NULL;\n\n    if (vendor && bus) {\n        rc = virUSBDeviceFind(vendor, product, bus, device,\n                              NULL,\n                              autoAddress ? false : mandatory,\n                              usb);\n        if (rc < 0) {\n            return -1;\n        } else if (!autoAddress) {\n            goto out;\n        } else {\n            VIR_INFO(\"USB device %x:%x could not be found at previous\"\n                     \" address (bus:%u device:%u)\",\n                     vendor, product, bus, device);\n        }\n    }\n\n    /* When vendor is specified, its USB address is either unspecified or the\n     * device could not be found at the USB device where it had been\n     * automatically found before.\n     */\n    if (vendor) {\n        g_autoptr(virUSBDeviceList) devs = NULL;\n\n        rc = virUSBDeviceFindByVendor(vendor, product, NULL, mandatory, &devs);\n        if (rc < 0) {\n            return -1;\n        } else if (rc == 0) {\n            goto out;\n        } else if (rc > 1) {\n            if (autoAddress) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x were found,\"\n                                 \" but none of them is at bus:%u device:%u\"),\n                               vendor, product, bus, device);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x, \"\n                                 \"use <address> to specify one\"),\n                               vendor, product);\n            }\n            return -1;\n        }\n\n        *usb = virUSBDeviceListGet(devs, 0);\n        virUSBDeviceListSteal(devs, *usb);\n\n        usbsrc->bus = virUSBDeviceGetBus(*usb);\n        usbsrc->device = virUSBDeviceGetDevno(*usb);\n        usbsrc->autoAddress = true;\n\n        if (autoAddress) {\n            VIR_INFO(\"USB device %x:%x found at bus:%u device:%u (moved\"\n                     \" from bus:%u device:%u)\",\n                     vendor, product,\n                     usbsrc->bus, usbsrc->device,\n                     bus, device);\n        }\n    } else if (!vendor && bus) {\n        if (virUSBDeviceFindByBus(bus, device, NULL, mandatory, usb) < 0)\n            return -1;\n    }\n\n out:\n    if (!*usb)\n        hostdev->missing = true;\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevFindUSBDevice(virDomainHostdevDefPtr hostdev,\n                        bool mandatory,\n                        virUSBDevicePtr *usb)\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n    unsigned vendor = usbsrc->vendor;\n    unsigned product = usbsrc->product;\n    unsigned bus = usbsrc->bus;\n    unsigned device = usbsrc->device;\n    bool autoAddress = usbsrc->autoAddress;\n    int rc;\n\n    *usb = NULL;\n\n    if (vendor && bus) {\n        rc = virUSBDeviceFind(vendor, product, bus, device,\n                              NULL,\n                              autoAddress ? false : mandatory,\n                              usb);\n        if (rc < 0) {\n            return -1;\n        } else if (!autoAddress) {\n            goto out;\n        } else {\n            VIR_INFO(\"USB device %x:%x could not be found at previous\"\n                     \" address (bus:%u device:%u)\",\n                     vendor, product, bus, device);\n        }\n    }\n\n    /* When vendor is specified, its USB address is either unspecified or the\n     * device could not be found at the USB device where it had been\n     * automatically found before.\n     */\n    if (vendor) {\n        g_autoptr(virUSBDeviceList) devs = NULL;\n\n        rc = virUSBDeviceFindByVendor(vendor, product, NULL, mandatory, &devs);\n        if (rc < 0) {\n            return -1;\n        } else if (rc == 0) {\n            goto out;\n        } else if (rc > 1) {\n            if (autoAddress) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x were found,\"\n                                 \" but none of them is at bus:%u device:%u\"),\n                               vendor, product, bus, device);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x, \"\n                                 \"use <address> to specify one\"),\n                               vendor, product);\n            }\n            return -1;\n        }\n\n        *usb = virUSBDeviceListGet(devs, 0);\n        virUSBDeviceListSteal(devs, *usb);\n\n        usbsrc->bus = virUSBDeviceGetBus(*usb);\n        usbsrc->device = virUSBDeviceGetDevno(*usb);\n        usbsrc->autoAddress = true;\n\n        if (autoAddress) {\n            VIR_INFO(\"USB device %x:%x found at bus:%u device:%u (moved\"\n                     \" from bus:%u device:%u)\",\n                     vendor, product,\n                     usbsrc->bus, usbsrc->device,\n                     bus, device);\n        }\n    } else if (!vendor && bus) {\n        if (virUSBDeviceFindByBus(bus, device, NULL, mandatory, usb) < 0)\n            return -1;\n    }\n\n out:\n    if (!*usb)\n        hostdev->missing = true;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceNew",
          "args": [
            "usbsrc->bus",
            "usbsrc->device",
            "NULL"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "308-351",
          "snippet": "virUSBDevicePtr\nvirUSBDeviceNew(unsigned int bus,\n                unsigned int devno,\n                const char *vroot)\n{\n    virUSBDevicePtr dev;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus     = bus;\n    dev->dev     = devno;\n\n    if (g_snprintf(dev->name, sizeof(dev->name), \"%.3d:%.3d\",\n                   dev->bus, dev->dev) >= sizeof(dev->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->name buffer overflow: %.3d:%.3d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    if (vroot) {\n        dev->path = g_strdup_printf(\"%s/%03d/%03d\",\n                                    vroot, dev->bus, dev->dev);\n    } else {\n        dev->path = g_strdup_printf(USB_DEVFS \"%03d/%03d\",\n                                    dev->bus, dev->dev);\n    }\n\n    /* XXX fixme. this should be product/vendor */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%d %d\", dev->bus,\n                   dev->dev) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %d %d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return dev;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirUSBDevicePtr\nvirUSBDeviceNew(unsigned int bus,\n                unsigned int devno,\n                const char *vroot)\n{\n    virUSBDevicePtr dev;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus     = bus;\n    dev->dev     = devno;\n\n    if (g_snprintf(dev->name, sizeof(dev->name), \"%.3d:%.3d\",\n                   dev->bus, dev->dev) >= sizeof(dev->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->name buffer overflow: %.3d:%.3d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    if (vroot) {\n        dev->path = g_strdup_printf(\"%s/%03d/%03d\",\n                                    vroot, dev->bus, dev->dev);\n    } else {\n        dev->path = g_strdup_printf(USB_DEVFS \"%03d/%03d\",\n                                    dev->bus, dev->dev);\n    }\n\n    /* XXX fixme. this should be product/vendor */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%d %d\", dev->bus,\n                   dev->dev) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %d %d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "defaultRenderNode"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostGetDRMRenderNode",
          "args": [],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "virHostGetDRMRenderNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1693-1728",
          "snippet": "char *\nvirHostGetDRMRenderNode(void)\n{\n    char *ret = NULL;\n    DIR *driDir = NULL;\n    const char *driPath = \"/dev/dri\";\n    struct dirent *ent = NULL;\n    int dirErr = 0;\n    bool have_rendernode = false;\n\n    if (virDirOpen(&driDir, driPath) < 0)\n        return NULL;\n\n    while ((dirErr = virDirRead(driDir, &ent, driPath)) > 0) {\n        if (STRPREFIX(ent->d_name, \"renderD\")) {\n            have_rendernode = true;\n            break;\n        }\n    }\n\n    if (dirErr < 0)\n        goto cleanup;\n\n    /* even if /dev/dri exists, there might be no renderDX nodes available */\n    if (!have_rendernode) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No DRM render nodes available\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup_printf(\"%s/%s\", driPath, ent->d_name);\n\n cleanup:\n    VIR_DIR_CLOSE(driDir);\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirHostGetDRMRenderNode(void)\n{\n    char *ret = NULL;\n    DIR *driDir = NULL;\n    const char *driPath = \"/dev/dri\";\n    struct dirent *ent = NULL;\n    int dirErr = 0;\n    bool have_rendernode = false;\n\n    if (virDirOpen(&driDir, driPath) < 0)\n        return NULL;\n\n    while ((dirErr = virDirRead(driDir, &ent, driPath)) > 0) {\n        if (STRPREFIX(ent->d_name, \"renderD\")) {\n            have_rendernode = true;\n            break;\n        }\n    }\n\n    if (dirErr < 0)\n        goto cleanup;\n\n    /* even if /dev/dri exists, there might be no renderDX nodes available */\n    if (!have_rendernode) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No DRM render nodes available\"));\n        goto cleanup;\n    }\n\n    ret = g_strdup_printf(\"%s/%s\", driPath, ent->d_name);\n\n cleanup:\n    VIR_DIR_CLOSE(driDir);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsNeedsAutoRenderNode",
          "args": [
            "graphics"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsNeedsAutoRenderNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32178-32192",
          "snippet": "bool\nvirDomainGraphicsNeedsAutoRenderNode(const virDomainGraphicsDef *graphics)\n{\n    if (!virDomainGraphicsSupportsRenderNode(graphics))\n        return false;\n\n    if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE &&\n        graphics->data.spice.gl != VIR_TRISTATE_BOOL_YES)\n        return false;\n\n    if (virDomainGraphicsGetRenderNode(graphics))\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainGraphicsNeedsAutoRenderNode(const virDomainGraphicsDef *graphics)\n{\n    if (!virDomainGraphicsSupportsRenderNode(graphics))\n        return false;\n\n    if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE &&\n        graphics->data.spice.gl != VIR_TRISTATE_BOOL_YES)\n        return false;\n\n    if (virDomainGraphicsGetRenderNode(graphics))\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsGetRenderNode",
          "args": [
            "graphics"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsGetRenderNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32154-32175",
          "snippet": "const char *\nvirDomainGraphicsGetRenderNode(const virDomainGraphicsDef *graphics)\n{\n    const char *ret = NULL;\n\n    switch (graphics->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        ret = graphics->data.spice.rendernode;\n        break;\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        ret = graphics->data.egl_headless.rendernode;\n        break;\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainGraphicsGetRenderNode(const virDomainGraphicsDef *graphics)\n{\n    const char *ret = NULL;\n\n    switch (graphics->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        ret = graphics->data.spice.rendernode;\n        break;\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        ret = graphics->data.egl_headless.rendernode;\n        break;\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storage_source_add_files",
          "args": [
            "disk->src",
            "&buf",
            "0"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "storage_source_add_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "890-909",
          "snippet": "static int\nstorage_source_add_files(virStorageSourcePtr src,\n                         virBufferPtr buf,\n                         size_t depth)\n{\n    virStorageSourcePtr tmp;\n\n    for (tmp = src; virStorageSourceIsBacking(tmp); tmp = tmp->backingStore) {\n        if (add_file_path(tmp, depth, buf) < 0)\n            return -1;\n\n        if (tmp->externalDataStore &&\n            storage_source_add_files(tmp->externalDataStore, buf, depth) < 0)\n            return -1;\n\n        depth++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nstorage_source_add_files(virStorageSourcePtr src,\n                         virBufferPtr buf,\n                         size_t depth)\n{\n    virStorageSourcePtr tmp;\n\n    for (tmp = src; virStorageSourceIsBacking(tmp); tmp = tmp->backingStore) {\n        if (add_file_path(tmp, depth, buf) < 0)\n            return -1;\n\n        if (tmp->externalDataStore &&\n            storage_source_add_files(tmp->externalDataStore, buf, depth) < 0)\n            return -1;\n\n        depth++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileGetMetadata",
          "args": [
            "disk->src",
            "-1",
            "-1",
            "false"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileGetMetadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "5328-5356",
          "snippet": "int\nvirStorageFileGetMetadata(virStorageSourcePtr src,\n                          uid_t uid, gid_t gid,\n                          bool report_broken)\n{\n    VIR_DEBUG(\"path=%s format=%d uid=%u gid=%u report_broken=%d\",\n              src->path, src->format, (unsigned int)uid, (unsigned int)gid,\n              report_broken);\n\n    virHashTablePtr cycle = NULL;\n    virStorageType actualType = virStorageSourceGetActualType(src);\n    int ret = -1;\n\n    if (!(cycle = virHashCreate(5, NULL)))\n        return -1;\n\n    if (src->format <= VIR_STORAGE_FILE_NONE) {\n        if (actualType == VIR_STORAGE_TYPE_DIR)\n            src->format = VIR_STORAGE_FILE_DIR;\n        else\n            src->format = VIR_STORAGE_FILE_RAW;\n    }\n\n    ret = virStorageFileGetMetadataRecurse(src, src, uid, gid,\n                                           report_broken, cycle, 1);\n\n    virHashFree(cycle);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageFileGetMetadata(virStorageSourcePtr src,\n                          uid_t uid, gid_t gid,\n                          bool report_broken)\n{\n    VIR_DEBUG(\"path=%s format=%d uid=%u gid=%u report_broken=%d\",\n              src->path, src->format, (unsigned int)uid, (unsigned int)gid,\n              report_broken);\n\n    virHashTablePtr cycle = NULL;\n    virStorageType actualType = virStorageSourceGetActualType(src);\n    int ret = -1;\n\n    if (!(cycle = virHashCreate(5, NULL)))\n        return -1;\n\n    if (src->format <= VIR_STORAGE_FILE_NONE) {\n        if (actualType == VIR_STORAGE_TYPE_DIR)\n            src->format = VIR_STORAGE_FILE_DIR;\n        else\n            src->format = VIR_STORAGE_FILE_RAW;\n    }\n\n    ret = virStorageFileGetMetadataRecurse(src, src, uid, gid,\n                                           report_broken, cycle, 1);\n\n    virHashFree(cycle);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceHasBacking",
          "args": [
            "disk->src"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceHasBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1593-1598",
          "snippet": "bool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceHasBacking(const virStorageSource *src)\n{\n    return virStorageSourceIsBacking(src) && src->backingStore &&\n           src->backingStore->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "disk"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDriverLoadModule",
          "args": [
            "\"storage\"",
            "\"storageRegister\"",
            "false"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "virDriverLoadModule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "46-69",
          "snippet": "int\nvirDriverLoadModule(const char *name,\n                    const char *regfunc,\n                    bool required)\n{\n    char *modfile = NULL;\n    int ret;\n\n    VIR_DEBUG(\"Module load %s\", name);\n\n    if (!(modfile = virFileFindResourceFull(name,\n                                            \"libvirt_driver_\",\n                                            \".so\",\n                                            abs_top_builddir \"/src/.libs\",\n                                            DEFAULT_DRIVER_DIR,\n                                            \"LIBVIRT_DRIVER_DIR\")))\n        return -1;\n\n    ret = virModuleLoad(modfile, regfunc, required);\n\n    VIR_FREE(modfile);\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define DEFAULT_DRIVER_DIR LIBDIR \"/libvirt/connection-driver\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\n#define DEFAULT_DRIVER_DIR LIBDIR \"/libvirt/connection-driver\"\n\nint\nvirDriverLoadModule(const char *name,\n                    const char *regfunc,\n                    bool required)\n{\n    char *modfile = NULL;\n    int ret;\n\n    VIR_DEBUG(\"Module load %s\", name);\n\n    if (!(modfile = virFileFindResourceFull(name,\n                                            \"libvirt_driver_\",\n                                            \".so\",\n                                            abs_top_builddir \"/src/.libs\",\n                                            DEFAULT_DRIVER_DIR,\n                                            \"LIBVIRT_DRIVER_DIR\")))\n        return -1;\n\n    ret = virModuleLoad(modfile, regfunc, required);\n\n    VIR_FREE(modfile);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vah_error",
          "args": [
            "ctl",
            "0",
            "_(\"given uuid does not match XML uuid\")"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "vah_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "119-129",
          "snippet": "static void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"given uuid does not match XML uuid\""
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "uuid",
            "ctl->uuid"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "ctl->def->uuid",
            "uuidstr"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
  },
  {
    "function_name": "storage_source_add_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "890-909",
    "snippet": "static int\nstorage_source_add_files(virStorageSourcePtr src,\n                         virBufferPtr buf,\n                         size_t depth)\n{\n    virStorageSourcePtr tmp;\n\n    for (tmp = src; virStorageSourceIsBacking(tmp); tmp = tmp->backingStore) {\n        if (add_file_path(tmp, depth, buf) < 0)\n            return -1;\n\n        if (tmp->externalDataStore &&\n            storage_source_add_files(tmp->externalDataStore, buf, depth) < 0)\n            return -1;\n\n        depth++;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "storage_source_add_files",
          "args": [
            "tmp->externalDataStore",
            "buf",
            "depth"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "storage_source_add_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "890-909",
          "snippet": "static int\nstorage_source_add_files(virStorageSourcePtr src,\n                         virBufferPtr buf,\n                         size_t depth)\n{\n    virStorageSourcePtr tmp;\n\n    for (tmp = src; virStorageSourceIsBacking(tmp); tmp = tmp->backingStore) {\n        if (add_file_path(tmp, depth, buf) < 0)\n            return -1;\n\n        if (tmp->externalDataStore &&\n            storage_source_add_files(tmp->externalDataStore, buf, depth) < 0)\n            return -1;\n\n        depth++;\n    }\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "add_file_path",
          "args": [
            "tmp",
            "depth",
            "buf"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "add_file_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "863-887",
          "snippet": "static int\nadd_file_path(virStorageSourcePtr src,\n              size_t depth,\n              virBufferPtr buf)\n{\n    int ret;\n\n    /* execute the callback only for local storage */\n    if (!src->path || !virStorageSourceIsLocalStorage(src))\n        return 0;\n\n    if (depth == 0) {\n        if (src->readonly)\n            ret = vah_add_file(buf, src->path, \"rk\");\n        else\n            ret = vah_add_file(buf, src->path, \"rwk\");\n    } else {\n        ret = vah_add_file(buf, src->path, \"rk\");\n    }\n\n    if (ret != 0)\n        ret = -1;\n\n    return ret;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nadd_file_path(virStorageSourcePtr src,\n              size_t depth,\n              virBufferPtr buf)\n{\n    int ret;\n\n    /* execute the callback only for local storage */\n    if (!src->path || !virStorageSourceIsLocalStorage(src))\n        return 0;\n\n    if (depth == 0) {\n        if (src->readonly)\n            ret = vah_add_file(buf, src->path, \"rk\");\n        else\n            ret = vah_add_file(buf, src->path, \"rwk\");\n    } else {\n        ret = vah_add_file(buf, src->path, \"rk\");\n    }\n\n    if (ret != 0)\n        ret = -1;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsBacking",
          "args": [
            "tmp"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1581-1585",
          "snippet": "bool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nstorage_source_add_files(virStorageSourcePtr src,\n                         virBufferPtr buf,\n                         size_t depth)\n{\n    virStorageSourcePtr tmp;\n\n    for (tmp = src; virStorageSourceIsBacking(tmp); tmp = tmp->backingStore) {\n        if (add_file_path(tmp, depth, buf) < 0)\n            return -1;\n\n        if (tmp->externalDataStore &&\n            storage_source_add_files(tmp->externalDataStore, buf, depth) < 0)\n            return -1;\n\n        depth++;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "add_file_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "863-887",
    "snippet": "static int\nadd_file_path(virStorageSourcePtr src,\n              size_t depth,\n              virBufferPtr buf)\n{\n    int ret;\n\n    /* execute the callback only for local storage */\n    if (!src->path || !virStorageSourceIsLocalStorage(src))\n        return 0;\n\n    if (depth == 0) {\n        if (src->readonly)\n            ret = vah_add_file(buf, src->path, \"rk\");\n        else\n            ret = vah_add_file(buf, src->path, \"rwk\");\n    } else {\n        ret = vah_add_file(buf, src->path, \"rk\");\n    }\n\n    if (ret != 0)\n        ret = -1;\n\n    return ret;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vah_add_file",
          "args": [
            "buf",
            "src->path",
            "\"rk\""
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "vah_add_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "803-807",
          "snippet": "static int\nvah_add_file(virBufferPtr buf, const char *path, const char *perms)\n{\n    return vah_add_path(buf, path, perms, false);\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvah_add_file(virBufferPtr buf, const char *path, const char *perms)\n{\n    return vah_add_path(buf, path, perms, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsLocalStorage",
          "args": [
            "src"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsLocalStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2586-2608",
          "snippet": "bool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nadd_file_path(virStorageSourcePtr src,\n              size_t depth,\n              virBufferPtr buf)\n{\n    int ret;\n\n    /* execute the callback only for local storage */\n    if (!src->path || !virStorageSourceIsLocalStorage(src))\n        return 0;\n\n    if (depth == 0) {\n        if (src->readonly)\n            ret = vah_add_file(buf, src->path, \"rk\");\n        else\n            ret = vah_add_file(buf, src->path, \"rwk\");\n    } else {\n        ret = vah_add_file(buf, src->path, \"rk\");\n    }\n\n    if (ret != 0)\n        ret = -1;\n\n    return ret;\n}"
  },
  {
    "function_name": "file_iterate_pci_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "855-861",
    "snippet": "static int\nfile_iterate_pci_cb(virPCIDevicePtr dev G_GNUC_UNUSED,\n                    const char *file, void *opaque)\n{\n    virBufferPtr buf = opaque;\n    return vah_add_file(buf, file, \"rw\");\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vah_add_file",
          "args": [
            "buf",
            "file",
            "\"rw\""
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "vah_add_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "803-807",
          "snippet": "static int\nvah_add_file(virBufferPtr buf, const char *path, const char *perms)\n{\n    return vah_add_path(buf, path, perms, false);\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvah_add_file(virBufferPtr buf, const char *path, const char *perms)\n{\n    return vah_add_path(buf, path, perms, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nfile_iterate_pci_cb(virPCIDevicePtr dev G_GNUC_UNUSED,\n                    const char *file, void *opaque)\n{\n    virBufferPtr buf = opaque;\n    return vah_add_file(buf, file, \"rw\");\n}"
  },
  {
    "function_name": "file_iterate_hostdev_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "847-853",
    "snippet": "static int\nfile_iterate_hostdev_cb(virUSBDevicePtr dev G_GNUC_UNUSED,\n                        const char *file, void *opaque)\n{\n    virBufferPtr buf = opaque;\n    return vah_add_file(buf, file, \"rw\");\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vah_add_file",
          "args": [
            "buf",
            "file",
            "\"rw\""
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "vah_add_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "803-807",
          "snippet": "static int\nvah_add_file(virBufferPtr buf, const char *path, const char *perms)\n{\n    return vah_add_path(buf, path, perms, false);\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvah_add_file(virBufferPtr buf, const char *path, const char *perms)\n{\n    return vah_add_path(buf, path, perms, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nfile_iterate_hostdev_cb(virUSBDevicePtr dev G_GNUC_UNUSED,\n                        const char *file, void *opaque)\n{\n    virBufferPtr buf = opaque;\n    return vah_add_file(buf, file, \"rw\");\n}"
  },
  {
    "function_name": "vah_add_file_chardev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "809-845",
    "snippet": "static int\nvah_add_file_chardev(virBufferPtr buf,\n                     const char *path,\n                     const char *perms,\n                     const int type)\n{\n    char *pipe_in;\n    char *pipe_out;\n    int rc = -1;\n\n    if (type == VIR_DOMAIN_CHR_TYPE_PIPE) {\n        /* add the pipe input */\n        pipe_in = g_strdup_printf(\"%s.in\", path);\n\n        if (vah_add_file(buf, pipe_in, perms) != 0)\n            goto clean_pipe_in;\n\n        /* add the pipe output */\n        pipe_out = g_strdup_printf(\"%s.out\", path);\n\n        if (vah_add_file(buf, pipe_out, perms) != 0)\n            goto clean_pipe_out;\n\n        rc = 0;\n      clean_pipe_out:\n        VIR_FREE(pipe_out);\n      clean_pipe_in:\n        VIR_FREE(pipe_in);\n    } else {\n        /* add the file */\n        if (vah_add_file(buf, path, perms) != 0)\n            return -1;\n        rc = 0;\n    }\n\n    return rc;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vah_add_file",
          "args": [
            "buf",
            "path",
            "perms"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "vah_add_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "803-807",
          "snippet": "static int\nvah_add_file(virBufferPtr buf, const char *path, const char *perms)\n{\n    return vah_add_path(buf, path, perms, false);\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvah_add_file(virBufferPtr buf, const char *path, const char *perms)\n{\n    return vah_add_path(buf, path, perms, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pipe_in"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pipe_out"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s.out\"",
            "path"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvah_add_file_chardev(virBufferPtr buf,\n                     const char *path,\n                     const char *perms,\n                     const int type)\n{\n    char *pipe_in;\n    char *pipe_out;\n    int rc = -1;\n\n    if (type == VIR_DOMAIN_CHR_TYPE_PIPE) {\n        /* add the pipe input */\n        pipe_in = g_strdup_printf(\"%s.in\", path);\n\n        if (vah_add_file(buf, pipe_in, perms) != 0)\n            goto clean_pipe_in;\n\n        /* add the pipe output */\n        pipe_out = g_strdup_printf(\"%s.out\", path);\n\n        if (vah_add_file(buf, pipe_out, perms) != 0)\n            goto clean_pipe_out;\n\n        rc = 0;\n      clean_pipe_out:\n        VIR_FREE(pipe_out);\n      clean_pipe_in:\n        VIR_FREE(pipe_in);\n    } else {\n        /* add the file */\n        if (vah_add_file(buf, path, perms) != 0)\n            return -1;\n        rc = 0;\n    }\n\n    return rc;\n}"
  },
  {
    "function_name": "vah_add_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "803-807",
    "snippet": "static int\nvah_add_file(virBufferPtr buf, const char *path, const char *perms)\n{\n    return vah_add_path(buf, path, perms, false);\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vah_add_path",
          "args": [
            "buf",
            "path",
            "perms",
            "false"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "vah_add_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "704-801",
          "snippet": "static int\nvah_add_path(virBufferPtr buf, const char *path, const char *perms, bool recursive)\n{\n    char *tmp = NULL;\n    int rc = -1;\n    bool readonly = true;\n    bool explicit_deny_rule = true;\n    char *sub = NULL;\n    char *perms_new = NULL;\n    char *pathdir = NULL;\n    char *pathtmp = NULL;\n    char *pathreal = NULL;\n\n    if (path == NULL)\n        return rc;\n\n    /* Skip files without an absolute path. Not having one confuses the\n     * apparmor parser and this also ensures things like tcp consoles don't\n     * get added to the profile.\n     */\n    if (STRNEQLEN(path, \"/\", 1)) {\n        vah_warning(path);\n        vah_warning(_(\"skipped non-absolute path\"));\n        return 0;\n    }\n\n    /* files might be created by qemu later on and not exist right now.\n     * But realpath needs a valid path to work on, therefore:\n     * 1. walk the path to find longest valid path\n     * 2. get the realpath of that valid path\n     * 3. re-combine the realpath with the remaining suffix\n     * Note: A totally non existent path is used as-is\n     */\n     pathdir = g_strdup(path);\n     while (!virFileExists(pathdir)) {\n         pathtmp = g_path_get_dirname(pathdir);\n         VIR_FREE(pathdir);\n         pathdir = g_steal_pointer(&pathtmp);\n     }\n\n    if (strlen(pathdir) == 1) {\n        /* nothing of the path does exist yet */\n        tmp = g_strdup(path);\n    } else {\n        pathtmp = g_strdup(path + strlen(pathdir));\n        if ((pathreal = realpath(pathdir, NULL)) == NULL) {\n            vah_error(NULL, 0, pathdir);\n            vah_error(NULL, 0, _(\"could not find realpath\"));\n            goto cleanup;\n        }\n        tmp = g_strdup_printf(\"%s%s\", pathreal, pathtmp);\n    }\n\n    perms_new = g_strdup(perms);\n\n    if (strchr(perms_new, 'w') != NULL) {\n        readonly = false;\n        explicit_deny_rule = false;\n    }\n\n    if ((sub = strchr(perms_new, 'R')) != NULL) {\n        /* Don't write the invalid R permission, replace it with 'r' */\n        sub[0] = 'r';\n        explicit_deny_rule = false;\n    }\n\n    rc = valid_path(tmp, readonly);\n    if (rc != 0) {\n        if (rc > 0) {\n            vah_error(NULL, 0, path);\n            vah_error(NULL, 0, _(\"skipped restricted file\"));\n        }\n        goto cleanup;\n    }\n\n    if (tmp[strlen(tmp) - 1] == '/')\n        tmp[strlen(tmp) - 1] = '\\0';\n\n    virBufferAsprintf(buf, \"  \\\"%s%s\\\" %s,\\n\", tmp, recursive ? \"/**\" : \"\",\n                      perms_new);\n    if (explicit_deny_rule) {\n        virBufferAddLit(buf, \"  # don't audit writes to readonly files\\n\");\n        virBufferAsprintf(buf, \"  deny \\\"%s%s\\\" w,\\n\", tmp, recursive ? \"/**\" : \"\");\n    }\n    if (recursive) {\n        /* allow reading (but not creating) the dir */\n        virBufferAsprintf(buf, \"  \\\"%s/\\\" r,\\n\", tmp);\n    }\n\n cleanup:\n    VIR_FREE(pathdir);\n    VIR_FREE(pathtmp);\n    VIR_FREE(pathreal);\n    VIR_FREE(perms_new);\n    VIR_FREE(tmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvah_add_path(virBufferPtr buf, const char *path, const char *perms, bool recursive)\n{\n    char *tmp = NULL;\n    int rc = -1;\n    bool readonly = true;\n    bool explicit_deny_rule = true;\n    char *sub = NULL;\n    char *perms_new = NULL;\n    char *pathdir = NULL;\n    char *pathtmp = NULL;\n    char *pathreal = NULL;\n\n    if (path == NULL)\n        return rc;\n\n    /* Skip files without an absolute path. Not having one confuses the\n     * apparmor parser and this also ensures things like tcp consoles don't\n     * get added to the profile.\n     */\n    if (STRNEQLEN(path, \"/\", 1)) {\n        vah_warning(path);\n        vah_warning(_(\"skipped non-absolute path\"));\n        return 0;\n    }\n\n    /* files might be created by qemu later on and not exist right now.\n     * But realpath needs a valid path to work on, therefore:\n     * 1. walk the path to find longest valid path\n     * 2. get the realpath of that valid path\n     * 3. re-combine the realpath with the remaining suffix\n     * Note: A totally non existent path is used as-is\n     */\n     pathdir = g_strdup(path);\n     while (!virFileExists(pathdir)) {\n         pathtmp = g_path_get_dirname(pathdir);\n         VIR_FREE(pathdir);\n         pathdir = g_steal_pointer(&pathtmp);\n     }\n\n    if (strlen(pathdir) == 1) {\n        /* nothing of the path does exist yet */\n        tmp = g_strdup(path);\n    } else {\n        pathtmp = g_strdup(path + strlen(pathdir));\n        if ((pathreal = realpath(pathdir, NULL)) == NULL) {\n            vah_error(NULL, 0, pathdir);\n            vah_error(NULL, 0, _(\"could not find realpath\"));\n            goto cleanup;\n        }\n        tmp = g_strdup_printf(\"%s%s\", pathreal, pathtmp);\n    }\n\n    perms_new = g_strdup(perms);\n\n    if (strchr(perms_new, 'w') != NULL) {\n        readonly = false;\n        explicit_deny_rule = false;\n    }\n\n    if ((sub = strchr(perms_new, 'R')) != NULL) {\n        /* Don't write the invalid R permission, replace it with 'r' */\n        sub[0] = 'r';\n        explicit_deny_rule = false;\n    }\n\n    rc = valid_path(tmp, readonly);\n    if (rc != 0) {\n        if (rc > 0) {\n            vah_error(NULL, 0, path);\n            vah_error(NULL, 0, _(\"skipped restricted file\"));\n        }\n        goto cleanup;\n    }\n\n    if (tmp[strlen(tmp) - 1] == '/')\n        tmp[strlen(tmp) - 1] = '\\0';\n\n    virBufferAsprintf(buf, \"  \\\"%s%s\\\" %s,\\n\", tmp, recursive ? \"/**\" : \"\",\n                      perms_new);\n    if (explicit_deny_rule) {\n        virBufferAddLit(buf, \"  # don't audit writes to readonly files\\n\");\n        virBufferAsprintf(buf, \"  deny \\\"%s%s\\\" w,\\n\", tmp, recursive ? \"/**\" : \"\");\n    }\n    if (recursive) {\n        /* allow reading (but not creating) the dir */\n        virBufferAsprintf(buf, \"  \\\"%s/\\\" r,\\n\", tmp);\n    }\n\n cleanup:\n    VIR_FREE(pathdir);\n    VIR_FREE(pathtmp);\n    VIR_FREE(pathreal);\n    VIR_FREE(perms_new);\n    VIR_FREE(tmp);\n\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvah_add_file(virBufferPtr buf, const char *path, const char *perms)\n{\n    return vah_add_path(buf, path, perms, false);\n}"
  },
  {
    "function_name": "vah_add_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "704-801",
    "snippet": "static int\nvah_add_path(virBufferPtr buf, const char *path, const char *perms, bool recursive)\n{\n    char *tmp = NULL;\n    int rc = -1;\n    bool readonly = true;\n    bool explicit_deny_rule = true;\n    char *sub = NULL;\n    char *perms_new = NULL;\n    char *pathdir = NULL;\n    char *pathtmp = NULL;\n    char *pathreal = NULL;\n\n    if (path == NULL)\n        return rc;\n\n    /* Skip files without an absolute path. Not having one confuses the\n     * apparmor parser and this also ensures things like tcp consoles don't\n     * get added to the profile.\n     */\n    if (STRNEQLEN(path, \"/\", 1)) {\n        vah_warning(path);\n        vah_warning(_(\"skipped non-absolute path\"));\n        return 0;\n    }\n\n    /* files might be created by qemu later on and not exist right now.\n     * But realpath needs a valid path to work on, therefore:\n     * 1. walk the path to find longest valid path\n     * 2. get the realpath of that valid path\n     * 3. re-combine the realpath with the remaining suffix\n     * Note: A totally non existent path is used as-is\n     */\n     pathdir = g_strdup(path);\n     while (!virFileExists(pathdir)) {\n         pathtmp = g_path_get_dirname(pathdir);\n         VIR_FREE(pathdir);\n         pathdir = g_steal_pointer(&pathtmp);\n     }\n\n    if (strlen(pathdir) == 1) {\n        /* nothing of the path does exist yet */\n        tmp = g_strdup(path);\n    } else {\n        pathtmp = g_strdup(path + strlen(pathdir));\n        if ((pathreal = realpath(pathdir, NULL)) == NULL) {\n            vah_error(NULL, 0, pathdir);\n            vah_error(NULL, 0, _(\"could not find realpath\"));\n            goto cleanup;\n        }\n        tmp = g_strdup_printf(\"%s%s\", pathreal, pathtmp);\n    }\n\n    perms_new = g_strdup(perms);\n\n    if (strchr(perms_new, 'w') != NULL) {\n        readonly = false;\n        explicit_deny_rule = false;\n    }\n\n    if ((sub = strchr(perms_new, 'R')) != NULL) {\n        /* Don't write the invalid R permission, replace it with 'r' */\n        sub[0] = 'r';\n        explicit_deny_rule = false;\n    }\n\n    rc = valid_path(tmp, readonly);\n    if (rc != 0) {\n        if (rc > 0) {\n            vah_error(NULL, 0, path);\n            vah_error(NULL, 0, _(\"skipped restricted file\"));\n        }\n        goto cleanup;\n    }\n\n    if (tmp[strlen(tmp) - 1] == '/')\n        tmp[strlen(tmp) - 1] = '\\0';\n\n    virBufferAsprintf(buf, \"  \\\"%s%s\\\" %s,\\n\", tmp, recursive ? \"/**\" : \"\",\n                      perms_new);\n    if (explicit_deny_rule) {\n        virBufferAddLit(buf, \"  # don't audit writes to readonly files\\n\");\n        virBufferAsprintf(buf, \"  deny \\\"%s%s\\\" w,\\n\", tmp, recursive ? \"/**\" : \"\");\n    }\n    if (recursive) {\n        /* allow reading (but not creating) the dir */\n        virBufferAsprintf(buf, \"  \\\"%s/\\\" r,\\n\", tmp);\n    }\n\n cleanup:\n    VIR_FREE(pathdir);\n    VIR_FREE(pathtmp);\n    VIR_FREE(pathreal);\n    VIR_FREE(perms_new);\n    VIR_FREE(tmp);\n\n    return rc;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "perms_new"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pathreal"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pathtmp"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pathdir"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"  \\\"%s/\\\" r,\\n\"",
            "tmp"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"  # don't audit writes to readonly files\\n\""
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vah_error",
          "args": [
            "NULL",
            "0",
            "_(\"skipped restricted file\")"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "vah_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "119-129",
          "snippet": "static void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"skipped restricted file\""
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_path",
          "args": [
            "tmp",
            "readonly"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "valid_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "450-529",
          "snippet": "static int\nvalid_path(const char *path, const bool readonly)\n{\n    const char * const restricted[] = {\n        \"/bin/\",\n        \"/etc/\",\n        \"/lib\",\n        \"/lost+found/\",\n        \"/proc/\",\n        \"/sbin/\",\n        \"/selinux/\",\n        \"/sys/\",\n        \"/usr/bin/\",\n        \"/usr/lib\",\n        \"/usr/sbin/\",\n        \"/usr/share/\",\n        \"/usr/local/bin/\",\n        \"/usr/local/etc/\",\n        \"/usr/local/lib\",\n        \"/usr/local/sbin/\"\n    };\n    /* these paths are ok for readonly, but not read/write */\n    const char * const restricted_rw[] = {\n        \"/boot/\",\n        \"/vmlinuz\",\n        \"/initrd\",\n        \"/initrd.img\",\n        \"/usr/share/edk2/\",\n        \"/usr/share/OVMF/\",              /* for OVMF images */\n        \"/usr/share/ovmf/\",              /* for OVMF images */\n        \"/usr/share/AAVMF/\",             /* for AAVMF images */\n        \"/usr/share/qemu-efi/\",          /* for AAVMF images */\n        \"/usr/share/qemu-efi-aarch64/\"   /* for AAVMF images */\n    };\n    /* override the above with these */\n    const char * const override[] = {\n        \"/sys/devices/pci\",                /* for hostdev pci devices */\n        \"/sys/kernel/config/target/vhost\", /* for hostdev vhost_scsi devices */\n        \"/etc/libvirt-sandbox/services/\"   /* for virt-sandbox service config */\n    };\n\n    const int nropaths = G_N_ELEMENTS(restricted);\n    const int nrwpaths = G_N_ELEMENTS(restricted_rw);\n    const int nopaths = G_N_ELEMENTS(override);\n\n    if (path == NULL) {\n        vah_error(NULL, 0, _(\"bad pathname\"));\n        return -1;\n    }\n\n    /* Don't allow double quotes, since we use them to quote the filename\n     * and this will confuse the apparmor parser.\n     */\n    if (strchr(path, '\"') != NULL)\n        return 1;\n\n    /* Require an absolute path */\n    if (STRNEQLEN(path, \"/\", 1))\n        return 1;\n\n    if (!virFileExists(path))\n        vah_warning(_(\"path does not exist, skipping file type checks\"));\n\n    /* overrides are always allowed */\n    if (array_starts_with(path, override, nopaths) == 0)\n        return 0;\n\n    /* allow read only paths upfront */\n    if (readonly) {\n        if (array_starts_with(path, restricted_rw, nrwpaths) == 0)\n            return 0;\n    }\n\n    /* disallow RW access to all paths in restricted and restriced_rw */\n    if ((array_starts_with(path, restricted, nropaths) == 0 ||\n         array_starts_with(path, restricted_rw, nrwpaths) == 0))\n        return 1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvalid_path(const char *path, const bool readonly)\n{\n    const char * const restricted[] = {\n        \"/bin/\",\n        \"/etc/\",\n        \"/lib\",\n        \"/lost+found/\",\n        \"/proc/\",\n        \"/sbin/\",\n        \"/selinux/\",\n        \"/sys/\",\n        \"/usr/bin/\",\n        \"/usr/lib\",\n        \"/usr/sbin/\",\n        \"/usr/share/\",\n        \"/usr/local/bin/\",\n        \"/usr/local/etc/\",\n        \"/usr/local/lib\",\n        \"/usr/local/sbin/\"\n    };\n    /* these paths are ok for readonly, but not read/write */\n    const char * const restricted_rw[] = {\n        \"/boot/\",\n        \"/vmlinuz\",\n        \"/initrd\",\n        \"/initrd.img\",\n        \"/usr/share/edk2/\",\n        \"/usr/share/OVMF/\",              /* for OVMF images */\n        \"/usr/share/ovmf/\",              /* for OVMF images */\n        \"/usr/share/AAVMF/\",             /* for AAVMF images */\n        \"/usr/share/qemu-efi/\",          /* for AAVMF images */\n        \"/usr/share/qemu-efi-aarch64/\"   /* for AAVMF images */\n    };\n    /* override the above with these */\n    const char * const override[] = {\n        \"/sys/devices/pci\",                /* for hostdev pci devices */\n        \"/sys/kernel/config/target/vhost\", /* for hostdev vhost_scsi devices */\n        \"/etc/libvirt-sandbox/services/\"   /* for virt-sandbox service config */\n    };\n\n    const int nropaths = G_N_ELEMENTS(restricted);\n    const int nrwpaths = G_N_ELEMENTS(restricted_rw);\n    const int nopaths = G_N_ELEMENTS(override);\n\n    if (path == NULL) {\n        vah_error(NULL, 0, _(\"bad pathname\"));\n        return -1;\n    }\n\n    /* Don't allow double quotes, since we use them to quote the filename\n     * and this will confuse the apparmor parser.\n     */\n    if (strchr(path, '\"') != NULL)\n        return 1;\n\n    /* Require an absolute path */\n    if (STRNEQLEN(path, \"/\", 1))\n        return 1;\n\n    if (!virFileExists(path))\n        vah_warning(_(\"path does not exist, skipping file type checks\"));\n\n    /* overrides are always allowed */\n    if (array_starts_with(path, override, nopaths) == 0)\n        return 0;\n\n    /* allow read only paths upfront */\n    if (readonly) {\n        if (array_starts_with(path, restricted_rw, nrwpaths) == 0)\n            return 0;\n    }\n\n    /* disallow RW access to all paths in restricted and restriced_rw */\n    if ((array_starts_with(path, restricted, nropaths) == 0 ||\n         array_starts_with(path, restricted_rw, nrwpaths) == 0))\n        return 1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "perms_new",
            "'R'"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "perms_new",
            "'w'"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "perms"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "realpath",
          "args": [
            "pathdir",
            "NULL"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pathdir"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pathdir"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&pathtmp"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pathdir"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_path_get_dirname",
          "args": [
            "pathdir"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "pathdir"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vah_warning",
          "args": [
            "_(\"skipped non-absolute path\")"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "vah_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "131-135",
          "snippet": "static void\nvah_warning(const char *str)\n{\n    fprintf(stderr, _(\"%s: warning: %s%c\"), progname, str, '\\n');\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_warning(const char *str)\n{\n    fprintf(stderr, _(\"%s: warning: %s%c\"), progname, str, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQLEN",
          "args": [
            "path",
            "\"/\"",
            "1"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvah_add_path(virBufferPtr buf, const char *path, const char *perms, bool recursive)\n{\n    char *tmp = NULL;\n    int rc = -1;\n    bool readonly = true;\n    bool explicit_deny_rule = true;\n    char *sub = NULL;\n    char *perms_new = NULL;\n    char *pathdir = NULL;\n    char *pathtmp = NULL;\n    char *pathreal = NULL;\n\n    if (path == NULL)\n        return rc;\n\n    /* Skip files without an absolute path. Not having one confuses the\n     * apparmor parser and this also ensures things like tcp consoles don't\n     * get added to the profile.\n     */\n    if (STRNEQLEN(path, \"/\", 1)) {\n        vah_warning(path);\n        vah_warning(_(\"skipped non-absolute path\"));\n        return 0;\n    }\n\n    /* files might be created by qemu later on and not exist right now.\n     * But realpath needs a valid path to work on, therefore:\n     * 1. walk the path to find longest valid path\n     * 2. get the realpath of that valid path\n     * 3. re-combine the realpath with the remaining suffix\n     * Note: A totally non existent path is used as-is\n     */\n     pathdir = g_strdup(path);\n     while (!virFileExists(pathdir)) {\n         pathtmp = g_path_get_dirname(pathdir);\n         VIR_FREE(pathdir);\n         pathdir = g_steal_pointer(&pathtmp);\n     }\n\n    if (strlen(pathdir) == 1) {\n        /* nothing of the path does exist yet */\n        tmp = g_strdup(path);\n    } else {\n        pathtmp = g_strdup(path + strlen(pathdir));\n        if ((pathreal = realpath(pathdir, NULL)) == NULL) {\n            vah_error(NULL, 0, pathdir);\n            vah_error(NULL, 0, _(\"could not find realpath\"));\n            goto cleanup;\n        }\n        tmp = g_strdup_printf(\"%s%s\", pathreal, pathtmp);\n    }\n\n    perms_new = g_strdup(perms);\n\n    if (strchr(perms_new, 'w') != NULL) {\n        readonly = false;\n        explicit_deny_rule = false;\n    }\n\n    if ((sub = strchr(perms_new, 'R')) != NULL) {\n        /* Don't write the invalid R permission, replace it with 'r' */\n        sub[0] = 'r';\n        explicit_deny_rule = false;\n    }\n\n    rc = valid_path(tmp, readonly);\n    if (rc != 0) {\n        if (rc > 0) {\n            vah_error(NULL, 0, path);\n            vah_error(NULL, 0, _(\"skipped restricted file\"));\n        }\n        goto cleanup;\n    }\n\n    if (tmp[strlen(tmp) - 1] == '/')\n        tmp[strlen(tmp) - 1] = '\\0';\n\n    virBufferAsprintf(buf, \"  \\\"%s%s\\\" %s,\\n\", tmp, recursive ? \"/**\" : \"\",\n                      perms_new);\n    if (explicit_deny_rule) {\n        virBufferAddLit(buf, \"  # don't audit writes to readonly files\\n\");\n        virBufferAsprintf(buf, \"  deny \\\"%s%s\\\" w,\\n\", tmp, recursive ? \"/**\" : \"\");\n    }\n    if (recursive) {\n        /* allow reading (but not creating) the dir */\n        virBufferAsprintf(buf, \"  \\\"%s/\\\" r,\\n\", tmp);\n    }\n\n cleanup:\n    VIR_FREE(pathdir);\n    VIR_FREE(pathtmp);\n    VIR_FREE(pathreal);\n    VIR_FREE(perms_new);\n    VIR_FREE(tmp);\n\n    return rc;\n}"
  },
  {
    "function_name": "get_definition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "622-698",
    "snippet": "static int\nget_definition(vahControl * ctl, const char *xmlStr)\n{\n    int ostype, virtType;\n    virCapsGuestPtr guest;  /* this is freed when caps is freed */\n\n    /*\n     * mock up some capabilities. We don't currently use these explicitly,\n     * but need them for virDomainDefParseString().\n     */\n    if (caps_mockup(ctl, xmlStr) != 0)\n        return -1;\n\n    if ((ctl->caps = virCapabilitiesNew(ctl->arch, true, true)) == NULL) {\n        vah_error(ctl, 0, _(\"could not allocate memory\"));\n        return -1;\n    }\n\n    if (!(ctl->xmlopt = virDomainXMLOptionNew(&virAAHelperDomainDefParserConfig,\n                                              NULL, NULL, NULL, NULL))) {\n        vah_error(ctl, 0, _(\"Failed to create XML config object\"));\n        return -1;\n    }\n\n    if ((ostype = virDomainOSTypeFromString(ctl->os)) < 0) {\n        vah_error(ctl, 0, _(\"unknown OS type\"));\n        return -1;\n    }\n\n    if ((guest = virCapabilitiesAddGuest(ctl->caps,\n                                         ostype,\n                                         ctl->arch,\n                                         NULL,\n                                         NULL,\n                                         0,\n                                         NULL)) == NULL) {\n        vah_error(ctl, 0, _(\"could not allocate memory\"));\n        return -1;\n    }\n\n    if ((virtType = virDomainVirtTypeFromString(ctl->virtType)) < 0) {\n        vah_error(ctl, 0, _(\"unknown virtualization type\"));\n        return -1;\n    }\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      virtType,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL) {\n        vah_error(ctl, 0, _(\"could not allocate memory\"));\n        return -1;\n    }\n\n    ctl->def = virDomainDefParseString(xmlStr,\n                                       ctl->xmlopt, NULL,\n                                       VIR_DOMAIN_DEF_PARSE_SKIP_SECLABEL |\n                                       VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n\n    if (ctl->def == NULL) {\n        vah_error(ctl, 0, _(\"could not parse XML\"));\n        return -1;\n    }\n\n    if (!ctl->def->name) {\n        vah_error(ctl, 0, _(\"could not find name in XML\"));\n        return -1;\n    }\n\n    if (valid_name(ctl->def->name) != 0) {\n        vah_error(ctl, 0, _(\"bad name\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "virDomainDefParserConfig virAAHelperDomainDefParserConfig = {\n    .features = VIR_DOMAIN_DEF_FEATURE_MEMORY_HOTPLUG |\n                VIR_DOMAIN_DEF_FEATURE_OFFLINE_VCPUPIN |\n                VIR_DOMAIN_DEF_FEATURE_INDIVIDUAL_VCPUS |\n                VIR_DOMAIN_DEF_FEATURE_NET_MODEL_STRING,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vah_error",
          "args": [
            "ctl",
            "0",
            "_(\"bad name\")"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "vah_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "119-129",
          "snippet": "static void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"bad name\""
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_name",
          "args": [
            "ctl->def->name"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "valid_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "407-421",
          "snippet": "static int\nvalid_name(const char *name)\n{\n    /* just try to filter out any dangerous characters in the name that can be\n     * used to subvert the profile */\n    const char *bad = \"/[]{}?^,\\\"*\";\n\n    if (strlen(name) == 0)\n        return -1;\n\n    if (strcspn(name, bad) != strlen(name))\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvalid_name(const char *name)\n{\n    /* just try to filter out any dangerous characters in the name that can be\n     * used to subvert the profile */\n    const char *bad = \"/[]{}?^,\\\"*\";\n\n    if (strlen(name) == 0)\n        return -1;\n\n    if (strcspn(name, bad) != strlen(name))\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefParseString",
          "args": [
            "xmlStr",
            "ctl->xmlopt",
            "NULL",
            "VIR_DOMAIN_DEF_PARSE_SKIP_SECLABEL |\n                                       VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "22134-22141",
          "snippet": "virDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuestDomain",
          "args": [
            "guest",
            "virtType",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuestDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "485-518",
          "snippet": "virCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainVirtTypeFromString",
          "args": [
            "ctl->virtType"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuest",
          "args": [
            "ctl->caps",
            "ostype",
            "ctl->arch",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "434-470",
          "snippet": "virCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainOSTypeFromString",
          "args": [
            "ctl->os"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainXMLOptionNew",
          "args": [
            "&virAAHelperDomainDefParserConfig",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainXMLOptionNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1415-1458",
          "snippet": "virDomainXMLOptionPtr\nvirDomainXMLOptionNew(virDomainDefParserConfigPtr config,\n                      virDomainXMLPrivateDataCallbacksPtr priv,\n                      virXMLNamespacePtr xmlns,\n                      virDomainABIStabilityPtr abi,\n                      virSaveCookieCallbacksPtr saveCookie)\n{\n    virDomainXMLOptionPtr xmlopt;\n\n    if (virDomainObjInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virDomainXMLOptionClass)))\n        return NULL;\n\n    if (priv)\n        xmlopt->privateData = *priv;\n\n    if (config)\n        xmlopt->config = *config;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    if (abi)\n        xmlopt->abi = *abi;\n\n    if (saveCookie)\n        xmlopt->saveCookie = *saveCookie;\n\n    /* Technically this forbids to use one of Xerox's MAC address prefixes in\n     * our hypervisor drivers. This shouldn't ever be a problem.\n     *\n     * Use the KVM prefix as default as it's in the privately administered\n     * range */\n    if (xmlopt->config.macPrefix[0] == 0 &&\n        xmlopt->config.macPrefix[1] == 0 &&\n        xmlopt->config.macPrefix[2] == 0) {\n        xmlopt->config.macPrefix[0] = 0x52;\n        xmlopt->config.macPrefix[1] = 0x54;\n    }\n\n    return xmlopt;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virDomainXMLOptionClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virClassPtr virDomainXMLOptionClass;\n\nvirDomainXMLOptionPtr\nvirDomainXMLOptionNew(virDomainDefParserConfigPtr config,\n                      virDomainXMLPrivateDataCallbacksPtr priv,\n                      virXMLNamespacePtr xmlns,\n                      virDomainABIStabilityPtr abi,\n                      virSaveCookieCallbacksPtr saveCookie)\n{\n    virDomainXMLOptionPtr xmlopt;\n\n    if (virDomainObjInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virDomainXMLOptionClass)))\n        return NULL;\n\n    if (priv)\n        xmlopt->privateData = *priv;\n\n    if (config)\n        xmlopt->config = *config;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    if (abi)\n        xmlopt->abi = *abi;\n\n    if (saveCookie)\n        xmlopt->saveCookie = *saveCookie;\n\n    /* Technically this forbids to use one of Xerox's MAC address prefixes in\n     * our hypervisor drivers. This shouldn't ever be a problem.\n     *\n     * Use the KVM prefix as default as it's in the privately administered\n     * range */\n    if (xmlopt->config.macPrefix[0] == 0 &&\n        xmlopt->config.macPrefix[1] == 0 &&\n        xmlopt->config.macPrefix[2] == 0) {\n        xmlopt->config.macPrefix[0] = 0x52;\n        xmlopt->config.macPrefix[1] = 0x54;\n    }\n\n    return xmlopt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesNew",
          "args": [
            "ctl->arch",
            "true",
            "true"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "78-96",
          "snippet": "virCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virCapsClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virCapsClass;\n\nvirCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "caps_mockup",
          "args": [
            "ctl",
            "xmlStr"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "caps_mockup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "566-613",
          "snippet": "static int\ncaps_mockup(vahControl * ctl, const char *xmlStr)\n{\n    int rc = -1;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    char *arch;\n\n    if (!(xml = virXMLParseStringCtxt(xmlStr, _(\"(domain_definition)\"),\n                                      &ctxt))) {\n        goto cleanup;\n    }\n\n    if (!virXMLNodeNameEqual(ctxt->node, \"domain\")) {\n        vah_error(NULL, 0, _(\"unexpected root element, expecting <domain>\"));\n        goto cleanup;\n    }\n\n    /* Quick sanity check for some required elements */\n    if (verify_xpath_context(ctxt) != 0)\n        goto cleanup;\n\n    ctl->virtType = virXPathString(\"string(./@type)\", ctxt);\n    if (!ctl->virtType) {\n        vah_error(ctl, 0, _(\"domain type is not defined\"));\n        goto cleanup;\n    }\n    ctl->os = virXPathString(\"string(./os/type[1])\", ctxt);\n    if (!ctl->os) {\n        vah_error(ctl, 0, _(\"os.type is not defined\"));\n        goto cleanup;\n    }\n    arch = virXPathString(\"string(./os/type[1]/@arch)\", ctxt);\n    if (!arch) {\n        ctl->arch = virArchFromHost();\n    } else {\n        ctl->arch = virArchFromString(arch);\n        VIR_FREE(arch);\n    }\n\n    rc = 0;\n\n cleanup:\n    xmlFreeDoc(xml);\n    xmlXPathFreeContext(ctxt);\n\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\ncaps_mockup(vahControl * ctl, const char *xmlStr)\n{\n    int rc = -1;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    char *arch;\n\n    if (!(xml = virXMLParseStringCtxt(xmlStr, _(\"(domain_definition)\"),\n                                      &ctxt))) {\n        goto cleanup;\n    }\n\n    if (!virXMLNodeNameEqual(ctxt->node, \"domain\")) {\n        vah_error(NULL, 0, _(\"unexpected root element, expecting <domain>\"));\n        goto cleanup;\n    }\n\n    /* Quick sanity check for some required elements */\n    if (verify_xpath_context(ctxt) != 0)\n        goto cleanup;\n\n    ctl->virtType = virXPathString(\"string(./@type)\", ctxt);\n    if (!ctl->virtType) {\n        vah_error(ctl, 0, _(\"domain type is not defined\"));\n        goto cleanup;\n    }\n    ctl->os = virXPathString(\"string(./os/type[1])\", ctxt);\n    if (!ctl->os) {\n        vah_error(ctl, 0, _(\"os.type is not defined\"));\n        goto cleanup;\n    }\n    arch = virXPathString(\"string(./os/type[1]/@arch)\", ctxt);\n    if (!arch) {\n        ctl->arch = virArchFromHost();\n    } else {\n        ctl->arch = virArchFromString(arch);\n        VIR_FREE(arch);\n    }\n\n    rc = 0;\n\n cleanup:\n    xmlFreeDoc(xml);\n    xmlXPathFreeContext(ctxt);\n\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nvirDomainDefParserConfig virAAHelperDomainDefParserConfig = {\n    .features = VIR_DOMAIN_DEF_FEATURE_MEMORY_HOTPLUG |\n                VIR_DOMAIN_DEF_FEATURE_OFFLINE_VCPUPIN |\n                VIR_DOMAIN_DEF_FEATURE_INDIVIDUAL_VCPUS |\n                VIR_DOMAIN_DEF_FEATURE_NET_MODEL_STRING,\n};\n\nstatic int\nget_definition(vahControl * ctl, const char *xmlStr)\n{\n    int ostype, virtType;\n    virCapsGuestPtr guest;  /* this is freed when caps is freed */\n\n    /*\n     * mock up some capabilities. We don't currently use these explicitly,\n     * but need them for virDomainDefParseString().\n     */\n    if (caps_mockup(ctl, xmlStr) != 0)\n        return -1;\n\n    if ((ctl->caps = virCapabilitiesNew(ctl->arch, true, true)) == NULL) {\n        vah_error(ctl, 0, _(\"could not allocate memory\"));\n        return -1;\n    }\n\n    if (!(ctl->xmlopt = virDomainXMLOptionNew(&virAAHelperDomainDefParserConfig,\n                                              NULL, NULL, NULL, NULL))) {\n        vah_error(ctl, 0, _(\"Failed to create XML config object\"));\n        return -1;\n    }\n\n    if ((ostype = virDomainOSTypeFromString(ctl->os)) < 0) {\n        vah_error(ctl, 0, _(\"unknown OS type\"));\n        return -1;\n    }\n\n    if ((guest = virCapabilitiesAddGuest(ctl->caps,\n                                         ostype,\n                                         ctl->arch,\n                                         NULL,\n                                         NULL,\n                                         0,\n                                         NULL)) == NULL) {\n        vah_error(ctl, 0, _(\"could not allocate memory\"));\n        return -1;\n    }\n\n    if ((virtType = virDomainVirtTypeFromString(ctl->virtType)) < 0) {\n        vah_error(ctl, 0, _(\"unknown virtualization type\"));\n        return -1;\n    }\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      virtType,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL) {\n        vah_error(ctl, 0, _(\"could not allocate memory\"));\n        return -1;\n    }\n\n    ctl->def = virDomainDefParseString(xmlStr,\n                                       ctl->xmlopt, NULL,\n                                       VIR_DOMAIN_DEF_PARSE_SKIP_SECLABEL |\n                                       VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n\n    if (ctl->def == NULL) {\n        vah_error(ctl, 0, _(\"could not parse XML\"));\n        return -1;\n    }\n\n    if (!ctl->def->name) {\n        vah_error(ctl, 0, _(\"could not find name in XML\"));\n        return -1;\n    }\n\n    if (valid_name(ctl->def->name) != 0) {\n        vah_error(ctl, 0, _(\"bad name\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "caps_mockup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "566-613",
    "snippet": "static int\ncaps_mockup(vahControl * ctl, const char *xmlStr)\n{\n    int rc = -1;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    char *arch;\n\n    if (!(xml = virXMLParseStringCtxt(xmlStr, _(\"(domain_definition)\"),\n                                      &ctxt))) {\n        goto cleanup;\n    }\n\n    if (!virXMLNodeNameEqual(ctxt->node, \"domain\")) {\n        vah_error(NULL, 0, _(\"unexpected root element, expecting <domain>\"));\n        goto cleanup;\n    }\n\n    /* Quick sanity check for some required elements */\n    if (verify_xpath_context(ctxt) != 0)\n        goto cleanup;\n\n    ctl->virtType = virXPathString(\"string(./@type)\", ctxt);\n    if (!ctl->virtType) {\n        vah_error(ctl, 0, _(\"domain type is not defined\"));\n        goto cleanup;\n    }\n    ctl->os = virXPathString(\"string(./os/type[1])\", ctxt);\n    if (!ctl->os) {\n        vah_error(ctl, 0, _(\"os.type is not defined\"));\n        goto cleanup;\n    }\n    arch = virXPathString(\"string(./os/type[1]/@arch)\", ctxt);\n    if (!arch) {\n        ctl->arch = virArchFromHost();\n    } else {\n        ctl->arch = virArchFromString(arch);\n        VIR_FREE(arch);\n    }\n\n    rc = 0;\n\n cleanup:\n    xmlFreeDoc(xml);\n    xmlXPathFreeContext(ctxt);\n\n    return rc;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "ctxt"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xml"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "arch"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchFromString",
          "args": [
            "arch"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "142-152",
          "snippet": "virArch virArchFromString(const char *archstr)\n{\n    size_t i;\n    for (i = 1; i < VIR_ARCH_LAST; i++) {\n        if (STREQ(virArchData[i].name, archstr))\n            return i;\n    }\n\n    VIR_DEBUG(\"Unknown arch %s\", archstr);\n    return VIR_ARCH_NONE;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nvirArch virArchFromString(const char *archstr)\n{\n    size_t i;\n    for (i = 1; i < VIR_ARCH_LAST; i++) {\n        if (STREQ(virArchData[i].name, archstr))\n            return i;\n    }\n\n    VIR_DEBUG(\"Unknown arch %s\", archstr);\n    return VIR_ARCH_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virArchFromHost",
          "args": [],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "206-235",
          "snippet": "virArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nvirArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./os/type[1]/@arch)\"",
            "ctxt"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vah_error",
          "args": [
            "ctl",
            "0",
            "_(\"os.type is not defined\")"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "vah_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "119-129",
          "snippet": "static void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"os.type is not defined\""
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_xpath_context",
          "args": [
            "ctxt"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "verify_xpath_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "531-556",
          "snippet": "static int\nverify_xpath_context(xmlXPathContextPtr ctxt)\n{\n    char *tmp = NULL;\n\n    if (!ctxt) {\n        vah_warning(_(\"Invalid context\"));\n        return -1;\n    }\n\n    /* check if have <name> */\n    if (!(tmp = virXPathString(\"string(./name[1])\", ctxt))) {\n        vah_warning(_(\"Could not find <name>\"));\n        return -1;\n    }\n    VIR_FREE(tmp);\n\n    /* check if have <uuid> */\n    if (!(tmp = virXPathString(\"string(./uuid[1])\", ctxt))) {\n        vah_warning(_(\"Could not find <uuid>\"));\n        return -1;\n    }\n    VIR_FREE(tmp);\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nverify_xpath_context(xmlXPathContextPtr ctxt)\n{\n    char *tmp = NULL;\n\n    if (!ctxt) {\n        vah_warning(_(\"Invalid context\"));\n        return -1;\n    }\n\n    /* check if have <name> */\n    if (!(tmp = virXPathString(\"string(./name[1])\", ctxt))) {\n        vah_warning(_(\"Could not find <name>\"));\n        return -1;\n    }\n    VIR_FREE(tmp);\n\n    /* check if have <uuid> */\n    if (!(tmp = virXPathString(\"string(./uuid[1])\", ctxt))) {\n        vah_warning(_(\"Could not find <uuid>\"));\n        return -1;\n    }\n    VIR_FREE(tmp);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "ctxt->node",
            "\"domain\""
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLParseStringCtxt",
          "args": [
            "xmlStr",
            "_(\"(domain_definition)\")",
            "&ctxt"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\ncaps_mockup(vahControl * ctl, const char *xmlStr)\n{\n    int rc = -1;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    char *arch;\n\n    if (!(xml = virXMLParseStringCtxt(xmlStr, _(\"(domain_definition)\"),\n                                      &ctxt))) {\n        goto cleanup;\n    }\n\n    if (!virXMLNodeNameEqual(ctxt->node, \"domain\")) {\n        vah_error(NULL, 0, _(\"unexpected root element, expecting <domain>\"));\n        goto cleanup;\n    }\n\n    /* Quick sanity check for some required elements */\n    if (verify_xpath_context(ctxt) != 0)\n        goto cleanup;\n\n    ctl->virtType = virXPathString(\"string(./@type)\", ctxt);\n    if (!ctl->virtType) {\n        vah_error(ctl, 0, _(\"domain type is not defined\"));\n        goto cleanup;\n    }\n    ctl->os = virXPathString(\"string(./os/type[1])\", ctxt);\n    if (!ctl->os) {\n        vah_error(ctl, 0, _(\"os.type is not defined\"));\n        goto cleanup;\n    }\n    arch = virXPathString(\"string(./os/type[1]/@arch)\", ctxt);\n    if (!arch) {\n        ctl->arch = virArchFromHost();\n    } else {\n        ctl->arch = virArchFromString(arch);\n        VIR_FREE(arch);\n    }\n\n    rc = 0;\n\n cleanup:\n    xmlFreeDoc(xml);\n    xmlXPathFreeContext(ctxt);\n\n    return rc;\n}"
  },
  {
    "function_name": "verify_xpath_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "531-556",
    "snippet": "static int\nverify_xpath_context(xmlXPathContextPtr ctxt)\n{\n    char *tmp = NULL;\n\n    if (!ctxt) {\n        vah_warning(_(\"Invalid context\"));\n        return -1;\n    }\n\n    /* check if have <name> */\n    if (!(tmp = virXPathString(\"string(./name[1])\", ctxt))) {\n        vah_warning(_(\"Could not find <name>\"));\n        return -1;\n    }\n    VIR_FREE(tmp);\n\n    /* check if have <uuid> */\n    if (!(tmp = virXPathString(\"string(./uuid[1])\", ctxt))) {\n        vah_warning(_(\"Could not find <uuid>\"));\n        return -1;\n    }\n    VIR_FREE(tmp);\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vah_warning",
          "args": [
            "_(\"Could not find <uuid>\")"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "vah_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "131-135",
          "snippet": "static void\nvah_warning(const char *str)\n{\n    fprintf(stderr, _(\"%s: warning: %s%c\"), progname, str, '\\n');\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_warning(const char *str)\n{\n    fprintf(stderr, _(\"%s: warning: %s%c\"), progname, str, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find <uuid>\""
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./uuid[1])\"",
            "ctxt"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nverify_xpath_context(xmlXPathContextPtr ctxt)\n{\n    char *tmp = NULL;\n\n    if (!ctxt) {\n        vah_warning(_(\"Invalid context\"));\n        return -1;\n    }\n\n    /* check if have <name> */\n    if (!(tmp = virXPathString(\"string(./name[1])\", ctxt))) {\n        vah_warning(_(\"Could not find <name>\"));\n        return -1;\n    }\n    VIR_FREE(tmp);\n\n    /* check if have <uuid> */\n    if (!(tmp = virXPathString(\"string(./uuid[1])\", ctxt))) {\n        vah_warning(_(\"Could not find <uuid>\"));\n        return -1;\n    }\n    VIR_FREE(tmp);\n\n    return 0;\n}"
  },
  {
    "function_name": "valid_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "450-529",
    "snippet": "static int\nvalid_path(const char *path, const bool readonly)\n{\n    const char * const restricted[] = {\n        \"/bin/\",\n        \"/etc/\",\n        \"/lib\",\n        \"/lost+found/\",\n        \"/proc/\",\n        \"/sbin/\",\n        \"/selinux/\",\n        \"/sys/\",\n        \"/usr/bin/\",\n        \"/usr/lib\",\n        \"/usr/sbin/\",\n        \"/usr/share/\",\n        \"/usr/local/bin/\",\n        \"/usr/local/etc/\",\n        \"/usr/local/lib\",\n        \"/usr/local/sbin/\"\n    };\n    /* these paths are ok for readonly, but not read/write */\n    const char * const restricted_rw[] = {\n        \"/boot/\",\n        \"/vmlinuz\",\n        \"/initrd\",\n        \"/initrd.img\",\n        \"/usr/share/edk2/\",\n        \"/usr/share/OVMF/\",              /* for OVMF images */\n        \"/usr/share/ovmf/\",              /* for OVMF images */\n        \"/usr/share/AAVMF/\",             /* for AAVMF images */\n        \"/usr/share/qemu-efi/\",          /* for AAVMF images */\n        \"/usr/share/qemu-efi-aarch64/\"   /* for AAVMF images */\n    };\n    /* override the above with these */\n    const char * const override[] = {\n        \"/sys/devices/pci\",                /* for hostdev pci devices */\n        \"/sys/kernel/config/target/vhost\", /* for hostdev vhost_scsi devices */\n        \"/etc/libvirt-sandbox/services/\"   /* for virt-sandbox service config */\n    };\n\n    const int nropaths = G_N_ELEMENTS(restricted);\n    const int nrwpaths = G_N_ELEMENTS(restricted_rw);\n    const int nopaths = G_N_ELEMENTS(override);\n\n    if (path == NULL) {\n        vah_error(NULL, 0, _(\"bad pathname\"));\n        return -1;\n    }\n\n    /* Don't allow double quotes, since we use them to quote the filename\n     * and this will confuse the apparmor parser.\n     */\n    if (strchr(path, '\"') != NULL)\n        return 1;\n\n    /* Require an absolute path */\n    if (STRNEQLEN(path, \"/\", 1))\n        return 1;\n\n    if (!virFileExists(path))\n        vah_warning(_(\"path does not exist, skipping file type checks\"));\n\n    /* overrides are always allowed */\n    if (array_starts_with(path, override, nopaths) == 0)\n        return 0;\n\n    /* allow read only paths upfront */\n    if (readonly) {\n        if (array_starts_with(path, restricted_rw, nrwpaths) == 0)\n            return 0;\n    }\n\n    /* disallow RW access to all paths in restricted and restriced_rw */\n    if ((array_starts_with(path, restricted, nropaths) == 0 ||\n         array_starts_with(path, restricted_rw, nrwpaths) == 0))\n        return 1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_starts_with",
          "args": [
            "path",
            "restricted_rw",
            "nrwpaths"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "array_starts_with",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "424-436",
          "snippet": "static int\narray_starts_with(const char *str, const char * const *arr, const long size)\n{\n    size_t i;\n    for (i = 0; i < size; i++) {\n        if (strlen(str) < strlen(arr[i]))\n            continue;\n\n        if (STRPREFIX(str, arr[i]))\n            return 0;\n    }\n    return 1;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\narray_starts_with(const char *str, const char * const *arr, const long size)\n{\n    size_t i;\n    for (i = 0; i < size; i++) {\n        if (strlen(str) < strlen(arr[i]))\n            continue;\n\n        if (STRPREFIX(str, arr[i]))\n            return 0;\n    }\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vah_warning",
          "args": [
            "_(\"path does not exist, skipping file type checks\")"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "vah_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "131-135",
          "snippet": "static void\nvah_warning(const char *str)\n{\n    fprintf(stderr, _(\"%s: warning: %s%c\"), progname, str, '\\n');\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_warning(const char *str)\n{\n    fprintf(stderr, _(\"%s: warning: %s%c\"), progname, str, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"path does not exist, skipping file type checks\""
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "path"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQLEN",
          "args": [
            "path",
            "\"/\"",
            "1"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "path",
            "'\"'"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vah_error",
          "args": [
            "NULL",
            "0",
            "_(\"bad pathname\")"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "vah_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "119-129",
          "snippet": "static void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "override"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "restricted_rw"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "restricted"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvalid_path(const char *path, const bool readonly)\n{\n    const char * const restricted[] = {\n        \"/bin/\",\n        \"/etc/\",\n        \"/lib\",\n        \"/lost+found/\",\n        \"/proc/\",\n        \"/sbin/\",\n        \"/selinux/\",\n        \"/sys/\",\n        \"/usr/bin/\",\n        \"/usr/lib\",\n        \"/usr/sbin/\",\n        \"/usr/share/\",\n        \"/usr/local/bin/\",\n        \"/usr/local/etc/\",\n        \"/usr/local/lib\",\n        \"/usr/local/sbin/\"\n    };\n    /* these paths are ok for readonly, but not read/write */\n    const char * const restricted_rw[] = {\n        \"/boot/\",\n        \"/vmlinuz\",\n        \"/initrd\",\n        \"/initrd.img\",\n        \"/usr/share/edk2/\",\n        \"/usr/share/OVMF/\",              /* for OVMF images */\n        \"/usr/share/ovmf/\",              /* for OVMF images */\n        \"/usr/share/AAVMF/\",             /* for AAVMF images */\n        \"/usr/share/qemu-efi/\",          /* for AAVMF images */\n        \"/usr/share/qemu-efi-aarch64/\"   /* for AAVMF images */\n    };\n    /* override the above with these */\n    const char * const override[] = {\n        \"/sys/devices/pci\",                /* for hostdev pci devices */\n        \"/sys/kernel/config/target/vhost\", /* for hostdev vhost_scsi devices */\n        \"/etc/libvirt-sandbox/services/\"   /* for virt-sandbox service config */\n    };\n\n    const int nropaths = G_N_ELEMENTS(restricted);\n    const int nrwpaths = G_N_ELEMENTS(restricted_rw);\n    const int nopaths = G_N_ELEMENTS(override);\n\n    if (path == NULL) {\n        vah_error(NULL, 0, _(\"bad pathname\"));\n        return -1;\n    }\n\n    /* Don't allow double quotes, since we use them to quote the filename\n     * and this will confuse the apparmor parser.\n     */\n    if (strchr(path, '\"') != NULL)\n        return 1;\n\n    /* Require an absolute path */\n    if (STRNEQLEN(path, \"/\", 1))\n        return 1;\n\n    if (!virFileExists(path))\n        vah_warning(_(\"path does not exist, skipping file type checks\"));\n\n    /* overrides are always allowed */\n    if (array_starts_with(path, override, nopaths) == 0)\n        return 0;\n\n    /* allow read only paths upfront */\n    if (readonly) {\n        if (array_starts_with(path, restricted_rw, nrwpaths) == 0)\n            return 0;\n    }\n\n    /* disallow RW access to all paths in restricted and restriced_rw */\n    if ((array_starts_with(path, restricted, nropaths) == 0 ||\n         array_starts_with(path, restricted_rw, nrwpaths) == 0))\n        return 1;\n\n    return 0;\n}"
  },
  {
    "function_name": "array_starts_with",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "424-436",
    "snippet": "static int\narray_starts_with(const char *str, const char * const *arr, const long size)\n{\n    size_t i;\n    for (i = 0; i < size; i++) {\n        if (strlen(str) < strlen(arr[i]))\n            continue;\n\n        if (STRPREFIX(str, arr[i]))\n            return 0;\n    }\n    return 1;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "str",
            "arr[i]"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "arr[i]"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\narray_starts_with(const char *str, const char * const *arr, const long size)\n{\n    size_t i;\n    for (i = 0; i < size; i++) {\n        if (strlen(str) < strlen(arr[i]))\n            continue;\n\n        if (STRPREFIX(str, arr[i]))\n            return 0;\n    }\n    return 1;\n}"
  },
  {
    "function_name": "valid_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "407-421",
    "snippet": "static int\nvalid_name(const char *name)\n{\n    /* just try to filter out any dangerous characters in the name that can be\n     * used to subvert the profile */\n    const char *bad = \"/[]{}?^,\\\"*\";\n\n    if (strlen(name) == 0)\n        return -1;\n\n    if (strcspn(name, bad) != strlen(name))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcspn",
          "args": [
            "name",
            "bad"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvalid_name(const char *name)\n{\n    /* just try to filter out any dangerous characters in the name that can be\n     * used to subvert the profile */\n    const char *bad = \"/[]{}?^,\\\"*\";\n\n    if (strlen(name) == 0)\n        return -1;\n\n    if (strcspn(name, bad) != strlen(name))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "valid_uuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "390-405",
    "snippet": "static int\nvalid_uuid(const char *uuid)\n{\n    unsigned char rawuuid[VIR_UUID_BUFLEN];\n\n    if (strlen(uuid) != PROFILE_NAME_SIZE - 1)\n        return -1;\n\n    if (!STRPREFIX(uuid, AA_PREFIX))\n        return -1;\n\n    if (virUUIDParse(uuid + strlen(AA_PREFIX), rawuuid) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "uuid + strlen(AA_PREFIX)",
            "rawuuid"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "AA_PREFIX"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "uuid",
            "AA_PREFIX"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "uuid"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvalid_uuid(const char *uuid)\n{\n    unsigned char rawuuid[VIR_UUID_BUFLEN];\n\n    if (strlen(uuid) != PROFILE_NAME_SIZE - 1)\n        return -1;\n\n    if (!STRPREFIX(uuid, AA_PREFIX))\n        return -1;\n\n    if (virUUIDParse(uuid + strlen(AA_PREFIX), rawuuid) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "parserReplace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "384-388",
    "snippet": "static int\nparserReplace(const char *profile_name)\n{\n    return parserCommand(profile_name, 'r');\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parserCommand",
          "args": [
            "profile_name",
            "'r'"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "parserCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "146-195",
          "snippet": "static int\nparserCommand(const char *profile_name, const char cmd)\n{\n    int result = -1;\n    char flag[3];\n    char *profile;\n    int status;\n    int ret;\n\n    if (strchr(\"arR\", cmd) == NULL) {\n        vah_error(NULL, 0, _(\"invalid flag\"));\n        return -1;\n    }\n\n    g_snprintf(flag, 3, \"-%c\", cmd);\n\n    profile = g_strdup_printf(\"%s/%s\", APPARMOR_DIR \"/libvirt\", profile_name);\n\n    if (!virFileExists(profile)) {\n        vah_error(NULL, 0, _(\"profile does not exist\"));\n        goto cleanup;\n    } else {\n        const char * const argv[] = {\n            \"/sbin/apparmor_parser\", flag, profile, NULL\n        };\n        g_autoptr(virCommand) command = virCommandNewArgs(argv);\n\n        virCommandRawStatus(command);\n        if ((ret = virCommandRun(command, &status)) != 0 ||\n            (WIFEXITED(status) && WEXITSTATUS(status) != 0)) {\n            if (ret != 0) {\n                vah_error(NULL, 0, _(\"failed to run apparmor_parser\"));\n                goto cleanup;\n            } else if (cmd == 'R' && WIFEXITED(status) &&\n                       WEXITSTATUS(status) == 234) {\n                vah_warning(_(\"unable to unload already unloaded profile\"));\n            } else {\n                vah_error(NULL, 0, _(\"apparmor_parser exited with error\"));\n                goto cleanup;\n            }\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(profile);\n\n    return result;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nparserCommand(const char *profile_name, const char cmd)\n{\n    int result = -1;\n    char flag[3];\n    char *profile;\n    int status;\n    int ret;\n\n    if (strchr(\"arR\", cmd) == NULL) {\n        vah_error(NULL, 0, _(\"invalid flag\"));\n        return -1;\n    }\n\n    g_snprintf(flag, 3, \"-%c\", cmd);\n\n    profile = g_strdup_printf(\"%s/%s\", APPARMOR_DIR \"/libvirt\", profile_name);\n\n    if (!virFileExists(profile)) {\n        vah_error(NULL, 0, _(\"profile does not exist\"));\n        goto cleanup;\n    } else {\n        const char * const argv[] = {\n            \"/sbin/apparmor_parser\", flag, profile, NULL\n        };\n        g_autoptr(virCommand) command = virCommandNewArgs(argv);\n\n        virCommandRawStatus(command);\n        if ((ret = virCommandRun(command, &status)) != 0 ||\n            (WIFEXITED(status) && WEXITSTATUS(status) != 0)) {\n            if (ret != 0) {\n                vah_error(NULL, 0, _(\"failed to run apparmor_parser\"));\n                goto cleanup;\n            } else if (cmd == 'R' && WIFEXITED(status) &&\n                       WEXITSTATUS(status) == 234) {\n                vah_warning(_(\"unable to unload already unloaded profile\"));\n            } else {\n                vah_error(NULL, 0, _(\"apparmor_parser exited with error\"));\n                goto cleanup;\n            }\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(profile);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nparserReplace(const char *profile_name)\n{\n    return parserCommand(profile_name, 'r');\n}"
  },
  {
    "function_name": "parserRemove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "375-379",
    "snippet": "static int\nparserRemove(const char *profile_name)\n{\n    return parserCommand(profile_name, 'R');\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parserCommand",
          "args": [
            "profile_name",
            "'R'"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "parserCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "146-195",
          "snippet": "static int\nparserCommand(const char *profile_name, const char cmd)\n{\n    int result = -1;\n    char flag[3];\n    char *profile;\n    int status;\n    int ret;\n\n    if (strchr(\"arR\", cmd) == NULL) {\n        vah_error(NULL, 0, _(\"invalid flag\"));\n        return -1;\n    }\n\n    g_snprintf(flag, 3, \"-%c\", cmd);\n\n    profile = g_strdup_printf(\"%s/%s\", APPARMOR_DIR \"/libvirt\", profile_name);\n\n    if (!virFileExists(profile)) {\n        vah_error(NULL, 0, _(\"profile does not exist\"));\n        goto cleanup;\n    } else {\n        const char * const argv[] = {\n            \"/sbin/apparmor_parser\", flag, profile, NULL\n        };\n        g_autoptr(virCommand) command = virCommandNewArgs(argv);\n\n        virCommandRawStatus(command);\n        if ((ret = virCommandRun(command, &status)) != 0 ||\n            (WIFEXITED(status) && WEXITSTATUS(status) != 0)) {\n            if (ret != 0) {\n                vah_error(NULL, 0, _(\"failed to run apparmor_parser\"));\n                goto cleanup;\n            } else if (cmd == 'R' && WIFEXITED(status) &&\n                       WEXITSTATUS(status) == 234) {\n                vah_warning(_(\"unable to unload already unloaded profile\"));\n            } else {\n                vah_error(NULL, 0, _(\"apparmor_parser exited with error\"));\n                goto cleanup;\n            }\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(profile);\n\n    return result;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nparserCommand(const char *profile_name, const char cmd)\n{\n    int result = -1;\n    char flag[3];\n    char *profile;\n    int status;\n    int ret;\n\n    if (strchr(\"arR\", cmd) == NULL) {\n        vah_error(NULL, 0, _(\"invalid flag\"));\n        return -1;\n    }\n\n    g_snprintf(flag, 3, \"-%c\", cmd);\n\n    profile = g_strdup_printf(\"%s/%s\", APPARMOR_DIR \"/libvirt\", profile_name);\n\n    if (!virFileExists(profile)) {\n        vah_error(NULL, 0, _(\"profile does not exist\"));\n        goto cleanup;\n    } else {\n        const char * const argv[] = {\n            \"/sbin/apparmor_parser\", flag, profile, NULL\n        };\n        g_autoptr(virCommand) command = virCommandNewArgs(argv);\n\n        virCommandRawStatus(command);\n        if ((ret = virCommandRun(command, &status)) != 0 ||\n            (WIFEXITED(status) && WEXITSTATUS(status) != 0)) {\n            if (ret != 0) {\n                vah_error(NULL, 0, _(\"failed to run apparmor_parser\"));\n                goto cleanup;\n            } else if (cmd == 'R' && WIFEXITED(status) &&\n                       WEXITSTATUS(status) == 234) {\n                vah_warning(_(\"unable to unload already unloaded profile\"));\n            } else {\n                vah_error(NULL, 0, _(\"apparmor_parser exited with error\"));\n                goto cleanup;\n            }\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(profile);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nparserRemove(const char *profile_name)\n{\n    return parserCommand(profile_name, 'R');\n}"
  },
  {
    "function_name": "parserLoad",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "366-370",
    "snippet": "static int\nparserLoad(const char *profile_name)\n{\n    return parserCommand(profile_name, 'a');\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parserCommand",
          "args": [
            "profile_name",
            "'a'"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "parserCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "146-195",
          "snippet": "static int\nparserCommand(const char *profile_name, const char cmd)\n{\n    int result = -1;\n    char flag[3];\n    char *profile;\n    int status;\n    int ret;\n\n    if (strchr(\"arR\", cmd) == NULL) {\n        vah_error(NULL, 0, _(\"invalid flag\"));\n        return -1;\n    }\n\n    g_snprintf(flag, 3, \"-%c\", cmd);\n\n    profile = g_strdup_printf(\"%s/%s\", APPARMOR_DIR \"/libvirt\", profile_name);\n\n    if (!virFileExists(profile)) {\n        vah_error(NULL, 0, _(\"profile does not exist\"));\n        goto cleanup;\n    } else {\n        const char * const argv[] = {\n            \"/sbin/apparmor_parser\", flag, profile, NULL\n        };\n        g_autoptr(virCommand) command = virCommandNewArgs(argv);\n\n        virCommandRawStatus(command);\n        if ((ret = virCommandRun(command, &status)) != 0 ||\n            (WIFEXITED(status) && WEXITSTATUS(status) != 0)) {\n            if (ret != 0) {\n                vah_error(NULL, 0, _(\"failed to run apparmor_parser\"));\n                goto cleanup;\n            } else if (cmd == 'R' && WIFEXITED(status) &&\n                       WEXITSTATUS(status) == 234) {\n                vah_warning(_(\"unable to unload already unloaded profile\"));\n            } else {\n                vah_error(NULL, 0, _(\"apparmor_parser exited with error\"));\n                goto cleanup;\n            }\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(profile);\n\n    return result;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nparserCommand(const char *profile_name, const char cmd)\n{\n    int result = -1;\n    char flag[3];\n    char *profile;\n    int status;\n    int ret;\n\n    if (strchr(\"arR\", cmd) == NULL) {\n        vah_error(NULL, 0, _(\"invalid flag\"));\n        return -1;\n    }\n\n    g_snprintf(flag, 3, \"-%c\", cmd);\n\n    profile = g_strdup_printf(\"%s/%s\", APPARMOR_DIR \"/libvirt\", profile_name);\n\n    if (!virFileExists(profile)) {\n        vah_error(NULL, 0, _(\"profile does not exist\"));\n        goto cleanup;\n    } else {\n        const char * const argv[] = {\n            \"/sbin/apparmor_parser\", flag, profile, NULL\n        };\n        g_autoptr(virCommand) command = virCommandNewArgs(argv);\n\n        virCommandRawStatus(command);\n        if ((ret = virCommandRun(command, &status)) != 0 ||\n            (WIFEXITED(status) && WEXITSTATUS(status) != 0)) {\n            if (ret != 0) {\n                vah_error(NULL, 0, _(\"failed to run apparmor_parser\"));\n                goto cleanup;\n            } else if (cmd == 'R' && WIFEXITED(status) &&\n                       WEXITSTATUS(status) == 234) {\n                vah_warning(_(\"unable to unload already unloaded profile\"));\n            } else {\n                vah_error(NULL, 0, _(\"apparmor_parser exited with error\"));\n                goto cleanup;\n            }\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(profile);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nparserLoad(const char *profile_name)\n{\n    return parserCommand(profile_name, 'a');\n}"
  },
  {
    "function_name": "create_profile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "263-361",
    "snippet": "static int\ncreate_profile(const char *profile, const char *profile_name,\n               const char *profile_files, int virtType)\n{\n    g_autofree char *template = NULL;\n    g_autofree char *tcontent = NULL;\n    g_autofree char *pcontent = NULL;\n    g_autofree char *replace_name = NULL;\n    g_autofree char *replace_files = NULL;\n    char *tmp = NULL;\n    const char *template_name = \"\\nprofile LIBVIRT_TEMPLATE\";\n    const char *template_end = \"\\n}\";\n    int tlen, plen;\n    int fd;\n    const char *driver_name = NULL;\n\n    if (virFileExists(profile)) {\n        vah_error(NULL, 0, _(\"profile exists\"));\n        return -1;\n    }\n\n    switch (virtType) {\n    case VIR_DOMAIN_VIRT_QEMU:\n    case VIR_DOMAIN_VIRT_KQEMU:\n    case VIR_DOMAIN_VIRT_KVM:\n        driver_name = \"qemu\";\n        break;\n    default:\n        driver_name = virDomainVirtTypeToString(virtType);\n    }\n\n    template = g_strdup_printf(\"%s/TEMPLATE.%s\", APPARMOR_DIR \"/libvirt\", driver_name);\n\n    if (!virFileExists(template)) {\n        vah_error(NULL, 0, _(\"template does not exist\"));\n        return -1;\n    }\n\n    if ((tlen = virFileReadAll(template, MAX_FILE_LEN, &tcontent)) < 0) {\n        vah_error(NULL, 0, _(\"failed to read AppArmor template\"));\n        return -1;\n    }\n\n    if (strstr(tcontent, template_name) == NULL) {\n        vah_error(NULL, 0, _(\"no replacement string in template\"));\n        return -1;\n    }\n\n    if (strstr(tcontent, template_end) == NULL) {\n        vah_error(NULL, 0, _(\"no replacement string in template\"));\n        return -1;\n    }\n\n    /* '\\nprofile <profile_name>\\0' */\n    replace_name = g_strdup_printf(\"\\nprofile %s\", profile_name);\n\n    /* '\\n<profile_files>\\n}\\0' */\n    if (virtType != VIR_DOMAIN_VIRT_LXC)\n    replace_files = g_strdup_printf(\"\\n%s\\n}\", profile_files);\n\n    plen = tlen + strlen(replace_name) - strlen(template_name) + 1;\n\n    if (virtType != VIR_DOMAIN_VIRT_LXC)\n        plen += strlen(replace_files) - strlen(template_end);\n\n    if (plen > MAX_FILE_LEN || plen < tlen) {\n        vah_error(NULL, 0, _(\"invalid length for new profile\"));\n        return -1;\n    }\n\n    if (!(pcontent = virStringReplace(tcontent, template_name, replace_name)))\n        return -1;\n\n    if (virtType != VIR_DOMAIN_VIRT_LXC) {\n        if (!(tmp = virStringReplace(pcontent, template_end, replace_files)))\n            return -1;\n        VIR_FREE(pcontent);\n        pcontent = g_steal_pointer(&tmp);\n    }\n\n    /* write the file */\n    if ((fd = open(profile, O_CREAT | O_EXCL | O_WRONLY, 0644)) == -1) {\n        vah_error(NULL, 0, _(\"failed to create profile\"));\n        return -1;\n    }\n\n    if (safewrite(fd, pcontent, plen - 1) < 0) { /* don't write the '\\0' */\n        VIR_FORCE_CLOSE(fd);\n        vah_error(NULL, 0, _(\"failed to write to profile\"));\n        return -1;\n    }\n\n    if (VIR_CLOSE(fd) != 0) {\n        vah_error(NULL, 0, _(\"failed to close or write to profile\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vah_error",
          "args": [
            "NULL",
            "0",
            "_(\"failed to close or write to profile\")"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "vah_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "119-129",
          "snippet": "static void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to close or write to profile\""
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "fd"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "fd",
            "pcontent",
            "plen - 1"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "profile",
            "O_CREAT | O_EXCL | O_WRONLY",
            "0644"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3308-3323",
          "snippet": "int\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&tmp"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pcontent"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringReplace",
          "args": [
            "pcontent",
            "template_end",
            "replace_files"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "virStringReplace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1067-1095",
          "snippet": "char *\nvirStringReplace(const char *haystack,\n                 const char *oldneedle,\n                 const char *newneedle)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *tmp1, *tmp2;\n    size_t oldneedlelen = strlen(oldneedle);\n    size_t newneedlelen = strlen(newneedle);\n\n    tmp1 = haystack;\n    tmp2 = NULL;\n\n    while (tmp1) {\n        tmp2 = strstr(tmp1, oldneedle);\n\n        if (tmp2) {\n            virBufferAdd(&buf, tmp1, (tmp2 - tmp1));\n            virBufferAdd(&buf, newneedle, newneedlelen);\n            tmp2 += oldneedlelen;\n        } else {\n            virBufferAdd(&buf, tmp1, -1);\n        }\n\n        tmp1 = tmp2;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar *\nvirStringReplace(const char *haystack,\n                 const char *oldneedle,\n                 const char *newneedle)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *tmp1, *tmp2;\n    size_t oldneedlelen = strlen(oldneedle);\n    size_t newneedlelen = strlen(newneedle);\n\n    tmp1 = haystack;\n    tmp2 = NULL;\n\n    while (tmp1) {\n        tmp2 = strstr(tmp1, oldneedle);\n\n        if (tmp2) {\n            virBufferAdd(&buf, tmp1, (tmp2 - tmp1));\n            virBufferAdd(&buf, newneedle, newneedlelen);\n            tmp2 += oldneedlelen;\n        } else {\n            virBufferAdd(&buf, tmp1, -1);\n        }\n\n        tmp1 = tmp2;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "template_end"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "replace_files"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "template_name"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "replace_name"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"\\n%s\\n}\"",
            "profile_files"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "tcontent",
            "template_end"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "tcontent",
            "template_name"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "template",
            "MAX_FILE_LEN",
            "&tcontent"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "template"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainVirtTypeToString",
          "args": [
            "virtType"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\ncreate_profile(const char *profile, const char *profile_name,\n               const char *profile_files, int virtType)\n{\n    g_autofree char *template = NULL;\n    g_autofree char *tcontent = NULL;\n    g_autofree char *pcontent = NULL;\n    g_autofree char *replace_name = NULL;\n    g_autofree char *replace_files = NULL;\n    char *tmp = NULL;\n    const char *template_name = \"\\nprofile LIBVIRT_TEMPLATE\";\n    const char *template_end = \"\\n}\";\n    int tlen, plen;\n    int fd;\n    const char *driver_name = NULL;\n\n    if (virFileExists(profile)) {\n        vah_error(NULL, 0, _(\"profile exists\"));\n        return -1;\n    }\n\n    switch (virtType) {\n    case VIR_DOMAIN_VIRT_QEMU:\n    case VIR_DOMAIN_VIRT_KQEMU:\n    case VIR_DOMAIN_VIRT_KVM:\n        driver_name = \"qemu\";\n        break;\n    default:\n        driver_name = virDomainVirtTypeToString(virtType);\n    }\n\n    template = g_strdup_printf(\"%s/TEMPLATE.%s\", APPARMOR_DIR \"/libvirt\", driver_name);\n\n    if (!virFileExists(template)) {\n        vah_error(NULL, 0, _(\"template does not exist\"));\n        return -1;\n    }\n\n    if ((tlen = virFileReadAll(template, MAX_FILE_LEN, &tcontent)) < 0) {\n        vah_error(NULL, 0, _(\"failed to read AppArmor template\"));\n        return -1;\n    }\n\n    if (strstr(tcontent, template_name) == NULL) {\n        vah_error(NULL, 0, _(\"no replacement string in template\"));\n        return -1;\n    }\n\n    if (strstr(tcontent, template_end) == NULL) {\n        vah_error(NULL, 0, _(\"no replacement string in template\"));\n        return -1;\n    }\n\n    /* '\\nprofile <profile_name>\\0' */\n    replace_name = g_strdup_printf(\"\\nprofile %s\", profile_name);\n\n    /* '\\n<profile_files>\\n}\\0' */\n    if (virtType != VIR_DOMAIN_VIRT_LXC)\n    replace_files = g_strdup_printf(\"\\n%s\\n}\", profile_files);\n\n    plen = tlen + strlen(replace_name) - strlen(template_name) + 1;\n\n    if (virtType != VIR_DOMAIN_VIRT_LXC)\n        plen += strlen(replace_files) - strlen(template_end);\n\n    if (plen > MAX_FILE_LEN || plen < tlen) {\n        vah_error(NULL, 0, _(\"invalid length for new profile\"));\n        return -1;\n    }\n\n    if (!(pcontent = virStringReplace(tcontent, template_name, replace_name)))\n        return -1;\n\n    if (virtType != VIR_DOMAIN_VIRT_LXC) {\n        if (!(tmp = virStringReplace(pcontent, template_end, replace_files)))\n            return -1;\n        VIR_FREE(pcontent);\n        pcontent = g_steal_pointer(&tmp);\n    }\n\n    /* write the file */\n    if ((fd = open(profile, O_CREAT | O_EXCL | O_WRONLY, 0644)) == -1) {\n        vah_error(NULL, 0, _(\"failed to create profile\"));\n        return -1;\n    }\n\n    if (safewrite(fd, pcontent, plen - 1) < 0) { /* don't write the '\\0' */\n        VIR_FORCE_CLOSE(fd);\n        vah_error(NULL, 0, _(\"failed to write to profile\"));\n        return -1;\n    }\n\n    if (VIR_CLOSE(fd) != 0) {\n        vah_error(NULL, 0, _(\"failed to close or write to profile\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "update_include_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "200-258",
    "snippet": "static int\nupdate_include_file(const char *include_file, const char *included_files,\n                    bool append)\n{\n    int rc = -1;\n    int plen, flen = 0;\n    int fd;\n    char *pcontent = NULL;\n    char *existing = NULL;\n    const char *warning =\n         \"# DO NOT EDIT THIS FILE DIRECTLY. IT IS MANAGED BY LIBVIRT.\\n\";\n\n    if (virFileExists(include_file)) {\n        flen = virFileReadAll(include_file, MAX_FILE_LEN, &existing);\n        if (flen < 0)\n            return rc;\n    }\n\n    if (append && virFileExists(include_file))\n        pcontent = g_strdup_printf(\"%s%s\", existing, included_files);\n    else\n        pcontent = g_strdup_printf(\"%s%s\", warning, included_files);\n\n    plen = strlen(pcontent);\n    if (plen > MAX_FILE_LEN) {\n        vah_error(NULL, 0, _(\"invalid length for new profile\"));\n        goto cleanup;\n    }\n\n    /* only update the disk profile if it is different */\n    if (flen > 0 && flen == plen && STREQLEN(existing, pcontent, plen)) {\n        rc = 0;\n        goto cleanup;\n    }\n\n    /* write the file */\n    if ((fd = open(include_file, O_CREAT | O_TRUNC | O_WRONLY, 0644)) == -1) {\n        vah_error(NULL, 0, _(\"failed to create include file\"));\n        goto cleanup;\n    }\n\n    if (safewrite(fd, pcontent, plen) < 0) { /* don't write the '\\0' */\n        VIR_FORCE_CLOSE(fd);\n        vah_error(NULL, 0, _(\"failed to write to profile\"));\n        goto cleanup;\n    }\n\n    if (VIR_CLOSE(fd) != 0) {\n        vah_error(NULL, 0, _(\"failed to close or write to profile\"));\n        goto cleanup;\n    }\n    rc = 0;\n\n cleanup:\n    VIR_FREE(pcontent);\n    VIR_FREE(existing);\n\n    return rc;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "existing"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pcontent"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vah_error",
          "args": [
            "NULL",
            "0",
            "_(\"failed to close or write to profile\")"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "vah_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "119-129",
          "snippet": "static void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to close or write to profile\""
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "fd"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "fd",
            "pcontent",
            "plen"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "include_file",
            "O_CREAT | O_TRUNC | O_WRONLY",
            "0644"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3308-3323",
          "snippet": "int\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQLEN",
          "args": [
            "existing",
            "pcontent",
            "plen"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pcontent"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s%s\"",
            "warning",
            "included_files"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "include_file"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "include_file",
            "MAX_FILE_LEN",
            "&existing"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nupdate_include_file(const char *include_file, const char *included_files,\n                    bool append)\n{\n    int rc = -1;\n    int plen, flen = 0;\n    int fd;\n    char *pcontent = NULL;\n    char *existing = NULL;\n    const char *warning =\n         \"# DO NOT EDIT THIS FILE DIRECTLY. IT IS MANAGED BY LIBVIRT.\\n\";\n\n    if (virFileExists(include_file)) {\n        flen = virFileReadAll(include_file, MAX_FILE_LEN, &existing);\n        if (flen < 0)\n            return rc;\n    }\n\n    if (append && virFileExists(include_file))\n        pcontent = g_strdup_printf(\"%s%s\", existing, included_files);\n    else\n        pcontent = g_strdup_printf(\"%s%s\", warning, included_files);\n\n    plen = strlen(pcontent);\n    if (plen > MAX_FILE_LEN) {\n        vah_error(NULL, 0, _(\"invalid length for new profile\"));\n        goto cleanup;\n    }\n\n    /* only update the disk profile if it is different */\n    if (flen > 0 && flen == plen && STREQLEN(existing, pcontent, plen)) {\n        rc = 0;\n        goto cleanup;\n    }\n\n    /* write the file */\n    if ((fd = open(include_file, O_CREAT | O_TRUNC | O_WRONLY, 0644)) == -1) {\n        vah_error(NULL, 0, _(\"failed to create include file\"));\n        goto cleanup;\n    }\n\n    if (safewrite(fd, pcontent, plen) < 0) { /* don't write the '\\0' */\n        VIR_FORCE_CLOSE(fd);\n        vah_error(NULL, 0, _(\"failed to write to profile\"));\n        goto cleanup;\n    }\n\n    if (VIR_CLOSE(fd) != 0) {\n        vah_error(NULL, 0, _(\"failed to close or write to profile\"));\n        goto cleanup;\n    }\n    rc = 0;\n\n cleanup:\n    VIR_FREE(pcontent);\n    VIR_FREE(existing);\n\n    return rc;\n}"
  },
  {
    "function_name": "parserCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "146-195",
    "snippet": "static int\nparserCommand(const char *profile_name, const char cmd)\n{\n    int result = -1;\n    char flag[3];\n    char *profile;\n    int status;\n    int ret;\n\n    if (strchr(\"arR\", cmd) == NULL) {\n        vah_error(NULL, 0, _(\"invalid flag\"));\n        return -1;\n    }\n\n    g_snprintf(flag, 3, \"-%c\", cmd);\n\n    profile = g_strdup_printf(\"%s/%s\", APPARMOR_DIR \"/libvirt\", profile_name);\n\n    if (!virFileExists(profile)) {\n        vah_error(NULL, 0, _(\"profile does not exist\"));\n        goto cleanup;\n    } else {\n        const char * const argv[] = {\n            \"/sbin/apparmor_parser\", flag, profile, NULL\n        };\n        g_autoptr(virCommand) command = virCommandNewArgs(argv);\n\n        virCommandRawStatus(command);\n        if ((ret = virCommandRun(command, &status)) != 0 ||\n            (WIFEXITED(status) && WEXITSTATUS(status) != 0)) {\n            if (ret != 0) {\n                vah_error(NULL, 0, _(\"failed to run apparmor_parser\"));\n                goto cleanup;\n            } else if (cmd == 'R' && WIFEXITED(status) &&\n                       WEXITSTATUS(status) == 234) {\n                vah_warning(_(\"unable to unload already unloaded profile\"));\n            } else {\n                vah_error(NULL, 0, _(\"apparmor_parser exited with error\"));\n                goto cleanup;\n            }\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(profile);\n\n    return result;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "profile"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vah_error",
          "args": [
            "NULL",
            "0",
            "_(\"apparmor_parser exited with error\")"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "vah_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "119-129",
          "snippet": "static void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"apparmor_parser exited with error\""
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vah_warning",
          "args": [
            "_(\"unable to unload already unloaded profile\")"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "vah_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "131-135",
          "snippet": "static void\nvah_warning(const char *str)\n{\n    fprintf(stderr, _(\"%s: warning: %s%c\"), progname, str, '\\n');\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *progname;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_warning(const char *str)\n{\n    fprintf(stderr, _(\"%s: warning: %s%c\"), progname, str, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "status"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "status"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "command",
            "&status"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandRawStatus",
          "args": [
            "command"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRawStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1298-1305",
          "snippet": "void\nvirCommandRawStatus(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->rawStatus = true;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandRawStatus(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->rawStatus = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNewArgs",
          "args": [
            "argv"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "937-958",
          "snippet": "virCommandPtr\nvirCommandNewArgs(const char *const*args)\n{\n    virCommandPtr cmd;\n\n    if (VIR_ALLOC(cmd) < 0)\n        return NULL;\n\n    cmd->handshakeWait[0] = -1;\n    cmd->handshakeWait[1] = -1;\n    cmd->handshakeNotify[0] = -1;\n    cmd->handshakeNotify[1] = -1;\n\n    cmd->infd = cmd->inpipe = cmd->outfd = cmd->errfd = -1;\n    cmd->pid = -1;\n    cmd->uid = -1;\n    cmd->gid = -1;\n\n    virCommandAddArgSet(cmd, args);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgs(const char *const*args)\n{\n    virCommandPtr cmd;\n\n    if (VIR_ALLOC(cmd) < 0)\n        return NULL;\n\n    cmd->handshakeWait[0] = -1;\n    cmd->handshakeWait[1] = -1;\n    cmd->handshakeNotify[0] = -1;\n    cmd->handshakeNotify[1] = -1;\n\n    cmd->infd = cmd->inpipe = cmd->outfd = cmd->errfd = -1;\n    cmd->pid = -1;\n    cmd->uid = -1;\n    cmd->gid = -1;\n\n    virCommandAddArgSet(cmd, args);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "profile"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s\"",
            "APPARMOR_DIR \"/libvirt\"",
            "profile_name"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "flag",
            "3",
            "\"-%c\"",
            "cmd"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "\"arR\"",
            "cmd"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nparserCommand(const char *profile_name, const char cmd)\n{\n    int result = -1;\n    char flag[3];\n    char *profile;\n    int status;\n    int ret;\n\n    if (strchr(\"arR\", cmd) == NULL) {\n        vah_error(NULL, 0, _(\"invalid flag\"));\n        return -1;\n    }\n\n    g_snprintf(flag, 3, \"-%c\", cmd);\n\n    profile = g_strdup_printf(\"%s/%s\", APPARMOR_DIR \"/libvirt\", profile_name);\n\n    if (!virFileExists(profile)) {\n        vah_error(NULL, 0, _(\"profile does not exist\"));\n        goto cleanup;\n    } else {\n        const char * const argv[] = {\n            \"/sbin/apparmor_parser\", flag, profile, NULL\n        };\n        g_autoptr(virCommand) command = virCommandNewArgs(argv);\n\n        virCommandRawStatus(command);\n        if ((ret = virCommandRun(command, &status)) != 0 ||\n            (WIFEXITED(status) && WEXITSTATUS(status) != 0)) {\n            if (ret != 0) {\n                vah_error(NULL, 0, _(\"failed to run apparmor_parser\"));\n                goto cleanup;\n            } else if (cmd == 'R' && WIFEXITED(status) &&\n                       WEXITSTATUS(status) == 234) {\n                vah_warning(_(\"unable to unload already unloaded profile\"));\n            } else {\n                vah_error(NULL, 0, _(\"apparmor_parser exited with error\"));\n                goto cleanup;\n            }\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(profile);\n\n    return result;\n}"
  },
  {
    "function_name": "vah_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "137-141",
    "snippet": "static void\nvah_info(const char *str)\n{\n    fprintf(stderr, _(\"%s:\\n%s%c\"), progname, str, '\\n');\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *progname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s:\\n%s%c\")",
            "progname",
            "str",
            "'\\n'"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s:\\n%s%c\""
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_info(const char *str)\n{\n    fprintf(stderr, _(\"%s:\\n%s%c\"), progname, str, '\\n');\n}"
  },
  {
    "function_name": "vah_warning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "131-135",
    "snippet": "static void\nvah_warning(const char *str)\n{\n    fprintf(stderr, _(\"%s: warning: %s%c\"), progname, str, '\\n');\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *progname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s: warning: %s%c\")",
            "progname",
            "str",
            "'\\n'"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s: warning: %s%c\""
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_warning(const char *str)\n{\n    fprintf(stderr, _(\"%s: warning: %s%c\"), progname, str, '\\n');\n}"
  },
  {
    "function_name": "vah_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "119-129",
    "snippet": "static void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *progname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vahDeinit",
          "args": [
            "ctl"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "vahDeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "75-90",
          "snippet": "static int\nvahDeinit(vahControl * ctl)\n{\n    if (ctl == NULL)\n        return -1;\n\n    VIR_FREE(ctl->def);\n    virObjectUnref(ctl->caps);\n    virObjectUnref(ctl->xmlopt);\n    VIR_FREE(ctl->files);\n    VIR_FREE(ctl->virtType);\n    VIR_FREE(ctl->os);\n    VIR_FREE(ctl->newfile);\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvahDeinit(vahControl * ctl)\n{\n    if (ctl == NULL)\n        return -1;\n\n    VIR_FREE(ctl->def);\n    virObjectUnref(ctl->caps);\n    virObjectUnref(ctl->xmlopt);\n    VIR_FREE(ctl->files);\n    VIR_FREE(ctl->virtType);\n    VIR_FREE(ctl->os);\n    VIR_FREE(ctl->newfile);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "_(\"%s: error: %s%c\")",
            "progname",
            "str",
            "'\\n'"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s: error: %s%c\""
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_error(vahControl * ctl, int doexit, const char *str)\n{\n    fprintf(stderr, _(\"%s: error: %s%c\"), progname, str, '\\n');\n\n    if (doexit) {\n        if (ctl != NULL)\n            vahDeinit(ctl);\n        exit(EXIT_FAILURE);\n    }\n}"
  },
  {
    "function_name": "vah_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "95-117",
    "snippet": "static void\nvah_usage(void)\n{\n    printf(_(\"\\n%s mode [options] [extra file] [< def.xml]\\n\\n\"\n            \"  Modes:\\n\"\n            \"    -a | --add                     load profile\\n\"\n            \"    -c | --create                  create profile from template\\n\"\n            \"    -D | --delete                  unload and delete profile\\n\"\n            \"    -r | --replace                 reload profile\\n\"\n            \"    -R | --remove                  unload profile\\n\"\n            \"  Options:\\n\"\n            \"    -d | --dryrun                  dry run\\n\"\n            \"    -u | --uuid <uuid>             uuid (profile name)\\n\"\n            \"    -h | --help                    this help\\n\"\n            \"  Extra File:\\n\"\n            \"    -f | --add-file <file>         add file to a profile generated from XML\\n\"\n            \"    -F | --append-file <file>      append file to an existing profile\\n\"\n            \"\\n\"), progname);\n\n    puts(_(\"This command is intended to be used by libvirtd \"\n           \"and not used directly.\\n\"));\n    return;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char *progname;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "puts",
          "args": [
            "_(\"This command is intended to be used by libvirtd \"\n           \"and not used directly.\\n\")"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "virLogSetOutputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virlog.c",
          "lines": "1747-1779",
          "snippet": "int\nvirLogSetOutputs(const char *src)\n{\n    int ret = -1;\n    int noutputs = 0;\n    const char *outputstr = virLogDefaultOutput;\n    virLogOutputPtr *outputs = NULL;\n\n    if (virLogInitialize() < 0)\n        return -1;\n\n    if (src && *src)\n        outputstr = src;\n\n    /* This can only happen during daemon init when the default output is not\n     * determined yet. It's safe to do, since it's the only place setting the\n     * default output.\n     */\n    if (!outputstr)\n        return 0;\n\n    if ((noutputs = virLogParseOutputs(outputstr, &outputs)) < 0)\n        goto cleanup;\n\n    if (virLogDefineOutputs(outputs, noutputs) < 0)\n        goto cleanup;\n\n    outputs = NULL;\n    ret = 0;\n cleanup:\n    virLogOutputListFree(outputs, noutputs);\n    return ret;\n}",
          "includes": [
            "# include <sys/uio.h>",
            "#include \"virsocket.h\"",
            "#include \"configmake.h\"",
            "#include \"virstring.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <syslog.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/time.h>",
            "#include <time.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char *virLogDefaultOutput;"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <sys/uio.h>\n#include \"virsocket.h\"\n#include \"configmake.h\"\n#include \"virstring.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <syslog.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <time.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *virLogDefaultOutput;\n\nint\nvirLogSetOutputs(const char *src)\n{\n    int ret = -1;\n    int noutputs = 0;\n    const char *outputstr = virLogDefaultOutput;\n    virLogOutputPtr *outputs = NULL;\n\n    if (virLogInitialize() < 0)\n        return -1;\n\n    if (src && *src)\n        outputstr = src;\n\n    /* This can only happen during daemon init when the default output is not\n     * determined yet. It's safe to do, since it's the only place setting the\n     * default output.\n     */\n    if (!outputstr)\n        return 0;\n\n    if ((noutputs = virLogParseOutputs(outputstr, &outputs)) < 0)\n        goto cleanup;\n\n    if (virLogDefineOutputs(outputs, noutputs) < 0)\n        goto cleanup;\n\n    outputs = NULL;\n    ret = 0;\n cleanup:\n    virLogOutputListFree(outputs, noutputs);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"This command is intended to be used by libvirtd \"\n           \"and not used directly.\\n\""
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "_(\"\\n%s mode [options] [extra file] [< def.xml]\\n\\n\"\n            \"  Modes:\\n\"\n            \"    -a | --add                     load profile\\n\"\n            \"    -c | --create                  create profile from template\\n\"\n            \"    -D | --delete                  unload and delete profile\\n\"\n            \"    -r | --replace                 reload profile\\n\"\n            \"    -R | --remove                  unload profile\\n\"\n            \"  Options:\\n\"\n            \"    -d | --dryrun                  dry run\\n\"\n            \"    -u | --uuid <uuid>             uuid (profile name)\\n\"\n            \"    -h | --help                    this help\\n\"\n            \"  Extra File:\\n\"\n            \"    -f | --add-file <file>         add file to a profile generated from XML\\n\"\n            \"    -F | --append-file <file>      append file to an existing profile\\n\"\n            \"\\n\")",
            "progname"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_vprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "205-213",
          "snippet": "char *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_vprintf(const char *msg, va_list args)\n{\n    char *ret;\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic char *progname;\n\nstatic void\nvah_usage(void)\n{\n    printf(_(\"\\n%s mode [options] [extra file] [< def.xml]\\n\\n\"\n            \"  Modes:\\n\"\n            \"    -a | --add                     load profile\\n\"\n            \"    -c | --create                  create profile from template\\n\"\n            \"    -D | --delete                  unload and delete profile\\n\"\n            \"    -r | --replace                 reload profile\\n\"\n            \"    -R | --remove                  unload profile\\n\"\n            \"  Options:\\n\"\n            \"    -d | --dryrun                  dry run\\n\"\n            \"    -u | --uuid <uuid>             uuid (profile name)\\n\"\n            \"    -h | --help                    this help\\n\"\n            \"  Extra File:\\n\"\n            \"    -f | --add-file <file>         add file to a profile generated from XML\\n\"\n            \"    -F | --append-file <file>      append file to an existing profile\\n\"\n            \"\\n\"), progname);\n\n    puts(_(\"This command is intended to be used by libvirtd \"\n           \"and not used directly.\\n\"));\n    return;\n}"
  },
  {
    "function_name": "vahDeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
    "lines": "75-90",
    "snippet": "static int\nvahDeinit(vahControl * ctl)\n{\n    if (ctl == NULL)\n        return -1;\n\n    VIR_FREE(ctl->def);\n    virObjectUnref(ctl->caps);\n    virObjectUnref(ctl->xmlopt);\n    VIR_FREE(ctl->files);\n    VIR_FREE(ctl->virtType);\n    VIR_FREE(ctl->os);\n    VIR_FREE(ctl->newfile);\n\n    return 0;\n}",
    "includes": [
      "#include \"virhostdev.h\"",
      "#include \"virgettext.h\"",
      "#include \"virstring.h\"",
      "#include \"virrandom.h\"",
      "#include \"configmake.h\"",
      "#include \"virfile.h\"",
      "#include \"virpci.h\"",
      "#include \"virutil.h\"",
      "#include \"virusb.h\"",
      "#include \"viruuid.h\"",
      "#include \"virxml.h\"",
      "#include \"domain_conf.h\"",
      "#include \"security_apparmor.h\"",
      "#include \"security_driver.h\"",
      "#include \"driver.h\"",
      "#include \"virlog.h\"",
      "#include \"vircommand.h\"",
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include <sys/utsname.h>",
      "#include <getopt.h>",
      "#include <fcntl.h>",
      "#include <sys/types.h>",
      "#include <unistd.h>",
      "#include <stdarg.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ctl->newfile"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ctl->os"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ctl->virtType"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ctl->files"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "ctl->xmlopt"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ctl->def"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nvahDeinit(vahControl * ctl)\n{\n    if (ctl == NULL)\n        return -1;\n\n    VIR_FREE(ctl->def);\n    virObjectUnref(ctl->caps);\n    virObjectUnref(ctl->xmlopt);\n    VIR_FREE(ctl->files);\n    VIR_FREE(ctl->virtType);\n    VIR_FREE(ctl->os);\n    VIR_FREE(ctl->newfile);\n\n    return 0;\n}"
  }
]