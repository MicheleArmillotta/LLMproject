[
  {
    "function_name": "virPidFileForceCleanupPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
    "lines": "515-545",
    "snippet": "int\nvirPidFileForceCleanupPath(const char *path)\n{\n    pid_t pid = 0;\n    int fd = -1;\n\n    if (!virFileExists(path))\n        return 0;\n\n    if (virPidFileReadPath(path, &pid) < 0)\n        return -1;\n\n    fd = virPidFileAcquirePath(path, false, 0);\n    if (fd < 0) {\n        virResetLastError();\n\n        /* Only kill the process if the pid is valid one.  0 means\n         * there is somebody else doing the same pidfile cleanup\n         * machinery. */\n        if (pid)\n            virProcessKillPainfully(pid, true);\n\n        if (virPidFileDeletePath(path) < 0)\n            return -1;\n    }\n\n    if (fd)\n        virPidFileReleasePath(path, fd);\n\n    return 0;\n}",
    "includes": [
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virpidfile.h\"",
      "#include <sys/stat.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPidFileReleasePath",
          "args": [
            "path",
            "fd"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReleasePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "430-450",
          "snippet": "int virPidFileReleasePath(const char *path,\n                          int fd)\n{\n    int rc = 0;\n    /*\n     * We need to unlink before closing the FD to avoid\n     * a race, but Win32 won't let you unlink an open\n     * file handle. So on that platform we do the reverse\n     * and just have to live with the possible race.\n     */\n#ifdef WIN32\n    VIR_FORCE_CLOSE(fd);\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n#else\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n    VIR_FORCE_CLOSE(fd);\n#endif\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReleasePath(const char *path,\n                          int fd)\n{\n    int rc = 0;\n    /*\n     * We need to unlink before closing the FD to avoid\n     * a race, but Win32 won't let you unlink an open\n     * file handle. So on that platform we do the reverse\n     * and just have to live with the possible race.\n     */\n#ifdef WIN32\n    VIR_FORCE_CLOSE(fd);\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n#else\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n    VIR_FORCE_CLOSE(fd);\n#endif\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileDeletePath",
          "args": [
            "path"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileDeletePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "305-313",
          "snippet": "int virPidFileDeletePath(const char *pidfile)\n{\n    int rc = 0;\n\n    if (unlink(pidfile) < 0 && errno != ENOENT)\n        rc = -errno;\n\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileDeletePath(const char *pidfile)\n{\n    int rc = 0;\n\n    if (unlink(pidfile) < 0 && errno != ENOENT)\n        rc = -errno;\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessKillPainfully",
          "args": [
            "pid",
            "true"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessKillPainfully",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "437-440",
          "snippet": "int virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virProcessKillPainfully(pid_t pid, bool force)\n{\n    return virProcessKillPainfullyDelay(pid, force, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileAcquirePath",
          "args": [
            "path",
            "false",
            "0"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileAcquirePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "330-410",
          "snippet": "int virPidFileAcquirePath(const char *path,\n                          bool waitForLock,\n                          pid_t pid)\n{\n    int fd = -1;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if (path[0] == '\\0')\n        return 0;\n\n    while (1) {\n        struct stat a, b;\n        if ((fd = open(path, O_WRONLY|O_CREAT, 0644)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open pid file '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        if (virSetCloseExec(fd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to set close-on-exec flag '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (fstat(fd, &b) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to check status of pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (virFileLock(fd, false, 0, 1, waitForLock) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to acquire pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        /* Now make sure the pidfile we locked is the same\n         * one that now exists on the filesystem\n         */\n        if (stat(path, &a) < 0) {\n            VIR_DEBUG(\"Pid file '%s' disappeared: %s\",\n                      path, g_strerror(errno));\n            VIR_FORCE_CLOSE(fd);\n            /* Someone else must be racing with us, so try again */\n            continue;\n        }\n\n        if (a.st_ino == b.st_ino)\n            break;\n\n        VIR_DEBUG(\"Pid file '%s' was recreated\", path);\n        VIR_FORCE_CLOSE(fd);\n        /* Someone else must be racing with us, so try again */\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to write to pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n    }\n\n    return fd;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileAcquirePath(const char *path,\n                          bool waitForLock,\n                          pid_t pid)\n{\n    int fd = -1;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if (path[0] == '\\0')\n        return 0;\n\n    while (1) {\n        struct stat a, b;\n        if ((fd = open(path, O_WRONLY|O_CREAT, 0644)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open pid file '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        if (virSetCloseExec(fd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to set close-on-exec flag '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (fstat(fd, &b) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to check status of pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (virFileLock(fd, false, 0, 1, waitForLock) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to acquire pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        /* Now make sure the pidfile we locked is the same\n         * one that now exists on the filesystem\n         */\n        if (stat(path, &a) < 0) {\n            VIR_DEBUG(\"Pid file '%s' disappeared: %s\",\n                      path, g_strerror(errno));\n            VIR_FORCE_CLOSE(fd);\n            /* Someone else must be racing with us, so try again */\n            continue;\n        }\n\n        if (a.st_ino == b.st_ino)\n            break;\n\n        VIR_DEBUG(\"Pid file '%s' was recreated\", path);\n        VIR_FORCE_CLOSE(fd);\n        /* Someone else must be racing with us, so try again */\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to write to pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n    }\n\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileReadPath",
          "args": [
            "path",
            "&pid"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "105-145",
          "snippet": "int virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "path"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirPidFileForceCleanupPath(const char *path)\n{\n    pid_t pid = 0;\n    int fd = -1;\n\n    if (!virFileExists(path))\n        return 0;\n\n    if (virPidFileReadPath(path, &pid) < 0)\n        return -1;\n\n    fd = virPidFileAcquirePath(path, false, 0);\n    if (fd < 0) {\n        virResetLastError();\n\n        /* Only kill the process if the pid is valid one.  0 means\n         * there is somebody else doing the same pidfile cleanup\n         * machinery. */\n        if (pid)\n            virProcessKillPainfully(pid, true);\n\n        if (virPidFileDeletePath(path) < 0)\n            return -1;\n    }\n\n    if (fd)\n        virPidFileReleasePath(path, fd);\n\n    return 0;\n}"
  },
  {
    "function_name": "virPidFileConstructPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
    "lines": "469-502",
    "snippet": "int\nvirPidFileConstructPath(bool privileged,\n                        const char *runstatedir,\n                        const char *progname,\n                        char **pidfile)\n{\n    g_autofree char *rundir = NULL;\n\n    if (privileged) {\n        /*\n         * This is here just to allow calling this function with\n         * statedir == NULL; of course only when !privileged.\n         */\n        if (!runstatedir) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"No runstatedir specified\"));\n            return -1;\n        }\n        *pidfile = g_strdup_printf(\"%s/%s.pid\", runstatedir, progname);\n    } else {\n        rundir = virGetUserRuntimeDirectory();\n\n        if (virFileMakePathWithMode(rundir, 0700) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot create user runtime directory '%s'\"),\n                                 rundir);\n            return -1;\n        }\n\n        *pidfile = g_strdup_printf(\"%s/%s.pid\", rundir, progname);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virpidfile.h\"",
      "#include <sys/stat.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s.pid\"",
            "rundir",
            "progname"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Cannot create user runtime directory '%s'\")",
            "rundir"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileMakePathWithMode",
          "args": [
            "rundir",
            "0700"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePathWithMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3082-3091",
          "snippet": "int\nvirFileMakePathWithMode(const char *path,\n                        mode_t mode)\n{\n    g_autofree char *tmp = NULL;\n\n    tmp = g_strdup(path);\n\n    return virFileMakePathHelper(tmp, mode);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePathWithMode(const char *path,\n                        mode_t mode)\n{\n    g_autofree char *tmp = NULL;\n\n    tmp = g_strdup(path);\n\n    return virFileMakePathHelper(tmp, mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserRuntimeDirectory",
          "args": [],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserRuntimeDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "594-601",
          "snippet": "char *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"No runstatedir specified\")"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirPidFileConstructPath(bool privileged,\n                        const char *runstatedir,\n                        const char *progname,\n                        char **pidfile)\n{\n    g_autofree char *rundir = NULL;\n\n    if (privileged) {\n        /*\n         * This is here just to allow calling this function with\n         * statedir == NULL; of course only when !privileged.\n         */\n        if (!runstatedir) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"No runstatedir specified\"));\n            return -1;\n        }\n        *pidfile = g_strdup_printf(\"%s/%s.pid\", runstatedir, progname);\n    } else {\n        rundir = virGetUserRuntimeDirectory();\n\n        if (virFileMakePathWithMode(rundir, 0700) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot create user runtime directory '%s'\"),\n                                 rundir);\n            return -1;\n        }\n\n        *pidfile = g_strdup_printf(\"%s/%s.pid\", rundir, progname);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virPidFileRelease",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
    "lines": "453-466",
    "snippet": "int virPidFileRelease(const char *dir,\n                      const char *name,\n                      int fd)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileReleasePath(pidfile, fd);\n}",
    "includes": [
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virpidfile.h\"",
      "#include <sys/stat.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPidFileReleasePath",
          "args": [
            "pidfile",
            "fd"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReleasePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "430-450",
          "snippet": "int virPidFileReleasePath(const char *path,\n                          int fd)\n{\n    int rc = 0;\n    /*\n     * We need to unlink before closing the FD to avoid\n     * a race, but Win32 won't let you unlink an open\n     * file handle. So on that platform we do the reverse\n     * and just have to live with the possible race.\n     */\n#ifdef WIN32\n    VIR_FORCE_CLOSE(fd);\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n#else\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n    VIR_FORCE_CLOSE(fd);\n#endif\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReleasePath(const char *path,\n                          int fd)\n{\n    int rc = 0;\n    /*\n     * We need to unlink before closing the FD to avoid\n     * a race, but Win32 won't let you unlink an open\n     * file handle. So on that platform we do the reverse\n     * and just have to live with the possible race.\n     */\n#ifdef WIN32\n    VIR_FORCE_CLOSE(fd);\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n#else\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n    VIR_FORCE_CLOSE(fd);\n#endif\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileBuildPath",
          "args": [
            "dir",
            "name"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "43-51",
          "snippet": "char *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileRelease(const char *dir,\n                      const char *name,\n                      int fd)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileReleasePath(pidfile, fd);\n}"
  },
  {
    "function_name": "virPidFileReleasePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
    "lines": "430-450",
    "snippet": "int virPidFileReleasePath(const char *path,\n                          int fd)\n{\n    int rc = 0;\n    /*\n     * We need to unlink before closing the FD to avoid\n     * a race, but Win32 won't let you unlink an open\n     * file handle. So on that platform we do the reverse\n     * and just have to live with the possible race.\n     */\n#ifdef WIN32\n    VIR_FORCE_CLOSE(fd);\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n#else\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n    VIR_FORCE_CLOSE(fd);\n#endif\n    return rc;\n}",
    "includes": [
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virpidfile.h\"",
      "#include <sys/stat.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "path"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReleasePath(const char *path,\n                          int fd)\n{\n    int rc = 0;\n    /*\n     * We need to unlink before closing the FD to avoid\n     * a race, but Win32 won't let you unlink an open\n     * file handle. So on that platform we do the reverse\n     * and just have to live with the possible race.\n     */\n#ifdef WIN32\n    VIR_FORCE_CLOSE(fd);\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n#else\n    if (unlink(path) < 0 && errno != ENOENT)\n        rc = -errno;\n    VIR_FORCE_CLOSE(fd);\n#endif\n    return rc;\n}"
  },
  {
    "function_name": "virPidFileAcquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
    "lines": "413-427",
    "snippet": "int virPidFileAcquire(const char *dir,\n                      const char *name,\n                      bool waitForLock,\n                      pid_t pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileAcquirePath(pidfile, waitForLock, pid);\n}",
    "includes": [
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virpidfile.h\"",
      "#include <sys/stat.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPidFileAcquirePath",
          "args": [
            "pidfile",
            "waitForLock",
            "pid"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileAcquirePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "330-410",
          "snippet": "int virPidFileAcquirePath(const char *path,\n                          bool waitForLock,\n                          pid_t pid)\n{\n    int fd = -1;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if (path[0] == '\\0')\n        return 0;\n\n    while (1) {\n        struct stat a, b;\n        if ((fd = open(path, O_WRONLY|O_CREAT, 0644)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open pid file '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        if (virSetCloseExec(fd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to set close-on-exec flag '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (fstat(fd, &b) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to check status of pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (virFileLock(fd, false, 0, 1, waitForLock) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to acquire pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        /* Now make sure the pidfile we locked is the same\n         * one that now exists on the filesystem\n         */\n        if (stat(path, &a) < 0) {\n            VIR_DEBUG(\"Pid file '%s' disappeared: %s\",\n                      path, g_strerror(errno));\n            VIR_FORCE_CLOSE(fd);\n            /* Someone else must be racing with us, so try again */\n            continue;\n        }\n\n        if (a.st_ino == b.st_ino)\n            break;\n\n        VIR_DEBUG(\"Pid file '%s' was recreated\", path);\n        VIR_FORCE_CLOSE(fd);\n        /* Someone else must be racing with us, so try again */\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to write to pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n    }\n\n    return fd;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileAcquirePath(const char *path,\n                          bool waitForLock,\n                          pid_t pid)\n{\n    int fd = -1;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if (path[0] == '\\0')\n        return 0;\n\n    while (1) {\n        struct stat a, b;\n        if ((fd = open(path, O_WRONLY|O_CREAT, 0644)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open pid file '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        if (virSetCloseExec(fd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to set close-on-exec flag '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (fstat(fd, &b) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to check status of pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (virFileLock(fd, false, 0, 1, waitForLock) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to acquire pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        /* Now make sure the pidfile we locked is the same\n         * one that now exists on the filesystem\n         */\n        if (stat(path, &a) < 0) {\n            VIR_DEBUG(\"Pid file '%s' disappeared: %s\",\n                      path, g_strerror(errno));\n            VIR_FORCE_CLOSE(fd);\n            /* Someone else must be racing with us, so try again */\n            continue;\n        }\n\n        if (a.st_ino == b.st_ino)\n            break;\n\n        VIR_DEBUG(\"Pid file '%s' was recreated\", path);\n        VIR_FORCE_CLOSE(fd);\n        /* Someone else must be racing with us, so try again */\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to write to pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n    }\n\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileBuildPath",
          "args": [
            "dir",
            "name"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "43-51",
          "snippet": "char *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileAcquire(const char *dir,\n                      const char *name,\n                      bool waitForLock,\n                      pid_t pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileAcquirePath(pidfile, waitForLock, pid);\n}"
  },
  {
    "function_name": "virPidFileAcquirePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
    "lines": "330-410",
    "snippet": "int virPidFileAcquirePath(const char *path,\n                          bool waitForLock,\n                          pid_t pid)\n{\n    int fd = -1;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if (path[0] == '\\0')\n        return 0;\n\n    while (1) {\n        struct stat a, b;\n        if ((fd = open(path, O_WRONLY|O_CREAT, 0644)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open pid file '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        if (virSetCloseExec(fd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to set close-on-exec flag '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (fstat(fd, &b) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to check status of pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (virFileLock(fd, false, 0, 1, waitForLock) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to acquire pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        /* Now make sure the pidfile we locked is the same\n         * one that now exists on the filesystem\n         */\n        if (stat(path, &a) < 0) {\n            VIR_DEBUG(\"Pid file '%s' disappeared: %s\",\n                      path, g_strerror(errno));\n            VIR_FORCE_CLOSE(fd);\n            /* Someone else must be racing with us, so try again */\n            continue;\n        }\n\n        if (a.st_ino == b.st_ino)\n            break;\n\n        VIR_DEBUG(\"Pid file '%s' was recreated\", path);\n        VIR_FORCE_CLOSE(fd);\n        /* Someone else must be racing with us, so try again */\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to write to pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n    }\n\n    return fd;\n}",
    "includes": [
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virpidfile.h\"",
      "#include <sys/stat.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to write to pid file '%s'\")",
            "path"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to write to pid file '%s'\""
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "fd",
            "pidstr",
            "strlen(pidstr)"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pidstr"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to truncate pid file '%s'\")",
            "path"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "fd",
            "0"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "pidstr",
            "sizeof(pidstr)",
            "\"%lld\"",
            "(long long) pid"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Pid file '%s' was recreated\"",
            "path"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Pid file '%s' disappeared: %s\"",
            "path",
            "g_strerror(errno)"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "path",
            "&a"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to acquire pid file '%s'\")",
            "path"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileLock",
          "args": [
            "fd",
            "false",
            "0",
            "1",
            "waitForLock"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "virFileLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "489-496",
          "snippet": "int virFileLock(int fd G_GNUC_UNUSED,\n                bool shared G_GNUC_UNUSED,\n                off_t start G_GNUC_UNUSED,\n                off_t len G_GNUC_UNUSED,\n                bool waitForLock G_GNUC_UNUSED)\n{\n    return -ENOSYS;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileLock(int fd G_GNUC_UNUSED,\n                bool shared G_GNUC_UNUSED,\n                off_t start G_GNUC_UNUSED,\n                off_t len G_GNUC_UNUSED,\n                bool waitForLock G_GNUC_UNUSED)\n{\n    return -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to check status of pid file '%s'\")",
            "path"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "fd",
            "&b"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to set close-on-exec flag '%s'\")",
            "path"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSetCloseExec",
          "args": [
            "fd"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "virSetCloseExec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "131-134",
          "snippet": "int virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to open pid file '%s'\")",
            "path"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_WRONLY|O_CREAT",
            "0644"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3308-3323",
          "snippet": "int\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileAcquirePath(const char *path,\n                          bool waitForLock,\n                          pid_t pid)\n{\n    int fd = -1;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if (path[0] == '\\0')\n        return 0;\n\n    while (1) {\n        struct stat a, b;\n        if ((fd = open(path, O_WRONLY|O_CREAT, 0644)) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open pid file '%s'\"),\n                                 path);\n            return -1;\n        }\n\n        if (virSetCloseExec(fd) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to set close-on-exec flag '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (fstat(fd, &b) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to check status of pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        if (virFileLock(fd, false, 0, 1, waitForLock) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to acquire pid file '%s'\"),\n                                 path);\n            VIR_FORCE_CLOSE(fd);\n            return -1;\n        }\n\n        /* Now make sure the pidfile we locked is the same\n         * one that now exists on the filesystem\n         */\n        if (stat(path, &a) < 0) {\n            VIR_DEBUG(\"Pid file '%s' disappeared: %s\",\n                      path, g_strerror(errno));\n            VIR_FORCE_CLOSE(fd);\n            /* Someone else must be racing with us, so try again */\n            continue;\n        }\n\n        if (a.st_ino == b.st_ino)\n            break;\n\n        VIR_DEBUG(\"Pid file '%s' was recreated\", path);\n        VIR_FORCE_CLOSE(fd);\n        /* Someone else must be racing with us, so try again */\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (ftruncate(fd, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to truncate pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to write to pid file '%s'\"),\n                             path);\n        VIR_FORCE_CLOSE(fd);\n    }\n\n    return fd;\n}"
  },
  {
    "function_name": "virPidFileDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
    "lines": "316-328",
    "snippet": "int virPidFileDelete(const char *dir,\n                     const char *name)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileDeletePath(pidfile);\n}",
    "includes": [
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virpidfile.h\"",
      "#include <sys/stat.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPidFileDeletePath",
          "args": [
            "pidfile"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileDeletePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "305-313",
          "snippet": "int virPidFileDeletePath(const char *pidfile)\n{\n    int rc = 0;\n\n    if (unlink(pidfile) < 0 && errno != ENOENT)\n        rc = -errno;\n\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileDeletePath(const char *pidfile)\n{\n    int rc = 0;\n\n    if (unlink(pidfile) < 0 && errno != ENOENT)\n        rc = -errno;\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileBuildPath",
          "args": [
            "dir",
            "name"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "43-51",
          "snippet": "char *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileDelete(const char *dir,\n                     const char *name)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileDeletePath(pidfile);\n}"
  },
  {
    "function_name": "virPidFileDeletePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
    "lines": "305-313",
    "snippet": "int virPidFileDeletePath(const char *pidfile)\n{\n    int rc = 0;\n\n    if (unlink(pidfile) < 0 && errno != ENOENT)\n        rc = -errno;\n\n    return rc;\n}",
    "includes": [
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virpidfile.h\"",
      "#include <sys/stat.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "pidfile"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileDeletePath(const char *pidfile)\n{\n    int rc = 0;\n\n    if (unlink(pidfile) < 0 && errno != ENOENT)\n        rc = -errno;\n\n    return rc;\n}"
  },
  {
    "function_name": "virPidFileReadIfAlive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
    "lines": "285-302",
    "snippet": "int virPidFileReadIfAlive(const char *dir,\n                          const char *name,\n                          pid_t *pid,\n                          const char *binpath)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -1;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -1;\n\n    if (virPidFileReadPathIfAlive(pidfile, pid, binpath) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virpidfile.h\"",
      "#include <sys/stat.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPidFileReadPathIfAlive",
          "args": [
            "pidfile",
            "pid",
            "binpath"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPathIfAlive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "187-264",
          "snippet": "int virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileBuildPath",
          "args": [
            "dir",
            "name"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "43-51",
          "snippet": "char *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadIfAlive(const char *dir,\n                          const char *name,\n                          pid_t *pid,\n                          const char *binpath)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -1;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -1;\n\n    if (virPidFileReadPathIfAlive(pidfile, pid, binpath) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virPidFileReadPathIfAlive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
    "lines": "187-264",
    "snippet": "int virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}",
    "includes": [
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virpidfile.h\"",
      "#include <sys/stat.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "resolvedBinPath",
            "resolvedProcLink"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileResolveAllLinks",
          "args": [
            "procLink",
            "&resolvedProcLink"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "virFileResolveAllLinks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1622-1626",
          "snippet": "int\nvirFileResolveAllLinks(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, true, resultpath);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileResolveAllLinks(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, true, resultpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "procLink"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_file_read_link",
          "args": [
            "procPath",
            "NULL"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileLinkPointsTo",
          "args": [
            "procPath",
            "binPath"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "virFileLinkPointsTo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1533-1543",
          "snippet": "int\nvirFileLinkPointsTo(const char *checkLink,\n                    const char *checkDest)\n{\n    struct stat src_sb;\n    struct stat dest_sb;\n\n    return (stat(checkLink, &src_sb) == 0\n            && stat(checkDest, &dest_sb) == 0\n            && SAME_INODE(src_sb, dest_sb));\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileLinkPointsTo(const char *checkLink,\n                    const char *checkDest)\n{\n    struct stat src_sb;\n    struct stat dest_sb;\n\n    return (stat(checkLink, &src_sb) == 0\n            && stat(checkDest, &dest_sb) == 0\n            && SAME_INODE(src_sb, dest_sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileIsLink",
          "args": [
            "procPath"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1633-1649",
          "snippet": "int\nvirFileIsLink(const char *linkpath)\n{\n    GStatBuf st;\n\n    /* Still do this on Windows so we report\n     * errors like ENOENT, etc\n     */\n    if (g_lstat(linkpath, &st) < 0)\n        return -errno;\n\n#ifndef WIN32\n    return S_ISLNK(st.st_mode) != 0;\n#else /* WIN32 */\n    return 0;\n#endif /* WIN32 */\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileIsLink(const char *linkpath)\n{\n    GStatBuf st;\n\n    /* Still do this on Windows so we report\n     * errors like ENOENT, etc\n     */\n    if (g_lstat(linkpath, &st) < 0)\n        return -errno;\n\n#ifndef WIN32\n    return S_ISLNK(st.st_mode) != 0;\n#else /* WIN32 */\n    return 0;\n#endif /* WIN32 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/proc/%lld/exe\"",
            "(long long)retPid"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "retPid",
            "0"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPidFileReadPath",
          "args": [
            "path",
            "&retPid"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "105-145",
          "snippet": "int virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "deletedText"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPathIfAlive(const char *path,\n                              pid_t *pid,\n                              const char *binPath)\n{\n    int rc;\n    bool isLink = false;\n    size_t procLinkLen;\n    const char deletedText[] = \" (deleted)\";\n    size_t deletedTextLen = strlen(deletedText);\n    pid_t retPid;\n    g_autofree char *procPath = NULL;\n    g_autofree char *procLink = NULL;\n    g_autofree char *resolvedBinPath = NULL;\n    g_autofree char *resolvedProcLink = NULL;\n\n    /* only set this at the very end on success */\n    *pid = -1;\n\n    if (virPidFileReadPath(path, &retPid) < 0)\n        return -1;\n\n#ifndef WIN32\n    /* Check that it's still alive.  Safe to skip this sanity check on\n     * mingw, which lacks kill().  */\n    if (kill(retPid, 0) < 0) {\n        *pid = -1;\n        return 0;\n    }\n#endif\n\n    if (!binPath) {\n        /* we only knew the pid, and that pid is alive, so we can\n         * return it.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    procPath = g_strdup_printf(\"/proc/%lld/exe\", (long long)retPid);\n\n    if ((rc = virFileIsLink(procPath)) < 0)\n        return -1;\n\n    if (rc == 1)\n        isLink = true;\n\n    if (isLink && virFileLinkPointsTo(procPath, binPath)) {\n        /* the link in /proc/$pid/exe is a symlink to a file\n         * that has the same inode as the file at binpath.\n         */\n        *pid = retPid;\n        return 0;\n    }\n\n    /* Even if virFileLinkPointsTo returns a mismatch, it could be\n     * that the binary was deleted/replaced after it was executed. In\n     * that case the link in /proc/$pid/exe will contain\n     * \"$procpath (deleted)\".  Read that link, remove the \" (deleted)\"\n     * part, and see if it has the same canonicalized name as binpath.\n     */\n    if (!(procLink = g_file_read_link(procPath, NULL)))\n        return -1;\n\n    procLinkLen = strlen(procLink);\n    if (procLinkLen > deletedTextLen)\n        procLink[procLinkLen - deletedTextLen] = 0;\n\n    if (virFileResolveAllLinks(binPath, &resolvedBinPath) < 0)\n        return -1;\n    if (virFileResolveAllLinks(procLink, &resolvedProcLink) < 0)\n        return -1;\n\n    if (STRNEQ(resolvedBinPath, resolvedProcLink))\n        return -1;\n\n    *pid = retPid;\n    return 0;\n}"
  },
  {
    "function_name": "virPidFileRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
    "lines": "148-163",
    "snippet": "int virPidFileRead(const char *dir,\n                   const char *name,\n                   pid_t *pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    *pid = 0;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileReadPath(pidfile, pid);\n}",
    "includes": [
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virpidfile.h\"",
      "#include <sys/stat.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPidFileReadPath",
          "args": [
            "pidfile",
            "pid"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileReadPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "105-145",
          "snippet": "int virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileBuildPath",
          "args": [
            "dir",
            "name"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "43-51",
          "snippet": "char *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileRead(const char *dir,\n                   const char *name,\n                   pid_t *pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    *pid = 0;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileReadPath(pidfile, pid);\n}"
  },
  {
    "function_name": "virPidFileReadPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
    "lines": "105-145",
    "snippet": "int virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}",
    "includes": [
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virpidfile.h\"",
      "#include <sys/stat.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "fd"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_isspace",
          "args": [
            "*endptr"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ll",
          "args": [
            "pidstr",
            "&endptr",
            "10",
            "&pid_value"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_ll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "526-542",
          "snippet": "int\nvirStrToLong_ll(char const *s, char **end_ptr, int base, long long *result)\n{\n    long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoll(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_ll(char const *s, char **end_ptr, int base, long long *result)\n{\n    long long val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtoll(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "saferead",
          "args": [
            "fd",
            "pidstr",
            "sizeof(pidstr)"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "saferead_lim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1330-1372",
          "snippet": "static char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "path",
            "O_RDONLY"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileReadPath(const char *path,\n                       pid_t *pid)\n{\n    int fd;\n    int rc;\n    ssize_t bytes;\n    long long pid_value = 0;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n    char *endptr = NULL;\n\n    *pid = 0;\n\n    if ((fd = open(path, O_RDONLY)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    bytes = saferead(fd, pidstr, sizeof(pidstr));\n    if (bytes < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n    pidstr[bytes] = '\\0';\n\n    if (virStrToLong_ll(pidstr, &endptr, 10, &pid_value) < 0 ||\n        !(*endptr == '\\0' || g_ascii_isspace(*endptr)) ||\n        (pid_t) pid_value != pid_value) {\n        rc = -EINVAL;\n        goto cleanup;\n    }\n\n    *pid = pid_value;\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}"
  },
  {
    "function_name": "virPidFileWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
    "lines": "86-102",
    "snippet": "int virPidFileWrite(const char *dir,\n                    const char *name,\n                    pid_t pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (virFileMakePath(dir) < 0)\n        return -errno;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileWritePath(pidfile, pid);\n}",
    "includes": [
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virpidfile.h\"",
      "#include <sys/stat.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPidFileWritePath",
          "args": [
            "pidfile",
            "pid"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileWritePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "54-83",
          "snippet": "int virPidFileWritePath(const char *pidfile,\n                        pid_t pid)\n{\n    int rc;\n    int fd;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if ((fd = open(pidfile,\n                   O_WRONLY | O_CREAT | O_TRUNC,\n                   S_IRUSR | S_IWUSR)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileWritePath(const char *pidfile,\n                        pid_t pid)\n{\n    int rc;\n    int fd;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if ((fd = open(pidfile,\n                   O_WRONLY | O_CREAT | O_TRUNC,\n                   S_IRUSR | S_IWUSR)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPidFileBuildPath",
          "args": [
            "dir",
            "name"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "virPidFileBuildPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
          "lines": "43-51",
          "snippet": "char *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virprocess.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virpidfile.h\"",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "dir"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileWrite(const char *dir,\n                    const char *name,\n                    pid_t pid)\n{\n    g_autofree char *pidfile = NULL;\n\n    if (name == NULL || dir == NULL)\n        return -EINVAL;\n\n    if (virFileMakePath(dir) < 0)\n        return -errno;\n\n    if (!(pidfile = virPidFileBuildPath(dir, name)))\n        return -ENOMEM;\n\n    return virPidFileWritePath(pidfile, pid);\n}"
  },
  {
    "function_name": "virPidFileWritePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
    "lines": "54-83",
    "snippet": "int virPidFileWritePath(const char *pidfile,\n                        pid_t pid)\n{\n    int rc;\n    int fd;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if ((fd = open(pidfile,\n                   O_WRONLY | O_CREAT | O_TRUNC,\n                   S_IRUSR | S_IWUSR)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}",
    "includes": [
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virpidfile.h\"",
      "#include <sys/stat.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "fd"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "fd",
            "pidstr",
            "strlen(pidstr)"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pidstr"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "pidstr",
            "sizeof(pidstr)",
            "\"%lld\"",
            "(long long) pid"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "pidfile",
            "O_WRONLY | O_CREAT | O_TRUNC",
            "S_IRUSR | S_IWUSR"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3308-3323",
          "snippet": "int\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint virPidFileWritePath(const char *pidfile,\n                        pid_t pid)\n{\n    int rc;\n    int fd;\n    char pidstr[VIR_INT64_STR_BUFLEN];\n\n    if ((fd = open(pidfile,\n                   O_WRONLY | O_CREAT | O_TRUNC,\n                   S_IRUSR | S_IWUSR)) < 0) {\n        rc = -errno;\n        goto cleanup;\n    }\n\n    g_snprintf(pidstr, sizeof(pidstr), \"%lld\", (long long) pid);\n\n    if (safewrite(fd, pidstr, strlen(pidstr)) < 0) {\n        rc = -errno;\n        VIR_FORCE_CLOSE(fd);\n        goto cleanup;\n    }\n\n    rc = 0;\n\n cleanup:\n    if (VIR_CLOSE(fd) < 0)\n        rc = -errno;\n\n    return rc;\n}"
  },
  {
    "function_name": "virPidFileBuildPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpidfile.c",
    "lines": "43-51",
    "snippet": "char *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"virprocess.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virpidfile.h\"",
      "#include <sys/stat.h>",
      "#include <signal.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "&buf",
            "\"/%s.pid\"",
            "name"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"%s\"",
            "dir"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprocess.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include <sys/stat.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *virPidFileBuildPath(const char *dir, const char* name)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAsprintf(&buf, \"%s\", dir);\n    virBufferEscapeString(&buf, \"/%s.pid\", name);\n\n    return virBufferContentAndReset(&buf);\n}"
  }
]