[
  {
    "function_name": "virDomainSnapshotRedefinePrep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "969-1006",
    "snippet": "int\nvirDomainSnapshotRedefinePrep(virDomainObjPtr vm,\n                              virDomainSnapshotDefPtr *defptr,\n                              virDomainMomentObjPtr *snap,\n                              virDomainXMLOptionPtr xmlopt,\n                              unsigned int flags)\n{\n    virDomainSnapshotDefPtr def = *defptr;\n    virDomainMomentObjPtr other;\n    virDomainSnapshotDefPtr otherdef = NULL;\n    bool check_if_stolen;\n\n    if (virDomainSnapshotCheckCycles(vm->snapshots, def, vm->def->name) < 0)\n        return -1;\n\n    other = virDomainSnapshotFindByName(vm->snapshots, def->parent.name);\n    if (other)\n        otherdef = virDomainSnapshotObjGetDef(other);\n    check_if_stolen = other && otherdef->parent.dom;\n    if (virDomainSnapshotRedefineValidate(def, vm->def->uuid, other, xmlopt,\n                                          flags) < 0) {\n        /* revert any stealing of the snapshot domain definition */\n        if (check_if_stolen && def->parent.dom && !otherdef->parent.dom)\n            otherdef->parent.dom = g_steal_pointer(&def->parent.dom);\n        return -1;\n    }\n    if (other) {\n        /* Drop and rebuild the parent relationship, but keep all\n         * child relations by reusing snap. */\n        virDomainMomentDropParent(other);\n        virObjectUnref(otherdef);\n        other->def = &(*defptr)->parent;\n        *defptr = NULL;\n        *snap = other;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "otherdef"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainMomentDropParent",
          "args": [
            "other"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainMomentDropParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainmomentobjlist.c",
          "lines": "119-141",
          "snippet": "void\nvirDomainMomentDropParent(virDomainMomentObjPtr moment)\n{\n    virDomainMomentObjPtr prev = NULL;\n    virDomainMomentObjPtr curr = NULL;\n\n    moment->parent->nchildren--;\n    curr = moment->parent->first_child;\n    while (curr != moment) {\n        if (!curr) {\n            VIR_WARN(\"inconsistent moment relations\");\n            return;\n        }\n        prev = curr;\n        curr = curr->sibling;\n    }\n    if (prev)\n        prev->sibling = moment->sibling;\n    else\n        moment->parent->first_child = moment->sibling;\n    moment->parent = NULL;\n    moment->sibling = NULL;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"viralloc.h\"",
            "#include \"moment_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virdomainmomentobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"viralloc.h\"\n#include \"moment_conf.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virdomainmomentobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainMomentDropParent(virDomainMomentObjPtr moment)\n{\n    virDomainMomentObjPtr prev = NULL;\n    virDomainMomentObjPtr curr = NULL;\n\n    moment->parent->nchildren--;\n    curr = moment->parent->first_child;\n    while (curr != moment) {\n        if (!curr) {\n            VIR_WARN(\"inconsistent moment relations\");\n            return;\n        }\n        prev = curr;\n        curr = curr->sibling;\n    }\n    if (prev)\n        prev->sibling = moment->sibling;\n    else\n        moment->parent->first_child = moment->sibling;\n    moment->parent = NULL;\n    moment->sibling = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&def->parent.dom"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotRedefineValidate",
          "args": [
            "def",
            "vm->def->uuid",
            "other",
            "xmlopt",
            "flags"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotRedefineValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "479-556",
          "snippet": "int\nvirDomainSnapshotRedefineValidate(virDomainSnapshotDefPtr def,\n                                  const unsigned char *domain_uuid,\n                                  virDomainMomentObjPtr other,\n                                  virDomainXMLOptionPtr xmlopt,\n                                  unsigned int flags)\n{\n    int align_location = VIR_DOMAIN_SNAPSHOT_LOCATION_INTERNAL;\n    bool align_match = true;\n    bool external = def->state == VIR_DOMAIN_SNAPSHOT_DISK_SNAPSHOT ||\n        virDomainSnapshotDefIsExternal(def);\n\n    if ((flags & VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY) && !external) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"disk-only flag for snapshot %s requires \"\n                         \"disk-snapshot state\"),\n                       def->parent.name);\n        return -1;\n    }\n    if (def->parent.dom && memcmp(def->parent.dom->uuid, domain_uuid,\n                                  VIR_UUID_BUFLEN)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(domain_uuid, uuidstr);\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"definition for snapshot %s must use uuid %s\"),\n                       def->parent.name, uuidstr);\n        return -1;\n    }\n\n    if (other) {\n        virDomainSnapshotDefPtr otherdef = virDomainSnapshotObjGetDef(other);\n\n        if ((otherdef->state == VIR_DOMAIN_SNAPSHOT_RUNNING ||\n             otherdef->state == VIR_DOMAIN_SNAPSHOT_PAUSED) !=\n            (def->state == VIR_DOMAIN_SNAPSHOT_RUNNING ||\n             def->state == VIR_DOMAIN_SNAPSHOT_PAUSED)) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"cannot change between online and offline \"\n                             \"snapshot state in snapshot %s\"),\n                           def->parent.name);\n            return -1;\n        }\n\n        if ((otherdef->state == VIR_DOMAIN_SNAPSHOT_DISK_SNAPSHOT) !=\n            (def->state == VIR_DOMAIN_SNAPSHOT_DISK_SNAPSHOT)) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"cannot change between disk only and \"\n                             \"full system in snapshot %s\"),\n                           def->parent.name);\n            return -1;\n        }\n\n        if (otherdef->parent.dom) {\n            if (def->parent.dom) {\n                if (!virDomainDefCheckABIStability(otherdef->parent.dom,\n                                                   def->parent.dom, xmlopt))\n                    return -1;\n            } else {\n                /* Transfer the domain def */\n                def->parent.dom = g_steal_pointer(&otherdef->parent.dom);\n            }\n        }\n    }\n\n    if (def->parent.dom) {\n        if (external) {\n            align_location = VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL;\n            align_match = false;\n        }\n        if (virDomainSnapshotAlignDisks(def, align_location,\n                                        align_match) < 0)\n            return -1;\n    }\n\n\n    return 0;\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainSnapshotRedefineValidate(virDomainSnapshotDefPtr def,\n                                  const unsigned char *domain_uuid,\n                                  virDomainMomentObjPtr other,\n                                  virDomainXMLOptionPtr xmlopt,\n                                  unsigned int flags)\n{\n    int align_location = VIR_DOMAIN_SNAPSHOT_LOCATION_INTERNAL;\n    bool align_match = true;\n    bool external = def->state == VIR_DOMAIN_SNAPSHOT_DISK_SNAPSHOT ||\n        virDomainSnapshotDefIsExternal(def);\n\n    if ((flags & VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY) && !external) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"disk-only flag for snapshot %s requires \"\n                         \"disk-snapshot state\"),\n                       def->parent.name);\n        return -1;\n    }\n    if (def->parent.dom && memcmp(def->parent.dom->uuid, domain_uuid,\n                                  VIR_UUID_BUFLEN)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(domain_uuid, uuidstr);\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"definition for snapshot %s must use uuid %s\"),\n                       def->parent.name, uuidstr);\n        return -1;\n    }\n\n    if (other) {\n        virDomainSnapshotDefPtr otherdef = virDomainSnapshotObjGetDef(other);\n\n        if ((otherdef->state == VIR_DOMAIN_SNAPSHOT_RUNNING ||\n             otherdef->state == VIR_DOMAIN_SNAPSHOT_PAUSED) !=\n            (def->state == VIR_DOMAIN_SNAPSHOT_RUNNING ||\n             def->state == VIR_DOMAIN_SNAPSHOT_PAUSED)) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"cannot change between online and offline \"\n                             \"snapshot state in snapshot %s\"),\n                           def->parent.name);\n            return -1;\n        }\n\n        if ((otherdef->state == VIR_DOMAIN_SNAPSHOT_DISK_SNAPSHOT) !=\n            (def->state == VIR_DOMAIN_SNAPSHOT_DISK_SNAPSHOT)) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"cannot change between disk only and \"\n                             \"full system in snapshot %s\"),\n                           def->parent.name);\n            return -1;\n        }\n\n        if (otherdef->parent.dom) {\n            if (def->parent.dom) {\n                if (!virDomainDefCheckABIStability(otherdef->parent.dom,\n                                                   def->parent.dom, xmlopt))\n                    return -1;\n            } else {\n                /* Transfer the domain def */\n                def->parent.dom = g_steal_pointer(&otherdef->parent.dom);\n            }\n        }\n    }\n\n    if (def->parent.dom) {\n        if (external) {\n            align_location = VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL;\n            align_match = false;\n        }\n        if (virDomainSnapshotAlignDisks(def, align_location,\n                                        align_match) < 0)\n            return -1;\n    }\n\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotObjGetDef",
          "args": [
            "other"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainsnapshotobjlist.h",
          "lines": "91-95",
          "snippet": "static inline virDomainSnapshotDefPtr\nvirDomainSnapshotObjGetDef(virDomainMomentObjPtr obj)\n{\n    return (virDomainSnapshotDefPtr) obj->def;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virdomainmomentobjlist.h\"",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "virDomainMomentObjPtr virDomainSnapshotAssignDef(virDomainSnapshotObjListPtr snapshots,\n                                                 virDomainSnapshotDefPtr def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virdomainmomentobjlist.h\"\n#include \"internal.h\"\n\nvirDomainMomentObjPtr virDomainSnapshotAssignDef(virDomainSnapshotObjListPtr snapshots,\n                                                 virDomainSnapshotDefPtr def);\n\nstatic inline virDomainSnapshotDefPtr\nvirDomainSnapshotObjGetDef(virDomainMomentObjPtr obj)\n{\n    return (virDomainSnapshotDefPtr) obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotFindByName",
          "args": [
            "vm->snapshots",
            "def->parent.name"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotFindByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainsnapshotobjlist.c",
          "lines": "167-172",
          "snippet": "virDomainMomentObjPtr\nvirDomainSnapshotFindByName(virDomainSnapshotObjListPtr snapshots,\n                            const char *name)\n{\n    return virDomainMomentFindByName(snapshots->base, name);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainMomentObjPtr\nvirDomainSnapshotFindByName(virDomainSnapshotObjListPtr snapshots,\n                            const char *name)\n{\n    return virDomainMomentFindByName(snapshots->base, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotCheckCycles",
          "args": [
            "vm->snapshots",
            "def",
            "vm->def->name"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotCheckCycles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainsnapshotobjlist.c",
          "lines": "246-252",
          "snippet": "int\nvirDomainSnapshotCheckCycles(virDomainSnapshotObjListPtr snapshots,\n                             virDomainSnapshotDefPtr def,\n                             const char *domname)\n{\n    return virDomainMomentCheckCycles(snapshots->base, &def->parent, domname);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDomainSnapshotCheckCycles(virDomainSnapshotObjListPtr snapshots,\n                             virDomainSnapshotDefPtr def,\n                             const char *domname)\n{\n    return virDomainMomentCheckCycles(snapshots->base, &def->parent, domname);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainSnapshotRedefinePrep(virDomainObjPtr vm,\n                              virDomainSnapshotDefPtr *defptr,\n                              virDomainMomentObjPtr *snap,\n                              virDomainXMLOptionPtr xmlopt,\n                              unsigned int flags)\n{\n    virDomainSnapshotDefPtr def = *defptr;\n    virDomainMomentObjPtr other;\n    virDomainSnapshotDefPtr otherdef = NULL;\n    bool check_if_stolen;\n\n    if (virDomainSnapshotCheckCycles(vm->snapshots, def, vm->def->name) < 0)\n        return -1;\n\n    other = virDomainSnapshotFindByName(vm->snapshots, def->parent.name);\n    if (other)\n        otherdef = virDomainSnapshotObjGetDef(other);\n    check_if_stolen = other && otherdef->parent.dom;\n    if (virDomainSnapshotRedefineValidate(def, vm->def->uuid, other, xmlopt,\n                                          flags) < 0) {\n        /* revert any stealing of the snapshot domain definition */\n        if (check_if_stolen && def->parent.dom && !otherdef->parent.dom)\n            otherdef->parent.dom = g_steal_pointer(&def->parent.dom);\n        return -1;\n    }\n    if (other) {\n        /* Drop and rebuild the parent relationship, but keep all\n         * child relations by reusing snap. */\n        virDomainMomentDropParent(other);\n        virObjectUnref(otherdef);\n        other->def = &(*defptr)->parent;\n        *defptr = NULL;\n        *snap = other;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainSnapshotIsExternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "961-967",
    "snippet": "bool\nvirDomainSnapshotIsExternal(virDomainMomentObjPtr snap)\n{\n    virDomainSnapshotDefPtr def = virDomainSnapshotObjGetDef(snap);\n\n    return virDomainSnapshotDefIsExternal(def);\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainSnapshotDefIsExternal",
          "args": [
            "def"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDefIsExternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "945-959",
          "snippet": "bool\nvirDomainSnapshotDefIsExternal(virDomainSnapshotDefPtr def)\n{\n    size_t i;\n\n    if (def->memory == VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL)\n        return true;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i].snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL)\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainSnapshotDefIsExternal(virDomainSnapshotDefPtr def)\n{\n    size_t i;\n\n    if (def->memory == VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL)\n        return true;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i].snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL)\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotObjGetDef",
          "args": [
            "snap"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainsnapshotobjlist.h",
          "lines": "91-95",
          "snippet": "static inline virDomainSnapshotDefPtr\nvirDomainSnapshotObjGetDef(virDomainMomentObjPtr obj)\n{\n    return (virDomainSnapshotDefPtr) obj->def;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virdomainmomentobjlist.h\"",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "virDomainMomentObjPtr virDomainSnapshotAssignDef(virDomainSnapshotObjListPtr snapshots,\n                                                 virDomainSnapshotDefPtr def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virdomainmomentobjlist.h\"\n#include \"internal.h\"\n\nvirDomainMomentObjPtr virDomainSnapshotAssignDef(virDomainSnapshotObjListPtr snapshots,\n                                                 virDomainSnapshotDefPtr def);\n\nstatic inline virDomainSnapshotDefPtr\nvirDomainSnapshotObjGetDef(virDomainMomentObjPtr obj)\n{\n    return (virDomainSnapshotDefPtr) obj->def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainSnapshotIsExternal(virDomainMomentObjPtr snap)\n{\n    virDomainSnapshotDefPtr def = virDomainSnapshotObjGetDef(snap);\n\n    return virDomainSnapshotDefIsExternal(def);\n}"
  },
  {
    "function_name": "virDomainSnapshotDefIsExternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "945-959",
    "snippet": "bool\nvirDomainSnapshotDefIsExternal(virDomainSnapshotDefPtr def)\n{\n    size_t i;\n\n    if (def->memory == VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL)\n        return true;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i].snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL)\n            return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainSnapshotDefIsExternal(virDomainSnapshotDefPtr def)\n{\n    size_t i;\n\n    if (def->memory == VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL)\n        return true;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i].snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL)\n            return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virDomainSnapshotDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "926-942",
    "snippet": "char *\nvirDomainSnapshotDefFormat(const char *uuidstr,\n                           virDomainSnapshotDefPtr def,\n                           virDomainXMLOptionPtr xmlopt,\n                           unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_INTERNAL |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_CURRENT, NULL);\n    if (virDomainSnapshotDefFormatInternal(&buf, uuidstr, def,\n                                           xmlopt, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDefFormatInternal",
          "args": [
            "&buf",
            "uuidstr",
            "def",
            "xmlopt",
            "flags"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDefFormatInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "833-923",
          "snippet": "static int\nvirDomainSnapshotDefFormatInternal(virBufferPtr buf,\n                                   const char *uuidstr,\n                                   virDomainSnapshotDefPtr def,\n                                   virDomainXMLOptionPtr xmlopt,\n                                   unsigned int flags)\n{\n    size_t i;\n    int domainflags = VIR_DOMAIN_DEF_FORMAT_INACTIVE;\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE)\n        domainflags |= VIR_DOMAIN_DEF_FORMAT_SECURE;\n\n    virBufferAddLit(buf, \"<domainsnapshot>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->parent.name);\n    if (def->parent.description)\n        virBufferEscapeString(buf, \"<description>%s</description>\\n\",\n                              def->parent.description);\n    if (def->state)\n        virBufferAsprintf(buf, \"<state>%s</state>\\n\",\n                          virDomainSnapshotStateTypeToString(def->state));\n\n    if (def->parent.parent_name) {\n        virBufferAddLit(buf, \"<parent>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\",\n                              def->parent.parent_name);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</parent>\\n\");\n    }\n\n    if (def->parent.creationTime)\n        virBufferAsprintf(buf, \"<creationTime>%lld</creationTime>\\n\",\n                          def->parent.creationTime);\n\n    if (def->memory) {\n        virBufferAsprintf(buf, \"<memory snapshot='%s'\",\n                          virDomainSnapshotLocationTypeToString(def->memory));\n        virBufferEscapeString(buf, \" file='%s'\", def->file);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->ndisks) {\n        virBufferAddLit(buf, \"<disks>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < def->ndisks; i++) {\n            if (virDomainSnapshotDiskDefFormat(buf, &def->disks[i], xmlopt) < 0)\n                goto error;\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</disks>\\n\");\n    }\n\n    if (def->parent.dom) {\n        if (virDomainDefFormatInternal(def->parent.dom, xmlopt,\n                                       buf, domainflags) < 0)\n            goto error;\n    } else if (uuidstr) {\n        virBufferAddLit(buf, \"<domain>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</domain>\\n\");\n    }\n\n    if (def->parent.inactiveDom) {\n        if (virDomainDefFormatInternalSetRootName(def->parent.inactiveDom, xmlopt,\n                                                  buf, \"inactiveDomain\",\n                                                  domainflags) < 0)\n            goto error;\n    }\n\n    if (virSaveCookieFormatBuf(buf, def->cookie,\n                               virDomainXMLOptionGetSaveCookie(xmlopt)) < 0)\n        goto error;\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_FORMAT_INTERNAL)\n        virBufferAsprintf(buf, \"<active>%d</active>\\n\",\n                          !!(flags & VIR_DOMAIN_SNAPSHOT_FORMAT_CURRENT));\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</domainsnapshot>\\n\");\n\n    return 0;\n\n error:\n    virBufferFreeAndReset(buf);\n    return -1;\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirDomainSnapshotDefFormatInternal(virBufferPtr buf,\n                                   const char *uuidstr,\n                                   virDomainSnapshotDefPtr def,\n                                   virDomainXMLOptionPtr xmlopt,\n                                   unsigned int flags)\n{\n    size_t i;\n    int domainflags = VIR_DOMAIN_DEF_FORMAT_INACTIVE;\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE)\n        domainflags |= VIR_DOMAIN_DEF_FORMAT_SECURE;\n\n    virBufferAddLit(buf, \"<domainsnapshot>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->parent.name);\n    if (def->parent.description)\n        virBufferEscapeString(buf, \"<description>%s</description>\\n\",\n                              def->parent.description);\n    if (def->state)\n        virBufferAsprintf(buf, \"<state>%s</state>\\n\",\n                          virDomainSnapshotStateTypeToString(def->state));\n\n    if (def->parent.parent_name) {\n        virBufferAddLit(buf, \"<parent>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\",\n                              def->parent.parent_name);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</parent>\\n\");\n    }\n\n    if (def->parent.creationTime)\n        virBufferAsprintf(buf, \"<creationTime>%lld</creationTime>\\n\",\n                          def->parent.creationTime);\n\n    if (def->memory) {\n        virBufferAsprintf(buf, \"<memory snapshot='%s'\",\n                          virDomainSnapshotLocationTypeToString(def->memory));\n        virBufferEscapeString(buf, \" file='%s'\", def->file);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->ndisks) {\n        virBufferAddLit(buf, \"<disks>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < def->ndisks; i++) {\n            if (virDomainSnapshotDiskDefFormat(buf, &def->disks[i], xmlopt) < 0)\n                goto error;\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</disks>\\n\");\n    }\n\n    if (def->parent.dom) {\n        if (virDomainDefFormatInternal(def->parent.dom, xmlopt,\n                                       buf, domainflags) < 0)\n            goto error;\n    } else if (uuidstr) {\n        virBufferAddLit(buf, \"<domain>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</domain>\\n\");\n    }\n\n    if (def->parent.inactiveDom) {\n        if (virDomainDefFormatInternalSetRootName(def->parent.inactiveDom, xmlopt,\n                                                  buf, \"inactiveDomain\",\n                                                  domainflags) < 0)\n            goto error;\n    }\n\n    if (virSaveCookieFormatBuf(buf, def->cookie,\n                               virDomainXMLOptionGetSaveCookie(xmlopt)) < 0)\n        goto error;\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_FORMAT_INTERNAL)\n        virBufferAsprintf(buf, \"<active>%d</active>\\n\",\n                          !!(flags & VIR_DOMAIN_SNAPSHOT_FORMAT_CURRENT));\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</domainsnapshot>\\n\");\n\n    return 0;\n\n error:\n    virBufferFreeAndReset(buf);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_INTERNAL |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_CURRENT",
            "NULL"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *\nvirDomainSnapshotDefFormat(const char *uuidstr,\n                           virDomainSnapshotDefPtr def,\n                           virDomainXMLOptionPtr xmlopt,\n                           unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_INTERNAL |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_CURRENT, NULL);\n    if (virDomainSnapshotDefFormatInternal(&buf, uuidstr, def,\n                                           xmlopt, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
  },
  {
    "function_name": "virDomainSnapshotDefFormatInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "833-923",
    "snippet": "static int\nvirDomainSnapshotDefFormatInternal(virBufferPtr buf,\n                                   const char *uuidstr,\n                                   virDomainSnapshotDefPtr def,\n                                   virDomainXMLOptionPtr xmlopt,\n                                   unsigned int flags)\n{\n    size_t i;\n    int domainflags = VIR_DOMAIN_DEF_FORMAT_INACTIVE;\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE)\n        domainflags |= VIR_DOMAIN_DEF_FORMAT_SECURE;\n\n    virBufferAddLit(buf, \"<domainsnapshot>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->parent.name);\n    if (def->parent.description)\n        virBufferEscapeString(buf, \"<description>%s</description>\\n\",\n                              def->parent.description);\n    if (def->state)\n        virBufferAsprintf(buf, \"<state>%s</state>\\n\",\n                          virDomainSnapshotStateTypeToString(def->state));\n\n    if (def->parent.parent_name) {\n        virBufferAddLit(buf, \"<parent>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\",\n                              def->parent.parent_name);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</parent>\\n\");\n    }\n\n    if (def->parent.creationTime)\n        virBufferAsprintf(buf, \"<creationTime>%lld</creationTime>\\n\",\n                          def->parent.creationTime);\n\n    if (def->memory) {\n        virBufferAsprintf(buf, \"<memory snapshot='%s'\",\n                          virDomainSnapshotLocationTypeToString(def->memory));\n        virBufferEscapeString(buf, \" file='%s'\", def->file);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->ndisks) {\n        virBufferAddLit(buf, \"<disks>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < def->ndisks; i++) {\n            if (virDomainSnapshotDiskDefFormat(buf, &def->disks[i], xmlopt) < 0)\n                goto error;\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</disks>\\n\");\n    }\n\n    if (def->parent.dom) {\n        if (virDomainDefFormatInternal(def->parent.dom, xmlopt,\n                                       buf, domainflags) < 0)\n            goto error;\n    } else if (uuidstr) {\n        virBufferAddLit(buf, \"<domain>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</domain>\\n\");\n    }\n\n    if (def->parent.inactiveDom) {\n        if (virDomainDefFormatInternalSetRootName(def->parent.inactiveDom, xmlopt,\n                                                  buf, \"inactiveDomain\",\n                                                  domainflags) < 0)\n            goto error;\n    }\n\n    if (virSaveCookieFormatBuf(buf, def->cookie,\n                               virDomainXMLOptionGetSaveCookie(xmlopt)) < 0)\n        goto error;\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_FORMAT_INTERNAL)\n        virBufferAsprintf(buf, \"<active>%d</active>\\n\",\n                          !!(flags & VIR_DOMAIN_SNAPSHOT_FORMAT_CURRENT));\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</domainsnapshot>\\n\");\n\n    return 0;\n\n error:\n    virBufferFreeAndReset(buf);\n    return -1;\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "buf"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</domainsnapshot>\\n\""
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"<active>%d</active>\\n\"",
            "!!(flags & VIR_DOMAIN_SNAPSHOT_FORMAT_CURRENT)"
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSaveCookieFormatBuf",
          "args": [
            "buf",
            "def->cookie",
            "virDomainXMLOptionGetSaveCookie(xmlopt)"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "virSaveCookieFormatBuf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virsavecookie.c",
          "lines": "106-124",
          "snippet": "int\nvirSaveCookieFormatBuf(virBufferPtr buf,\n                       virObjectPtr obj,\n                       virSaveCookieCallbacksPtr saveCookie)\n{\n    if (!obj || !saveCookie || !saveCookie->format)\n        return 0;\n\n    virBufferAddLit(buf, \"<cookie>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (saveCookie->format(buf, obj) < 0)\n        return -1;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</cookie>\\n\");\n\n    return 0;\n}",
          "includes": [
            "#include \"virsavecookie.h\"",
            "#include \"virxml.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsavecookie.h\"\n#include \"virxml.h\"\n#include \"virbuffer.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirSaveCookieFormatBuf(virBufferPtr buf,\n                       virObjectPtr obj,\n                       virSaveCookieCallbacksPtr saveCookie)\n{\n    if (!obj || !saveCookie || !saveCookie->format)\n        return 0;\n\n    virBufferAddLit(buf, \"<cookie>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    if (saveCookie->format(buf, obj) < 0)\n        return -1;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</cookie>\\n\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainXMLOptionGetSaveCookie",
          "args": [
            "xmlopt"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainXMLOptionGetSaveCookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1513-1517",
          "snippet": "virSaveCookieCallbacksPtr\nvirDomainXMLOptionGetSaveCookie(virDomainXMLOptionPtr xmlopt)\n{\n    return &xmlopt->saveCookie;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSaveCookieCallbacksPtr\nvirDomainXMLOptionGetSaveCookie(virDomainXMLOptionPtr xmlopt)\n{\n    return &xmlopt->saveCookie;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormatInternalSetRootName",
          "args": [
            "def->parent.inactiveDom",
            "xmlopt",
            "buf",
            "\"inactiveDomain\"",
            "domainflags"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormatInternalSetRootName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "28958-29474",
          "snippet": "int\nvirDomainDefFormatInternalSetRootName(virDomainDefPtr def,\n                                      virDomainXMLOptionPtr xmlopt,\n                                      virBufferPtr buf,\n                                      const char *rootname,\n                                      unsigned int flags)\n{\n    unsigned char *uuid;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    const char *type = NULL;\n    int n;\n    size_t i;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS |\n                  VIR_DOMAIN_DEF_FORMAT_STATUS |\n                  VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                  VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                  VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST,\n                  -1);\n\n    if (!(type = virDomainVirtTypeToString(def->virtType))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected domain type %d\"), def->virtType);\n        goto error;\n    }\n\n    if (def->id == -1)\n        flags |= VIR_DOMAIN_DEF_FORMAT_INACTIVE;\n\n    virBufferAsprintf(buf, \"<%s type='%s'\", rootname, type);\n    if (!(flags & VIR_DOMAIN_DEF_FORMAT_INACTIVE))\n        virBufferAsprintf(buf, \" id='%d'\", def->id);\n    if (def->namespaceData && def->ns.format)\n        virXMLNamespaceFormatNS(buf, &def->ns);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->name);\n\n    uuid = def->uuid;\n    virUUIDFormat(uuid, uuidstr);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n\n    if (def->genidRequested) {\n        char genidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(def->genid, genidstr);\n        virBufferAsprintf(buf, \"<genid>%s</genid>\\n\", genidstr);\n    }\n\n    virBufferEscapeString(buf, \"<title>%s</title>\\n\", def->title);\n\n    virBufferEscapeString(buf, \"<description>%s</description>\\n\",\n                          def->description);\n\n    if (def->metadata) {\n        xmlBufferPtr xmlbuf;\n        int oldIndentTreeOutput = xmlIndentTreeOutput;\n\n        /* Indentation on output requires that we previously set\n         * xmlKeepBlanksDefault to 0 when parsing; also, libxml does 2\n         * spaces per level of indentation of intermediate elements,\n         * but no leading indentation before the starting element.\n         * Thankfully, libxml maps what looks like globals into\n         * thread-local uses, so we are thread-safe.  */\n        xmlIndentTreeOutput = 1;\n        xmlbuf = xmlBufferCreate();\n        if (xmlNodeDump(xmlbuf, def->metadata->doc, def->metadata,\n                        virBufferGetIndent(buf) / 2, 1) < 0) {\n            xmlBufferFree(xmlbuf);\n            xmlIndentTreeOutput = oldIndentTreeOutput;\n            goto error;\n        }\n        virBufferAsprintf(buf, \"%s\\n\", (char *) xmlBufferContent(xmlbuf));\n        xmlBufferFree(xmlbuf);\n        xmlIndentTreeOutput = oldIndentTreeOutput;\n    }\n\n    if (virDomainDefHasMemoryHotplug(def)) {\n        virBufferAsprintf(buf,\n                          \"<maxMemory slots='%u' unit='KiB'>%llu</maxMemory>\\n\",\n                          def->mem.memory_slots, def->mem.max_memory);\n    }\n\n    virBufferAddLit(buf, \"<memory\");\n    if (def->mem.dump_core)\n        virBufferAsprintf(buf, \" dumpCore='%s'\",\n                          virTristateSwitchTypeToString(def->mem.dump_core));\n    virBufferAsprintf(buf, \" unit='KiB'>%llu</memory>\\n\",\n                      virDomainDefGetMemoryTotal(def));\n\n    virBufferAsprintf(buf, \"<currentMemory unit='KiB'>%llu</currentMemory>\\n\",\n                      def->mem.cur_balloon);\n\n    if (virDomainDefFormatBlkiotune(buf, def) < 0)\n        goto error;\n\n    virDomainMemtuneFormat(buf, &def->mem);\n    virDomainMemorybackingFormat(buf, &def->mem);\n\n    if (virDomainCpuDefFormat(buf, def) < 0)\n        goto error;\n\n    if (def->niothreadids > 0) {\n        virBufferAsprintf(buf, \"<iothreads>%zu</iothreads>\\n\",\n                          def->niothreadids);\n        if (virDomainDefIothreadShouldFormat(def)) {\n            virBufferAddLit(buf, \"<iothreadids>\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (i = 0; i < def->niothreadids; i++) {\n                virBufferAsprintf(buf, \"<iothread id='%u'/>\\n\",\n                                  def->iothreadids[i]->iothread_id);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</iothreadids>\\n\");\n        }\n    }\n\n    if (virDomainCputuneDefFormat(buf, def, flags) < 0)\n        goto error;\n\n    if (virDomainNumatuneFormatXML(buf, def->numa) < 0)\n        goto error;\n\n    if (def->resource)\n        virDomainResourceDefFormat(buf, def->resource);\n\n    if (def->sysinfo)\n        ignore_value(virSysinfoFormat(buf, def->sysinfo));\n\n    if (def->os.bootloader) {\n        virBufferEscapeString(buf, \"<bootloader>%s</bootloader>\\n\",\n                              def->os.bootloader);\n        virBufferEscapeString(buf,\n                              \"<bootloader_args>%s</bootloader_args>\\n\",\n                              def->os.bootloaderArgs);\n    }\n\n    virBufferAddLit(buf, \"<os\");\n    if (def->os.firmware)\n        virBufferAsprintf(buf, \" firmware='%s'\",\n                          virDomainOsDefFirmwareTypeToString(def->os.firmware));\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferAddLit(buf, \"<type\");\n    if (def->os.arch)\n        virBufferAsprintf(buf, \" arch='%s'\", virArchToString(def->os.arch));\n    if (def->os.machine)\n        virBufferAsprintf(buf, \" machine='%s'\", def->os.machine);\n    /*\n     * HACK: For xen driver we previously used bogus 'linux' as the\n     * os type for paravirt, whereas capabilities declare it to\n     * be 'xen'. So we convert to the former for backcompat\n     */\n    if (def->virtType == VIR_DOMAIN_VIRT_XEN &&\n        def->os.type == VIR_DOMAIN_OSTYPE_XEN)\n        virBufferAsprintf(buf, \">%s</type>\\n\",\n                          virDomainOSTypeToString(VIR_DOMAIN_OSTYPE_LINUX));\n    else\n        virBufferAsprintf(buf, \">%s</type>\\n\",\n                          virDomainOSTypeToString(def->os.type));\n\n    virBufferEscapeString(buf, \"<init>%s</init>\\n\",\n                          def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        virBufferEscapeString(buf, \"<initarg>%s</initarg>\\n\",\n                              def->os.initargv[i]);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++)\n        virBufferAsprintf(buf, \"<initenv name='%s'>%s</initenv>\\n\",\n                          def->os.initenv[i]->name, def->os.initenv[i]->value);\n    if (def->os.initdir)\n        virBufferEscapeString(buf, \"<initdir>%s</initdir>\\n\",\n                              def->os.initdir);\n    if (def->os.inituser)\n        virBufferAsprintf(buf, \"<inituser>%s</inituser>\\n\", def->os.inituser);\n    if (def->os.initgroup)\n        virBufferAsprintf(buf, \"<initgroup>%s</initgroup>\\n\", def->os.initgroup);\n\n    if (def->os.loader)\n        virDomainLoaderDefFormat(buf, def->os.loader);\n    virBufferEscapeString(buf, \"<kernel>%s</kernel>\\n\",\n                          def->os.kernel);\n    virBufferEscapeString(buf, \"<initrd>%s</initrd>\\n\",\n                          def->os.initrd);\n    virBufferEscapeString(buf, \"<cmdline>%s</cmdline>\\n\",\n                          def->os.cmdline);\n    virBufferEscapeString(buf, \"<dtb>%s</dtb>\\n\",\n                          def->os.dtb);\n    virBufferEscapeString(buf, \"<root>%s</root>\\n\",\n                          def->os.root);\n    if (def->os.slic_table) {\n        virBufferAddLit(buf, \"<acpi>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferEscapeString(buf, \"<table type='slic'>%s</table>\\n\",\n                              def->os.slic_table);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</acpi>\\n\");\n    }\n\n    if (!def->os.bootloader) {\n        for (n = 0; n < def->os.nBootDevs; n++) {\n            const char *boottype =\n                virDomainBootTypeToString(def->os.bootDevs[n]);\n            if (!boottype) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unexpected boot device type %d\"),\n                               def->os.bootDevs[n]);\n                goto error;\n            }\n            virBufferAsprintf(buf, \"<boot dev='%s'/>\\n\", boottype);\n        }\n\n        if (def->os.bootmenu) {\n            virBufferAsprintf(buf, \"<bootmenu enable='%s'\",\n                              virTristateBoolTypeToString(def->os.bootmenu));\n            if (def->os.bm_timeout_set)\n                virBufferAsprintf(buf, \" timeout='%u'\", def->os.bm_timeout);\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n\n        if (def->os.bios.useserial || def->os.bios.rt_set) {\n            virBufferAddLit(buf, \"<bios\");\n            if (def->os.bios.useserial)\n                virBufferAsprintf(buf, \" useserial='%s'\",\n                                  virTristateBoolTypeToString(def->os.bios.useserial));\n            if (def->os.bios.rt_set)\n                virBufferAsprintf(buf, \" rebootTimeout='%d'\", def->os.bios.rt_delay);\n\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    if (def->os.smbios_mode) {\n        const char *mode;\n\n        mode = virDomainSmbiosModeTypeToString(def->os.smbios_mode);\n        if (mode == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected smbios mode %d\"), def->os.smbios_mode);\n            goto error;\n        }\n        virBufferAsprintf(buf, \"<smbios mode='%s'/>\\n\", mode);\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</os>\\n\");\n\n\n    if (def->idmap.uidmap) {\n        virBufferAddLit(buf, \"<idmap>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < def->idmap.nuidmap; i++) {\n            virBufferAsprintf(buf,\n                              \"<uid start='%u' target='%u' count='%u'/>\\n\",\n                              def->idmap.uidmap[i].start,\n                              def->idmap.uidmap[i].target,\n                              def->idmap.uidmap[i].count);\n        }\n        for (i = 0; i < def->idmap.ngidmap; i++) {\n            virBufferAsprintf(buf,\n                              \"<gid start='%u' target='%u' count='%u'/>\\n\",\n                              def->idmap.gidmap[i].start,\n                              def->idmap.gidmap[i].target,\n                              def->idmap.gidmap[i].count);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</idmap>\\n\");\n    }\n\n    if (virDomainDefFormatFeatures(buf, def) < 0)\n        goto error;\n\n    if (virCPUDefFormatBufFull(buf, def->cpu, def->numa) < 0)\n        goto error;\n\n    virBufferAsprintf(buf, \"<clock offset='%s'\",\n                      virDomainClockOffsetTypeToString(def->clock.offset));\n    switch (def->clock.offset) {\n    case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n    case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n        if (def->clock.data.utc_reset)\n            virBufferAddLit(buf, \" adjustment='reset'\");\n        break;\n    case VIR_DOMAIN_CLOCK_OFFSET_VARIABLE:\n        virBufferAsprintf(buf, \" adjustment='%lld' basis='%s'\",\n                          def->clock.data.variable.adjustment,\n                          virDomainClockBasisTypeToString(def->clock.data.variable.basis));\n        if (flags & VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST) {\n            if (def->clock.data.variable.adjustment0)\n                virBufferAsprintf(buf, \" adjustment0='%lld'\",\n                                  def->clock.data.variable.adjustment0);\n        }\n        break;\n    case VIR_DOMAIN_CLOCK_OFFSET_TIMEZONE:\n        virBufferEscapeString(buf, \" timezone='%s'\", def->clock.data.timezone);\n        break;\n    }\n    if (def->clock.ntimers == 0) {\n        virBufferAddLit(buf, \"/>\\n\");\n    } else {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (n = 0; n < def->clock.ntimers; n++) {\n            if (virDomainTimerDefFormat(buf, def->clock.timers[n]) < 0)\n                goto error;\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</clock>\\n\");\n    }\n\n    if (virDomainEventActionDefFormat(buf, def->onPoweroff,\n                                      \"on_poweroff\",\n                                      virDomainLifecycleActionTypeToString) < 0)\n        goto error;\n    if (virDomainEventActionDefFormat(buf, def->onReboot,\n                                      \"on_reboot\",\n                                      virDomainLifecycleActionTypeToString) < 0)\n        goto error;\n    if (virDomainEventActionDefFormat(buf, def->onCrash,\n                                      \"on_crash\",\n                                      virDomainLifecycleActionTypeToString) < 0)\n        goto error;\n    if (def->onLockFailure != VIR_DOMAIN_LOCK_FAILURE_DEFAULT &&\n        virDomainEventActionDefFormat(buf, def->onLockFailure,\n                                      \"on_lockfailure\",\n                                      virDomainLockFailureTypeToString) < 0)\n        goto error;\n\n    if (def->pm.s3 || def->pm.s4) {\n        virBufferAddLit(buf, \"<pm>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        if (def->pm.s3) {\n            virBufferAsprintf(buf, \"<suspend-to-mem enabled='%s'/>\\n\",\n                              virTristateBoolTypeToString(def->pm.s3));\n        }\n        if (def->pm.s4) {\n            virBufferAsprintf(buf, \"<suspend-to-disk enabled='%s'/>\\n\",\n                              virTristateBoolTypeToString(def->pm.s4));\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</pm>\\n\");\n    }\n\n    virDomainPerfDefFormat(buf, &def->perf);\n\n    virBufferAddLit(buf, \"<devices>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferEscapeString(buf, \"<emulator>%s</emulator>\\n\",\n                          def->emulator);\n\n    for (n = 0; n < def->ndisks; n++)\n        if (virDomainDiskDefFormat(buf, def->disks[n], flags, xmlopt) < 0)\n            goto error;\n\n    for (n = 0; n < def->ncontrollers; n++)\n        if (virDomainControllerDefFormat(buf, def->controllers[n], flags) < 0)\n            goto error;\n\n    for (n = 0; n < def->nleases; n++)\n        if (virDomainLeaseDefFormat(buf, def->leases[n]) < 0)\n            goto error;\n\n    for (n = 0; n < def->nfss; n++)\n        if (virDomainFSDefFormat(buf, def->fss[n], flags) < 0)\n            goto error;\n\n    for (n = 0; n < def->nnets; n++)\n        if (virDomainNetDefFormat(buf, def->nets[n], xmlopt, flags) < 0)\n            goto error;\n\n    for (n = 0; n < def->nsmartcards; n++)\n        if (virDomainSmartcardDefFormat(buf, def->smartcards[n], flags) < 0)\n            goto error;\n\n    for (n = 0; n < def->nserials; n++)\n        if (virDomainChrDefFormat(buf, def->serials[n], flags) < 0)\n            goto error;\n\n    for (n = 0; n < def->nparallels; n++)\n        if (virDomainChrDefFormat(buf, def->parallels[n], flags) < 0)\n            goto error;\n\n    for (n = 0; n < def->nconsoles; n++) {\n        virDomainChrDef console;\n        /* Back compat, ignore the console element for hvm guests\n         * if it is type == serial\n         */\n        if (def->os.type == VIR_DOMAIN_OSTYPE_HVM &&\n            (def->consoles[n]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_SERIAL ||\n             def->consoles[n]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_NONE) &&\n            (n < def->nserials)) {\n            memcpy(&console, def->serials[n], sizeof(console));\n            console.deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE;\n            console.targetType = VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_SERIAL;\n        } else {\n            memcpy(&console, def->consoles[n], sizeof(console));\n        }\n        if (virDomainChrDefFormat(buf, &console, flags) < 0)\n            goto error;\n    }\n\n    for (n = 0; n < def->nchannels; n++)\n        if (virDomainChrDefFormat(buf, def->channels[n], flags) < 0)\n            goto error;\n\n    for (n = 0; n < def->ninputs; n++) {\n        if (virDomainInputDefFormat(buf, def->inputs[n], flags) < 0)\n            goto error;\n    }\n\n    if (def->tpm) {\n        if (virDomainTPMDefFormat(buf, def->tpm, flags) < 0)\n            goto error;\n    }\n\n    for (n = 0; n < def->ngraphics; n++) {\n        if (virDomainGraphicsDefFormat(buf, def->graphics[n], flags) < 0)\n            goto error;\n    }\n\n    for (n = 0; n < def->nsounds; n++) {\n        if (virDomainSoundDefFormat(buf, def->sounds[n], flags) < 0)\n            goto error;\n    }\n\n    for (n = 0; n < def->nvideos; n++) {\n        if (virDomainVideoDefFormat(buf, def->videos[n], flags) < 0)\n            goto error;\n    }\n\n    for (n = 0; n < def->nhostdevs; n++) {\n        /* If parentnet != NONE, this is just a pointer to the\n         * hostdev in a higher-level device (e.g. virDomainNetDef),\n         * and will have already been formatted there.\n         */\n        if (!def->hostdevs[n]->parentnet &&\n            virDomainHostdevDefFormat(buf, def->hostdevs[n], flags) < 0) {\n            goto error;\n        }\n    }\n\n    for (n = 0; n < def->nredirdevs; n++) {\n        if (virDomainRedirdevDefFormat(buf, def->redirdevs[n], flags) < 0)\n            goto error;\n    }\n\n    if (def->redirfilter)\n        virDomainRedirFilterDefFormat(buf, def->redirfilter);\n\n    for (n = 0; n < def->nhubs; n++) {\n        if (virDomainHubDefFormat(buf, def->hubs[n], flags) < 0)\n            goto error;\n    }\n\n    if (def->watchdog)\n        virDomainWatchdogDefFormat(buf, def->watchdog, flags);\n\n    if (def->memballoon)\n        virDomainMemballoonDefFormat(buf, def->memballoon, flags);\n\n    for (n = 0; n < def->nrngs; n++) {\n        if (virDomainRNGDefFormat(buf, def->rngs[n], flags))\n            goto error;\n    }\n\n    if (def->nvram)\n        virDomainNVRAMDefFormat(buf, def->nvram, flags);\n\n    for (n = 0; n < def->npanics; n++) {\n        if (virDomainPanicDefFormat(buf, def->panics[n]) < 0)\n            goto error;\n    }\n\n    for (n = 0; n < def->nshmems; n++) {\n        if (virDomainShmemDefFormat(buf, def->shmems[n], flags) < 0)\n            goto error;\n    }\n\n    for (n = 0; n < def->nmems; n++) {\n        if (virDomainMemoryDefFormat(buf, def->mems[n], flags) < 0)\n            goto error;\n    }\n\n    if (def->iommu &&\n        virDomainIOMMUDefFormat(buf, def->iommu) < 0)\n        goto error;\n\n    if (def->vsock &&\n        virDomainVsockDefFormat(buf, def->vsock) < 0)\n        goto error;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</devices>\\n\");\n\n    for (n = 0; n < def->nseclabels; n++)\n        virSecurityLabelDefFormat(buf, def->seclabels[n], flags);\n\n    if (def->namespaceData && def->ns.format) {\n        if ((def->ns.format)(buf, def->namespaceData) < 0)\n            goto error;\n    }\n\n    if (def->keywrap)\n        virDomainKeyWrapDefFormat(buf, def->keywrap);\n\n    virDomainSEVDefFormat(buf, def->sev);\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAsprintf(buf, \"</%s>\\n\", rootname);\n\n    return 0;\n\n error:\n    virBufferFreeAndReset(buf);\n    return -1;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)\n\nint\nvirDomainDefFormatInternalSetRootName(virDomainDefPtr def,\n                                      virDomainXMLOptionPtr xmlopt,\n                                      virBufferPtr buf,\n                                      const char *rootname,\n                                      unsigned int flags)\n{\n    unsigned char *uuid;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    const char *type = NULL;\n    int n;\n    size_t i;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS |\n                  VIR_DOMAIN_DEF_FORMAT_STATUS |\n                  VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                  VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                  VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST,\n                  -1);\n\n    if (!(type = virDomainVirtTypeToString(def->virtType))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected domain type %d\"), def->virtType);\n        goto error;\n    }\n\n    if (def->id == -1)\n        flags |= VIR_DOMAIN_DEF_FORMAT_INACTIVE;\n\n    virBufferAsprintf(buf, \"<%s type='%s'\", rootname, type);\n    if (!(flags & VIR_DOMAIN_DEF_FORMAT_INACTIVE))\n        virBufferAsprintf(buf, \" id='%d'\", def->id);\n    if (def->namespaceData && def->ns.format)\n        virXMLNamespaceFormatNS(buf, &def->ns);\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->name);\n\n    uuid = def->uuid;\n    virUUIDFormat(uuid, uuidstr);\n    virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n\n    if (def->genidRequested) {\n        char genidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(def->genid, genidstr);\n        virBufferAsprintf(buf, \"<genid>%s</genid>\\n\", genidstr);\n    }\n\n    virBufferEscapeString(buf, \"<title>%s</title>\\n\", def->title);\n\n    virBufferEscapeString(buf, \"<description>%s</description>\\n\",\n                          def->description);\n\n    if (def->metadata) {\n        xmlBufferPtr xmlbuf;\n        int oldIndentTreeOutput = xmlIndentTreeOutput;\n\n        /* Indentation on output requires that we previously set\n         * xmlKeepBlanksDefault to 0 when parsing; also, libxml does 2\n         * spaces per level of indentation of intermediate elements,\n         * but no leading indentation before the starting element.\n         * Thankfully, libxml maps what looks like globals into\n         * thread-local uses, so we are thread-safe.  */\n        xmlIndentTreeOutput = 1;\n        xmlbuf = xmlBufferCreate();\n        if (xmlNodeDump(xmlbuf, def->metadata->doc, def->metadata,\n                        virBufferGetIndent(buf) / 2, 1) < 0) {\n            xmlBufferFree(xmlbuf);\n            xmlIndentTreeOutput = oldIndentTreeOutput;\n            goto error;\n        }\n        virBufferAsprintf(buf, \"%s\\n\", (char *) xmlBufferContent(xmlbuf));\n        xmlBufferFree(xmlbuf);\n        xmlIndentTreeOutput = oldIndentTreeOutput;\n    }\n\n    if (virDomainDefHasMemoryHotplug(def)) {\n        virBufferAsprintf(buf,\n                          \"<maxMemory slots='%u' unit='KiB'>%llu</maxMemory>\\n\",\n                          def->mem.memory_slots, def->mem.max_memory);\n    }\n\n    virBufferAddLit(buf, \"<memory\");\n    if (def->mem.dump_core)\n        virBufferAsprintf(buf, \" dumpCore='%s'\",\n                          virTristateSwitchTypeToString(def->mem.dump_core));\n    virBufferAsprintf(buf, \" unit='KiB'>%llu</memory>\\n\",\n                      virDomainDefGetMemoryTotal(def));\n\n    virBufferAsprintf(buf, \"<currentMemory unit='KiB'>%llu</currentMemory>\\n\",\n                      def->mem.cur_balloon);\n\n    if (virDomainDefFormatBlkiotune(buf, def) < 0)\n        goto error;\n\n    virDomainMemtuneFormat(buf, &def->mem);\n    virDomainMemorybackingFormat(buf, &def->mem);\n\n    if (virDomainCpuDefFormat(buf, def) < 0)\n        goto error;\n\n    if (def->niothreadids > 0) {\n        virBufferAsprintf(buf, \"<iothreads>%zu</iothreads>\\n\",\n                          def->niothreadids);\n        if (virDomainDefIothreadShouldFormat(def)) {\n            virBufferAddLit(buf, \"<iothreadids>\\n\");\n            virBufferAdjustIndent(buf, 2);\n            for (i = 0; i < def->niothreadids; i++) {\n                virBufferAsprintf(buf, \"<iothread id='%u'/>\\n\",\n                                  def->iothreadids[i]->iothread_id);\n            }\n            virBufferAdjustIndent(buf, -2);\n            virBufferAddLit(buf, \"</iothreadids>\\n\");\n        }\n    }\n\n    if (virDomainCputuneDefFormat(buf, def, flags) < 0)\n        goto error;\n\n    if (virDomainNumatuneFormatXML(buf, def->numa) < 0)\n        goto error;\n\n    if (def->resource)\n        virDomainResourceDefFormat(buf, def->resource);\n\n    if (def->sysinfo)\n        ignore_value(virSysinfoFormat(buf, def->sysinfo));\n\n    if (def->os.bootloader) {\n        virBufferEscapeString(buf, \"<bootloader>%s</bootloader>\\n\",\n                              def->os.bootloader);\n        virBufferEscapeString(buf,\n                              \"<bootloader_args>%s</bootloader_args>\\n\",\n                              def->os.bootloaderArgs);\n    }\n\n    virBufferAddLit(buf, \"<os\");\n    if (def->os.firmware)\n        virBufferAsprintf(buf, \" firmware='%s'\",\n                          virDomainOsDefFirmwareTypeToString(def->os.firmware));\n    virBufferAddLit(buf, \">\\n\");\n    virBufferAdjustIndent(buf, 2);\n    virBufferAddLit(buf, \"<type\");\n    if (def->os.arch)\n        virBufferAsprintf(buf, \" arch='%s'\", virArchToString(def->os.arch));\n    if (def->os.machine)\n        virBufferAsprintf(buf, \" machine='%s'\", def->os.machine);\n    /*\n     * HACK: For xen driver we previously used bogus 'linux' as the\n     * os type for paravirt, whereas capabilities declare it to\n     * be 'xen'. So we convert to the former for backcompat\n     */\n    if (def->virtType == VIR_DOMAIN_VIRT_XEN &&\n        def->os.type == VIR_DOMAIN_OSTYPE_XEN)\n        virBufferAsprintf(buf, \">%s</type>\\n\",\n                          virDomainOSTypeToString(VIR_DOMAIN_OSTYPE_LINUX));\n    else\n        virBufferAsprintf(buf, \">%s</type>\\n\",\n                          virDomainOSTypeToString(def->os.type));\n\n    virBufferEscapeString(buf, \"<init>%s</init>\\n\",\n                          def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        virBufferEscapeString(buf, \"<initarg>%s</initarg>\\n\",\n                              def->os.initargv[i]);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++)\n        virBufferAsprintf(buf, \"<initenv name='%s'>%s</initenv>\\n\",\n                          def->os.initenv[i]->name, def->os.initenv[i]->value);\n    if (def->os.initdir)\n        virBufferEscapeString(buf, \"<initdir>%s</initdir>\\n\",\n                              def->os.initdir);\n    if (def->os.inituser)\n        virBufferAsprintf(buf, \"<inituser>%s</inituser>\\n\", def->os.inituser);\n    if (def->os.initgroup)\n        virBufferAsprintf(buf, \"<initgroup>%s</initgroup>\\n\", def->os.initgroup);\n\n    if (def->os.loader)\n        virDomainLoaderDefFormat(buf, def->os.loader);\n    virBufferEscapeString(buf, \"<kernel>%s</kernel>\\n\",\n                          def->os.kernel);\n    virBufferEscapeString(buf, \"<initrd>%s</initrd>\\n\",\n                          def->os.initrd);\n    virBufferEscapeString(buf, \"<cmdline>%s</cmdline>\\n\",\n                          def->os.cmdline);\n    virBufferEscapeString(buf, \"<dtb>%s</dtb>\\n\",\n                          def->os.dtb);\n    virBufferEscapeString(buf, \"<root>%s</root>\\n\",\n                          def->os.root);\n    if (def->os.slic_table) {\n        virBufferAddLit(buf, \"<acpi>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferEscapeString(buf, \"<table type='slic'>%s</table>\\n\",\n                              def->os.slic_table);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</acpi>\\n\");\n    }\n\n    if (!def->os.bootloader) {\n        for (n = 0; n < def->os.nBootDevs; n++) {\n            const char *boottype =\n                virDomainBootTypeToString(def->os.bootDevs[n]);\n            if (!boottype) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unexpected boot device type %d\"),\n                               def->os.bootDevs[n]);\n                goto error;\n            }\n            virBufferAsprintf(buf, \"<boot dev='%s'/>\\n\", boottype);\n        }\n\n        if (def->os.bootmenu) {\n            virBufferAsprintf(buf, \"<bootmenu enable='%s'\",\n                              virTristateBoolTypeToString(def->os.bootmenu));\n            if (def->os.bm_timeout_set)\n                virBufferAsprintf(buf, \" timeout='%u'\", def->os.bm_timeout);\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n\n        if (def->os.bios.useserial || def->os.bios.rt_set) {\n            virBufferAddLit(buf, \"<bios\");\n            if (def->os.bios.useserial)\n                virBufferAsprintf(buf, \" useserial='%s'\",\n                                  virTristateBoolTypeToString(def->os.bios.useserial));\n            if (def->os.bios.rt_set)\n                virBufferAsprintf(buf, \" rebootTimeout='%d'\", def->os.bios.rt_delay);\n\n            virBufferAddLit(buf, \"/>\\n\");\n        }\n    }\n\n    if (def->os.smbios_mode) {\n        const char *mode;\n\n        mode = virDomainSmbiosModeTypeToString(def->os.smbios_mode);\n        if (mode == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected smbios mode %d\"), def->os.smbios_mode);\n            goto error;\n        }\n        virBufferAsprintf(buf, \"<smbios mode='%s'/>\\n\", mode);\n    }\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</os>\\n\");\n\n\n    if (def->idmap.uidmap) {\n        virBufferAddLit(buf, \"<idmap>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < def->idmap.nuidmap; i++) {\n            virBufferAsprintf(buf,\n                              \"<uid start='%u' target='%u' count='%u'/>\\n\",\n                              def->idmap.uidmap[i].start,\n                              def->idmap.uidmap[i].target,\n                              def->idmap.uidmap[i].count);\n        }\n        for (i = 0; i < def->idmap.ngidmap; i++) {\n            virBufferAsprintf(buf,\n                              \"<gid start='%u' target='%u' count='%u'/>\\n\",\n                              def->idmap.gidmap[i].start,\n                              def->idmap.gidmap[i].target,\n                              def->idmap.gidmap[i].count);\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</idmap>\\n\");\n    }\n\n    if (virDomainDefFormatFeatures(buf, def) < 0)\n        goto error;\n\n    if (virCPUDefFormatBufFull(buf, def->cpu, def->numa) < 0)\n        goto error;\n\n    virBufferAsprintf(buf, \"<clock offset='%s'\",\n                      virDomainClockOffsetTypeToString(def->clock.offset));\n    switch (def->clock.offset) {\n    case VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME:\n    case VIR_DOMAIN_CLOCK_OFFSET_UTC:\n        if (def->clock.data.utc_reset)\n            virBufferAddLit(buf, \" adjustment='reset'\");\n        break;\n    case VIR_DOMAIN_CLOCK_OFFSET_VARIABLE:\n        virBufferAsprintf(buf, \" adjustment='%lld' basis='%s'\",\n                          def->clock.data.variable.adjustment,\n                          virDomainClockBasisTypeToString(def->clock.data.variable.basis));\n        if (flags & VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST) {\n            if (def->clock.data.variable.adjustment0)\n                virBufferAsprintf(buf, \" adjustment0='%lld'\",\n                                  def->clock.data.variable.adjustment0);\n        }\n        break;\n    case VIR_DOMAIN_CLOCK_OFFSET_TIMEZONE:\n        virBufferEscapeString(buf, \" timezone='%s'\", def->clock.data.timezone);\n        break;\n    }\n    if (def->clock.ntimers == 0) {\n        virBufferAddLit(buf, \"/>\\n\");\n    } else {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (n = 0; n < def->clock.ntimers; n++) {\n            if (virDomainTimerDefFormat(buf, def->clock.timers[n]) < 0)\n                goto error;\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</clock>\\n\");\n    }\n\n    if (virDomainEventActionDefFormat(buf, def->onPoweroff,\n                                      \"on_poweroff\",\n                                      virDomainLifecycleActionTypeToString) < 0)\n        goto error;\n    if (virDomainEventActionDefFormat(buf, def->onReboot,\n                                      \"on_reboot\",\n                                      virDomainLifecycleActionTypeToString) < 0)\n        goto error;\n    if (virDomainEventActionDefFormat(buf, def->onCrash,\n                                      \"on_crash\",\n                                      virDomainLifecycleActionTypeToString) < 0)\n        goto error;\n    if (def->onLockFailure != VIR_DOMAIN_LOCK_FAILURE_DEFAULT &&\n        virDomainEventActionDefFormat(buf, def->onLockFailure,\n                                      \"on_lockfailure\",\n                                      virDomainLockFailureTypeToString) < 0)\n        goto error;\n\n    if (def->pm.s3 || def->pm.s4) {\n        virBufferAddLit(buf, \"<pm>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        if (def->pm.s3) {\n            virBufferAsprintf(buf, \"<suspend-to-mem enabled='%s'/>\\n\",\n                              virTristateBoolTypeToString(def->pm.s3));\n        }\n        if (def->pm.s4) {\n            virBufferAsprintf(buf, \"<suspend-to-disk enabled='%s'/>\\n\",\n                              virTristateBoolTypeToString(def->pm.s4));\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</pm>\\n\");\n    }\n\n    virDomainPerfDefFormat(buf, &def->perf);\n\n    virBufferAddLit(buf, \"<devices>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferEscapeString(buf, \"<emulator>%s</emulator>\\n\",\n                          def->emulator);\n\n    for (n = 0; n < def->ndisks; n++)\n        if (virDomainDiskDefFormat(buf, def->disks[n], flags, xmlopt) < 0)\n            goto error;\n\n    for (n = 0; n < def->ncontrollers; n++)\n        if (virDomainControllerDefFormat(buf, def->controllers[n], flags) < 0)\n            goto error;\n\n    for (n = 0; n < def->nleases; n++)\n        if (virDomainLeaseDefFormat(buf, def->leases[n]) < 0)\n            goto error;\n\n    for (n = 0; n < def->nfss; n++)\n        if (virDomainFSDefFormat(buf, def->fss[n], flags) < 0)\n            goto error;\n\n    for (n = 0; n < def->nnets; n++)\n        if (virDomainNetDefFormat(buf, def->nets[n], xmlopt, flags) < 0)\n            goto error;\n\n    for (n = 0; n < def->nsmartcards; n++)\n        if (virDomainSmartcardDefFormat(buf, def->smartcards[n], flags) < 0)\n            goto error;\n\n    for (n = 0; n < def->nserials; n++)\n        if (virDomainChrDefFormat(buf, def->serials[n], flags) < 0)\n            goto error;\n\n    for (n = 0; n < def->nparallels; n++)\n        if (virDomainChrDefFormat(buf, def->parallels[n], flags) < 0)\n            goto error;\n\n    for (n = 0; n < def->nconsoles; n++) {\n        virDomainChrDef console;\n        /* Back compat, ignore the console element for hvm guests\n         * if it is type == serial\n         */\n        if (def->os.type == VIR_DOMAIN_OSTYPE_HVM &&\n            (def->consoles[n]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_SERIAL ||\n             def->consoles[n]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_NONE) &&\n            (n < def->nserials)) {\n            memcpy(&console, def->serials[n], sizeof(console));\n            console.deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE;\n            console.targetType = VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_SERIAL;\n        } else {\n            memcpy(&console, def->consoles[n], sizeof(console));\n        }\n        if (virDomainChrDefFormat(buf, &console, flags) < 0)\n            goto error;\n    }\n\n    for (n = 0; n < def->nchannels; n++)\n        if (virDomainChrDefFormat(buf, def->channels[n], flags) < 0)\n            goto error;\n\n    for (n = 0; n < def->ninputs; n++) {\n        if (virDomainInputDefFormat(buf, def->inputs[n], flags) < 0)\n            goto error;\n    }\n\n    if (def->tpm) {\n        if (virDomainTPMDefFormat(buf, def->tpm, flags) < 0)\n            goto error;\n    }\n\n    for (n = 0; n < def->ngraphics; n++) {\n        if (virDomainGraphicsDefFormat(buf, def->graphics[n], flags) < 0)\n            goto error;\n    }\n\n    for (n = 0; n < def->nsounds; n++) {\n        if (virDomainSoundDefFormat(buf, def->sounds[n], flags) < 0)\n            goto error;\n    }\n\n    for (n = 0; n < def->nvideos; n++) {\n        if (virDomainVideoDefFormat(buf, def->videos[n], flags) < 0)\n            goto error;\n    }\n\n    for (n = 0; n < def->nhostdevs; n++) {\n        /* If parentnet != NONE, this is just a pointer to the\n         * hostdev in a higher-level device (e.g. virDomainNetDef),\n         * and will have already been formatted there.\n         */\n        if (!def->hostdevs[n]->parentnet &&\n            virDomainHostdevDefFormat(buf, def->hostdevs[n], flags) < 0) {\n            goto error;\n        }\n    }\n\n    for (n = 0; n < def->nredirdevs; n++) {\n        if (virDomainRedirdevDefFormat(buf, def->redirdevs[n], flags) < 0)\n            goto error;\n    }\n\n    if (def->redirfilter)\n        virDomainRedirFilterDefFormat(buf, def->redirfilter);\n\n    for (n = 0; n < def->nhubs; n++) {\n        if (virDomainHubDefFormat(buf, def->hubs[n], flags) < 0)\n            goto error;\n    }\n\n    if (def->watchdog)\n        virDomainWatchdogDefFormat(buf, def->watchdog, flags);\n\n    if (def->memballoon)\n        virDomainMemballoonDefFormat(buf, def->memballoon, flags);\n\n    for (n = 0; n < def->nrngs; n++) {\n        if (virDomainRNGDefFormat(buf, def->rngs[n], flags))\n            goto error;\n    }\n\n    if (def->nvram)\n        virDomainNVRAMDefFormat(buf, def->nvram, flags);\n\n    for (n = 0; n < def->npanics; n++) {\n        if (virDomainPanicDefFormat(buf, def->panics[n]) < 0)\n            goto error;\n    }\n\n    for (n = 0; n < def->nshmems; n++) {\n        if (virDomainShmemDefFormat(buf, def->shmems[n], flags) < 0)\n            goto error;\n    }\n\n    for (n = 0; n < def->nmems; n++) {\n        if (virDomainMemoryDefFormat(buf, def->mems[n], flags) < 0)\n            goto error;\n    }\n\n    if (def->iommu &&\n        virDomainIOMMUDefFormat(buf, def->iommu) < 0)\n        goto error;\n\n    if (def->vsock &&\n        virDomainVsockDefFormat(buf, def->vsock) < 0)\n        goto error;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</devices>\\n\");\n\n    for (n = 0; n < def->nseclabels; n++)\n        virSecurityLabelDefFormat(buf, def->seclabels[n], flags);\n\n    if (def->namespaceData && def->ns.format) {\n        if ((def->ns.format)(buf, def->namespaceData) < 0)\n            goto error;\n    }\n\n    if (def->keywrap)\n        virDomainKeyWrapDefFormat(buf, def->keywrap);\n\n    virDomainSEVDefFormat(buf, def->sev);\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAsprintf(buf, \"</%s>\\n\", rootname);\n\n    return 0;\n\n error:\n    virBufferFreeAndReset(buf);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</domain>\\n\""
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<domain>\\n\""
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefFormatInternal",
          "args": [
            "def->parent.dom",
            "xmlopt",
            "buf",
            "domainflags"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormatInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "28943-28951",
          "snippet": "int\nvirDomainDefFormatInternal(virDomainDefPtr def,\n                           virDomainXMLOptionPtr xmlopt,\n                           virBufferPtr buf,\n                           unsigned int flags)\n{\n    return virDomainDefFormatInternalSetRootName(def, xmlopt, buf,\n                                                 \"domain\", flags);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefFormatInternal(virDomainDefPtr def,\n                           virDomainXMLOptionPtr xmlopt,\n                           virBufferPtr buf,\n                           unsigned int flags)\n{\n    return virDomainDefFormatInternalSetRootName(def, xmlopt, buf,\n                                                 \"domain\", flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</disks>\\n\""
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDiskDefFormat",
          "args": [
            "buf",
            "&def->disks[i]",
            "xmlopt"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDiskDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "795-828",
          "snippet": "static int\nvirDomainSnapshotDiskDefFormat(virBufferPtr buf,\n                               virDomainSnapshotDiskDefPtr disk,\n                               virDomainXMLOptionPtr xmlopt)\n{\n    int type = disk->src->type;\n\n    if (!disk->name)\n        return 0;\n\n    virBufferEscapeString(buf, \"<disk name='%s'\", disk->name);\n    if (disk->snapshot > 0)\n        virBufferAsprintf(buf, \" snapshot='%s'\",\n                          virDomainSnapshotLocationTypeToString(disk->snapshot));\n\n    if (!disk->src->path && disk->src->format == 0) {\n        virBufferAddLit(buf, \"/>\\n\");\n        return 0;\n    }\n\n    virBufferAsprintf(buf, \" type='%s'>\\n\", virStorageTypeToString(type));\n    virBufferAdjustIndent(buf, 2);\n\n    if (disk->src->format > 0)\n        virBufferEscapeString(buf, \"<driver type='%s'/>\\n\",\n                              virStorageFileFormatTypeToString(disk->src->format));\n    if (virDomainDiskSourceFormat(buf, disk->src, \"source\", 0, false, 0, true,\n                                  xmlopt) < 0)\n        return -1;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</disk>\\n\");\n    return 0;\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirDomainSnapshotDiskDefFormat(virBufferPtr buf,\n                               virDomainSnapshotDiskDefPtr disk,\n                               virDomainXMLOptionPtr xmlopt)\n{\n    int type = disk->src->type;\n\n    if (!disk->name)\n        return 0;\n\n    virBufferEscapeString(buf, \"<disk name='%s'\", disk->name);\n    if (disk->snapshot > 0)\n        virBufferAsprintf(buf, \" snapshot='%s'\",\n                          virDomainSnapshotLocationTypeToString(disk->snapshot));\n\n    if (!disk->src->path && disk->src->format == 0) {\n        virBufferAddLit(buf, \"/>\\n\");\n        return 0;\n    }\n\n    virBufferAsprintf(buf, \" type='%s'>\\n\", virStorageTypeToString(type));\n    virBufferAdjustIndent(buf, 2);\n\n    if (disk->src->format > 0)\n        virBufferEscapeString(buf, \"<driver type='%s'/>\\n\",\n                              virStorageFileFormatTypeToString(disk->src->format));\n    if (virDomainDiskSourceFormat(buf, disk->src, \"source\", 0, false, 0, true,\n                                  xmlopt) < 0)\n        return -1;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</disk>\\n\");\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<disks>\\n\""
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\" file='%s'\"",
            "def->file"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotLocationTypeToString",
          "args": [
            "def->memory"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</parent>\\n\""
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<parent>\\n\""
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotStateTypeToString",
          "args": [
            "def->state"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<domainsnapshot>\\n\""
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirDomainSnapshotDefFormatInternal(virBufferPtr buf,\n                                   const char *uuidstr,\n                                   virDomainSnapshotDefPtr def,\n                                   virDomainXMLOptionPtr xmlopt,\n                                   unsigned int flags)\n{\n    size_t i;\n    int domainflags = VIR_DOMAIN_DEF_FORMAT_INACTIVE;\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE)\n        domainflags |= VIR_DOMAIN_DEF_FORMAT_SECURE;\n\n    virBufferAddLit(buf, \"<domainsnapshot>\\n\");\n    virBufferAdjustIndent(buf, 2);\n\n    virBufferEscapeString(buf, \"<name>%s</name>\\n\", def->parent.name);\n    if (def->parent.description)\n        virBufferEscapeString(buf, \"<description>%s</description>\\n\",\n                              def->parent.description);\n    if (def->state)\n        virBufferAsprintf(buf, \"<state>%s</state>\\n\",\n                          virDomainSnapshotStateTypeToString(def->state));\n\n    if (def->parent.parent_name) {\n        virBufferAddLit(buf, \"<parent>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferEscapeString(buf, \"<name>%s</name>\\n\",\n                              def->parent.parent_name);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</parent>\\n\");\n    }\n\n    if (def->parent.creationTime)\n        virBufferAsprintf(buf, \"<creationTime>%lld</creationTime>\\n\",\n                          def->parent.creationTime);\n\n    if (def->memory) {\n        virBufferAsprintf(buf, \"<memory snapshot='%s'\",\n                          virDomainSnapshotLocationTypeToString(def->memory));\n        virBufferEscapeString(buf, \" file='%s'\", def->file);\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    if (def->ndisks) {\n        virBufferAddLit(buf, \"<disks>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        for (i = 0; i < def->ndisks; i++) {\n            if (virDomainSnapshotDiskDefFormat(buf, &def->disks[i], xmlopt) < 0)\n                goto error;\n        }\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</disks>\\n\");\n    }\n\n    if (def->parent.dom) {\n        if (virDomainDefFormatInternal(def->parent.dom, xmlopt,\n                                       buf, domainflags) < 0)\n            goto error;\n    } else if (uuidstr) {\n        virBufferAddLit(buf, \"<domain>\\n\");\n        virBufferAdjustIndent(buf, 2);\n        virBufferAsprintf(buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n        virBufferAdjustIndent(buf, -2);\n        virBufferAddLit(buf, \"</domain>\\n\");\n    }\n\n    if (def->parent.inactiveDom) {\n        if (virDomainDefFormatInternalSetRootName(def->parent.inactiveDom, xmlopt,\n                                                  buf, \"inactiveDomain\",\n                                                  domainflags) < 0)\n            goto error;\n    }\n\n    if (virSaveCookieFormatBuf(buf, def->cookie,\n                               virDomainXMLOptionGetSaveCookie(xmlopt)) < 0)\n        goto error;\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_FORMAT_INTERNAL)\n        virBufferAsprintf(buf, \"<active>%d</active>\\n\",\n                          !!(flags & VIR_DOMAIN_SNAPSHOT_FORMAT_CURRENT));\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</domainsnapshot>\\n\");\n\n    return 0;\n\n error:\n    virBufferFreeAndReset(buf);\n    return -1;\n}"
  },
  {
    "function_name": "virDomainSnapshotDiskDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "795-828",
    "snippet": "static int\nvirDomainSnapshotDiskDefFormat(virBufferPtr buf,\n                               virDomainSnapshotDiskDefPtr disk,\n                               virDomainXMLOptionPtr xmlopt)\n{\n    int type = disk->src->type;\n\n    if (!disk->name)\n        return 0;\n\n    virBufferEscapeString(buf, \"<disk name='%s'\", disk->name);\n    if (disk->snapshot > 0)\n        virBufferAsprintf(buf, \" snapshot='%s'\",\n                          virDomainSnapshotLocationTypeToString(disk->snapshot));\n\n    if (!disk->src->path && disk->src->format == 0) {\n        virBufferAddLit(buf, \"/>\\n\");\n        return 0;\n    }\n\n    virBufferAsprintf(buf, \" type='%s'>\\n\", virStorageTypeToString(type));\n    virBufferAdjustIndent(buf, 2);\n\n    if (disk->src->format > 0)\n        virBufferEscapeString(buf, \"<driver type='%s'/>\\n\",\n                              virStorageFileFormatTypeToString(disk->src->format));\n    if (virDomainDiskSourceFormat(buf, disk->src, \"source\", 0, false, 0, true,\n                                  xmlopt) < 0)\n        return -1;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</disk>\\n\");\n    return 0;\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</disk>\\n\""
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskSourceFormat",
          "args": [
            "buf",
            "disk->src",
            "\"source\"",
            "0",
            "false",
            "0",
            "true",
            "xmlopt"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSourceFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "24732-24824",
          "snippet": "int\nvirDomainDiskSourceFormat(virBufferPtr buf,\n                          virStorageSourcePtr src,\n                          const char *element,\n                          int policy,\n                          bool attrIndex,\n                          unsigned int flags,\n                          bool formatsecrets,\n                          virDomainXMLOptionPtr xmlopt)\n{\n    g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    switch ((virStorageType)src->type) {\n    case VIR_STORAGE_TYPE_FILE:\n        virBufferEscapeString(&attrBuf, \" file='%s'\", src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_BLOCK:\n        virBufferEscapeString(&attrBuf, \" dev='%s'\", src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_DIR:\n        virBufferEscapeString(&attrBuf, \" dir='%s'\", src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n        if (virDomainDiskSourceFormatNetwork(&attrBuf, &childBuf,\n                                             src, flags) < 0)\n            return -1;\n        break;\n\n    case VIR_STORAGE_TYPE_VOLUME:\n        if (src->srcpool) {\n            virBufferEscapeString(&attrBuf, \" pool='%s'\", src->srcpool->pool);\n            virBufferEscapeString(&attrBuf, \" volume='%s'\",\n                                  src->srcpool->volume);\n            if (src->srcpool->mode)\n                virBufferAsprintf(&attrBuf, \" mode='%s'\",\n                                  virStorageSourcePoolModeTypeToString(src->srcpool->mode));\n        }\n\n        break;\n\n    case VIR_STORAGE_TYPE_NVME:\n        virDomainDiskSourceNVMeFormat(&attrBuf, &childBuf, src->nvme);\n        break;\n\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected disk type %d\"), src->type);\n        return -1;\n    }\n\n    virDomainDiskSourceFormatSlices(&childBuf, src);\n\n    if (src->type != VIR_STORAGE_TYPE_NETWORK)\n        virDomainSourceDefFormatSeclabel(&childBuf, src->nseclabels,\n                                         src->seclabels, flags);\n\n    /* Storage Source formatting will not carry through the blunder\n     * that disk source formatting had at one time to format the\n     * <auth> for a volume source type. The <auth> information is\n     * kept in the storage pool and would be overwritten anyway.\n     * So avoid formatting it for volumes. */\n    if (src->auth && (src->authInherited || formatsecrets) &&\n        src->type != VIR_STORAGE_TYPE_VOLUME)\n        virStorageAuthDefFormat(&childBuf, src->auth);\n\n    /* If we found encryption as a child of <source>, then format it\n     * as we found it. */\n    if (src->encryption && (src->encryptionInherited || formatsecrets) &&\n        virStorageEncryptionFormat(&childBuf, src->encryption) < 0)\n        return -1;\n\n    if (src->pr)\n        virStoragePRDefFormat(&childBuf, src->pr,\n                              flags & VIR_DOMAIN_DEF_FORMAT_MIGRATABLE);\n    if (policy && src->type != VIR_STORAGE_TYPE_NETWORK)\n        virBufferEscapeString(&attrBuf, \" startupPolicy='%s'\",\n                              virDomainStartupPolicyTypeToString(policy));\n\n    if (attrIndex && src->id != 0)\n        virBufferAsprintf(&attrBuf, \" index='%u'\", src->id);\n\n    if (virDomainDiskSourceFormatPrivateData(&childBuf, src, flags, xmlopt) < 0)\n        return -1;\n\n    virXMLFormatElement(buf, element, &attrBuf, &childBuf);\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskSourceFormat(virBufferPtr buf,\n                          virStorageSourcePtr src,\n                          const char *element,\n                          int policy,\n                          bool attrIndex,\n                          unsigned int flags,\n                          bool formatsecrets,\n                          virDomainXMLOptionPtr xmlopt)\n{\n    g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    switch ((virStorageType)src->type) {\n    case VIR_STORAGE_TYPE_FILE:\n        virBufferEscapeString(&attrBuf, \" file='%s'\", src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_BLOCK:\n        virBufferEscapeString(&attrBuf, \" dev='%s'\", src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_DIR:\n        virBufferEscapeString(&attrBuf, \" dir='%s'\", src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n        if (virDomainDiskSourceFormatNetwork(&attrBuf, &childBuf,\n                                             src, flags) < 0)\n            return -1;\n        break;\n\n    case VIR_STORAGE_TYPE_VOLUME:\n        if (src->srcpool) {\n            virBufferEscapeString(&attrBuf, \" pool='%s'\", src->srcpool->pool);\n            virBufferEscapeString(&attrBuf, \" volume='%s'\",\n                                  src->srcpool->volume);\n            if (src->srcpool->mode)\n                virBufferAsprintf(&attrBuf, \" mode='%s'\",\n                                  virStorageSourcePoolModeTypeToString(src->srcpool->mode));\n        }\n\n        break;\n\n    case VIR_STORAGE_TYPE_NVME:\n        virDomainDiskSourceNVMeFormat(&attrBuf, &childBuf, src->nvme);\n        break;\n\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected disk type %d\"), src->type);\n        return -1;\n    }\n\n    virDomainDiskSourceFormatSlices(&childBuf, src);\n\n    if (src->type != VIR_STORAGE_TYPE_NETWORK)\n        virDomainSourceDefFormatSeclabel(&childBuf, src->nseclabels,\n                                         src->seclabels, flags);\n\n    /* Storage Source formatting will not carry through the blunder\n     * that disk source formatting had at one time to format the\n     * <auth> for a volume source type. The <auth> information is\n     * kept in the storage pool and would be overwritten anyway.\n     * So avoid formatting it for volumes. */\n    if (src->auth && (src->authInherited || formatsecrets) &&\n        src->type != VIR_STORAGE_TYPE_VOLUME)\n        virStorageAuthDefFormat(&childBuf, src->auth);\n\n    /* If we found encryption as a child of <source>, then format it\n     * as we found it. */\n    if (src->encryption && (src->encryptionInherited || formatsecrets) &&\n        virStorageEncryptionFormat(&childBuf, src->encryption) < 0)\n        return -1;\n\n    if (src->pr)\n        virStoragePRDefFormat(&childBuf, src->pr,\n                              flags & VIR_DOMAIN_DEF_FORMAT_MIGRATABLE);\n    if (policy && src->type != VIR_STORAGE_TYPE_NETWORK)\n        virBufferEscapeString(&attrBuf, \" startupPolicy='%s'\",\n                              virDomainStartupPolicyTypeToString(policy));\n\n    if (attrIndex && src->id != 0)\n        virBufferAsprintf(&attrBuf, \" index='%u'\", src->id);\n\n    if (virDomainDiskSourceFormatPrivateData(&childBuf, src, flags, xmlopt) < 0)\n        return -1;\n\n    virXMLFormatElement(buf, element, &attrBuf, &childBuf);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "buf",
            "\"<driver type='%s'/>\\n\"",
            "virStorageFileFormatTypeToString(disk->src->format)"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "disk->src->format"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" type='%s'>\\n\"",
            "virStorageTypeToString(type)"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageTypeToString",
          "args": [
            "type"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotLocationTypeToString",
          "args": [
            "disk->snapshot"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirDomainSnapshotDiskDefFormat(virBufferPtr buf,\n                               virDomainSnapshotDiskDefPtr disk,\n                               virDomainXMLOptionPtr xmlopt)\n{\n    int type = disk->src->type;\n\n    if (!disk->name)\n        return 0;\n\n    virBufferEscapeString(buf, \"<disk name='%s'\", disk->name);\n    if (disk->snapshot > 0)\n        virBufferAsprintf(buf, \" snapshot='%s'\",\n                          virDomainSnapshotLocationTypeToString(disk->snapshot));\n\n    if (!disk->src->path && disk->src->format == 0) {\n        virBufferAddLit(buf, \"/>\\n\");\n        return 0;\n    }\n\n    virBufferAsprintf(buf, \" type='%s'>\\n\", virStorageTypeToString(type));\n    virBufferAdjustIndent(buf, 2);\n\n    if (disk->src->format > 0)\n        virBufferEscapeString(buf, \"<driver type='%s'/>\\n\",\n                              virStorageFileFormatTypeToString(disk->src->format));\n    if (virDomainDiskSourceFormat(buf, disk->src, \"source\", 0, false, 0, true,\n                                  xmlopt) < 0)\n        return -1;\n\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</disk>\\n\");\n    return 0;\n}"
  },
  {
    "function_name": "virDomainSnapshotFormatConvertXMLFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "783-792",
    "snippet": "unsigned int\nvirDomainSnapshotFormatConvertXMLFlags(unsigned int flags)\n{\n    unsigned int formatFlags = 0;\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_XML_SECURE)\n        formatFlags |= VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE;\n\n    return formatFlags;\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int\nvirDomainSnapshotFormatConvertXMLFlags(unsigned int flags)\n{\n    unsigned int formatFlags = 0;\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_XML_SECURE)\n        formatFlags |= VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE;\n\n    return formatFlags;\n}"
  },
  {
    "function_name": "virDomainSnapshotAlignDisks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "651-777",
    "snippet": "int\nvirDomainSnapshotAlignDisks(virDomainSnapshotDefPtr def,\n                            int default_snapshot,\n                            bool require_match)\n{\n    int ret = -1;\n    virBitmapPtr map = NULL;\n    size_t i;\n    int ndisks;\n\n    if (!def->parent.dom) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing domain in snapshot\"));\n        goto cleanup;\n    }\n\n    if (def->ndisks > def->parent.dom->ndisks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"too many disk snapshot requests for domain\"));\n        goto cleanup;\n    }\n\n    /* Unlikely to have a guest without disks but technically possible.  */\n    if (!def->parent.dom->ndisks) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(map = virBitmapNew(def->parent.dom->ndisks)))\n        goto cleanup;\n\n    /* Double check requested disks.  */\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainSnapshotDiskDefPtr disk = &def->disks[i];\n        int idx = virDomainDiskIndexByName(def->parent.dom, disk->name, false);\n        int disk_snapshot;\n\n        if (idx < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"no disk named '%s'\"), disk->name);\n            goto cleanup;\n        }\n\n        if (virBitmapIsBitSet(map, idx)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' specified twice\"),\n                           disk->name);\n            goto cleanup;\n        }\n        ignore_value(virBitmapSetBit(map, idx));\n        disk->idx = idx;\n\n        disk_snapshot = def->parent.dom->disks[idx]->snapshot;\n        if (!disk->snapshot) {\n            if (disk_snapshot &&\n                (!require_match ||\n                 disk_snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_NONE))\n                disk->snapshot = disk_snapshot;\n            else\n                disk->snapshot = default_snapshot;\n        } else if (require_match &&\n                   disk->snapshot != default_snapshot &&\n                   !(disk->snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_NONE &&\n                     disk_snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_NONE)) {\n            const char *tmp;\n\n            tmp = virDomainSnapshotLocationTypeToString(default_snapshot);\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' must use snapshot mode '%s'\"),\n                           disk->name, tmp);\n            goto cleanup;\n        }\n        if (disk->src->path &&\n            disk->snapshot != VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"file '%s' for disk '%s' requires \"\n                             \"use of external snapshot mode\"),\n                           disk->src->path, disk->name);\n            goto cleanup;\n        }\n        if (STRNEQ(disk->name, def->parent.dom->disks[idx]->dst)) {\n            VIR_FREE(disk->name);\n            disk->name = g_strdup(def->parent.dom->disks[idx]->dst);\n        }\n    }\n\n    /* Provide defaults for all remaining disks.  */\n    ndisks = def->ndisks;\n    if (VIR_EXPAND_N(def->disks, def->ndisks,\n                     def->parent.dom->ndisks - def->ndisks) < 0)\n        goto cleanup;\n\n    for (i = 0; i < def->parent.dom->ndisks; i++) {\n        virDomainSnapshotDiskDefPtr disk;\n\n        if (virBitmapIsBitSet(map, i))\n            continue;\n        disk = &def->disks[ndisks++];\n        if (!(disk->src = virStorageSourceNew()))\n            goto cleanup;\n        disk->name = g_strdup(def->parent.dom->disks[i]->dst);\n        disk->idx = i;\n\n        /* Don't snapshot empty drives */\n        if (virStorageSourceIsEmpty(def->parent.dom->disks[i]->src))\n            disk->snapshot = VIR_DOMAIN_SNAPSHOT_LOCATION_NONE;\n        else\n            disk->snapshot = def->parent.dom->disks[i]->snapshot;\n\n        disk->src->type = VIR_STORAGE_TYPE_FILE;\n        if (!disk->snapshot)\n            disk->snapshot = default_snapshot;\n    }\n\n    qsort(&def->disks[0], def->ndisks, sizeof(def->disks[0]),\n          virDomainSnapshotCompareDiskIndex);\n\n    /* Generate default external file names for external snapshot locations */\n    if (virDomainSnapshotDefAssignExternalNames(def) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virBitmapFree(map);\n    return ret;\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBitmapFree",
          "args": [
            "map"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "128-135",
          "snippet": "void\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirBitmapFree(virBitmapPtr bitmap)\n{\n    if (bitmap) {\n        VIR_FREE(bitmap->map);\n        VIR_FREE(bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDefAssignExternalNames",
          "args": [
            "def"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDefAssignExternalNames",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "566-631",
          "snippet": "static int\nvirDomainSnapshotDefAssignExternalNames(virDomainSnapshotDefPtr def)\n{\n    const char *origpath;\n    char *tmppath;\n    char *tmp;\n    struct stat sb;\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainSnapshotDiskDefPtr disk = &def->disks[i];\n\n        if (disk->snapshot != VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL ||\n            disk->src->path)\n            continue;\n\n        if (disk->src->type != VIR_STORAGE_TYPE_FILE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"cannot generate external snapshot name \"\n                             \"for disk '%s' on a '%s' device\"),\n                           disk->name, virStorageTypeToString(disk->src->type));\n            return -1;\n        }\n\n        if (!(origpath = virDomainDiskGetSource(def->parent.dom->disks[i]))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"cannot generate external snapshot name \"\n                             \"for disk '%s' without source\"),\n                           disk->name);\n            return -1;\n        }\n\n        if (stat(origpath, &sb) < 0 || !S_ISREG(sb.st_mode)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"source for disk '%s' is not a regular \"\n                             \"file; refusing to generate external \"\n                             \"snapshot name\"),\n                           disk->name);\n            return -1;\n        }\n\n        tmppath = g_strdup(origpath);\n\n        /* drop suffix of the file name */\n        if ((tmp = strrchr(tmppath, '.')) && !strchr(tmp, '/'))\n            *tmp = '\\0';\n\n        disk->src->path = g_strdup_printf(\"%s.%s\", tmppath, def->parent.name);\n\n        VIR_FREE(tmppath);\n\n        /* verify that we didn't generate a duplicate name */\n        for (j = 0; j < i; j++) {\n            if (STREQ_NULLABLE(disk->src->path, def->disks[j].src->path)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"cannot generate external snapshot name for \"\n                                 \"disk '%s': collision with disk '%s'\"),\n                               disk->name, def->disks[j].name);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirDomainSnapshotDefAssignExternalNames(virDomainSnapshotDefPtr def)\n{\n    const char *origpath;\n    char *tmppath;\n    char *tmp;\n    struct stat sb;\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainSnapshotDiskDefPtr disk = &def->disks[i];\n\n        if (disk->snapshot != VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL ||\n            disk->src->path)\n            continue;\n\n        if (disk->src->type != VIR_STORAGE_TYPE_FILE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"cannot generate external snapshot name \"\n                             \"for disk '%s' on a '%s' device\"),\n                           disk->name, virStorageTypeToString(disk->src->type));\n            return -1;\n        }\n\n        if (!(origpath = virDomainDiskGetSource(def->parent.dom->disks[i]))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"cannot generate external snapshot name \"\n                             \"for disk '%s' without source\"),\n                           disk->name);\n            return -1;\n        }\n\n        if (stat(origpath, &sb) < 0 || !S_ISREG(sb.st_mode)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"source for disk '%s' is not a regular \"\n                             \"file; refusing to generate external \"\n                             \"snapshot name\"),\n                           disk->name);\n            return -1;\n        }\n\n        tmppath = g_strdup(origpath);\n\n        /* drop suffix of the file name */\n        if ((tmp = strrchr(tmppath, '.')) && !strchr(tmp, '/'))\n            *tmp = '\\0';\n\n        disk->src->path = g_strdup_printf(\"%s.%s\", tmppath, def->parent.name);\n\n        VIR_FREE(tmppath);\n\n        /* verify that we didn't generate a duplicate name */\n        for (j = 0; j < i; j++) {\n            if (STREQ_NULLABLE(disk->src->path, def->disks[j].src->path)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"cannot generate external snapshot name for \"\n                                 \"disk '%s': collision with disk '%s'\"),\n                               disk->name, def->disks[j].name);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "&def->disks[0]",
            "def->ndisks",
            "sizeof(def->disks[0])",
            "virDomainSnapshotCompareDiskIndex"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsEmpty",
          "args": [
            "def->parent.dom->disks[i]->src"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2619-2633",
          "snippet": "bool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "def->parent.dom->disks[i]->dst"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNew",
          "args": [],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2744-2751",
          "snippet": "virStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virStorageSourceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virClassPtr virStorageSourceClass;\n\nvirStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapIsBitSet",
          "args": [
            "map",
            "i"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapIsBitSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "298-306",
          "snippet": "bool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirBitmapIsBitSet(virBitmapPtr bitmap,\n                  size_t b)\n{\n    if (bitmap->nbits <= b)\n        return false;\n\n    return virBitmapIsSet(bitmap, b);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "def->disks",
            "def->ndisks",
            "def->parent.dom->ndisks - def->ndisks"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disk->name"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "disk->name",
            "def->parent.dom->disks[idx]->dst"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"file '%s' for disk '%s' requires \"\n                             \"use of external snapshot mode\")",
            "disk->src->path",
            "disk->name"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"file '%s' for disk '%s' requires \"\n                             \"use of external snapshot mode\""
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"disk '%s' must use snapshot mode '%s'\")",
            "disk->name",
            "tmp"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotLocationTypeToString",
          "args": [
            "default_snapshot"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(map, idx)"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "map",
            "idx"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"disk '%s' specified twice\")",
            "disk->name"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"no disk named '%s'\")",
            "disk->name"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskIndexByName",
          "args": [
            "def->parent.dom",
            "disk->name",
            "false"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskIndexByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17299-17325",
          "snippet": "int\nvirDomainDiskIndexByName(virDomainDefPtr def, const char *name,\n                         bool allow_ambiguous)\n{\n    virDomainDiskDefPtr vdisk;\n    size_t i;\n    int candidate = -1;\n\n    /* We prefer the <target dev='name'/> name (it's shorter, required\n     * for all disks, and should be unambiguous), but also support\n     * <source file='name'/> (if unambiguous).  Assume dst if there is\n     * no leading slash, source name otherwise.  */\n    for (i = 0; i < def->ndisks; i++) {\n        vdisk = def->disks[i];\n        if (*name != '/') {\n            if (STREQ(vdisk->dst, name))\n                return i;\n        } else if (STREQ_NULLABLE(virDomainDiskGetSource(vdisk), name)) {\n            if (allow_ambiguous)\n                return i;\n            if (candidate >= 0)\n                return -1;\n            candidate = i;\n        }\n    }\n    return candidate;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskIndexByName(virDomainDefPtr def, const char *name,\n                         bool allow_ambiguous)\n{\n    virDomainDiskDefPtr vdisk;\n    size_t i;\n    int candidate = -1;\n\n    /* We prefer the <target dev='name'/> name (it's shorter, required\n     * for all disks, and should be unambiguous), but also support\n     * <source file='name'/> (if unambiguous).  Assume dst if there is\n     * no leading slash, source name otherwise.  */\n    for (i = 0; i < def->ndisks; i++) {\n        vdisk = def->disks[i];\n        if (*name != '/') {\n            if (STREQ(vdisk->dst, name))\n                return i;\n        } else if (STREQ_NULLABLE(virDomainDiskGetSource(vdisk), name)) {\n            if (allow_ambiguous)\n                return i;\n            if (candidate >= 0)\n                return -1;\n            candidate = i;\n        }\n    }\n    return candidate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "def->parent.dom->ndisks"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"too many disk snapshot requests for domain\")"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing domain in snapshot\")"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainSnapshotAlignDisks(virDomainSnapshotDefPtr def,\n                            int default_snapshot,\n                            bool require_match)\n{\n    int ret = -1;\n    virBitmapPtr map = NULL;\n    size_t i;\n    int ndisks;\n\n    if (!def->parent.dom) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing domain in snapshot\"));\n        goto cleanup;\n    }\n\n    if (def->ndisks > def->parent.dom->ndisks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"too many disk snapshot requests for domain\"));\n        goto cleanup;\n    }\n\n    /* Unlikely to have a guest without disks but technically possible.  */\n    if (!def->parent.dom->ndisks) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(map = virBitmapNew(def->parent.dom->ndisks)))\n        goto cleanup;\n\n    /* Double check requested disks.  */\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainSnapshotDiskDefPtr disk = &def->disks[i];\n        int idx = virDomainDiskIndexByName(def->parent.dom, disk->name, false);\n        int disk_snapshot;\n\n        if (idx < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"no disk named '%s'\"), disk->name);\n            goto cleanup;\n        }\n\n        if (virBitmapIsBitSet(map, idx)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' specified twice\"),\n                           disk->name);\n            goto cleanup;\n        }\n        ignore_value(virBitmapSetBit(map, idx));\n        disk->idx = idx;\n\n        disk_snapshot = def->parent.dom->disks[idx]->snapshot;\n        if (!disk->snapshot) {\n            if (disk_snapshot &&\n                (!require_match ||\n                 disk_snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_NONE))\n                disk->snapshot = disk_snapshot;\n            else\n                disk->snapshot = default_snapshot;\n        } else if (require_match &&\n                   disk->snapshot != default_snapshot &&\n                   !(disk->snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_NONE &&\n                     disk_snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_NONE)) {\n            const char *tmp;\n\n            tmp = virDomainSnapshotLocationTypeToString(default_snapshot);\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' must use snapshot mode '%s'\"),\n                           disk->name, tmp);\n            goto cleanup;\n        }\n        if (disk->src->path &&\n            disk->snapshot != VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"file '%s' for disk '%s' requires \"\n                             \"use of external snapshot mode\"),\n                           disk->src->path, disk->name);\n            goto cleanup;\n        }\n        if (STRNEQ(disk->name, def->parent.dom->disks[idx]->dst)) {\n            VIR_FREE(disk->name);\n            disk->name = g_strdup(def->parent.dom->disks[idx]->dst);\n        }\n    }\n\n    /* Provide defaults for all remaining disks.  */\n    ndisks = def->ndisks;\n    if (VIR_EXPAND_N(def->disks, def->ndisks,\n                     def->parent.dom->ndisks - def->ndisks) < 0)\n        goto cleanup;\n\n    for (i = 0; i < def->parent.dom->ndisks; i++) {\n        virDomainSnapshotDiskDefPtr disk;\n\n        if (virBitmapIsBitSet(map, i))\n            continue;\n        disk = &def->disks[ndisks++];\n        if (!(disk->src = virStorageSourceNew()))\n            goto cleanup;\n        disk->name = g_strdup(def->parent.dom->disks[i]->dst);\n        disk->idx = i;\n\n        /* Don't snapshot empty drives */\n        if (virStorageSourceIsEmpty(def->parent.dom->disks[i]->src))\n            disk->snapshot = VIR_DOMAIN_SNAPSHOT_LOCATION_NONE;\n        else\n            disk->snapshot = def->parent.dom->disks[i]->snapshot;\n\n        disk->src->type = VIR_STORAGE_TYPE_FILE;\n        if (!disk->snapshot)\n            disk->snapshot = default_snapshot;\n    }\n\n    qsort(&def->disks[0], def->ndisks, sizeof(def->disks[0]),\n          virDomainSnapshotCompareDiskIndex);\n\n    /* Generate default external file names for external snapshot locations */\n    if (virDomainSnapshotDefAssignExternalNames(def) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virBitmapFree(map);\n    return ret;\n}"
  },
  {
    "function_name": "virDomainSnapshotCompareDiskIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "634-642",
    "snippet": "static int\nvirDomainSnapshotCompareDiskIndex(const void *a, const void *b)\n{\n    const virDomainSnapshotDiskDef *diska = a;\n    const virDomainSnapshotDiskDef *diskb = b;\n\n    /* Integer overflow shouldn't be a problem here.  */\n    return diska->idx - diskb->idx;\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirDomainSnapshotCompareDiskIndex(const void *a, const void *b)\n{\n    const virDomainSnapshotDiskDef *diska = a;\n    const virDomainSnapshotDiskDef *diskb = b;\n\n    /* Integer overflow shouldn't be a problem here.  */\n    return diska->idx - diskb->idx;\n}"
  },
  {
    "function_name": "virDomainSnapshotDefAssignExternalNames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "566-631",
    "snippet": "static int\nvirDomainSnapshotDefAssignExternalNames(virDomainSnapshotDefPtr def)\n{\n    const char *origpath;\n    char *tmppath;\n    char *tmp;\n    struct stat sb;\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainSnapshotDiskDefPtr disk = &def->disks[i];\n\n        if (disk->snapshot != VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL ||\n            disk->src->path)\n            continue;\n\n        if (disk->src->type != VIR_STORAGE_TYPE_FILE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"cannot generate external snapshot name \"\n                             \"for disk '%s' on a '%s' device\"),\n                           disk->name, virStorageTypeToString(disk->src->type));\n            return -1;\n        }\n\n        if (!(origpath = virDomainDiskGetSource(def->parent.dom->disks[i]))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"cannot generate external snapshot name \"\n                             \"for disk '%s' without source\"),\n                           disk->name);\n            return -1;\n        }\n\n        if (stat(origpath, &sb) < 0 || !S_ISREG(sb.st_mode)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"source for disk '%s' is not a regular \"\n                             \"file; refusing to generate external \"\n                             \"snapshot name\"),\n                           disk->name);\n            return -1;\n        }\n\n        tmppath = g_strdup(origpath);\n\n        /* drop suffix of the file name */\n        if ((tmp = strrchr(tmppath, '.')) && !strchr(tmp, '/'))\n            *tmp = '\\0';\n\n        disk->src->path = g_strdup_printf(\"%s.%s\", tmppath, def->parent.name);\n\n        VIR_FREE(tmppath);\n\n        /* verify that we didn't generate a duplicate name */\n        for (j = 0; j < i; j++) {\n            if (STREQ_NULLABLE(disk->src->path, def->disks[j].src->path)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"cannot generate external snapshot name for \"\n                                 \"disk '%s': collision with disk '%s'\"),\n                               disk->name, def->disks[j].name);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"cannot generate external snapshot name for \"\n                                 \"disk '%s': collision with disk '%s'\")",
            "disk->name",
            "def->disks[j].name"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot generate external snapshot name for \"\n                                 \"disk '%s': collision with disk '%s'\""
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "disk->src->path",
            "def->disks[j].src->path"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmppath"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s.%s\"",
            "tmppath",
            "def->parent.name"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "tmp",
            "'/'"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "tmppath",
            "'.'"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"source for disk '%s' is not a regular \"\n                             \"file; refusing to generate external \"\n                             \"snapshot name\")",
            "disk->name"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "sb.st_mode"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "origpath",
            "&sb"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"cannot generate external snapshot name \"\n                             \"for disk '%s' without source\")",
            "disk->name"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "def->parent.dom->disks[i]"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"cannot generate external snapshot name \"\n                             \"for disk '%s' on a '%s' device\")",
            "disk->name",
            "virStorageTypeToString(disk->src->type)"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageTypeToString",
          "args": [
            "disk->src->type"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirDomainSnapshotDefAssignExternalNames(virDomainSnapshotDefPtr def)\n{\n    const char *origpath;\n    char *tmppath;\n    char *tmp;\n    struct stat sb;\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainSnapshotDiskDefPtr disk = &def->disks[i];\n\n        if (disk->snapshot != VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL ||\n            disk->src->path)\n            continue;\n\n        if (disk->src->type != VIR_STORAGE_TYPE_FILE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"cannot generate external snapshot name \"\n                             \"for disk '%s' on a '%s' device\"),\n                           disk->name, virStorageTypeToString(disk->src->type));\n            return -1;\n        }\n\n        if (!(origpath = virDomainDiskGetSource(def->parent.dom->disks[i]))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"cannot generate external snapshot name \"\n                             \"for disk '%s' without source\"),\n                           disk->name);\n            return -1;\n        }\n\n        if (stat(origpath, &sb) < 0 || !S_ISREG(sb.st_mode)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"source for disk '%s' is not a regular \"\n                             \"file; refusing to generate external \"\n                             \"snapshot name\"),\n                           disk->name);\n            return -1;\n        }\n\n        tmppath = g_strdup(origpath);\n\n        /* drop suffix of the file name */\n        if ((tmp = strrchr(tmppath, '.')) && !strchr(tmp, '/'))\n            *tmp = '\\0';\n\n        disk->src->path = g_strdup_printf(\"%s.%s\", tmppath, def->parent.name);\n\n        VIR_FREE(tmppath);\n\n        /* verify that we didn't generate a duplicate name */\n        for (j = 0; j < i; j++) {\n            if (STREQ_NULLABLE(disk->src->path, def->disks[j].src->path)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"cannot generate external snapshot name for \"\n                                 \"disk '%s': collision with disk '%s'\"),\n                               disk->name, def->disks[j].name);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainSnapshotRedefineValidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "479-556",
    "snippet": "int\nvirDomainSnapshotRedefineValidate(virDomainSnapshotDefPtr def,\n                                  const unsigned char *domain_uuid,\n                                  virDomainMomentObjPtr other,\n                                  virDomainXMLOptionPtr xmlopt,\n                                  unsigned int flags)\n{\n    int align_location = VIR_DOMAIN_SNAPSHOT_LOCATION_INTERNAL;\n    bool align_match = true;\n    bool external = def->state == VIR_DOMAIN_SNAPSHOT_DISK_SNAPSHOT ||\n        virDomainSnapshotDefIsExternal(def);\n\n    if ((flags & VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY) && !external) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"disk-only flag for snapshot %s requires \"\n                         \"disk-snapshot state\"),\n                       def->parent.name);\n        return -1;\n    }\n    if (def->parent.dom && memcmp(def->parent.dom->uuid, domain_uuid,\n                                  VIR_UUID_BUFLEN)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(domain_uuid, uuidstr);\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"definition for snapshot %s must use uuid %s\"),\n                       def->parent.name, uuidstr);\n        return -1;\n    }\n\n    if (other) {\n        virDomainSnapshotDefPtr otherdef = virDomainSnapshotObjGetDef(other);\n\n        if ((otherdef->state == VIR_DOMAIN_SNAPSHOT_RUNNING ||\n             otherdef->state == VIR_DOMAIN_SNAPSHOT_PAUSED) !=\n            (def->state == VIR_DOMAIN_SNAPSHOT_RUNNING ||\n             def->state == VIR_DOMAIN_SNAPSHOT_PAUSED)) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"cannot change between online and offline \"\n                             \"snapshot state in snapshot %s\"),\n                           def->parent.name);\n            return -1;\n        }\n\n        if ((otherdef->state == VIR_DOMAIN_SNAPSHOT_DISK_SNAPSHOT) !=\n            (def->state == VIR_DOMAIN_SNAPSHOT_DISK_SNAPSHOT)) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"cannot change between disk only and \"\n                             \"full system in snapshot %s\"),\n                           def->parent.name);\n            return -1;\n        }\n\n        if (otherdef->parent.dom) {\n            if (def->parent.dom) {\n                if (!virDomainDefCheckABIStability(otherdef->parent.dom,\n                                                   def->parent.dom, xmlopt))\n                    return -1;\n            } else {\n                /* Transfer the domain def */\n                def->parent.dom = g_steal_pointer(&otherdef->parent.dom);\n            }\n        }\n    }\n\n    if (def->parent.dom) {\n        if (external) {\n            align_location = VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL;\n            align_match = false;\n        }\n        if (virDomainSnapshotAlignDisks(def, align_location,\n                                        align_match) < 0)\n            return -1;\n    }\n\n\n    return 0;\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainSnapshotAlignDisks",
          "args": [
            "def",
            "align_location",
            "align_match"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotAlignDisks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "651-777",
          "snippet": "int\nvirDomainSnapshotAlignDisks(virDomainSnapshotDefPtr def,\n                            int default_snapshot,\n                            bool require_match)\n{\n    int ret = -1;\n    virBitmapPtr map = NULL;\n    size_t i;\n    int ndisks;\n\n    if (!def->parent.dom) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing domain in snapshot\"));\n        goto cleanup;\n    }\n\n    if (def->ndisks > def->parent.dom->ndisks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"too many disk snapshot requests for domain\"));\n        goto cleanup;\n    }\n\n    /* Unlikely to have a guest without disks but technically possible.  */\n    if (!def->parent.dom->ndisks) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(map = virBitmapNew(def->parent.dom->ndisks)))\n        goto cleanup;\n\n    /* Double check requested disks.  */\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainSnapshotDiskDefPtr disk = &def->disks[i];\n        int idx = virDomainDiskIndexByName(def->parent.dom, disk->name, false);\n        int disk_snapshot;\n\n        if (idx < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"no disk named '%s'\"), disk->name);\n            goto cleanup;\n        }\n\n        if (virBitmapIsBitSet(map, idx)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' specified twice\"),\n                           disk->name);\n            goto cleanup;\n        }\n        ignore_value(virBitmapSetBit(map, idx));\n        disk->idx = idx;\n\n        disk_snapshot = def->parent.dom->disks[idx]->snapshot;\n        if (!disk->snapshot) {\n            if (disk_snapshot &&\n                (!require_match ||\n                 disk_snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_NONE))\n                disk->snapshot = disk_snapshot;\n            else\n                disk->snapshot = default_snapshot;\n        } else if (require_match &&\n                   disk->snapshot != default_snapshot &&\n                   !(disk->snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_NONE &&\n                     disk_snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_NONE)) {\n            const char *tmp;\n\n            tmp = virDomainSnapshotLocationTypeToString(default_snapshot);\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' must use snapshot mode '%s'\"),\n                           disk->name, tmp);\n            goto cleanup;\n        }\n        if (disk->src->path &&\n            disk->snapshot != VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"file '%s' for disk '%s' requires \"\n                             \"use of external snapshot mode\"),\n                           disk->src->path, disk->name);\n            goto cleanup;\n        }\n        if (STRNEQ(disk->name, def->parent.dom->disks[idx]->dst)) {\n            VIR_FREE(disk->name);\n            disk->name = g_strdup(def->parent.dom->disks[idx]->dst);\n        }\n    }\n\n    /* Provide defaults for all remaining disks.  */\n    ndisks = def->ndisks;\n    if (VIR_EXPAND_N(def->disks, def->ndisks,\n                     def->parent.dom->ndisks - def->ndisks) < 0)\n        goto cleanup;\n\n    for (i = 0; i < def->parent.dom->ndisks; i++) {\n        virDomainSnapshotDiskDefPtr disk;\n\n        if (virBitmapIsBitSet(map, i))\n            continue;\n        disk = &def->disks[ndisks++];\n        if (!(disk->src = virStorageSourceNew()))\n            goto cleanup;\n        disk->name = g_strdup(def->parent.dom->disks[i]->dst);\n        disk->idx = i;\n\n        /* Don't snapshot empty drives */\n        if (virStorageSourceIsEmpty(def->parent.dom->disks[i]->src))\n            disk->snapshot = VIR_DOMAIN_SNAPSHOT_LOCATION_NONE;\n        else\n            disk->snapshot = def->parent.dom->disks[i]->snapshot;\n\n        disk->src->type = VIR_STORAGE_TYPE_FILE;\n        if (!disk->snapshot)\n            disk->snapshot = default_snapshot;\n    }\n\n    qsort(&def->disks[0], def->ndisks, sizeof(def->disks[0]),\n          virDomainSnapshotCompareDiskIndex);\n\n    /* Generate default external file names for external snapshot locations */\n    if (virDomainSnapshotDefAssignExternalNames(def) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virBitmapFree(map);\n    return ret;\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainSnapshotAlignDisks(virDomainSnapshotDefPtr def,\n                            int default_snapshot,\n                            bool require_match)\n{\n    int ret = -1;\n    virBitmapPtr map = NULL;\n    size_t i;\n    int ndisks;\n\n    if (!def->parent.dom) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing domain in snapshot\"));\n        goto cleanup;\n    }\n\n    if (def->ndisks > def->parent.dom->ndisks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"too many disk snapshot requests for domain\"));\n        goto cleanup;\n    }\n\n    /* Unlikely to have a guest without disks but technically possible.  */\n    if (!def->parent.dom->ndisks) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(map = virBitmapNew(def->parent.dom->ndisks)))\n        goto cleanup;\n\n    /* Double check requested disks.  */\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainSnapshotDiskDefPtr disk = &def->disks[i];\n        int idx = virDomainDiskIndexByName(def->parent.dom, disk->name, false);\n        int disk_snapshot;\n\n        if (idx < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"no disk named '%s'\"), disk->name);\n            goto cleanup;\n        }\n\n        if (virBitmapIsBitSet(map, idx)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' specified twice\"),\n                           disk->name);\n            goto cleanup;\n        }\n        ignore_value(virBitmapSetBit(map, idx));\n        disk->idx = idx;\n\n        disk_snapshot = def->parent.dom->disks[idx]->snapshot;\n        if (!disk->snapshot) {\n            if (disk_snapshot &&\n                (!require_match ||\n                 disk_snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_NONE))\n                disk->snapshot = disk_snapshot;\n            else\n                disk->snapshot = default_snapshot;\n        } else if (require_match &&\n                   disk->snapshot != default_snapshot &&\n                   !(disk->snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_NONE &&\n                     disk_snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_NONE)) {\n            const char *tmp;\n\n            tmp = virDomainSnapshotLocationTypeToString(default_snapshot);\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' must use snapshot mode '%s'\"),\n                           disk->name, tmp);\n            goto cleanup;\n        }\n        if (disk->src->path &&\n            disk->snapshot != VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"file '%s' for disk '%s' requires \"\n                             \"use of external snapshot mode\"),\n                           disk->src->path, disk->name);\n            goto cleanup;\n        }\n        if (STRNEQ(disk->name, def->parent.dom->disks[idx]->dst)) {\n            VIR_FREE(disk->name);\n            disk->name = g_strdup(def->parent.dom->disks[idx]->dst);\n        }\n    }\n\n    /* Provide defaults for all remaining disks.  */\n    ndisks = def->ndisks;\n    if (VIR_EXPAND_N(def->disks, def->ndisks,\n                     def->parent.dom->ndisks - def->ndisks) < 0)\n        goto cleanup;\n\n    for (i = 0; i < def->parent.dom->ndisks; i++) {\n        virDomainSnapshotDiskDefPtr disk;\n\n        if (virBitmapIsBitSet(map, i))\n            continue;\n        disk = &def->disks[ndisks++];\n        if (!(disk->src = virStorageSourceNew()))\n            goto cleanup;\n        disk->name = g_strdup(def->parent.dom->disks[i]->dst);\n        disk->idx = i;\n\n        /* Don't snapshot empty drives */\n        if (virStorageSourceIsEmpty(def->parent.dom->disks[i]->src))\n            disk->snapshot = VIR_DOMAIN_SNAPSHOT_LOCATION_NONE;\n        else\n            disk->snapshot = def->parent.dom->disks[i]->snapshot;\n\n        disk->src->type = VIR_STORAGE_TYPE_FILE;\n        if (!disk->snapshot)\n            disk->snapshot = default_snapshot;\n    }\n\n    qsort(&def->disks[0], def->ndisks, sizeof(def->disks[0]),\n          virDomainSnapshotCompareDiskIndex);\n\n    /* Generate default external file names for external snapshot locations */\n    if (virDomainSnapshotDefAssignExternalNames(def) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virBitmapFree(map);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&otherdef->parent.dom"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefCheckABIStability",
          "args": [
            "otherdef->parent.dom",
            "def->parent.dom",
            "xmlopt"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefCheckABIStability",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "24133-24139",
          "snippet": "bool\nvirDomainDefCheckABIStability(virDomainDefPtr src,\n                              virDomainDefPtr dst,\n                              virDomainXMLOptionPtr xmlopt)\n{\n    return virDomainDefCheckABIStabilityFlags(src, dst, xmlopt, 0);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainDefCheckABIStability(virDomainDefPtr src,\n                              virDomainDefPtr dst,\n                              virDomainXMLOptionPtr xmlopt)\n{\n    return virDomainDefCheckABIStabilityFlags(src, dst, xmlopt, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"cannot change between disk only and \"\n                             \"full system in snapshot %s\")",
            "def->parent.name"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot change between disk only and \"\n                             \"full system in snapshot %s\""
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"cannot change between online and offline \"\n                             \"snapshot state in snapshot %s\")",
            "def->parent.name"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotObjGetDef",
          "args": [
            "other"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotObjGetDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainsnapshotobjlist.h",
          "lines": "91-95",
          "snippet": "static inline virDomainSnapshotDefPtr\nvirDomainSnapshotObjGetDef(virDomainMomentObjPtr obj)\n{\n    return (virDomainSnapshotDefPtr) obj->def;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"virdomainmomentobjlist.h\"",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "virDomainMomentObjPtr virDomainSnapshotAssignDef(virDomainSnapshotObjListPtr snapshots,\n                                                 virDomainSnapshotDefPtr def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"virdomainmomentobjlist.h\"\n#include \"internal.h\"\n\nvirDomainMomentObjPtr virDomainSnapshotAssignDef(virDomainSnapshotObjListPtr snapshots,\n                                                 virDomainSnapshotDefPtr def);\n\nstatic inline virDomainSnapshotDefPtr\nvirDomainSnapshotObjGetDef(virDomainMomentObjPtr obj)\n{\n    return (virDomainSnapshotDefPtr) obj->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"definition for snapshot %s must use uuid %s\")",
            "def->parent.name",
            "uuidstr"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "domain_uuid",
            "uuidstr"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "def->parent.dom->uuid",
            "domain_uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"disk-only flag for snapshot %s requires \"\n                         \"disk-snapshot state\")",
            "def->parent.name"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDefIsExternal",
          "args": [
            "def"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDefIsExternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "945-959",
          "snippet": "bool\nvirDomainSnapshotDefIsExternal(virDomainSnapshotDefPtr def)\n{\n    size_t i;\n\n    if (def->memory == VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL)\n        return true;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i].snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL)\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainSnapshotDefIsExternal(virDomainSnapshotDefPtr def)\n{\n    size_t i;\n\n    if (def->memory == VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL)\n        return true;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (def->disks[i].snapshot == VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL)\n            return true;\n    }\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainSnapshotRedefineValidate(virDomainSnapshotDefPtr def,\n                                  const unsigned char *domain_uuid,\n                                  virDomainMomentObjPtr other,\n                                  virDomainXMLOptionPtr xmlopt,\n                                  unsigned int flags)\n{\n    int align_location = VIR_DOMAIN_SNAPSHOT_LOCATION_INTERNAL;\n    bool align_match = true;\n    bool external = def->state == VIR_DOMAIN_SNAPSHOT_DISK_SNAPSHOT ||\n        virDomainSnapshotDefIsExternal(def);\n\n    if ((flags & VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY) && !external) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"disk-only flag for snapshot %s requires \"\n                         \"disk-snapshot state\"),\n                       def->parent.name);\n        return -1;\n    }\n    if (def->parent.dom && memcmp(def->parent.dom->uuid, domain_uuid,\n                                  VIR_UUID_BUFLEN)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(domain_uuid, uuidstr);\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"definition for snapshot %s must use uuid %s\"),\n                       def->parent.name, uuidstr);\n        return -1;\n    }\n\n    if (other) {\n        virDomainSnapshotDefPtr otherdef = virDomainSnapshotObjGetDef(other);\n\n        if ((otherdef->state == VIR_DOMAIN_SNAPSHOT_RUNNING ||\n             otherdef->state == VIR_DOMAIN_SNAPSHOT_PAUSED) !=\n            (def->state == VIR_DOMAIN_SNAPSHOT_RUNNING ||\n             def->state == VIR_DOMAIN_SNAPSHOT_PAUSED)) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"cannot change between online and offline \"\n                             \"snapshot state in snapshot %s\"),\n                           def->parent.name);\n            return -1;\n        }\n\n        if ((otherdef->state == VIR_DOMAIN_SNAPSHOT_DISK_SNAPSHOT) !=\n            (def->state == VIR_DOMAIN_SNAPSHOT_DISK_SNAPSHOT)) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"cannot change between disk only and \"\n                             \"full system in snapshot %s\"),\n                           def->parent.name);\n            return -1;\n        }\n\n        if (otherdef->parent.dom) {\n            if (def->parent.dom) {\n                if (!virDomainDefCheckABIStability(otherdef->parent.dom,\n                                                   def->parent.dom, xmlopt))\n                    return -1;\n            } else {\n                /* Transfer the domain def */\n                def->parent.dom = g_steal_pointer(&otherdef->parent.dom);\n            }\n        }\n    }\n\n    if (def->parent.dom) {\n        if (external) {\n            align_location = VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL;\n            align_match = false;\n        }\n        if (virDomainSnapshotAlignDisks(def, align_location,\n                                        align_match) < 0)\n            return -1;\n    }\n\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainSnapshotDefParseString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "452-473",
    "snippet": "virDomainSnapshotDefPtr\nvirDomainSnapshotDefParseString(const char *xmlStr,\n                                virDomainXMLOptionPtr xmlopt,\n                                void *parseOpaque,\n                                bool *current,\n                                unsigned int flags)\n{\n    virDomainSnapshotDefPtr ret = NULL;\n    xmlDocPtr xml;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_snapshot)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainSnapshotDefParseNode(xml, xmlDocGetRootElement(xml),\n                                            xmlopt, parseOpaque,\n                                            current, flags);\n        xmlFreeDoc(xml);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlKeepBlanksDefault",
          "args": [
            "keepBlanksDefault"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xml"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDefParseNode",
          "args": [
            "xml",
            "xmlDocGetRootElement(xml)",
            "xmlopt",
            "parseOpaque",
            "current",
            "flags"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDefParseNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "418-450",
          "snippet": "virDomainSnapshotDefPtr\nvirDomainSnapshotDefParseNode(xmlDocPtr xml,\n                              xmlNodePtr root,\n                              virDomainXMLOptionPtr xmlopt,\n                              void *parseOpaque,\n                              bool *current,\n                              unsigned int flags)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"domainsnapshot\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\", _(\"domainsnapshot\"));\n        return NULL;\n    }\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_PARSE_VALIDATE) {\n        g_autofree char *schema = NULL;\n\n        schema = virFileFindResource(\"domainsnapshot.rng\",\n                                     abs_top_srcdir \"/docs/schemas\",\n                                     PKGDATADIR \"/schemas\");\n        if (!schema)\n            return NULL;\n        if (virXMLValidateAgainstSchema(schema, xml) < 0)\n            return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virDomainSnapshotDefParse(ctxt, xmlopt, parseOpaque, current, flags);\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainSnapshotDefPtr\nvirDomainSnapshotDefParseNode(xmlDocPtr xml,\n                              xmlNodePtr root,\n                              virDomainXMLOptionPtr xmlopt,\n                              void *parseOpaque,\n                              bool *current,\n                              unsigned int flags)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"domainsnapshot\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\", _(\"domainsnapshot\"));\n        return NULL;\n    }\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_PARSE_VALIDATE) {\n        g_autofree char *schema = NULL;\n\n        schema = virFileFindResource(\"domainsnapshot.rng\",\n                                     abs_top_srcdir \"/docs/schemas\",\n                                     PKGDATADIR \"/schemas\");\n        if (!schema)\n            return NULL;\n        if (virXMLValidateAgainstSchema(schema, xml) < 0)\n            return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virDomainSnapshotDefParse(ctxt, xmlopt, parseOpaque, current, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xml"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlKeepBlanksDefault",
          "args": [
            "keepBlanksDefault"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLParse",
          "args": [
            "NULL",
            "xmlStr",
            "_(\"(domain_snapshot)\")"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"(domain_snapshot)\""
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlKeepBlanksDefault",
          "args": [
            "0"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainSnapshotDefPtr\nvirDomainSnapshotDefParseString(const char *xmlStr,\n                                virDomainXMLOptionPtr xmlopt,\n                                void *parseOpaque,\n                                bool *current,\n                                unsigned int flags)\n{\n    virDomainSnapshotDefPtr ret = NULL;\n    xmlDocPtr xml;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_snapshot)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainSnapshotDefParseNode(xml, xmlDocGetRootElement(xml),\n                                            xmlopt, parseOpaque,\n                                            current, flags);\n        xmlFreeDoc(xml);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}"
  },
  {
    "function_name": "virDomainSnapshotDefParseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "418-450",
    "snippet": "virDomainSnapshotDefPtr\nvirDomainSnapshotDefParseNode(xmlDocPtr xml,\n                              xmlNodePtr root,\n                              virDomainXMLOptionPtr xmlopt,\n                              void *parseOpaque,\n                              bool *current,\n                              unsigned int flags)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"domainsnapshot\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\", _(\"domainsnapshot\"));\n        return NULL;\n    }\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_PARSE_VALIDATE) {\n        g_autofree char *schema = NULL;\n\n        schema = virFileFindResource(\"domainsnapshot.rng\",\n                                     abs_top_srcdir \"/docs/schemas\",\n                                     PKGDATADIR \"/schemas\");\n        if (!schema)\n            return NULL;\n        if (virXMLValidateAgainstSchema(schema, xml) < 0)\n            return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virDomainSnapshotDefParse(ctxt, xmlopt, parseOpaque, current, flags);\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainSnapshotDefParse",
          "args": [
            "ctxt",
            "xmlopt",
            "parseOpaque",
            "current",
            "flags"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "452-473",
          "snippet": "virDomainSnapshotDefPtr\nvirDomainSnapshotDefParseString(const char *xmlStr,\n                                virDomainXMLOptionPtr xmlopt,\n                                void *parseOpaque,\n                                bool *current,\n                                unsigned int flags)\n{\n    virDomainSnapshotDefPtr ret = NULL;\n    xmlDocPtr xml;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_snapshot)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainSnapshotDefParseNode(xml, xmlDocGetRootElement(xml),\n                                            xmlopt, parseOpaque,\n                                            current, flags);\n        xmlFreeDoc(xml);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainSnapshotDefPtr\nvirDomainSnapshotDefParseString(const char *xmlStr,\n                                virDomainXMLOptionPtr xmlopt,\n                                void *parseOpaque,\n                                bool *current,\n                                unsigned int flags)\n{\n    virDomainSnapshotDefPtr ret = NULL;\n    xmlDocPtr xml;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_snapshot)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainSnapshotDefParseNode(xml, xmlDocGetRootElement(xml),\n                                            xmlopt, parseOpaque,\n                                            current, flags);\n        xmlFreeDoc(xml);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLXPathContextNew",
          "args": [
            "xml"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLXPathContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "48-59",
          "snippet": "xmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLValidateAgainstSchema",
          "args": [
            "schema",
            "xml"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLValidateAgainstSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1325-1342",
          "snippet": "int\nvirXMLValidateAgainstSchema(const char *schemafile,\n                            xmlDocPtr doc)\n{\n    virXMLValidatorPtr validator = NULL;\n    int ret = -1;\n\n    if (!(validator = virXMLValidatorInit(schemafile)))\n        return -1;\n\n    if (virXMLValidatorValidate(validator, doc) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virXMLValidatorFree(validator);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXMLValidateAgainstSchema(const char *schemafile,\n                            xmlDocPtr doc)\n{\n    virXMLValidatorPtr validator = NULL;\n    int ret = -1;\n\n    if (!(validator = virXMLValidatorInit(schemafile)))\n        return -1;\n\n    if (virXMLValidatorValidate(validator, doc) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virXMLValidatorFree(validator);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileFindResource",
          "args": [
            "\"domainsnapshot.rng\"",
            "abs_top_srcdir \"/docs/schemas\"",
            "PKGDATADIR \"/schemas\""
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFindResource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1771-1777",
          "snippet": "char *\nvirFileFindResource(const char *filename,\n                    const char *builddir,\n                    const char *installdir)\n{\n    return virFileFindResourceFull(filename, NULL, NULL, builddir, installdir, NULL);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFileFindResource(const char *filename,\n                    const char *builddir,\n                    const char *installdir)\n{\n    return virFileFindResourceFull(filename, NULL, NULL, builddir, installdir, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"domainsnapshot\")"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"domainsnapshot\""
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "root",
            "\"domainsnapshot\""
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainSnapshotDefPtr\nvirDomainSnapshotDefParseNode(xmlDocPtr xml,\n                              xmlNodePtr root,\n                              virDomainXMLOptionPtr xmlopt,\n                              void *parseOpaque,\n                              bool *current,\n                              unsigned int flags)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"domainsnapshot\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\", _(\"domainsnapshot\"));\n        return NULL;\n    }\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_PARSE_VALIDATE) {\n        g_autofree char *schema = NULL;\n\n        schema = virFileFindResource(\"domainsnapshot.rng\",\n                                     abs_top_srcdir \"/docs/schemas\",\n                                     PKGDATADIR \"/schemas\");\n        if (!schema)\n            return NULL;\n        if (virXMLValidateAgainstSchema(schema, xml) < 0)\n            return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virDomainSnapshotDefParse(ctxt, xmlopt, parseOpaque, current, flags);\n}"
  },
  {
    "function_name": "virDomainSnapshotDefParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "222-416",
    "snippet": "static virDomainSnapshotDefPtr\nvirDomainSnapshotDefParse(xmlXPathContextPtr ctxt,\n                          virDomainXMLOptionPtr xmlopt,\n                          void *parseOpaque,\n                          bool *current,\n                          unsigned int flags)\n{\n    virDomainSnapshotDefPtr def = NULL;\n    virDomainSnapshotDefPtr ret = NULL;\n    xmlNodePtr *nodes = NULL;\n    xmlNodePtr inactiveDomNode = NULL;\n    size_t i;\n    int n;\n    char *creation = NULL, *state = NULL;\n    int active;\n    char *tmp;\n    char *memorySnapshot = NULL;\n    char *memoryFile = NULL;\n    bool offline = !!(flags & VIR_DOMAIN_SNAPSHOT_PARSE_OFFLINE);\n    virSaveCookieCallbacksPtr saveCookie = virDomainXMLOptionGetSaveCookie(xmlopt);\n    int domainflags = VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                      VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE;\n\n    if (!(def = virDomainSnapshotDefNew()))\n        return NULL;\n\n    def->parent.name = virXPathString(\"string(./name)\", ctxt);\n    if (def->parent.name == NULL) {\n        if (flags & VIR_DOMAIN_SNAPSHOT_PARSE_REDEFINE) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"a redefined snapshot must have a name\"));\n            goto cleanup;\n        }\n    }\n\n    def->parent.description = virXPathString(\"string(./description)\", ctxt);\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_PARSE_REDEFINE) {\n        if (virXPathLongLong(\"string(./creationTime)\", ctxt,\n                             &def->parent.creationTime) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing creationTime from existing snapshot\"));\n            goto cleanup;\n        }\n\n        def->parent.parent_name = virXPathString(\"string(./parent/name)\", ctxt);\n\n        state = virXPathString(\"string(./state)\", ctxt);\n        if (state == NULL) {\n            /* there was no state in an existing snapshot; this\n             * should never happen\n             */\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing state from existing snapshot\"));\n            goto cleanup;\n        }\n        def->state = virDomainSnapshotStateTypeFromString(state);\n        if (def->state <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Invalid state '%s' in domain snapshot XML\"),\n                           state);\n            goto cleanup;\n        }\n        offline = (def->state == VIR_DOMAIN_SNAPSHOT_SHUTOFF ||\n                   def->state == VIR_DOMAIN_SNAPSHOT_DISK_SNAPSHOT);\n\n        /* Older snapshots were created with just <domain>/<uuid>, and\n         * lack domain/@type.  In that case, leave dom NULL, and\n         * clients will have to decide between best effort\n         * initialization or outright failure.  */\n        if ((tmp = virXPathString(\"string(./domain/@type)\", ctxt))) {\n            xmlNodePtr domainNode = virXPathNode(\"./domain\", ctxt);\n\n            VIR_FREE(tmp);\n            if (!domainNode) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing domain in snapshot\"));\n                goto cleanup;\n            }\n            def->parent.dom = virDomainDefParseNode(ctxt->node->doc, domainNode,\n                                                    xmlopt, parseOpaque,\n                                                    domainflags);\n            if (!def->parent.dom)\n                goto cleanup;\n        } else {\n            VIR_WARN(\"parsing older snapshot that lacks domain\");\n        }\n\n        /* /inactiveDomain entry saves the config XML present in a running\n         * VM. In case of absent, leave parent.inactiveDom NULL and use\n         * parent.dom for config and live XML. */\n        if ((inactiveDomNode = virXPathNode(\"./inactiveDomain\", ctxt))) {\n            def->parent.inactiveDom = virDomainDefParseNode(ctxt->node->doc, inactiveDomNode,\n                                                            xmlopt, NULL, domainflags);\n            if (!def->parent.inactiveDom)\n                goto cleanup;\n        }\n    } else if (virDomainXMLOptionRunMomentPostParse(xmlopt, &def->parent) < 0) {\n        goto cleanup;\n    }\n\n    memorySnapshot = virXPathString(\"string(./memory/@snapshot)\", ctxt);\n    memoryFile = virXPathString(\"string(./memory/@file)\", ctxt);\n    if (memorySnapshot) {\n        def->memory = virDomainSnapshotLocationTypeFromString(memorySnapshot);\n        if (def->memory <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown memory snapshot setting '%s'\"),\n                           memorySnapshot);\n            goto cleanup;\n        }\n        if (memoryFile &&\n            def->memory != VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"memory filename '%s' requires external snapshot\"),\n                           memoryFile);\n            goto cleanup;\n        }\n        if (!memoryFile &&\n            def->memory == VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"external memory snapshots require a filename\"));\n            goto cleanup;\n        }\n    } else if (memoryFile) {\n        def->memory = VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL;\n    } else if (flags & VIR_DOMAIN_SNAPSHOT_PARSE_REDEFINE) {\n        def->memory = (offline ?\n                       VIR_DOMAIN_SNAPSHOT_LOCATION_NONE :\n                       VIR_DOMAIN_SNAPSHOT_LOCATION_INTERNAL);\n    }\n    if (offline && def->memory &&\n        def->memory != VIR_DOMAIN_SNAPSHOT_LOCATION_NONE) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"memory state cannot be saved with offline or \"\n                         \"disk-only snapshot\"));\n        goto cleanup;\n    }\n    def->file = g_steal_pointer(&memoryFile);\n\n    /* verify that memory path is absolute */\n    if (def->file && def->file[0] != '/') {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"memory snapshot file path (%s) must be absolute\"),\n                       def->file);\n        goto cleanup;\n    }\n\n    if ((n = virXPathNodeSet(\"./disks/*\", ctxt, &nodes)) < 0)\n        goto cleanup;\n    if (flags & VIR_DOMAIN_SNAPSHOT_PARSE_DISKS) {\n        if (n && VIR_ALLOC_N(def->disks, n) < 0)\n            goto cleanup;\n        def->ndisks = n;\n        for (i = 0; i < def->ndisks; i++) {\n            if (virDomainSnapshotDiskDefParseXML(nodes[i], ctxt, &def->disks[i],\n                                                 flags, xmlopt) < 0)\n                goto cleanup;\n        }\n        VIR_FREE(nodes);\n    } else if (n) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"unable to handle disk requests in snapshot\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_PARSE_INTERNAL) {\n        if (!current) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"internal parse requested with NULL current\"));\n            goto cleanup;\n        }\n        if (virXPathInt(\"string(./active)\", ctxt, &active) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not find 'active' element\"));\n            goto cleanup;\n        }\n        *current = active != 0;\n    }\n\n    if (!offline && virSaveCookieParse(ctxt, &def->cookie, saveCookie) < 0)\n        goto cleanup;\n\n    ret = g_steal_pointer(&def);\n\n cleanup:\n    VIR_FREE(creation);\n    VIR_FREE(state);\n    VIR_FREE(nodes);\n    VIR_FREE(memorySnapshot);\n    VIR_FREE(memoryFile);\n    virObjectUnref(def);\n\n    return ret;\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "def"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "memoryFile"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "memorySnapshot"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "state"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "creation"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&def"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSaveCookieParse",
          "args": [
            "ctxt",
            "&def->cookie",
            "saveCookie"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "virSaveCookieParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virsavecookie.c",
          "lines": "78-103",
          "snippet": "int\nvirSaveCookieParseString(const char *xml,\n                         virObjectPtr *obj,\n                         virSaveCookieCallbacksPtr saveCookie)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    int ret = -1;\n\n    *obj = NULL;\n\n    if (!xml) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"(save cookie)\"), &ctxt)))\n        goto cleanup;\n\n    ret = virSaveCookieParseNode(ctxt, obj, saveCookie);\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n    return ret;\n}",
          "includes": [
            "#include \"virsavecookie.h\"",
            "#include \"virxml.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsavecookie.h\"\n#include \"virxml.h\"\n#include \"virbuffer.h\"\n#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirSaveCookieParseString(const char *xml,\n                         virObjectPtr *obj,\n                         virSaveCookieCallbacksPtr saveCookie)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    int ret = -1;\n\n    *obj = NULL;\n\n    if (!xml) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"(save cookie)\"), &ctxt)))\n        goto cleanup;\n\n    ret = virSaveCookieParseNode(ctxt, obj, saveCookie);\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not find 'active' element\")"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find 'active' element\""
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathInt",
          "args": [
            "\"string(./active)\"",
            "ctxt",
            "&active"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "223-238",
          "snippet": "int\nvirXPathInt(const char *xpath,\n            xmlXPathContextPtr ctxt,\n            int *value)\n{\n    long tmp;\n    int ret;\n\n    ret = virXPathLongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathInt(const char *xpath,\n            xmlXPathContextPtr ctxt,\n            int *value)\n{\n    long tmp;\n    int ret;\n\n    ret = virXPathLongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"internal parse requested with NULL current\")"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "\"%s\"",
            "_(\"unable to handle disk requests in snapshot\")"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDiskDefParseXML",
          "args": [
            "nodes[i]",
            "ctxt",
            "&def->disks[i]",
            "flags",
            "xmlopt"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDiskDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "135-216",
          "snippet": "int\nvirDomainSnapshotDiskDefParseXML(xmlNodePtr node,\n                                 xmlXPathContextPtr ctxt,\n                                 virDomainSnapshotDiskDefPtr def,\n                                 unsigned int flags,\n                                 virDomainXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    char *snapshot = NULL;\n    char *type = NULL;\n    char *driver = NULL;\n    xmlNodePtr cur;\n    xmlNodePtr saved = ctxt->node;\n\n    ctxt->node = node;\n\n    if (!(def->src = virStorageSourceNew()))\n        goto cleanup;\n\n    def->name = virXMLPropString(node, \"name\");\n    if (!def->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing name from disk snapshot element\"));\n        goto cleanup;\n    }\n\n    snapshot = virXMLPropString(node, \"snapshot\");\n    if (snapshot) {\n        def->snapshot = virDomainSnapshotLocationTypeFromString(snapshot);\n        if (def->snapshot <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown disk snapshot setting '%s'\"),\n                           snapshot);\n            goto cleanup;\n        }\n    }\n\n    if ((type = virXMLPropString(node, \"type\"))) {\n        if ((def->src->type = virStorageTypeFromString(type)) <= 0 ||\n            def->src->type == VIR_STORAGE_TYPE_VOLUME ||\n            def->src->type == VIR_STORAGE_TYPE_DIR) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown disk snapshot type '%s'\"), type);\n            goto cleanup;\n        }\n    } else {\n        def->src->type = VIR_STORAGE_TYPE_FILE;\n    }\n\n    if ((cur = virXPathNode(\"./source\", ctxt)) &&\n        virDomainStorageSourceParse(cur, ctxt, def->src, flags, xmlopt) < 0)\n        goto cleanup;\n\n    if ((driver = virXPathString(\"string(./driver/@type)\", ctxt)) &&\n        (def->src->format = virStorageFileFormatTypeFromString(driver)) <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown disk snapshot driver '%s'\"), driver);\n            goto cleanup;\n    }\n\n    /* validate that the passed path is absolute */\n    if (virStorageSourceIsRelative(def->src)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"disk snapshot image path '%s' must be absolute\"),\n                       def->src->path);\n        goto cleanup;\n    }\n\n    if (!def->snapshot && (def->src->path || def->src->format))\n        def->snapshot = VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL;\n\n    ret = 0;\n cleanup:\n    ctxt->node = saved;\n\n    VIR_FREE(driver);\n    VIR_FREE(snapshot);\n    VIR_FREE(type);\n    if (ret < 0)\n        virDomainSnapshotDiskDefClear(def);\n    return ret;\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainSnapshotDiskDefParseXML(xmlNodePtr node,\n                                 xmlXPathContextPtr ctxt,\n                                 virDomainSnapshotDiskDefPtr def,\n                                 unsigned int flags,\n                                 virDomainXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    char *snapshot = NULL;\n    char *type = NULL;\n    char *driver = NULL;\n    xmlNodePtr cur;\n    xmlNodePtr saved = ctxt->node;\n\n    ctxt->node = node;\n\n    if (!(def->src = virStorageSourceNew()))\n        goto cleanup;\n\n    def->name = virXMLPropString(node, \"name\");\n    if (!def->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing name from disk snapshot element\"));\n        goto cleanup;\n    }\n\n    snapshot = virXMLPropString(node, \"snapshot\");\n    if (snapshot) {\n        def->snapshot = virDomainSnapshotLocationTypeFromString(snapshot);\n        if (def->snapshot <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown disk snapshot setting '%s'\"),\n                           snapshot);\n            goto cleanup;\n        }\n    }\n\n    if ((type = virXMLPropString(node, \"type\"))) {\n        if ((def->src->type = virStorageTypeFromString(type)) <= 0 ||\n            def->src->type == VIR_STORAGE_TYPE_VOLUME ||\n            def->src->type == VIR_STORAGE_TYPE_DIR) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown disk snapshot type '%s'\"), type);\n            goto cleanup;\n        }\n    } else {\n        def->src->type = VIR_STORAGE_TYPE_FILE;\n    }\n\n    if ((cur = virXPathNode(\"./source\", ctxt)) &&\n        virDomainStorageSourceParse(cur, ctxt, def->src, flags, xmlopt) < 0)\n        goto cleanup;\n\n    if ((driver = virXPathString(\"string(./driver/@type)\", ctxt)) &&\n        (def->src->format = virStorageFileFormatTypeFromString(driver)) <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown disk snapshot driver '%s'\"), driver);\n            goto cleanup;\n    }\n\n    /* validate that the passed path is absolute */\n    if (virStorageSourceIsRelative(def->src)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"disk snapshot image path '%s' must be absolute\"),\n                       def->src->path);\n        goto cleanup;\n    }\n\n    if (!def->snapshot && (def->src->path || def->src->format))\n        def->snapshot = VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL;\n\n    ret = 0;\n cleanup:\n    ctxt->node = saved;\n\n    VIR_FREE(driver);\n    VIR_FREE(snapshot);\n    VIR_FREE(type);\n    if (ret < 0)\n        virDomainSnapshotDiskDefClear(def);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->disks",
            "n"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./disks/*\"",
            "ctxt",
            "&nodes"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"memory snapshot file path (%s) must be absolute\")",
            "def->file"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&memoryFile"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"memory state cannot be saved with offline or \"\n                         \"disk-only snapshot\")"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"external memory snapshots require a filename\")"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"memory filename '%s' requires external snapshot\")",
            "memoryFile"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unknown memory snapshot setting '%s'\")",
            "memorySnapshot"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotLocationTypeFromString",
          "args": [
            "memorySnapshot"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./memory/@file)\"",
            "ctxt"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainXMLOptionRunMomentPostParse",
          "args": [
            "xmlopt",
            "&def->parent"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainXMLOptionRunMomentPostParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1528-1535",
          "snippet": "int\nvirDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                     virDomainMomentDefPtr def)\n{\n    if (!xmlopt->momentPostParse)\n        return virDomainMomentDefPostParse(def);\n    return xmlopt->momentPostParse(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                     virDomainMomentDefPtr def)\n{\n    if (!xmlopt->momentPostParse)\n        return virDomainMomentDefPostParse(def);\n    return xmlopt->momentPostParse(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefParseNode",
          "args": [
            "ctxt->node->doc",
            "inactiveDomNode",
            "xmlopt",
            "NULL",
            "domainflags"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefParseNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "22153-22180",
          "snippet": "virDomainDefPtr\nvirDomainDefParseNode(xmlDocPtr xml,\n                      xmlNodePtr root,\n                      virDomainXMLOptionPtr xmlopt,\n                      void *parseOpaque,\n                      unsigned int flags)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autoptr(virDomainDef) def = NULL;\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n\n    if (!(def = virDomainDefParseXML(xml, ctxt, xmlopt, flags)))\n        return NULL;\n\n    /* callback to fill driver specific domain aspects */\n    if (virDomainDefPostParse(def, flags, xmlopt, parseOpaque) < 0)\n        return NULL;\n\n    /* validate configuration */\n    if (virDomainDefValidate(def, flags, xmlopt) < 0)\n        return NULL;\n\n    return g_steal_pointer(&def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefParseNode(xmlDocPtr xml,\n                      xmlNodePtr root,\n                      virDomainXMLOptionPtr xmlopt,\n                      void *parseOpaque,\n                      unsigned int flags)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autoptr(virDomainDef) def = NULL;\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n\n    if (!(def = virDomainDefParseXML(xml, ctxt, xmlopt, flags)))\n        return NULL;\n\n    /* callback to fill driver specific domain aspects */\n    if (virDomainDefPostParse(def, flags, xmlopt, parseOpaque) < 0)\n        return NULL;\n\n    /* validate configuration */\n    if (virDomainDefValidate(def, flags, xmlopt) < 0)\n        return NULL;\n\n    return g_steal_pointer(&def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./inactiveDomain\"",
            "ctxt"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"parsing older snapshot that lacks domain\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing domain in snapshot\")"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Invalid state '%s' in domain snapshot XML\")",
            "state"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotStateTypeFromString",
          "args": [
            "state"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing state from existing snapshot\")"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing creationTime from existing snapshot\")"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathLongLong",
          "args": [
            "\"string(./creationTime)\"",
            "ctxt",
            "&def->parent.creationTime"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathLongLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "444-476",
          "snippet": "int\nvirXPathLongLong(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathLongLong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ll((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathLongLong(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 long long *value)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret = 0;\n\n    if ((ctxt == NULL) || (xpath == NULL) || (value == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathLongLong()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj != NULL) && (obj->type == XPATH_STRING) &&\n        (obj->stringval != NULL) && (obj->stringval[0] != 0)) {\n        if (virStrToLong_ll((char *) obj->stringval, NULL, 10, value) < 0)\n            ret = -2;\n    } else if ((obj != NULL) && (obj->type == XPATH_NUMBER) &&\n               (!(isnan(obj->floatval)))) {\n        *value = (long long) obj->floatval;\n        if (*value != obj->floatval)\n            ret = -2;\n    } else {\n        ret = -1;\n    }\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"a redefined snapshot must have a name\")"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDefNew",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "113-120",
          "snippet": "virDomainSnapshotDefPtr\nvirDomainSnapshotDefNew(void)\n{\n    if (virDomainSnapshotInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virDomainSnapshotDefClass);\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virDomainSnapshotDefClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virClassPtr virDomainSnapshotDefClass;\n\nvirDomainSnapshotDefPtr\nvirDomainSnapshotDefNew(void)\n{\n    if (virDomainSnapshotInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virDomainSnapshotDefClass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainXMLOptionGetSaveCookie",
          "args": [
            "xmlopt"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainXMLOptionGetSaveCookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1513-1517",
          "snippet": "virSaveCookieCallbacksPtr\nvirDomainXMLOptionGetSaveCookie(virDomainXMLOptionPtr xmlopt)\n{\n    return &xmlopt->saveCookie;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSaveCookieCallbacksPtr\nvirDomainXMLOptionGetSaveCookie(virDomainXMLOptionPtr xmlopt)\n{\n    return &xmlopt->saveCookie;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virDomainSnapshotDefPtr\nvirDomainSnapshotDefParse(xmlXPathContextPtr ctxt,\n                          virDomainXMLOptionPtr xmlopt,\n                          void *parseOpaque,\n                          bool *current,\n                          unsigned int flags)\n{\n    virDomainSnapshotDefPtr def = NULL;\n    virDomainSnapshotDefPtr ret = NULL;\n    xmlNodePtr *nodes = NULL;\n    xmlNodePtr inactiveDomNode = NULL;\n    size_t i;\n    int n;\n    char *creation = NULL, *state = NULL;\n    int active;\n    char *tmp;\n    char *memorySnapshot = NULL;\n    char *memoryFile = NULL;\n    bool offline = !!(flags & VIR_DOMAIN_SNAPSHOT_PARSE_OFFLINE);\n    virSaveCookieCallbacksPtr saveCookie = virDomainXMLOptionGetSaveCookie(xmlopt);\n    int domainflags = VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                      VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE;\n\n    if (!(def = virDomainSnapshotDefNew()))\n        return NULL;\n\n    def->parent.name = virXPathString(\"string(./name)\", ctxt);\n    if (def->parent.name == NULL) {\n        if (flags & VIR_DOMAIN_SNAPSHOT_PARSE_REDEFINE) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"a redefined snapshot must have a name\"));\n            goto cleanup;\n        }\n    }\n\n    def->parent.description = virXPathString(\"string(./description)\", ctxt);\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_PARSE_REDEFINE) {\n        if (virXPathLongLong(\"string(./creationTime)\", ctxt,\n                             &def->parent.creationTime) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"missing creationTime from existing snapshot\"));\n            goto cleanup;\n        }\n\n        def->parent.parent_name = virXPathString(\"string(./parent/name)\", ctxt);\n\n        state = virXPathString(\"string(./state)\", ctxt);\n        if (state == NULL) {\n            /* there was no state in an existing snapshot; this\n             * should never happen\n             */\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing state from existing snapshot\"));\n            goto cleanup;\n        }\n        def->state = virDomainSnapshotStateTypeFromString(state);\n        if (def->state <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Invalid state '%s' in domain snapshot XML\"),\n                           state);\n            goto cleanup;\n        }\n        offline = (def->state == VIR_DOMAIN_SNAPSHOT_SHUTOFF ||\n                   def->state == VIR_DOMAIN_SNAPSHOT_DISK_SNAPSHOT);\n\n        /* Older snapshots were created with just <domain>/<uuid>, and\n         * lack domain/@type.  In that case, leave dom NULL, and\n         * clients will have to decide between best effort\n         * initialization or outright failure.  */\n        if ((tmp = virXPathString(\"string(./domain/@type)\", ctxt))) {\n            xmlNodePtr domainNode = virXPathNode(\"./domain\", ctxt);\n\n            VIR_FREE(tmp);\n            if (!domainNode) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing domain in snapshot\"));\n                goto cleanup;\n            }\n            def->parent.dom = virDomainDefParseNode(ctxt->node->doc, domainNode,\n                                                    xmlopt, parseOpaque,\n                                                    domainflags);\n            if (!def->parent.dom)\n                goto cleanup;\n        } else {\n            VIR_WARN(\"parsing older snapshot that lacks domain\");\n        }\n\n        /* /inactiveDomain entry saves the config XML present in a running\n         * VM. In case of absent, leave parent.inactiveDom NULL and use\n         * parent.dom for config and live XML. */\n        if ((inactiveDomNode = virXPathNode(\"./inactiveDomain\", ctxt))) {\n            def->parent.inactiveDom = virDomainDefParseNode(ctxt->node->doc, inactiveDomNode,\n                                                            xmlopt, NULL, domainflags);\n            if (!def->parent.inactiveDom)\n                goto cleanup;\n        }\n    } else if (virDomainXMLOptionRunMomentPostParse(xmlopt, &def->parent) < 0) {\n        goto cleanup;\n    }\n\n    memorySnapshot = virXPathString(\"string(./memory/@snapshot)\", ctxt);\n    memoryFile = virXPathString(\"string(./memory/@file)\", ctxt);\n    if (memorySnapshot) {\n        def->memory = virDomainSnapshotLocationTypeFromString(memorySnapshot);\n        if (def->memory <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown memory snapshot setting '%s'\"),\n                           memorySnapshot);\n            goto cleanup;\n        }\n        if (memoryFile &&\n            def->memory != VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"memory filename '%s' requires external snapshot\"),\n                           memoryFile);\n            goto cleanup;\n        }\n        if (!memoryFile &&\n            def->memory == VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"external memory snapshots require a filename\"));\n            goto cleanup;\n        }\n    } else if (memoryFile) {\n        def->memory = VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL;\n    } else if (flags & VIR_DOMAIN_SNAPSHOT_PARSE_REDEFINE) {\n        def->memory = (offline ?\n                       VIR_DOMAIN_SNAPSHOT_LOCATION_NONE :\n                       VIR_DOMAIN_SNAPSHOT_LOCATION_INTERNAL);\n    }\n    if (offline && def->memory &&\n        def->memory != VIR_DOMAIN_SNAPSHOT_LOCATION_NONE) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"memory state cannot be saved with offline or \"\n                         \"disk-only snapshot\"));\n        goto cleanup;\n    }\n    def->file = g_steal_pointer(&memoryFile);\n\n    /* verify that memory path is absolute */\n    if (def->file && def->file[0] != '/') {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"memory snapshot file path (%s) must be absolute\"),\n                       def->file);\n        goto cleanup;\n    }\n\n    if ((n = virXPathNodeSet(\"./disks/*\", ctxt, &nodes)) < 0)\n        goto cleanup;\n    if (flags & VIR_DOMAIN_SNAPSHOT_PARSE_DISKS) {\n        if (n && VIR_ALLOC_N(def->disks, n) < 0)\n            goto cleanup;\n        def->ndisks = n;\n        for (i = 0; i < def->ndisks; i++) {\n            if (virDomainSnapshotDiskDefParseXML(nodes[i], ctxt, &def->disks[i],\n                                                 flags, xmlopt) < 0)\n                goto cleanup;\n        }\n        VIR_FREE(nodes);\n    } else if (n) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"unable to handle disk requests in snapshot\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_PARSE_INTERNAL) {\n        if (!current) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"internal parse requested with NULL current\"));\n            goto cleanup;\n        }\n        if (virXPathInt(\"string(./active)\", ctxt, &active) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not find 'active' element\"));\n            goto cleanup;\n        }\n        *current = active != 0;\n    }\n\n    if (!offline && virSaveCookieParse(ctxt, &def->cookie, saveCookie) < 0)\n        goto cleanup;\n\n    ret = g_steal_pointer(&def);\n\n cleanup:\n    VIR_FREE(creation);\n    VIR_FREE(state);\n    VIR_FREE(nodes);\n    VIR_FREE(memorySnapshot);\n    VIR_FREE(memoryFile);\n    virObjectUnref(def);\n\n    return ret;\n}"
  },
  {
    "function_name": "virDomainSnapshotDiskDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "135-216",
    "snippet": "int\nvirDomainSnapshotDiskDefParseXML(xmlNodePtr node,\n                                 xmlXPathContextPtr ctxt,\n                                 virDomainSnapshotDiskDefPtr def,\n                                 unsigned int flags,\n                                 virDomainXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    char *snapshot = NULL;\n    char *type = NULL;\n    char *driver = NULL;\n    xmlNodePtr cur;\n    xmlNodePtr saved = ctxt->node;\n\n    ctxt->node = node;\n\n    if (!(def->src = virStorageSourceNew()))\n        goto cleanup;\n\n    def->name = virXMLPropString(node, \"name\");\n    if (!def->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing name from disk snapshot element\"));\n        goto cleanup;\n    }\n\n    snapshot = virXMLPropString(node, \"snapshot\");\n    if (snapshot) {\n        def->snapshot = virDomainSnapshotLocationTypeFromString(snapshot);\n        if (def->snapshot <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown disk snapshot setting '%s'\"),\n                           snapshot);\n            goto cleanup;\n        }\n    }\n\n    if ((type = virXMLPropString(node, \"type\"))) {\n        if ((def->src->type = virStorageTypeFromString(type)) <= 0 ||\n            def->src->type == VIR_STORAGE_TYPE_VOLUME ||\n            def->src->type == VIR_STORAGE_TYPE_DIR) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown disk snapshot type '%s'\"), type);\n            goto cleanup;\n        }\n    } else {\n        def->src->type = VIR_STORAGE_TYPE_FILE;\n    }\n\n    if ((cur = virXPathNode(\"./source\", ctxt)) &&\n        virDomainStorageSourceParse(cur, ctxt, def->src, flags, xmlopt) < 0)\n        goto cleanup;\n\n    if ((driver = virXPathString(\"string(./driver/@type)\", ctxt)) &&\n        (def->src->format = virStorageFileFormatTypeFromString(driver)) <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown disk snapshot driver '%s'\"), driver);\n            goto cleanup;\n    }\n\n    /* validate that the passed path is absolute */\n    if (virStorageSourceIsRelative(def->src)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"disk snapshot image path '%s' must be absolute\"),\n                       def->src->path);\n        goto cleanup;\n    }\n\n    if (!def->snapshot && (def->src->path || def->src->format))\n        def->snapshot = VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL;\n\n    ret = 0;\n cleanup:\n    ctxt->node = saved;\n\n    VIR_FREE(driver);\n    VIR_FREE(snapshot);\n    VIR_FREE(type);\n    if (ret < 0)\n        virDomainSnapshotDiskDefClear(def);\n    return ret;\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainSnapshotDiskDefClear",
          "args": [
            "def"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDiskDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "93-99",
          "snippet": "static void\nvirDomainSnapshotDiskDefClear(virDomainSnapshotDiskDefPtr disk)\n{\n    VIR_FREE(disk->name);\n    virObjectUnref(disk->src);\n    disk->src = NULL;\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvirDomainSnapshotDiskDefClear(virDomainSnapshotDiskDefPtr disk)\n{\n    VIR_FREE(disk->name);\n    virObjectUnref(disk->src);\n    disk->src = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "type"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshot"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "driver"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"disk snapshot image path '%s' must be absolute\")",
            "def->src->path"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"disk snapshot image path '%s' must be absolute\""
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsRelative",
          "args": [
            "def->src"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsRelative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "4531-4554",
          "snippet": "bool\nvirStorageSourceIsRelative(virStorageSourcePtr src)\n{\n    virStorageType actual_type = virStorageSourceGetActualType(src);\n\n    if (!src->path)\n        return false;\n\n    switch (actual_type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return src->path[0] != '/';\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        return false;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsRelative(virStorageSourcePtr src)\n{\n    virStorageType actual_type = virStorageSourceGetActualType(src);\n\n    if (!src->path)\n        return false;\n\n    switch (actual_type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return src->path[0] != '/';\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        return false;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unknown disk snapshot driver '%s'\")",
            "driver"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeFromString",
          "args": [
            "driver"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./driver/@type)\"",
            "ctxt"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainStorageSourceParse",
          "args": [
            "cur",
            "ctxt",
            "def->src",
            "flags",
            "xmlopt"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainStorageSourceParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "9702-9778",
          "snippet": "int\nvirDomainStorageSourceParse(xmlNodePtr node,\n                            xmlXPathContextPtr ctxt,\n                            virStorageSourcePtr src,\n                            unsigned int flags,\n                            virDomainXMLOptionPtr xmlopt)\n{\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n    xmlNodePtr tmp;\n\n    ctxt->node = node;\n\n    switch ((virStorageType)src->type) {\n    case VIR_STORAGE_TYPE_FILE:\n        src->path = virXMLPropString(node, \"file\");\n        break;\n    case VIR_STORAGE_TYPE_BLOCK:\n        src->path = virXMLPropString(node, \"dev\");\n        break;\n    case VIR_STORAGE_TYPE_DIR:\n        src->path = virXMLPropString(node, \"dir\");\n        break;\n    case VIR_STORAGE_TYPE_NETWORK:\n        if (virDomainDiskSourceNetworkParse(node, ctxt, src, flags) < 0)\n            return -1;\n        break;\n    case VIR_STORAGE_TYPE_VOLUME:\n        if (virDomainDiskSourcePoolDefParse(node, &src->srcpool) < 0)\n            return -1;\n        break;\n    case VIR_STORAGE_TYPE_NVME:\n        if (virDomainDiskSourceNVMeParse(node, ctxt, src) < 0)\n            return -1;\n        break;\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected disk type %s\"),\n                       virStorageTypeToString(src->type));\n        return -1;\n    }\n\n    if ((tmp = virXPathNode(\"./auth\", ctxt)) &&\n        !(src->auth = virStorageAuthDefParse(tmp, ctxt)))\n        return -1;\n\n    if ((tmp = virXPathNode(\"./encryption\", ctxt)) &&\n        !(src->encryption = virStorageEncryptionParseNode(tmp, ctxt)))\n        return -1;\n\n    if (virDomainDiskSourcePRParse(node, ctxt, &src->pr) < 0)\n        return -1;\n\n    if (virDomainStorageSourceParseSlices(src, ctxt) < 0)\n        return -1;\n\n    if (virSecurityDeviceLabelDefParseXML(&src->seclabels, &src->nseclabels,\n                                          ctxt, flags) < 0)\n        return -1;\n\n    /* People sometimes pass a bogus '' source path when they mean to omit the\n     * source element completely (e.g. CDROM without media). This is just a\n     * little compatibility check to help those broken apps */\n    if (src->path && !*src->path)\n        VIR_FREE(src->path);\n\n    if ((flags & VIR_DOMAIN_DEF_PARSE_STATUS) &&\n        xmlopt && xmlopt->privateData.storageParse &&\n        (tmp = virXPathNode(\"./privateData\", ctxt))) {\n        ctxt->node = tmp;\n\n        if (xmlopt->privateData.storageParse(ctxt, src) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainStorageSourceParse(xmlNodePtr node,\n                            xmlXPathContextPtr ctxt,\n                            virStorageSourcePtr src,\n                            unsigned int flags,\n                            virDomainXMLOptionPtr xmlopt)\n{\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n    xmlNodePtr tmp;\n\n    ctxt->node = node;\n\n    switch ((virStorageType)src->type) {\n    case VIR_STORAGE_TYPE_FILE:\n        src->path = virXMLPropString(node, \"file\");\n        break;\n    case VIR_STORAGE_TYPE_BLOCK:\n        src->path = virXMLPropString(node, \"dev\");\n        break;\n    case VIR_STORAGE_TYPE_DIR:\n        src->path = virXMLPropString(node, \"dir\");\n        break;\n    case VIR_STORAGE_TYPE_NETWORK:\n        if (virDomainDiskSourceNetworkParse(node, ctxt, src, flags) < 0)\n            return -1;\n        break;\n    case VIR_STORAGE_TYPE_VOLUME:\n        if (virDomainDiskSourcePoolDefParse(node, &src->srcpool) < 0)\n            return -1;\n        break;\n    case VIR_STORAGE_TYPE_NVME:\n        if (virDomainDiskSourceNVMeParse(node, ctxt, src) < 0)\n            return -1;\n        break;\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected disk type %s\"),\n                       virStorageTypeToString(src->type));\n        return -1;\n    }\n\n    if ((tmp = virXPathNode(\"./auth\", ctxt)) &&\n        !(src->auth = virStorageAuthDefParse(tmp, ctxt)))\n        return -1;\n\n    if ((tmp = virXPathNode(\"./encryption\", ctxt)) &&\n        !(src->encryption = virStorageEncryptionParseNode(tmp, ctxt)))\n        return -1;\n\n    if (virDomainDiskSourcePRParse(node, ctxt, &src->pr) < 0)\n        return -1;\n\n    if (virDomainStorageSourceParseSlices(src, ctxt) < 0)\n        return -1;\n\n    if (virSecurityDeviceLabelDefParseXML(&src->seclabels, &src->nseclabels,\n                                          ctxt, flags) < 0)\n        return -1;\n\n    /* People sometimes pass a bogus '' source path when they mean to omit the\n     * source element completely (e.g. CDROM without media). This is just a\n     * little compatibility check to help those broken apps */\n    if (src->path && !*src->path)\n        VIR_FREE(src->path);\n\n    if ((flags & VIR_DOMAIN_DEF_PARSE_STATUS) &&\n        xmlopt && xmlopt->privateData.storageParse &&\n        (tmp = virXPathNode(\"./privateData\", ctxt))) {\n        ctxt->node = tmp;\n\n        if (xmlopt->privateData.storageParse(ctxt, src) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./source\"",
            "ctxt"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unknown disk snapshot type '%s'\")",
            "type"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageTypeFromString",
          "args": [
            "type"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "node",
            "\"type\""
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unknown disk snapshot setting '%s'\")",
            "snapshot"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotLocationTypeFromString",
          "args": [
            "snapshot"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing name from disk snapshot element\")"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceNew",
          "args": [],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2744-2751",
          "snippet": "virStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virStorageSourceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virClassPtr virStorageSourceClass;\n\nvirStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainSnapshotDiskDefParseXML(xmlNodePtr node,\n                                 xmlXPathContextPtr ctxt,\n                                 virDomainSnapshotDiskDefPtr def,\n                                 unsigned int flags,\n                                 virDomainXMLOptionPtr xmlopt)\n{\n    int ret = -1;\n    char *snapshot = NULL;\n    char *type = NULL;\n    char *driver = NULL;\n    xmlNodePtr cur;\n    xmlNodePtr saved = ctxt->node;\n\n    ctxt->node = node;\n\n    if (!(def->src = virStorageSourceNew()))\n        goto cleanup;\n\n    def->name = virXMLPropString(node, \"name\");\n    if (!def->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing name from disk snapshot element\"));\n        goto cleanup;\n    }\n\n    snapshot = virXMLPropString(node, \"snapshot\");\n    if (snapshot) {\n        def->snapshot = virDomainSnapshotLocationTypeFromString(snapshot);\n        if (def->snapshot <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown disk snapshot setting '%s'\"),\n                           snapshot);\n            goto cleanup;\n        }\n    }\n\n    if ((type = virXMLPropString(node, \"type\"))) {\n        if ((def->src->type = virStorageTypeFromString(type)) <= 0 ||\n            def->src->type == VIR_STORAGE_TYPE_VOLUME ||\n            def->src->type == VIR_STORAGE_TYPE_DIR) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown disk snapshot type '%s'\"), type);\n            goto cleanup;\n        }\n    } else {\n        def->src->type = VIR_STORAGE_TYPE_FILE;\n    }\n\n    if ((cur = virXPathNode(\"./source\", ctxt)) &&\n        virDomainStorageSourceParse(cur, ctxt, def->src, flags, xmlopt) < 0)\n        goto cleanup;\n\n    if ((driver = virXPathString(\"string(./driver/@type)\", ctxt)) &&\n        (def->src->format = virStorageFileFormatTypeFromString(driver)) <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown disk snapshot driver '%s'\"), driver);\n            goto cleanup;\n    }\n\n    /* validate that the passed path is absolute */\n    if (virStorageSourceIsRelative(def->src)) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"disk snapshot image path '%s' must be absolute\"),\n                       def->src->path);\n        goto cleanup;\n    }\n\n    if (!def->snapshot && (def->src->path || def->src->format))\n        def->snapshot = VIR_DOMAIN_SNAPSHOT_LOCATION_EXTERNAL;\n\n    ret = 0;\n cleanup:\n    ctxt->node = saved;\n\n    VIR_FREE(driver);\n    VIR_FREE(snapshot);\n    VIR_FREE(type);\n    if (ret < 0)\n        virDomainSnapshotDiskDefClear(def);\n    return ret;\n}"
  },
  {
    "function_name": "virDomainSnapshotDefDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "122-133",
    "snippet": "static void\nvirDomainSnapshotDefDispose(void *obj)\n{\n    virDomainSnapshotDefPtr def = obj;\n    size_t i;\n\n    VIR_FREE(def->file);\n    for (i = 0; i < def->ndisks; i++)\n        virDomainSnapshotDiskDefClear(&def->disks[i]);\n    VIR_FREE(def->disks);\n    virObjectUnref(def->cookie);\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virDomainSnapshotDefDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "def->cookie"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->disks"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDiskDefClear",
          "args": [
            "&def->disks[i]"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDiskDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "93-99",
          "snippet": "static void\nvirDomainSnapshotDiskDefClear(virDomainSnapshotDiskDefPtr disk)\n{\n    VIR_FREE(disk->name);\n    virObjectUnref(disk->src);\n    disk->src = NULL;\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvirDomainSnapshotDiskDefClear(virDomainSnapshotDiskDefPtr disk)\n{\n    VIR_FREE(disk->name);\n    virObjectUnref(disk->src);\n    disk->src = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->file"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virDomainSnapshotDefDispose(void *obj);\n\nstatic void\nvirDomainSnapshotDefDispose(void *obj)\n{\n    virDomainSnapshotDefPtr def = obj;\n    size_t i;\n\n    VIR_FREE(def->file);\n    for (i = 0; i < def->ndisks; i++)\n        virDomainSnapshotDiskDefClear(&def->disks[i]);\n    VIR_FREE(def->disks);\n    virObjectUnref(def->cookie);\n}"
  },
  {
    "function_name": "virDomainSnapshotDefNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "113-120",
    "snippet": "virDomainSnapshotDefPtr\nvirDomainSnapshotDefNew(void)\n{\n    if (virDomainSnapshotInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virDomainSnapshotDefClass);\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virDomainSnapshotDefClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "virDomainSnapshotDefClass"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotInitialize",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virClassPtr virDomainSnapshotDefClass;\n\nvirDomainSnapshotDefPtr\nvirDomainSnapshotDefNew(void)\n{\n    if (virDomainSnapshotInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virDomainSnapshotDefClass);\n}"
  },
  {
    "function_name": "virDomainSnapshotDiskDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "101-109",
    "snippet": "void\nvirDomainSnapshotDiskDefFree(virDomainSnapshotDiskDefPtr disk)\n{\n    if (!disk)\n        return;\n\n    virDomainSnapshotDiskDefClear(disk);\n    VIR_FREE(disk);\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disk"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDiskDefClear",
          "args": [
            "disk"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDiskDefClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "93-99",
          "snippet": "static void\nvirDomainSnapshotDiskDefClear(virDomainSnapshotDiskDefPtr disk)\n{\n    VIR_FREE(disk->name);\n    virObjectUnref(disk->src);\n    disk->src = NULL;\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvirDomainSnapshotDiskDefClear(virDomainSnapshotDiskDefPtr disk)\n{\n    VIR_FREE(disk->name);\n    virObjectUnref(disk->src);\n    disk->src = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainSnapshotDiskDefFree(virDomainSnapshotDiskDefPtr disk)\n{\n    if (!disk)\n        return;\n\n    virDomainSnapshotDiskDefClear(disk);\n    VIR_FREE(disk);\n}"
  },
  {
    "function_name": "virDomainSnapshotDiskDefClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "93-99",
    "snippet": "static void\nvirDomainSnapshotDiskDefClear(virDomainSnapshotDiskDefPtr disk)\n{\n    VIR_FREE(disk->name);\n    virObjectUnref(disk->src);\n    disk->src = NULL;\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "disk->src"
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disk->name"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvirDomainSnapshotDiskDefClear(virDomainSnapshotDiskDefPtr disk)\n{\n    VIR_FREE(disk->name);\n    virObjectUnref(disk->src);\n    disk->src = NULL;\n}"
  },
  {
    "function_name": "virDomainSnapshotOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
    "lines": "59-66",
    "snippet": "static int\nvirDomainSnapshotOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virDomainSnapshotDef, virClassForDomainMomentDef()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"snapshot_conf_priv.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"viruuid.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"secret_conf.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include \"netdev_bandwidth_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virbitmap.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virDomainSnapshotDef",
            "virClassForDomainMomentDef()"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForDomainMomentDef",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForDomainMomentDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/moment_conf.c",
          "lines": "51-58",
          "snippet": "virClassPtr\nvirClassForDomainMomentDef(void)\n{\n    if (virDomainMomentInitialize() < 0)\n        return NULL;\n\n    return virDomainMomentDefClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"moment_conf.h\"",
            "#include \"internal.h\"",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virDomainMomentDefClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"moment_conf.h\"\n#include \"internal.h\"\n#include <sys/time.h>\n#include <config.h>\n\nstatic virClassPtr virDomainMomentDefClass;\n\nvirClassPtr\nvirClassForDomainMomentDef(void)\n{\n    if (virDomainMomentInitialize() < 0)\n        return NULL;\n\n    return virDomainMomentDefClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirDomainSnapshotOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virDomainSnapshotDef, virClassForDomainMomentDef()))\n        return -1;\n\n    return 0;\n}"
  }
]