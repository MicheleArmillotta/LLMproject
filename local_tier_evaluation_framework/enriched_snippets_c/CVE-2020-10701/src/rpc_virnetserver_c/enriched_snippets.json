[
  {
    "function_name": "virNetServerUpdateTlsFiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "1228-1257",
    "snippet": "int\nvirNetServerUpdateTlsFiles(virNetServerPtr srv)\n{\n    int ret = -1;\n    virNetTLSContextPtr ctxt = NULL;\n    bool privileged = geteuid() == 0 ? true : false;\n\n    ctxt = virNetServerGetTLSContext(srv);\n    if (!ctxt) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no tls service found, unable to update tls files\"));\n        return -1;\n    }\n\n    virObjectLock(srv);\n    virObjectLock(ctxt);\n\n    if (virNetTLSContextReloadForServer(ctxt, !privileged)) {\n        VIR_DEBUG(\"failed to reload server's tls context\");\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"update tls files success\");\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(ctxt);\n    virObjectUnlock(srv);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"update tls files success\""
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"failed to reload server's tls context\""
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetTLSContextReloadForServer",
          "args": [
            "ctxt",
            "!privileged"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "virNetTLSContextReloadForServer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnettlscontext.c",
          "lines": "922-965",
          "snippet": "int virNetTLSContextReloadForServer(virNetTLSContextPtr ctxt,\n                                    bool tryUserPkiPath)\n{\n    gnutls_certificate_credentials_t x509credBak;\n    int err;\n    char *cacert = NULL;\n    char *cacrl = NULL;\n    char *cert = NULL;\n    char *key = NULL;\n\n    x509credBak = ctxt->x509cred;\n    ctxt->x509cred = NULL;\n\n    if (virNetTLSContextLocateCredentials(NULL, tryUserPkiPath, true,\n                                          &cacert, &cacrl, &cert, &key))\n        goto error;\n\n    err = gnutls_certificate_allocate_credentials(&ctxt->x509cred);\n    if (err) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to allocate x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    if (virNetTLSContextSanityCheckCredentials(true, cacert, cert))\n        goto error;\n\n    if (virNetTLSContextLoadCredentials(ctxt, true, cacert, cacrl, cert, key))\n        goto error;\n\n    gnutls_certificate_set_dh_params(ctxt->x509cred,\n                                     ctxt->dhParams);\n\n    gnutls_certificate_free_credentials(x509credBak);\n\n    return 0;\n\n error:\n    if (ctxt->x509cred)\n        gnutls_certificate_free_credentials(ctxt->x509cred);\n    ctxt->x509cred = x509credBak;\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virthread.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virnettlscontext.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/crypto.h>",
            "#include <gnutls/gnutls.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virthread.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virnettlscontext.h\"\n#include <gnutls/x509.h>\n#include <gnutls/crypto.h>\n#include <gnutls/gnutls.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetTLSContextReloadForServer(virNetTLSContextPtr ctxt,\n                                    bool tryUserPkiPath)\n{\n    gnutls_certificate_credentials_t x509credBak;\n    int err;\n    char *cacert = NULL;\n    char *cacrl = NULL;\n    char *cert = NULL;\n    char *key = NULL;\n\n    x509credBak = ctxt->x509cred;\n    ctxt->x509cred = NULL;\n\n    if (virNetTLSContextLocateCredentials(NULL, tryUserPkiPath, true,\n                                          &cacert, &cacrl, &cert, &key))\n        goto error;\n\n    err = gnutls_certificate_allocate_credentials(&ctxt->x509cred);\n    if (err) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to allocate x509 credentials: %s\"),\n                       gnutls_strerror(err));\n        goto error;\n    }\n\n    if (virNetTLSContextSanityCheckCredentials(true, cacert, cert))\n        goto error;\n\n    if (virNetTLSContextLoadCredentials(ctxt, true, cacert, cacrl, cert, key))\n        goto error;\n\n    gnutls_certificate_set_dh_params(ctxt->x509cred,\n                                     ctxt->dhParams);\n\n    gnutls_certificate_free_credentials(x509credBak);\n\n    return 0;\n\n error:\n    if (ctxt->x509cred)\n        gnutls_certificate_free_credentials(ctxt->x509cred);\n    ctxt->x509cred = x509credBak;\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "ctxt"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no tls service found, unable to update tls files\")"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no tls service found, unable to update tls files\""
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerGetTLSContext",
          "args": [
            "srv"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerGetTLSContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "1210-1226",
          "snippet": "static virNetTLSContextPtr\nvirNetServerGetTLSContext(virNetServerPtr srv)\n{\n    size_t i;\n    virNetTLSContextPtr ctxt = NULL;\n    virNetServerServicePtr svc = NULL;\n\n    /* find svcTLS from srv, get svcTLS->tls */\n    for (i = 0; i < srv->nservices; i++) {\n        svc = srv->services[i];\n        ctxt = virNetServerServiceGetTLSContext(svc);\n        if (ctxt != NULL)\n            break;\n    }\n\n    return ctxt;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic virNetTLSContextPtr\nvirNetServerGetTLSContext(virNetServerPtr srv)\n{\n    size_t i;\n    virNetTLSContextPtr ctxt = NULL;\n    virNetServerServicePtr svc = NULL;\n\n    /* find svcTLS from srv, get svcTLS->tls */\n    for (i = 0; i < srv->nservices; i++) {\n        svc = srv->services[i];\n        ctxt = virNetServerServiceGetTLSContext(svc);\n        if (ctxt != NULL)\n            break;\n    }\n\n    return ctxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint\nvirNetServerUpdateTlsFiles(virNetServerPtr srv)\n{\n    int ret = -1;\n    virNetTLSContextPtr ctxt = NULL;\n    bool privileged = geteuid() == 0 ? true : false;\n\n    ctxt = virNetServerGetTLSContext(srv);\n    if (!ctxt) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no tls service found, unable to update tls files\"));\n        return -1;\n    }\n\n    virObjectLock(srv);\n    virObjectLock(ctxt);\n\n    if (virNetTLSContextReloadForServer(ctxt, !privileged)) {\n        VIR_DEBUG(\"failed to reload server's tls context\");\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"update tls files success\");\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(ctxt);\n    virObjectUnlock(srv);\n    return ret;\n}"
  },
  {
    "function_name": "virNetServerGetTLSContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "1210-1226",
    "snippet": "static virNetTLSContextPtr\nvirNetServerGetTLSContext(virNetServerPtr srv)\n{\n    size_t i;\n    virNetTLSContextPtr ctxt = NULL;\n    virNetServerServicePtr svc = NULL;\n\n    /* find svcTLS from srv, get svcTLS->tls */\n    for (i = 0; i < srv->nservices; i++) {\n        svc = srv->services[i];\n        ctxt = virNetServerServiceGetTLSContext(svc);\n        if (ctxt != NULL)\n            break;\n    }\n\n    return ctxt;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerServiceGetTLSContext",
          "args": [
            "svc"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceGetTLSContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "404-407",
          "snippet": "virNetTLSContextPtr virNetServerServiceGetTLSContext(virNetServerServicePtr svc)\n{\n    return svc->tls;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvirNetTLSContextPtr virNetServerServiceGetTLSContext(virNetServerServicePtr svc)\n{\n    return svc->tls;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic virNetTLSContextPtr\nvirNetServerGetTLSContext(virNetServerPtr srv)\n{\n    size_t i;\n    virNetTLSContextPtr ctxt = NULL;\n    virNetServerServicePtr svc = NULL;\n\n    /* find svcTLS from srv, get svcTLS->tls */\n    for (i = 0; i < srv->nservices; i++) {\n        svc = srv->services[i];\n        ctxt = virNetServerServiceGetTLSContext(svc);\n        if (ctxt != NULL)\n            break;\n    }\n\n    return ctxt;\n}"
  },
  {
    "function_name": "virNetServerSetClientLimits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "1174-1208",
    "snippet": "int\nvirNetServerSetClientLimits(virNetServerPtr srv,\n                            long long int maxClients,\n                            long long int maxClientsUnauth)\n{\n    int ret = -1;\n    size_t max, max_unauth;\n\n    virObjectLock(srv);\n\n    max = maxClients >= 0 ? maxClients : srv->nclients_max;\n    max_unauth = maxClientsUnauth >= 0 ?\n        maxClientsUnauth : srv->nclients_unauth_max;\n\n    if (max < max_unauth) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"The overall maximum number of clients must be \"\n                         \"greater than the maximum number of clients waiting \"\n                         \"for authentication\"));\n        goto cleanup;\n    }\n\n    if (maxClients >= 0)\n        srv->nclients_max = maxClients;\n\n    if (maxClientsUnauth >= 0)\n        srv->nclients_unauth_max = maxClientsUnauth;\n\n    virNetServerCheckLimits(srv);\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(srv);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerCheckLimits",
          "args": [
            "srv"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerCheckLimits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "255-284",
          "snippet": "static void\nvirNetServerCheckLimits(virNetServerPtr srv)\n{\n    VIR_DEBUG(\"Checking client-related limits to re-enable or temporarily \"\n              \"suspend services: nclients=%zu nclients_max=%zu \"\n              \"nclients_unauth=%zu nclients_unauth_max=%zu\",\n              srv->nclients, srv->nclients_max,\n              srv->nclients_unauth, srv->nclients_unauth_max);\n\n    /* Check the max_anonymous_clients and max_clients limits so that we can\n     * decide whether the services should be temporarily suspended, thus not\n     * accepting any more clients for a while or re-enabling the previously\n     * suspended services in order to accept new clients again.\n     * A new client can only be accepted if both max_clients and\n     * max_anonymous_clients wouldn't get overcommitted by accepting it.\n     */\n    if (srv->nclients >= srv->nclients_max ||\n        (srv->nclients_unauth_max &&\n         srv->nclients_unauth >= srv->nclients_unauth_max)) {\n        /* Temporarily stop accepting new clients */\n        VIR_INFO(\"Temporarily suspending services\");\n        virNetServerUpdateServicesLocked(srv, false);\n    } else if (srv->nclients < srv->nclients_max &&\n               (!srv->nclients_unauth_max ||\n                srv->nclients_unauth < srv->nclients_unauth_max)) {\n        /* Now it makes sense to accept() a new client. */\n        VIR_INFO(\"Re-enabling services\");\n        virNetServerUpdateServicesLocked(srv, true);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic void\nvirNetServerCheckLimits(virNetServerPtr srv)\n{\n    VIR_DEBUG(\"Checking client-related limits to re-enable or temporarily \"\n              \"suspend services: nclients=%zu nclients_max=%zu \"\n              \"nclients_unauth=%zu nclients_unauth_max=%zu\",\n              srv->nclients, srv->nclients_max,\n              srv->nclients_unauth, srv->nclients_unauth_max);\n\n    /* Check the max_anonymous_clients and max_clients limits so that we can\n     * decide whether the services should be temporarily suspended, thus not\n     * accepting any more clients for a while or re-enabling the previously\n     * suspended services in order to accept new clients again.\n     * A new client can only be accepted if both max_clients and\n     * max_anonymous_clients wouldn't get overcommitted by accepting it.\n     */\n    if (srv->nclients >= srv->nclients_max ||\n        (srv->nclients_unauth_max &&\n         srv->nclients_unauth >= srv->nclients_unauth_max)) {\n        /* Temporarily stop accepting new clients */\n        VIR_INFO(\"Temporarily suspending services\");\n        virNetServerUpdateServicesLocked(srv, false);\n    } else if (srv->nclients < srv->nclients_max &&\n               (!srv->nclients_unauth_max ||\n                srv->nclients_unauth < srv->nclients_unauth_max)) {\n        /* Now it makes sense to accept() a new client. */\n        VIR_INFO(\"Re-enabling services\");\n        virNetServerUpdateServicesLocked(srv, true);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"The overall maximum number of clients must be \"\n                         \"greater than the maximum number of clients waiting \"\n                         \"for authentication\")"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"The overall maximum number of clients must be \"\n                         \"greater than the maximum number of clients waiting \"\n                         \"for authentication\""
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint\nvirNetServerSetClientLimits(virNetServerPtr srv,\n                            long long int maxClients,\n                            long long int maxClientsUnauth)\n{\n    int ret = -1;\n    size_t max, max_unauth;\n\n    virObjectLock(srv);\n\n    max = maxClients >= 0 ? maxClients : srv->nclients_max;\n    max_unauth = maxClientsUnauth >= 0 ?\n        maxClientsUnauth : srv->nclients_unauth_max;\n\n    if (max < max_unauth) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"The overall maximum number of clients must be \"\n                         \"greater than the maximum number of clients waiting \"\n                         \"for authentication\"));\n        goto cleanup;\n    }\n\n    if (maxClients >= 0)\n        srv->nclients_max = maxClients;\n\n    if (maxClientsUnauth >= 0)\n        srv->nclients_unauth_max = maxClientsUnauth;\n\n    virNetServerCheckLimits(srv);\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(srv);\n    return ret;\n}"
  },
  {
    "function_name": "virNetServerGetClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "1151-1172",
    "snippet": "virNetServerClientPtr\nvirNetServerGetClient(virNetServerPtr srv,\n                      unsigned long long id)\n{\n    size_t i;\n    virNetServerClientPtr ret = NULL;\n\n    virObjectLock(srv);\n\n    for (i = 0; i < srv->nclients; i++) {\n        virNetServerClientPtr client = srv->clients[i];\n        if (virNetServerClientGetID(client) == id)\n            ret = virObjectRef(client);\n    }\n\n    virObjectUnlock(srv);\n\n    if (!ret)\n        virReportError(VIR_ERR_NO_CLIENT,\n                       _(\"No client with matching ID '%llu'\"), id);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_CLIENT",
            "_(\"No client with matching ID '%llu'\")",
            "id"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No client with matching ID '%llu'\""
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "client"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientGetID",
          "args": [
            "client"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientGetID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "680-683",
          "snippet": "unsigned long long virNetServerClientGetID(virNetServerClientPtr client)\n{\n    return client->id;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nunsigned long long virNetServerClientGetID(virNetServerClientPtr client)\n{\n    return client->id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nvirNetServerClientPtr\nvirNetServerGetClient(virNetServerPtr srv,\n                      unsigned long long id)\n{\n    size_t i;\n    virNetServerClientPtr ret = NULL;\n\n    virObjectLock(srv);\n\n    for (i = 0; i < srv->nclients; i++) {\n        virNetServerClientPtr client = srv->clients[i];\n        if (virNetServerClientGetID(client) == id)\n            ret = virObjectRef(client);\n    }\n\n    virObjectUnlock(srv);\n\n    if (!ret)\n        virReportError(VIR_ERR_NO_CLIENT,\n                       _(\"No client with matching ID '%llu'\"), id);\n    return ret;\n}"
  },
  {
    "function_name": "virNetServerGetClients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "1122-1149",
    "snippet": "int\nvirNetServerGetClients(virNetServerPtr srv,\n                       virNetServerClientPtr **clts)\n{\n    int ret = -1;\n    size_t i;\n    size_t nclients = 0;\n    virNetServerClientPtr *list = NULL;\n\n    virObjectLock(srv);\n\n    for (i = 0; i < srv->nclients; i++) {\n        virNetServerClientPtr client = virObjectRef(srv->clients[i]);\n        if (VIR_APPEND_ELEMENT(list, nclients, client) < 0) {\n            virObjectUnref(client);\n            goto cleanup;\n        }\n    }\n\n    *clts = list;\n    list = NULL;\n    ret = nclients;\n\n cleanup:\n    virObjectListFreeCount(list, nclients);\n    virObjectUnlock(srv);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectListFreeCount",
          "args": [
            "list",
            "nclients"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectListFreeCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "625-638",
          "snippet": "void\nvirObjectListFreeCount(void *list,\n                       size_t count)\n{\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < count; i++)\n        virObjectUnref(((void **)list)[i]);\n\n    VIR_FREE(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid\nvirObjectListFreeCount(void *list,\n                       size_t count)\n{\n    size_t i;\n\n    if (!list)\n        return;\n\n    for (i = 0; i < count; i++)\n        virObjectUnref(((void **)list)[i]);\n\n    VIR_FREE(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "client"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "list",
            "nclients",
            "client"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "srv->clients[i]"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint\nvirNetServerGetClients(virNetServerPtr srv,\n                       virNetServerClientPtr **clts)\n{\n    int ret = -1;\n    size_t i;\n    size_t nclients = 0;\n    virNetServerClientPtr *list = NULL;\n\n    virObjectLock(srv);\n\n    for (i = 0; i < srv->nclients; i++) {\n        virNetServerClientPtr client = virObjectRef(srv->clients[i]);\n        if (VIR_APPEND_ELEMENT(list, nclients, client) < 0) {\n            virObjectUnref(client);\n            goto cleanup;\n        }\n    }\n\n    *clts = list;\n    list = NULL;\n    ret = nclients;\n\n cleanup:\n    virObjectListFreeCount(list, nclients);\n    virObjectUnlock(srv);\n    return ret;\n}"
  },
  {
    "function_name": "virNetServerNeedsAuth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "1106-1120",
    "snippet": "bool virNetServerNeedsAuth(virNetServerPtr srv,\n                           int auth)\n{\n    bool ret = false;\n    size_t i;\n\n    virObjectLock(srv);\n    for (i = 0; i < srv->nservices; i++) {\n        if (virNetServerServiceGetAuth(srv->services[i]) == auth)\n            ret = true;\n    }\n    virObjectUnlock(srv);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceGetAuth",
          "args": [
            "srv->services[i]"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceGetAuth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "387-390",
          "snippet": "int virNetServerServiceGetAuth(virNetServerServicePtr svc)\n{\n    return svc->auth;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nint virNetServerServiceGetAuth(virNetServerServicePtr svc)\n{\n    return svc->auth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nbool virNetServerNeedsAuth(virNetServerPtr srv,\n                           int auth)\n{\n    bool ret = false;\n    size_t i;\n\n    virObjectLock(srv);\n    for (i = 0; i < srv->nservices; i++) {\n        if (virNetServerServiceGetAuth(srv->services[i]) == auth)\n            ret = true;\n    }\n    virObjectUnlock(srv);\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetServerGetCurrentUnauthClients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "1093-1103",
    "snippet": "size_t\nvirNetServerGetCurrentUnauthClients(virNetServerPtr srv)\n{\n    size_t ret;\n\n    virObjectLock(srv);\n    ret = srv->nclients_unauth;\n    virObjectUnlock(srv);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nsize_t\nvirNetServerGetCurrentUnauthClients(virNetServerPtr srv)\n{\n    size_t ret;\n\n    virObjectLock(srv);\n    ret = srv->nclients_unauth;\n    virObjectUnlock(srv);\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetServerGetMaxUnauthClients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "1081-1091",
    "snippet": "size_t\nvirNetServerGetMaxUnauthClients(virNetServerPtr srv)\n{\n    size_t ret;\n\n    virObjectLock(srv);\n    ret = srv->nclients_unauth_max;\n    virObjectUnlock(srv);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nsize_t\nvirNetServerGetMaxUnauthClients(virNetServerPtr srv)\n{\n    size_t ret;\n\n    virObjectLock(srv);\n    ret = srv->nclients_unauth_max;\n    virObjectUnlock(srv);\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetServerGetCurrentClients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "1069-1079",
    "snippet": "size_t\nvirNetServerGetCurrentClients(virNetServerPtr srv)\n{\n    size_t ret;\n\n    virObjectLock(srv);\n    ret = srv->nclients;\n    virObjectUnlock(srv);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nsize_t\nvirNetServerGetCurrentClients(virNetServerPtr srv)\n{\n    size_t ret;\n\n    virObjectLock(srv);\n    ret = srv->nclients;\n    virObjectUnlock(srv);\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetServerGetMaxClients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "1057-1067",
    "snippet": "size_t\nvirNetServerGetMaxClients(virNetServerPtr srv)\n{\n    size_t ret;\n\n    virObjectLock(srv);\n    ret = srv->nclients_max;\n    virObjectUnlock(srv);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nsize_t\nvirNetServerGetMaxClients(virNetServerPtr srv)\n{\n    size_t ret;\n\n    virObjectLock(srv);\n    ret = srv->nclients_max;\n    virObjectUnlock(srv);\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetServerSetThreadPoolParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "1041-1055",
    "snippet": "int\nvirNetServerSetThreadPoolParameters(virNetServerPtr srv,\n                                    long long int minWorkers,\n                                    long long int maxWorkers,\n                                    long long int prioWorkers)\n{\n    int ret;\n\n    virObjectLock(srv);\n    ret = virThreadPoolSetParameters(srv->workers, minWorkers,\n                                     maxWorkers, prioWorkers);\n    virObjectUnlock(srv);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadPoolSetParameters",
          "args": [
            "srv->workers",
            "minWorkers",
            "maxWorkers",
            "prioWorkers"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolSetParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "428-485",
          "snippet": "int\nvirThreadPoolSetParameters(virThreadPoolPtr pool,\n                           long long int minWorkers,\n                           long long int maxWorkers,\n                           long long int prioWorkers)\n{\n    size_t max;\n    size_t min;\n\n    virMutexLock(&pool->mutex);\n\n    max = maxWorkers >= 0 ? maxWorkers : pool->maxWorkers;\n    min = minWorkers >= 0 ? minWorkers : pool->minWorkers;\n    if (min > max) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"minWorkers cannot be larger than maxWorkers\"));\n        goto error;\n    }\n\n    if ((maxWorkers == 0 && pool->maxWorkers > 0) ||\n        (maxWorkers > 0 && pool->maxWorkers == 0)) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"maxWorkers must not be switched from zero to non-zero\"\n                         \" and vice versa\"));\n        goto error;\n    }\n\n    if (minWorkers >= 0) {\n        if ((size_t) minWorkers > pool->nWorkers &&\n            virThreadPoolExpand(pool, minWorkers - pool->nWorkers,\n                                false) < 0)\n            goto error;\n        pool->minWorkers = minWorkers;\n    }\n\n    if (maxWorkers >= 0) {\n        pool->maxWorkers = maxWorkers;\n        virCondBroadcast(&pool->cond);\n    }\n\n    if (prioWorkers >= 0) {\n        if (prioWorkers < pool->nPrioWorkers) {\n            virCondBroadcast(&pool->prioCond);\n        } else if ((size_t) prioWorkers > pool->nPrioWorkers &&\n                   virThreadPoolExpand(pool, prioWorkers - pool->nPrioWorkers,\n                                       true) < 0) {\n            goto error;\n        }\n        pool->maxPrioWorkers = prioWorkers;\n    }\n\n    virMutexUnlock(&pool->mutex);\n    return 0;\n\n error:\n    virMutexUnlock(&pool->mutex);\n    return -1;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nint\nvirThreadPoolSetParameters(virThreadPoolPtr pool,\n                           long long int minWorkers,\n                           long long int maxWorkers,\n                           long long int prioWorkers)\n{\n    size_t max;\n    size_t min;\n\n    virMutexLock(&pool->mutex);\n\n    max = maxWorkers >= 0 ? maxWorkers : pool->maxWorkers;\n    min = minWorkers >= 0 ? minWorkers : pool->minWorkers;\n    if (min > max) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"minWorkers cannot be larger than maxWorkers\"));\n        goto error;\n    }\n\n    if ((maxWorkers == 0 && pool->maxWorkers > 0) ||\n        (maxWorkers > 0 && pool->maxWorkers == 0)) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"maxWorkers must not be switched from zero to non-zero\"\n                         \" and vice versa\"));\n        goto error;\n    }\n\n    if (minWorkers >= 0) {\n        if ((size_t) minWorkers > pool->nWorkers &&\n            virThreadPoolExpand(pool, minWorkers - pool->nWorkers,\n                                false) < 0)\n            goto error;\n        pool->minWorkers = minWorkers;\n    }\n\n    if (maxWorkers >= 0) {\n        pool->maxWorkers = maxWorkers;\n        virCondBroadcast(&pool->cond);\n    }\n\n    if (prioWorkers >= 0) {\n        if (prioWorkers < pool->nPrioWorkers) {\n            virCondBroadcast(&pool->prioCond);\n        } else if ((size_t) prioWorkers > pool->nPrioWorkers &&\n                   virThreadPoolExpand(pool, prioWorkers - pool->nPrioWorkers,\n                                       true) < 0) {\n            goto error;\n        }\n        pool->maxPrioWorkers = prioWorkers;\n    }\n\n    virMutexUnlock(&pool->mutex);\n    return 0;\n\n error:\n    virMutexUnlock(&pool->mutex);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint\nvirNetServerSetThreadPoolParameters(virNetServerPtr srv,\n                                    long long int minWorkers,\n                                    long long int maxWorkers,\n                                    long long int prioWorkers)\n{\n    int ret;\n\n    virObjectLock(srv);\n    ret = virThreadPoolSetParameters(srv->workers, minWorkers,\n                                     maxWorkers, prioWorkers);\n    virObjectUnlock(srv);\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetServerGetThreadPoolParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "1019-1039",
    "snippet": "int\nvirNetServerGetThreadPoolParameters(virNetServerPtr srv,\n                                    size_t *minWorkers,\n                                    size_t *maxWorkers,\n                                    size_t *nWorkers,\n                                    size_t *freeWorkers,\n                                    size_t *nPrioWorkers,\n                                    size_t *jobQueueDepth)\n{\n    virObjectLock(srv);\n\n    *minWorkers = virThreadPoolGetMinWorkers(srv->workers);\n    *maxWorkers = virThreadPoolGetMaxWorkers(srv->workers);\n    *freeWorkers = virThreadPoolGetFreeWorkers(srv->workers);\n    *nWorkers = virThreadPoolGetCurrentWorkers(srv->workers);\n    *nPrioWorkers = virThreadPoolGetPriorityWorkers(srv->workers);\n    *jobQueueDepth = virThreadPoolGetJobQueueDepth(srv->workers);\n\n    virObjectUnlock(srv);\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadPoolGetJobQueueDepth",
          "args": [
            "srv->workers"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolGetJobQueueDepth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "367-376",
          "snippet": "size_t virThreadPoolGetJobQueueDepth(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->jobQueueDepth;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetJobQueueDepth(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->jobQueueDepth;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadPoolGetPriorityWorkers",
          "args": [
            "srv->workers"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolGetPriorityWorkers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "334-343",
          "snippet": "size_t virThreadPoolGetPriorityWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->nPrioWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetPriorityWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->nPrioWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadPoolGetCurrentWorkers",
          "args": [
            "srv->workers"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolGetCurrentWorkers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "345-354",
          "snippet": "size_t virThreadPoolGetCurrentWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->nWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetCurrentWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->nWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadPoolGetFreeWorkers",
          "args": [
            "srv->workers"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolGetFreeWorkers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "356-365",
          "snippet": "size_t virThreadPoolGetFreeWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->freeWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetFreeWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->freeWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadPoolGetMaxWorkers",
          "args": [
            "srv->workers"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolGetMaxWorkers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "323-332",
          "snippet": "size_t virThreadPoolGetMaxWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->maxWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetMaxWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->maxWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadPoolGetMinWorkers",
          "args": [
            "srv->workers"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolGetMinWorkers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "312-321",
          "snippet": "size_t virThreadPoolGetMinWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->minWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetMinWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->minWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint\nvirNetServerGetThreadPoolParameters(virNetServerPtr srv,\n                                    size_t *minWorkers,\n                                    size_t *maxWorkers,\n                                    size_t *nWorkers,\n                                    size_t *freeWorkers,\n                                    size_t *nPrioWorkers,\n                                    size_t *jobQueueDepth)\n{\n    virObjectLock(srv);\n\n    *minWorkers = virThreadPoolGetMinWorkers(srv->workers);\n    *maxWorkers = virThreadPoolGetMaxWorkers(srv->workers);\n    *freeWorkers = virThreadPoolGetFreeWorkers(srv->workers);\n    *nWorkers = virThreadPoolGetCurrentWorkers(srv->workers);\n    *nPrioWorkers = virThreadPoolGetPriorityWorkers(srv->workers);\n    *jobQueueDepth = virThreadPoolGetJobQueueDepth(srv->workers);\n\n    virObjectUnlock(srv);\n    return 0;\n}"
  },
  {
    "function_name": "virNetServerGetName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "1013-1017",
    "snippet": "const char *\nvirNetServerGetName(virNetServerPtr srv)\n{\n    return srv->name;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nconst char *\nvirNetServerGetName(virNetServerPtr srv)\n{\n    return srv->name;\n}"
  },
  {
    "function_name": "virNetServerProcessClients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "972-1011",
    "snippet": "void\nvirNetServerProcessClients(virNetServerPtr srv)\n{\n    size_t i;\n    virNetServerClientPtr client;\n\n    virObjectLock(srv);\n\n reprocess:\n    for (i = 0; i < srv->nclients; i++) {\n        /* Coverity 5.3.0 couldn't see that srv->clients is non-NULL\n         * if srv->nclients is non-zero.  */\n        sa_assert(srv->clients);\n\n        client = srv->clients[i];\n        virObjectLock(client);\n        if (virNetServerClientWantCloseLocked(client))\n            virNetServerClientCloseLocked(client);\n\n        if (virNetServerClientIsClosedLocked(client)) {\n            VIR_DELETE_ELEMENT(srv->clients, i, srv->nclients);\n\n            /* Update server authentication tracking */\n            virNetServerSetClientAuthCompletedLocked(srv, client);\n            virObjectUnlock(client);\n\n            virNetServerCheckLimits(srv);\n\n            virObjectUnlock(srv);\n            virObjectUnref(client);\n            virObjectLock(srv);\n\n            goto reprocess;\n        } else {\n            virObjectUnlock(client);\n        }\n    }\n\n    virObjectUnlock(srv);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "client"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerCheckLimits",
          "args": [
            "srv"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerCheckLimits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "255-284",
          "snippet": "static void\nvirNetServerCheckLimits(virNetServerPtr srv)\n{\n    VIR_DEBUG(\"Checking client-related limits to re-enable or temporarily \"\n              \"suspend services: nclients=%zu nclients_max=%zu \"\n              \"nclients_unauth=%zu nclients_unauth_max=%zu\",\n              srv->nclients, srv->nclients_max,\n              srv->nclients_unauth, srv->nclients_unauth_max);\n\n    /* Check the max_anonymous_clients and max_clients limits so that we can\n     * decide whether the services should be temporarily suspended, thus not\n     * accepting any more clients for a while or re-enabling the previously\n     * suspended services in order to accept new clients again.\n     * A new client can only be accepted if both max_clients and\n     * max_anonymous_clients wouldn't get overcommitted by accepting it.\n     */\n    if (srv->nclients >= srv->nclients_max ||\n        (srv->nclients_unauth_max &&\n         srv->nclients_unauth >= srv->nclients_unauth_max)) {\n        /* Temporarily stop accepting new clients */\n        VIR_INFO(\"Temporarily suspending services\");\n        virNetServerUpdateServicesLocked(srv, false);\n    } else if (srv->nclients < srv->nclients_max &&\n               (!srv->nclients_unauth_max ||\n                srv->nclients_unauth < srv->nclients_unauth_max)) {\n        /* Now it makes sense to accept() a new client. */\n        VIR_INFO(\"Re-enabling services\");\n        virNetServerUpdateServicesLocked(srv, true);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic void\nvirNetServerCheckLimits(virNetServerPtr srv)\n{\n    VIR_DEBUG(\"Checking client-related limits to re-enable or temporarily \"\n              \"suspend services: nclients=%zu nclients_max=%zu \"\n              \"nclients_unauth=%zu nclients_unauth_max=%zu\",\n              srv->nclients, srv->nclients_max,\n              srv->nclients_unauth, srv->nclients_unauth_max);\n\n    /* Check the max_anonymous_clients and max_clients limits so that we can\n     * decide whether the services should be temporarily suspended, thus not\n     * accepting any more clients for a while or re-enabling the previously\n     * suspended services in order to accept new clients again.\n     * A new client can only be accepted if both max_clients and\n     * max_anonymous_clients wouldn't get overcommitted by accepting it.\n     */\n    if (srv->nclients >= srv->nclients_max ||\n        (srv->nclients_unauth_max &&\n         srv->nclients_unauth >= srv->nclients_unauth_max)) {\n        /* Temporarily stop accepting new clients */\n        VIR_INFO(\"Temporarily suspending services\");\n        virNetServerUpdateServicesLocked(srv, false);\n    } else if (srv->nclients < srv->nclients_max &&\n               (!srv->nclients_unauth_max ||\n                srv->nclients_unauth < srv->nclients_unauth_max)) {\n        /* Now it makes sense to accept() a new client. */\n        VIR_INFO(\"Re-enabling services\");\n        virNetServerUpdateServicesLocked(srv, true);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerSetClientAuthCompletedLocked",
          "args": [
            "srv",
            "client"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerSetClientAuthCompletedLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "854-862",
          "snippet": "static void\nvirNetServerSetClientAuthCompletedLocked(virNetServerPtr srv,\n                                         virNetServerClientPtr client)\n{\n    if (virNetServerClientIsAuthPendingLocked(client)) {\n        virNetServerClientSetAuthPendingLocked(client, false);\n        virNetServerTrackCompletedAuthLocked(srv);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic void\nvirNetServerSetClientAuthCompletedLocked(virNetServerPtr srv,\n                                         virNetServerClientPtr client)\n{\n    if (virNetServerClientIsAuthPendingLocked(client)) {\n        virNetServerClientSetAuthPendingLocked(client, false);\n        virNetServerTrackCompletedAuthLocked(srv);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "srv->clients",
            "i",
            "srv->nclients"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerClientIsClosedLocked",
          "args": [
            "client"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientIsClosedLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1069-1073",
          "snippet": "bool\nvirNetServerClientIsClosedLocked(virNetServerClientPtr client)\n{\n    return client->sock == NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nbool\nvirNetServerClientIsClosedLocked(virNetServerClientPtr client)\n{\n    return client->sock == NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientCloseLocked",
          "args": [
            "client"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientCloseLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1000-1057",
          "snippet": "void\nvirNetServerClientCloseLocked(virNetServerClientPtr client)\n{\n    virNetServerClientCloseFunc cf;\n    virKeepAlivePtr ka;\n\n    VIR_DEBUG(\"client=%p\", client);\n    if (!client->sock)\n        return;\n\n    if (client->keepalive) {\n        virKeepAliveStop(client->keepalive);\n        ka = client->keepalive;\n        client->keepalive = NULL;\n        virObjectRef(client);\n        virObjectUnlock(client);\n        virObjectUnref(ka);\n        virObjectLock(client);\n        virObjectUnref(client);\n    }\n\n    if (client->privateDataCloseFunc) {\n        cf = client->privateDataCloseFunc;\n        virObjectRef(client);\n        virObjectUnlock(client);\n        (cf)(client);\n        virObjectLock(client);\n        virObjectUnref(client);\n    }\n\n    /* Do now, even though we don't close the socket\n     * until end, to ensure we don't get invoked\n     * again due to tls shutdown */\n    if (client->sock)\n        virNetSocketRemoveIOCallback(client->sock);\n\n    if (client->tls) {\n        virObjectUnref(client->tls);\n        client->tls = NULL;\n    }\n    client->wantClose = true;\n\n    while (client->rx) {\n        virNetMessagePtr msg\n            = virNetMessageQueueServe(&client->rx);\n        virNetMessageFree(msg);\n    }\n    while (client->tx) {\n        virNetMessagePtr msg\n            = virNetMessageQueueServe(&client->tx);\n        virNetMessageFree(msg);\n    }\n\n    if (client->sock) {\n        virObjectUnref(client->sock);\n        client->sock = NULL;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);",
            "static int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\nstatic int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);\n\nvoid\nvirNetServerClientCloseLocked(virNetServerClientPtr client)\n{\n    virNetServerClientCloseFunc cf;\n    virKeepAlivePtr ka;\n\n    VIR_DEBUG(\"client=%p\", client);\n    if (!client->sock)\n        return;\n\n    if (client->keepalive) {\n        virKeepAliveStop(client->keepalive);\n        ka = client->keepalive;\n        client->keepalive = NULL;\n        virObjectRef(client);\n        virObjectUnlock(client);\n        virObjectUnref(ka);\n        virObjectLock(client);\n        virObjectUnref(client);\n    }\n\n    if (client->privateDataCloseFunc) {\n        cf = client->privateDataCloseFunc;\n        virObjectRef(client);\n        virObjectUnlock(client);\n        (cf)(client);\n        virObjectLock(client);\n        virObjectUnref(client);\n    }\n\n    /* Do now, even though we don't close the socket\n     * until end, to ensure we don't get invoked\n     * again due to tls shutdown */\n    if (client->sock)\n        virNetSocketRemoveIOCallback(client->sock);\n\n    if (client->tls) {\n        virObjectUnref(client->tls);\n        client->tls = NULL;\n    }\n    client->wantClose = true;\n\n    while (client->rx) {\n        virNetMessagePtr msg\n            = virNetMessageQueueServe(&client->rx);\n        virNetMessageFree(msg);\n    }\n    while (client->tx) {\n        virNetMessagePtr msg\n            = virNetMessageQueueServe(&client->tx);\n        virNetMessageFree(msg);\n    }\n\n    if (client->sock) {\n        virObjectUnref(client->sock);\n        client->sock = NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientWantCloseLocked",
          "args": [
            "client"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientWantCloseLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1091-1095",
          "snippet": "bool\nvirNetServerClientWantCloseLocked(virNetServerClientPtr client)\n{\n    return client->wantClose;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nbool\nvirNetServerClientWantCloseLocked(virNetServerClientPtr client)\n{\n    return client->wantClose;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sa_assert",
          "args": [
            "srv->clients"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nvoid\nvirNetServerProcessClients(virNetServerPtr srv)\n{\n    size_t i;\n    virNetServerClientPtr client;\n\n    virObjectLock(srv);\n\n reprocess:\n    for (i = 0; i < srv->nclients; i++) {\n        /* Coverity 5.3.0 couldn't see that srv->clients is non-NULL\n         * if srv->nclients is non-zero.  */\n        sa_assert(srv->clients);\n\n        client = srv->clients[i];\n        virObjectLock(client);\n        if (virNetServerClientWantCloseLocked(client))\n            virNetServerClientCloseLocked(client);\n\n        if (virNetServerClientIsClosedLocked(client)) {\n            VIR_DELETE_ELEMENT(srv->clients, i, srv->nclients);\n\n            /* Update server authentication tracking */\n            virNetServerSetClientAuthCompletedLocked(srv, client);\n            virObjectUnlock(client);\n\n            virNetServerCheckLimits(srv);\n\n            virObjectUnlock(srv);\n            virObjectUnref(client);\n            virObjectLock(srv);\n\n            goto reprocess;\n        } else {\n            virObjectUnlock(client);\n        }\n    }\n\n    virObjectUnlock(srv);\n}"
  },
  {
    "function_name": "virNetServerHasClients",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "960-970",
    "snippet": "bool\nvirNetServerHasClients(virNetServerPtr srv)\n{\n    bool ret;\n\n    virObjectLock(srv);\n    ret = !!srv->nclients;\n    virObjectUnlock(srv);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nbool\nvirNetServerHasClients(virNetServerPtr srv)\n{\n    bool ret;\n\n    virObjectLock(srv);\n    ret = !!srv->nclients;\n    virObjectUnlock(srv);\n\n    return ret;\n}"
  },
  {
    "function_name": "virNetServerTrackCompletedAuthLocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "953-957",
    "snippet": "static inline size_t\nvirNetServerTrackCompletedAuthLocked(virNetServerPtr srv)\n{\n    return --srv->nclients_unauth;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic inline size_t\nvirNetServerTrackCompletedAuthLocked(virNetServerPtr srv)\n{\n    return --srv->nclients_unauth;\n}"
  },
  {
    "function_name": "virNetServerTrackPendingAuthLocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "947-951",
    "snippet": "static inline size_t\nvirNetServerTrackPendingAuthLocked(virNetServerPtr srv)\n{\n    return ++srv->nclients_unauth;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic inline size_t\nvirNetServerTrackPendingAuthLocked(virNetServerPtr srv)\n{\n    return ++srv->nclients_unauth;\n}"
  },
  {
    "function_name": "virNetServerClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "929-945",
    "snippet": "void virNetServerClose(virNetServerPtr srv)\n{\n    size_t i;\n\n    if (!srv)\n        return;\n\n    virObjectLock(srv);\n\n    for (i = 0; i < srv->nservices; i++)\n        virNetServerServiceClose(srv->services[i]);\n\n    for (i = 0; i < srv->nclients; i++)\n        virNetServerClientClose(srv->clients[i]);\n\n    virObjectUnlock(srv);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientClose",
          "args": [
            "srv->clients[i]"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1060-1066",
          "snippet": "void\nvirNetServerClientClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    virNetServerClientCloseLocked(client);\n    virObjectUnlock(client);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid\nvirNetServerClientClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    virNetServerClientCloseLocked(client);\n    virObjectUnlock(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceClose",
          "args": [
            "srv->services[i]"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "442-454",
          "snippet": "void virNetServerServiceClose(virNetServerServicePtr svc)\n{\n    size_t i;\n\n    if (!svc)\n        return;\n\n    for (i = 0; i < svc->nsocks; i++) {\n        virNetSocketRemoveIOCallback(svc->socks[i]);\n        virNetSocketClose(svc->socks[i]);\n        virObjectUnref(svc);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvoid virNetServerServiceClose(virNetServerServicePtr svc)\n{\n    size_t i;\n\n    if (!svc)\n        return;\n\n    for (i = 0; i < svc->nsocks; i++) {\n        virNetSocketRemoveIOCallback(svc->socks[i]);\n        virNetSocketClose(svc->socks[i]);\n        virObjectUnref(svc);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nvoid virNetServerClose(virNetServerPtr srv)\n{\n    size_t i;\n\n    if (!srv)\n        return;\n\n    virObjectLock(srv);\n\n    for (i = 0; i < srv->nservices; i++)\n        virNetServerServiceClose(srv->services[i]);\n\n    for (i = 0; i < srv->nclients; i++)\n        virNetServerClientClose(srv->clients[i]);\n\n    virObjectUnlock(srv);\n}"
  },
  {
    "function_name": "virNetServerDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "907-927",
    "snippet": "void virNetServerDispose(void *obj)\n{\n    virNetServerPtr srv = obj;\n    size_t i;\n\n    VIR_FREE(srv->name);\n\n    virThreadPoolFree(srv->workers);\n\n    for (i = 0; i < srv->nservices; i++)\n        virObjectUnref(srv->services[i]);\n    VIR_FREE(srv->services);\n\n    for (i = 0; i < srv->nprograms; i++)\n        virObjectUnref(srv->programs[i]);\n    VIR_FREE(srv->programs);\n\n    for (i = 0; i < srv->nclients; i++)\n        virObjectUnref(srv->clients[i]);\n    VIR_FREE(srv->clients);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetServerDispose(void *obj);",
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "srv->clients"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "srv->clients[i]"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "srv->programs"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "srv->services"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadPoolFree",
          "args": [
            "srv->workers"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "274-309",
          "snippet": "void virThreadPoolFree(virThreadPoolPtr pool)\n{\n    virThreadPoolJobPtr job;\n    bool priority = false;\n\n    if (!pool)\n        return;\n\n    virMutexLock(&pool->mutex);\n    pool->quit = true;\n    if (pool->nWorkers > 0)\n        virCondBroadcast(&pool->cond);\n    if (pool->nPrioWorkers > 0) {\n        priority = true;\n        virCondBroadcast(&pool->prioCond);\n    }\n\n    while (pool->nWorkers > 0 || pool->nPrioWorkers > 0)\n        ignore_value(virCondWait(&pool->quit_cond, &pool->mutex));\n\n    while ((job = pool->jobList.head)) {\n        pool->jobList.head = pool->jobList.head->next;\n        VIR_FREE(job);\n    }\n\n    VIR_FREE(pool->workers);\n    virMutexUnlock(&pool->mutex);\n    virMutexDestroy(&pool->mutex);\n    virCondDestroy(&pool->quit_cond);\n    virCondDestroy(&pool->cond);\n    if (priority) {\n        VIR_FREE(pool->prioWorkers);\n        virCondDestroy(&pool->prioCond);\n    }\n    VIR_FREE(pool);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nvoid virThreadPoolFree(virThreadPoolPtr pool)\n{\n    virThreadPoolJobPtr job;\n    bool priority = false;\n\n    if (!pool)\n        return;\n\n    virMutexLock(&pool->mutex);\n    pool->quit = true;\n    if (pool->nWorkers > 0)\n        virCondBroadcast(&pool->cond);\n    if (pool->nPrioWorkers > 0) {\n        priority = true;\n        virCondBroadcast(&pool->prioCond);\n    }\n\n    while (pool->nWorkers > 0 || pool->nPrioWorkers > 0)\n        ignore_value(virCondWait(&pool->quit_cond, &pool->mutex));\n\n    while ((job = pool->jobList.head)) {\n        pool->jobList.head = pool->jobList.head->next;\n        VIR_FREE(job);\n    }\n\n    VIR_FREE(pool->workers);\n    virMutexUnlock(&pool->mutex);\n    virMutexDestroy(&pool->mutex);\n    virCondDestroy(&pool->quit_cond);\n    virCondDestroy(&pool->cond);\n    if (priority) {\n        VIR_FREE(pool->prioWorkers);\n        virCondDestroy(&pool->prioCond);\n    }\n    VIR_FREE(pool);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "srv->name"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic void virNetServerDispose(void *obj);\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nvoid virNetServerDispose(void *obj)\n{\n    virNetServerPtr srv = obj;\n    size_t i;\n\n    VIR_FREE(srv->name);\n\n    virThreadPoolFree(srv->workers);\n\n    for (i = 0; i < srv->nservices; i++)\n        virObjectUnref(srv->services[i]);\n    VIR_FREE(srv->services);\n\n    for (i = 0; i < srv->nprograms; i++)\n        virObjectUnref(srv->programs[i]);\n    VIR_FREE(srv->programs);\n\n    for (i = 0; i < srv->nclients; i++)\n        virObjectUnref(srv->clients[i]);\n    VIR_FREE(srv->clients);\n}"
  },
  {
    "function_name": "virNetServerUpdateServices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "899-905",
    "snippet": "void virNetServerUpdateServices(virNetServerPtr srv,\n                                bool enabled)\n{\n    virObjectLock(srv);\n    virNetServerUpdateServicesLocked(srv, enabled);\n    virObjectUnlock(srv);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetServerUpdateServicesLocked(virNetServerPtr srv,\n                                             bool enabled);",
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerUpdateServicesLocked",
          "args": [
            "srv",
            "enabled"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerUpdateServicesLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "888-896",
          "snippet": "static void\nvirNetServerUpdateServicesLocked(virNetServerPtr srv,\n                                 bool enabled)\n{\n    size_t i;\n\n    for (i = 0; i < srv->nservices; i++)\n        virNetServerServiceToggle(srv->services[i], enabled);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerUpdateServicesLocked(virNetServerPtr srv,\n                                             bool enabled);",
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic void virNetServerUpdateServicesLocked(virNetServerPtr srv,\n                                             bool enabled);\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic void\nvirNetServerUpdateServicesLocked(virNetServerPtr srv,\n                                 bool enabled)\n{\n    size_t i;\n\n    for (i = 0; i < srv->nservices; i++)\n        virNetServerServiceToggle(srv->services[i], enabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic void virNetServerUpdateServicesLocked(virNetServerPtr srv,\n                                             bool enabled);\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nvoid virNetServerUpdateServices(virNetServerPtr srv,\n                                bool enabled)\n{\n    virObjectLock(srv);\n    virNetServerUpdateServicesLocked(srv, enabled);\n    virObjectUnlock(srv);\n}"
  },
  {
    "function_name": "virNetServerUpdateServicesLocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "888-896",
    "snippet": "static void\nvirNetServerUpdateServicesLocked(virNetServerPtr srv,\n                                 bool enabled)\n{\n    size_t i;\n\n    for (i = 0; i < srv->nservices; i++)\n        virNetServerServiceToggle(srv->services[i], enabled);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetServerUpdateServicesLocked(virNetServerPtr srv,\n                                             bool enabled);",
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerServiceToggle",
          "args": [
            "srv->services[i]",
            "enabled"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceToggle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "430-440",
          "snippet": "void virNetServerServiceToggle(virNetServerServicePtr svc,\n                               bool enabled)\n{\n    size_t i;\n\n    for (i = 0; i < svc->nsocks; i++)\n        virNetSocketUpdateIOCallback(svc->socks[i],\n                                     enabled ?\n                                     VIR_EVENT_HANDLE_READABLE :\n                                     0);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvoid virNetServerServiceToggle(virNetServerServicePtr svc,\n                               bool enabled)\n{\n    size_t i;\n\n    for (i = 0; i < svc->nsocks; i++)\n        virNetSocketUpdateIOCallback(svc->socks[i],\n                                     enabled ?\n                                     VIR_EVENT_HANDLE_READABLE :\n                                     0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic void virNetServerUpdateServicesLocked(virNetServerPtr srv,\n                                             bool enabled);\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic void\nvirNetServerUpdateServicesLocked(virNetServerPtr srv,\n                                 bool enabled)\n{\n    size_t i;\n\n    for (i = 0; i < srv->nservices; i++)\n        virNetServerServiceToggle(srv->services[i], enabled);\n}"
  },
  {
    "function_name": "virNetServerSetClientAuthenticated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "874-885",
    "snippet": "void\nvirNetServerSetClientAuthenticated(virNetServerPtr srv,\n                                   virNetServerClientPtr client)\n{\n    virObjectLock(srv);\n    virObjectLock(client);\n    virNetServerClientSetAuthLocked(client, VIR_NET_SERVER_SERVICE_AUTH_NONE);\n    virNetServerSetClientAuthCompletedLocked(srv, client);\n    virNetServerCheckLimits(srv);\n    virObjectUnlock(client);\n    virObjectUnlock(srv);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerCheckLimits",
          "args": [
            "srv"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerCheckLimits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "255-284",
          "snippet": "static void\nvirNetServerCheckLimits(virNetServerPtr srv)\n{\n    VIR_DEBUG(\"Checking client-related limits to re-enable or temporarily \"\n              \"suspend services: nclients=%zu nclients_max=%zu \"\n              \"nclients_unauth=%zu nclients_unauth_max=%zu\",\n              srv->nclients, srv->nclients_max,\n              srv->nclients_unauth, srv->nclients_unauth_max);\n\n    /* Check the max_anonymous_clients and max_clients limits so that we can\n     * decide whether the services should be temporarily suspended, thus not\n     * accepting any more clients for a while or re-enabling the previously\n     * suspended services in order to accept new clients again.\n     * A new client can only be accepted if both max_clients and\n     * max_anonymous_clients wouldn't get overcommitted by accepting it.\n     */\n    if (srv->nclients >= srv->nclients_max ||\n        (srv->nclients_unauth_max &&\n         srv->nclients_unauth >= srv->nclients_unauth_max)) {\n        /* Temporarily stop accepting new clients */\n        VIR_INFO(\"Temporarily suspending services\");\n        virNetServerUpdateServicesLocked(srv, false);\n    } else if (srv->nclients < srv->nclients_max &&\n               (!srv->nclients_unauth_max ||\n                srv->nclients_unauth < srv->nclients_unauth_max)) {\n        /* Now it makes sense to accept() a new client. */\n        VIR_INFO(\"Re-enabling services\");\n        virNetServerUpdateServicesLocked(srv, true);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic void\nvirNetServerCheckLimits(virNetServerPtr srv)\n{\n    VIR_DEBUG(\"Checking client-related limits to re-enable or temporarily \"\n              \"suspend services: nclients=%zu nclients_max=%zu \"\n              \"nclients_unauth=%zu nclients_unauth_max=%zu\",\n              srv->nclients, srv->nclients_max,\n              srv->nclients_unauth, srv->nclients_unauth_max);\n\n    /* Check the max_anonymous_clients and max_clients limits so that we can\n     * decide whether the services should be temporarily suspended, thus not\n     * accepting any more clients for a while or re-enabling the previously\n     * suspended services in order to accept new clients again.\n     * A new client can only be accepted if both max_clients and\n     * max_anonymous_clients wouldn't get overcommitted by accepting it.\n     */\n    if (srv->nclients >= srv->nclients_max ||\n        (srv->nclients_unauth_max &&\n         srv->nclients_unauth >= srv->nclients_unauth_max)) {\n        /* Temporarily stop accepting new clients */\n        VIR_INFO(\"Temporarily suspending services\");\n        virNetServerUpdateServicesLocked(srv, false);\n    } else if (srv->nclients < srv->nclients_max &&\n               (!srv->nclients_unauth_max ||\n                srv->nclients_unauth < srv->nclients_unauth_max)) {\n        /* Now it makes sense to accept() a new client. */\n        VIR_INFO(\"Re-enabling services\");\n        virNetServerUpdateServicesLocked(srv, true);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerSetClientAuthCompletedLocked",
          "args": [
            "srv",
            "client"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerSetClientAuthCompletedLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "854-862",
          "snippet": "static void\nvirNetServerSetClientAuthCompletedLocked(virNetServerPtr srv,\n                                         virNetServerClientPtr client)\n{\n    if (virNetServerClientIsAuthPendingLocked(client)) {\n        virNetServerClientSetAuthPendingLocked(client, false);\n        virNetServerTrackCompletedAuthLocked(srv);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic void\nvirNetServerSetClientAuthCompletedLocked(virNetServerPtr srv,\n                                         virNetServerClientPtr client)\n{\n    if (virNetServerClientIsAuthPendingLocked(client)) {\n        virNetServerClientSetAuthPendingLocked(client, false);\n        virNetServerTrackCompletedAuthLocked(srv);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientSetAuthLocked",
          "args": [
            "client",
            "VIR_NET_SERVER_SERVICE_AUTH_NONE"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientSetAuthLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "652-657",
          "snippet": "void\nvirNetServerClientSetAuthLocked(virNetServerClientPtr client,\n                                int auth)\n{\n    client->auth = auth;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid\nvirNetServerClientSetAuthLocked(virNetServerClientPtr client,\n                                int auth)\n{\n    client->auth = auth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nvoid\nvirNetServerSetClientAuthenticated(virNetServerPtr srv,\n                                   virNetServerClientPtr client)\n{\n    virObjectLock(srv);\n    virObjectLock(client);\n    virNetServerClientSetAuthLocked(client, VIR_NET_SERVER_SERVICE_AUTH_NONE);\n    virNetServerSetClientAuthCompletedLocked(srv, client);\n    virNetServerCheckLimits(srv);\n    virObjectUnlock(client);\n    virObjectUnlock(srv);\n}"
  },
  {
    "function_name": "virNetServerSetClientAuthCompletedLocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "854-862",
    "snippet": "static void\nvirNetServerSetClientAuthCompletedLocked(virNetServerPtr srv,\n                                         virNetServerClientPtr client)\n{\n    if (virNetServerClientIsAuthPendingLocked(client)) {\n        virNetServerClientSetAuthPendingLocked(client, false);\n        virNetServerTrackCompletedAuthLocked(srv);\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerTrackCompletedAuthLocked",
          "args": [
            "srv"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerTrackCompletedAuthLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "953-957",
          "snippet": "static inline size_t\nvirNetServerTrackCompletedAuthLocked(virNetServerPtr srv)\n{\n    return --srv->nclients_unauth;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic inline size_t\nvirNetServerTrackCompletedAuthLocked(virNetServerPtr srv)\n{\n    return --srv->nclients_unauth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientSetAuthPendingLocked",
          "args": [
            "client",
            "false"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientSetAuthPendingLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1553-1558",
          "snippet": "void\nvirNetServerClientSetAuthPendingLocked(virNetServerClientPtr client,\n                                       bool auth_pending)\n{\n    client->auth_pending = auth_pending;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid\nvirNetServerClientSetAuthPendingLocked(virNetServerClientPtr client,\n                                       bool auth_pending)\n{\n    client->auth_pending = auth_pending;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientIsAuthPendingLocked",
          "args": [
            "client"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientIsAuthPendingLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1562-1566",
          "snippet": "bool\nvirNetServerClientIsAuthPendingLocked(virNetServerClientPtr client)\n{\n    return client->auth_pending;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nbool\nvirNetServerClientIsAuthPendingLocked(virNetServerClientPtr client)\n{\n    return client->auth_pending;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic void\nvirNetServerSetClientAuthCompletedLocked(virNetServerPtr srv,\n                                         virNetServerClientPtr client)\n{\n    if (virNetServerClientIsAuthPendingLocked(client)) {\n        virNetServerClientSetAuthPendingLocked(client, false);\n        virNetServerTrackCompletedAuthLocked(srv);\n    }\n}"
  },
  {
    "function_name": "virNetServerSetTLSContext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "838-843",
    "snippet": "int virNetServerSetTLSContext(virNetServerPtr srv,\n                              virNetTLSContextPtr tls)\n{\n    srv->tls = virObjectRef(tls);\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "tls"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint virNetServerSetTLSContext(virNetServerPtr srv,\n                              virNetTLSContextPtr tls)\n{\n    srv->tls = virObjectRef(tls);\n    return 0;\n}"
  },
  {
    "function_name": "virNetServerAddProgram",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "820-836",
    "snippet": "int virNetServerAddProgram(virNetServerPtr srv,\n                           virNetServerProgramPtr prog)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->programs, srv->nprograms, 1) < 0)\n        goto error;\n\n    srv->programs[srv->nprograms-1] = virObjectRef(prog);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "prog"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "srv->programs",
            "srv->nprograms",
            "1"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint virNetServerAddProgram(virNetServerPtr srv,\n                           virNetServerProgramPtr prog)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->programs, srv->nprograms, 1) < 0)\n        goto error;\n\n    srv->programs[srv->nprograms-1] = virObjectRef(prog);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}"
  },
  {
    "function_name": "virNetServerAddServiceUNIX",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "772-817",
    "snippet": "int virNetServerAddServiceUNIX(virNetServerPtr srv,\n                               virSystemdActivationPtr act,\n                               const char *actname,\n                               const char *path,\n                               mode_t mask,\n                               gid_t grp,\n                               int auth,\n                               virNetTLSContextPtr tls,\n                               bool readonly,\n                               size_t max_queued_clients,\n                               size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc = NULL;\n    int ret;\n\n    ret = virNetServerAddServiceActivation(srv, act, actname,\n                                           auth,\n                                           tls,\n                                           readonly,\n                                           max_queued_clients,\n                                           nrequests_client_max);\n    if (ret < 0)\n        return -1;\n\n    if (ret == 1)\n        return 0;\n\n    if (!(svc = virNetServerServiceNewUNIX(path,\n                                           mask,\n                                           grp,\n                                           auth,\n                                           tls,\n                                           readonly,\n                                           max_queued_clients,\n                                           nrequests_client_max)))\n        return -1;\n\n    if (virNetServerAddService(srv, svc) < 0) {\n        virObjectUnref(svc);\n        return -1;\n    }\n\n    virObjectUnref(svc);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "svc"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerAddService",
          "args": [
            "srv",
            "svc"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerAddService",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "653-673",
          "snippet": "int virNetServerAddService(virNetServerPtr srv,\n                           virNetServerServicePtr svc)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->services, srv->nservices, 1) < 0)\n        goto error;\n\n    srv->services[srv->nservices-1] = virObjectRef(svc);\n\n    virNetServerServiceSetDispatcher(svc,\n                                     virNetServerDispatchNewClient,\n                                     srv);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint virNetServerAddService(virNetServerPtr srv,\n                           virNetServerServicePtr svc)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->services, srv->nservices, 1) < 0)\n        goto error;\n\n    srv->services[srv->nservices-1] = virObjectRef(svc);\n\n    virNetServerServiceSetDispatcher(svc,\n                                     virNetServerDispatchNewClient,\n                                     srv);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceNewUNIX",
          "args": [
            "path",
            "mask",
            "grp",
            "auth",
            "tls",
            "readonly",
            "max_queued_clients",
            "nrequests_client_max"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceNewUNIX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "186-218",
          "snippet": "virNetServerServicePtr virNetServerServiceNewUNIX(const char *path,\n                                                  mode_t mask,\n                                                  gid_t grp,\n                                                  int auth,\n                                                  virNetTLSContextPtr tls,\n                                                  bool readonly,\n                                                  size_t max_queued_clients,\n                                                  size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    virNetSocketPtr sock;\n\n    VIR_DEBUG(\"Creating new UNIX server path='%s' mask=%o gid=%u\",\n              path, mask, grp);\n    if (virNetSocketNewListenUNIX(path,\n                                  mask,\n                                  -1,\n                                  grp,\n                                  &sock) < 0)\n        return NULL;\n\n    svc = virNetServerServiceNewSocket(&sock,\n                                       1,\n                                       auth,\n                                       tls,\n                                       readonly,\n                                       max_queued_clients,\n                                       nrequests_client_max);\n\n    virObjectUnref(sock);\n\n    return svc;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvirNetServerServicePtr virNetServerServiceNewUNIX(const char *path,\n                                                  mode_t mask,\n                                                  gid_t grp,\n                                                  int auth,\n                                                  virNetTLSContextPtr tls,\n                                                  bool readonly,\n                                                  size_t max_queued_clients,\n                                                  size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    virNetSocketPtr sock;\n\n    VIR_DEBUG(\"Creating new UNIX server path='%s' mask=%o gid=%u\",\n              path, mask, grp);\n    if (virNetSocketNewListenUNIX(path,\n                                  mask,\n                                  -1,\n                                  grp,\n                                  &sock) < 0)\n        return NULL;\n\n    svc = virNetServerServiceNewSocket(&sock,\n                                       1,\n                                       auth,\n                                       tls,\n                                       readonly,\n                                       max_queued_clients,\n                                       nrequests_client_max);\n\n    virObjectUnref(sock);\n\n    return svc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerAddServiceActivation",
          "args": [
            "srv",
            "act",
            "actname",
            "auth",
            "tls",
            "readonly",
            "max_queued_clients",
            "nrequests_client_max"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerAddServiceActivation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "676-721",
          "snippet": "static int\nvirNetServerAddServiceActivation(virNetServerPtr srv,\n                                 virSystemdActivationPtr act,\n                                 const char *actname,\n                                 int auth,\n                                 virNetTLSContextPtr tls,\n                                 bool readonly,\n                                 size_t max_queued_clients,\n                                 size_t nrequests_client_max)\n{\n    int *fds;\n    size_t nfds;\n\n    if (act == NULL)\n        return 0;\n\n    virSystemdActivationClaimFDs(act, actname, &fds, &nfds);\n\n    if (nfds) {\n        virNetServerServicePtr svc;\n\n        svc = virNetServerServiceNewFDs(fds,\n                                        nfds,\n                                        false,\n                                        auth,\n                                        tls,\n                                        readonly,\n                                        max_queued_clients,\n                                        nrequests_client_max);\n        if (!svc)\n            return -1;\n\n        if (virNetServerAddService(srv, svc) < 0) {\n            virObjectUnref(svc);\n            return -1;\n        }\n    }\n\n    /* Intentionally return 1 any time activation is present,\n     * even if we didn't find any sockets with the matching\n     * name. The user needs to be free to disable some of the\n     * services via unit files without causing us to fallback\n     * to creating the service manually.\n     */\n    return 1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic int\nvirNetServerAddServiceActivation(virNetServerPtr srv,\n                                 virSystemdActivationPtr act,\n                                 const char *actname,\n                                 int auth,\n                                 virNetTLSContextPtr tls,\n                                 bool readonly,\n                                 size_t max_queued_clients,\n                                 size_t nrequests_client_max)\n{\n    int *fds;\n    size_t nfds;\n\n    if (act == NULL)\n        return 0;\n\n    virSystemdActivationClaimFDs(act, actname, &fds, &nfds);\n\n    if (nfds) {\n        virNetServerServicePtr svc;\n\n        svc = virNetServerServiceNewFDs(fds,\n                                        nfds,\n                                        false,\n                                        auth,\n                                        tls,\n                                        readonly,\n                                        max_queued_clients,\n                                        nrequests_client_max);\n        if (!svc)\n            return -1;\n\n        if (virNetServerAddService(srv, svc) < 0) {\n            virObjectUnref(svc);\n            return -1;\n        }\n    }\n\n    /* Intentionally return 1 any time activation is present,\n     * even if we didn't find any sockets with the matching\n     * name. The user needs to be free to disable some of the\n     * services via unit files without causing us to fallback\n     * to creating the service manually.\n     */\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint virNetServerAddServiceUNIX(virNetServerPtr srv,\n                               virSystemdActivationPtr act,\n                               const char *actname,\n                               const char *path,\n                               mode_t mask,\n                               gid_t grp,\n                               int auth,\n                               virNetTLSContextPtr tls,\n                               bool readonly,\n                               size_t max_queued_clients,\n                               size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc = NULL;\n    int ret;\n\n    ret = virNetServerAddServiceActivation(srv, act, actname,\n                                           auth,\n                                           tls,\n                                           readonly,\n                                           max_queued_clients,\n                                           nrequests_client_max);\n    if (ret < 0)\n        return -1;\n\n    if (ret == 1)\n        return 0;\n\n    if (!(svc = virNetServerServiceNewUNIX(path,\n                                           mask,\n                                           grp,\n                                           auth,\n                                           tls,\n                                           readonly,\n                                           max_queued_clients,\n                                           nrequests_client_max)))\n        return -1;\n\n    if (virNetServerAddService(srv, svc) < 0) {\n        virObjectUnref(svc);\n        return -1;\n    }\n\n    virObjectUnref(svc);\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetServerAddServiceTCP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "724-769",
    "snippet": "int virNetServerAddServiceTCP(virNetServerPtr srv,\n                              virSystemdActivationPtr act,\n                              const char *actname,\n                              const char *nodename,\n                              const char *service,\n                              int family,\n                              int auth,\n                              virNetTLSContextPtr tls,\n                              bool readonly,\n                              size_t max_queued_clients,\n                              size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc = NULL;\n    int ret;\n\n    ret = virNetServerAddServiceActivation(srv, act, actname,\n                                           auth,\n                                           tls,\n                                           readonly,\n                                           max_queued_clients,\n                                           nrequests_client_max);\n    if (ret < 0)\n        return -1;\n\n    if (ret == 1)\n        return 0;\n\n    if (!(svc = virNetServerServiceNewTCP(nodename,\n                                          service,\n                                          family,\n                                          auth,\n                                          tls,\n                                          readonly,\n                                          max_queued_clients,\n                                          nrequests_client_max)))\n        return -1;\n\n    if (virNetServerAddService(srv, svc) < 0) {\n        virObjectUnref(svc);\n        return -1;\n    }\n\n    virObjectUnref(svc);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "svc"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerAddService",
          "args": [
            "srv",
            "svc"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerAddService",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "653-673",
          "snippet": "int virNetServerAddService(virNetServerPtr srv,\n                           virNetServerServicePtr svc)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->services, srv->nservices, 1) < 0)\n        goto error;\n\n    srv->services[srv->nservices-1] = virObjectRef(svc);\n\n    virNetServerServiceSetDispatcher(svc,\n                                     virNetServerDispatchNewClient,\n                                     srv);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint virNetServerAddService(virNetServerPtr srv,\n                           virNetServerServicePtr svc)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->services, srv->nservices, 1) < 0)\n        goto error;\n\n    srv->services[srv->nservices-1] = virObjectRef(svc);\n\n    virNetServerServiceSetDispatcher(svc,\n                                     virNetServerDispatchNewClient,\n                                     srv);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceNewTCP",
          "args": [
            "nodename",
            "service",
            "family",
            "auth",
            "tls",
            "readonly",
            "max_queued_clients",
            "nrequests_client_max"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceNewTCP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "147-183",
          "snippet": "virNetServerServicePtr virNetServerServiceNewTCP(const char *nodename,\n                                                 const char *service,\n                                                 int family,\n                                                 int auth,\n                                                 virNetTLSContextPtr tls,\n                                                 bool readonly,\n                                                 size_t max_queued_clients,\n                                                 size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    size_t i;\n    virNetSocketPtr *socks;\n    size_t nsocks;\n\n    VIR_DEBUG(\"Creating new TCP server nodename='%s' service='%s'\",\n              NULLSTR(nodename), NULLSTR(service));\n    if (virNetSocketNewListenTCP(nodename,\n                                 service,\n                                 family,\n                                 &socks,\n                                 &nsocks) < 0)\n        return NULL;\n\n    svc = virNetServerServiceNewSocket(socks,\n                                       nsocks,\n                                       auth,\n                                       tls,\n                                       readonly,\n                                       max_queued_clients,\n                                       nrequests_client_max);\n\n    for (i = 0; i < nsocks; i++)\n        virObjectUnref(socks[i]);\n    VIR_FREE(socks);\n\n    return svc;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvirNetServerServicePtr virNetServerServiceNewTCP(const char *nodename,\n                                                 const char *service,\n                                                 int family,\n                                                 int auth,\n                                                 virNetTLSContextPtr tls,\n                                                 bool readonly,\n                                                 size_t max_queued_clients,\n                                                 size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc;\n    size_t i;\n    virNetSocketPtr *socks;\n    size_t nsocks;\n\n    VIR_DEBUG(\"Creating new TCP server nodename='%s' service='%s'\",\n              NULLSTR(nodename), NULLSTR(service));\n    if (virNetSocketNewListenTCP(nodename,\n                                 service,\n                                 family,\n                                 &socks,\n                                 &nsocks) < 0)\n        return NULL;\n\n    svc = virNetServerServiceNewSocket(socks,\n                                       nsocks,\n                                       auth,\n                                       tls,\n                                       readonly,\n                                       max_queued_clients,\n                                       nrequests_client_max);\n\n    for (i = 0; i < nsocks; i++)\n        virObjectUnref(socks[i]);\n    VIR_FREE(socks);\n\n    return svc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerAddServiceActivation",
          "args": [
            "srv",
            "act",
            "actname",
            "auth",
            "tls",
            "readonly",
            "max_queued_clients",
            "nrequests_client_max"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerAddServiceActivation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "676-721",
          "snippet": "static int\nvirNetServerAddServiceActivation(virNetServerPtr srv,\n                                 virSystemdActivationPtr act,\n                                 const char *actname,\n                                 int auth,\n                                 virNetTLSContextPtr tls,\n                                 bool readonly,\n                                 size_t max_queued_clients,\n                                 size_t nrequests_client_max)\n{\n    int *fds;\n    size_t nfds;\n\n    if (act == NULL)\n        return 0;\n\n    virSystemdActivationClaimFDs(act, actname, &fds, &nfds);\n\n    if (nfds) {\n        virNetServerServicePtr svc;\n\n        svc = virNetServerServiceNewFDs(fds,\n                                        nfds,\n                                        false,\n                                        auth,\n                                        tls,\n                                        readonly,\n                                        max_queued_clients,\n                                        nrequests_client_max);\n        if (!svc)\n            return -1;\n\n        if (virNetServerAddService(srv, svc) < 0) {\n            virObjectUnref(svc);\n            return -1;\n        }\n    }\n\n    /* Intentionally return 1 any time activation is present,\n     * even if we didn't find any sockets with the matching\n     * name. The user needs to be free to disable some of the\n     * services via unit files without causing us to fallback\n     * to creating the service manually.\n     */\n    return 1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic int\nvirNetServerAddServiceActivation(virNetServerPtr srv,\n                                 virSystemdActivationPtr act,\n                                 const char *actname,\n                                 int auth,\n                                 virNetTLSContextPtr tls,\n                                 bool readonly,\n                                 size_t max_queued_clients,\n                                 size_t nrequests_client_max)\n{\n    int *fds;\n    size_t nfds;\n\n    if (act == NULL)\n        return 0;\n\n    virSystemdActivationClaimFDs(act, actname, &fds, &nfds);\n\n    if (nfds) {\n        virNetServerServicePtr svc;\n\n        svc = virNetServerServiceNewFDs(fds,\n                                        nfds,\n                                        false,\n                                        auth,\n                                        tls,\n                                        readonly,\n                                        max_queued_clients,\n                                        nrequests_client_max);\n        if (!svc)\n            return -1;\n\n        if (virNetServerAddService(srv, svc) < 0) {\n            virObjectUnref(svc);\n            return -1;\n        }\n    }\n\n    /* Intentionally return 1 any time activation is present,\n     * even if we didn't find any sockets with the matching\n     * name. The user needs to be free to disable some of the\n     * services via unit files without causing us to fallback\n     * to creating the service manually.\n     */\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint virNetServerAddServiceTCP(virNetServerPtr srv,\n                              virSystemdActivationPtr act,\n                              const char *actname,\n                              const char *nodename,\n                              const char *service,\n                              int family,\n                              int auth,\n                              virNetTLSContextPtr tls,\n                              bool readonly,\n                              size_t max_queued_clients,\n                              size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc = NULL;\n    int ret;\n\n    ret = virNetServerAddServiceActivation(srv, act, actname,\n                                           auth,\n                                           tls,\n                                           readonly,\n                                           max_queued_clients,\n                                           nrequests_client_max);\n    if (ret < 0)\n        return -1;\n\n    if (ret == 1)\n        return 0;\n\n    if (!(svc = virNetServerServiceNewTCP(nodename,\n                                          service,\n                                          family,\n                                          auth,\n                                          tls,\n                                          readonly,\n                                          max_queued_clients,\n                                          nrequests_client_max)))\n        return -1;\n\n    if (virNetServerAddService(srv, svc) < 0) {\n        virObjectUnref(svc);\n        return -1;\n    }\n\n    virObjectUnref(svc);\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetServerAddServiceActivation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "676-721",
    "snippet": "static int\nvirNetServerAddServiceActivation(virNetServerPtr srv,\n                                 virSystemdActivationPtr act,\n                                 const char *actname,\n                                 int auth,\n                                 virNetTLSContextPtr tls,\n                                 bool readonly,\n                                 size_t max_queued_clients,\n                                 size_t nrequests_client_max)\n{\n    int *fds;\n    size_t nfds;\n\n    if (act == NULL)\n        return 0;\n\n    virSystemdActivationClaimFDs(act, actname, &fds, &nfds);\n\n    if (nfds) {\n        virNetServerServicePtr svc;\n\n        svc = virNetServerServiceNewFDs(fds,\n                                        nfds,\n                                        false,\n                                        auth,\n                                        tls,\n                                        readonly,\n                                        max_queued_clients,\n                                        nrequests_client_max);\n        if (!svc)\n            return -1;\n\n        if (virNetServerAddService(srv, svc) < 0) {\n            virObjectUnref(svc);\n            return -1;\n        }\n    }\n\n    /* Intentionally return 1 any time activation is present,\n     * even if we didn't find any sockets with the matching\n     * name. The user needs to be free to disable some of the\n     * services via unit files without causing us to fallback\n     * to creating the service manually.\n     */\n    return 1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "svc"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerAddService",
          "args": [
            "srv",
            "svc"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerAddService",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "653-673",
          "snippet": "int virNetServerAddService(virNetServerPtr srv,\n                           virNetServerServicePtr svc)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->services, srv->nservices, 1) < 0)\n        goto error;\n\n    srv->services[srv->nservices-1] = virObjectRef(svc);\n\n    virNetServerServiceSetDispatcher(svc,\n                                     virNetServerDispatchNewClient,\n                                     srv);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint virNetServerAddService(virNetServerPtr srv,\n                           virNetServerServicePtr svc)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->services, srv->nservices, 1) < 0)\n        goto error;\n\n    srv->services[srv->nservices-1] = virObjectRef(svc);\n\n    virNetServerServiceSetDispatcher(svc,\n                                     virNetServerDispatchNewClient,\n                                     srv);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceNewFDs",
          "args": [
            "fds",
            "nfds",
            "false",
            "auth",
            "tls",
            "readonly",
            "max_queued_clients",
            "nrequests_client_max"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceNewFDs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "220-256",
          "snippet": "virNetServerServicePtr virNetServerServiceNewFDs(int *fds,\n                                                 size_t nfds,\n                                                 bool unlinkUNIX,\n                                                 int auth,\n                                                 virNetTLSContextPtr tls,\n                                                 bool readonly,\n                                                 size_t max_queued_clients,\n                                                 size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc = NULL;\n    virNetSocketPtr *socks;\n    size_t i;\n\n    if (VIR_ALLOC_N(socks, nfds) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nfds; i++) {\n        if (virNetSocketNewListenFD(fds[i],\n                                    unlinkUNIX,\n                                    &socks[i]) < 0)\n            goto cleanup;\n    }\n\n    svc = virNetServerServiceNewSocket(socks,\n                                       nfds,\n                                       auth,\n                                       tls,\n                                       readonly,\n                                       max_queued_clients,\n                                       nrequests_client_max);\n\n cleanup:\n    for (i = 0; i < nfds && socks; i++)\n        virObjectUnref(socks[i]);\n    VIR_FREE(socks);\n    return svc;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvirNetServerServicePtr virNetServerServiceNewFDs(int *fds,\n                                                 size_t nfds,\n                                                 bool unlinkUNIX,\n                                                 int auth,\n                                                 virNetTLSContextPtr tls,\n                                                 bool readonly,\n                                                 size_t max_queued_clients,\n                                                 size_t nrequests_client_max)\n{\n    virNetServerServicePtr svc = NULL;\n    virNetSocketPtr *socks;\n    size_t i;\n\n    if (VIR_ALLOC_N(socks, nfds) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nfds; i++) {\n        if (virNetSocketNewListenFD(fds[i],\n                                    unlinkUNIX,\n                                    &socks[i]) < 0)\n            goto cleanup;\n    }\n\n    svc = virNetServerServiceNewSocket(socks,\n                                       nfds,\n                                       auth,\n                                       tls,\n                                       readonly,\n                                       max_queued_clients,\n                                       nrequests_client_max);\n\n cleanup:\n    for (i = 0; i < nfds && socks; i++)\n        virObjectUnref(socks[i]);\n    VIR_FREE(socks);\n    return svc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSystemdActivationClaimFDs",
          "args": [
            "act",
            "actname",
            "&fds",
            "&nfds"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "virSystemdActivationClaimFDs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsystemd.c",
          "lines": "1004-1024",
          "snippet": "void\nvirSystemdActivationClaimFDs(virSystemdActivationPtr act,\n                             const char *name,\n                             int **fds,\n                             size_t *nfds)\n{\n    virSystemdActivationEntryPtr ent = virHashSteal(act->fds, name);\n\n    if (!ent) {\n        *fds = NULL;\n        *nfds = 0;\n        VIR_DEBUG(\"No FD with name %s\", name);\n        return;\n    }\n\n    VIR_DEBUG(\"Found %zu FDs with name %s\", ent->nfds, name);\n    *fds = ent->fds;\n    *nfds = ent->nfds;\n\n    VIR_FREE(ent);\n}",
          "includes": [
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virdbus.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virsystemdpriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virdbus.h\"\n#include \"virbuffer.h\"\n#include \"virsystemd.h\"\n#include \"virsystemdpriv.h\"\n#include <config.h>\n\nvoid\nvirSystemdActivationClaimFDs(virSystemdActivationPtr act,\n                             const char *name,\n                             int **fds,\n                             size_t *nfds)\n{\n    virSystemdActivationEntryPtr ent = virHashSteal(act->fds, name);\n\n    if (!ent) {\n        *fds = NULL;\n        *nfds = 0;\n        VIR_DEBUG(\"No FD with name %s\", name);\n        return;\n    }\n\n    VIR_DEBUG(\"Found %zu FDs with name %s\", ent->nfds, name);\n    *fds = ent->fds;\n    *nfds = ent->nfds;\n\n    VIR_FREE(ent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic int\nvirNetServerAddServiceActivation(virNetServerPtr srv,\n                                 virSystemdActivationPtr act,\n                                 const char *actname,\n                                 int auth,\n                                 virNetTLSContextPtr tls,\n                                 bool readonly,\n                                 size_t max_queued_clients,\n                                 size_t nrequests_client_max)\n{\n    int *fds;\n    size_t nfds;\n\n    if (act == NULL)\n        return 0;\n\n    virSystemdActivationClaimFDs(act, actname, &fds, &nfds);\n\n    if (nfds) {\n        virNetServerServicePtr svc;\n\n        svc = virNetServerServiceNewFDs(fds,\n                                        nfds,\n                                        false,\n                                        auth,\n                                        tls,\n                                        readonly,\n                                        max_queued_clients,\n                                        nrequests_client_max);\n        if (!svc)\n            return -1;\n\n        if (virNetServerAddService(srv, svc) < 0) {\n            virObjectUnref(svc);\n            return -1;\n        }\n    }\n\n    /* Intentionally return 1 any time activation is present,\n     * even if we didn't find any sockets with the matching\n     * name. The user needs to be free to disable some of the\n     * services via unit files without causing us to fallback\n     * to creating the service manually.\n     */\n    return 1;\n}"
  },
  {
    "function_name": "virNetServerAddService",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "653-673",
    "snippet": "int virNetServerAddService(virNetServerPtr srv,\n                           virNetServerServicePtr svc)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->services, srv->nservices, 1) < 0)\n        goto error;\n\n    srv->services[srv->nservices-1] = virObjectRef(svc);\n\n    virNetServerServiceSetDispatcher(svc,\n                                     virNetServerDispatchNewClient,\n                                     srv);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceSetDispatcher",
          "args": [
            "svc",
            "virNetServerDispatchNewClient",
            "srv"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceSetDispatcher",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "409-415",
          "snippet": "void virNetServerServiceSetDispatcher(virNetServerServicePtr svc,\n                                      virNetServerServiceDispatchFunc func,\n                                      void *opaque)\n{\n    svc->dispatchFunc = func;\n    svc->dispatchOpaque = opaque;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvoid virNetServerServiceSetDispatcher(virNetServerServicePtr svc,\n                                      virNetServerServiceDispatchFunc func,\n                                      void *opaque)\n{\n    svc->dispatchFunc = func;\n    svc->dispatchOpaque = opaque;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "svc"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "srv->services",
            "srv->nservices",
            "1"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint virNetServerAddService(virNetServerPtr srv,\n                           virNetServerServicePtr svc)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->services, srv->nservices, 1) < 0)\n        goto error;\n\n    srv->services[srv->nservices-1] = virObjectRef(svc);\n\n    virNetServerServiceSetDispatcher(svc,\n                                     virNetServerDispatchNewClient,\n                                     srv);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}"
  },
  {
    "function_name": "virNetServerPreExecRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "549-649",
    "snippet": "virJSONValuePtr virNetServerPreExecRestart(virNetServerPtr srv)\n{\n    virJSONValuePtr object = virJSONValueNewObject();\n    virJSONValuePtr clients;\n    virJSONValuePtr services;\n    size_t i;\n\n    virObjectLock(srv);\n\n    if (virJSONValueObjectAppendNumberUint(object, \"min_workers\",\n                                           virThreadPoolGetMinWorkers(srv->workers)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set min_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"max_workers\",\n                                           virThreadPoolGetMaxWorkers(srv->workers)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set max_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"priority_workers\",\n                                           virThreadPoolGetPriorityWorkers(srv->workers)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set priority_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"max_clients\", srv->nclients_max) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set max_clients data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"max_anonymous_clients\",\n                                           srv->nclients_unauth_max) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set max_anonymous_clients data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"keepaliveInterval\", srv->keepaliveInterval) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set keepaliveInterval data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"keepaliveCount\", srv->keepaliveCount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set keepaliveCount data in JSON document\"));\n        goto error;\n    }\n\n    if (virJSONValueObjectAppendNumberUlong(object, \"next_client_id\",\n                                            srv->next_client_id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set next_client_id data in JSON document\"));\n        goto error;\n    }\n\n    services = virJSONValueNewArray();\n\n    if (virJSONValueObjectAppend(object, \"services\", services) < 0) {\n        virJSONValueFree(services);\n        goto error;\n    }\n\n    for (i = 0; i < srv->nservices; i++) {\n        virJSONValuePtr child;\n        if (!(child = virNetServerServicePreExecRestart(srv->services[i])))\n            goto error;\n\n        if (virJSONValueArrayAppend(services, child) < 0) {\n            virJSONValueFree(child);\n            goto error;\n        }\n    }\n\n    clients = virJSONValueNewArray();\n\n    if (virJSONValueObjectAppend(object, \"clients\", clients) < 0) {\n        virJSONValueFree(clients);\n        goto error;\n    }\n\n    for (i = 0; i < srv->nclients; i++) {\n        virJSONValuePtr child;\n        if (!(child = virNetServerClientPreExecRestart(srv->clients[i])))\n            goto error;\n\n        if (virJSONValueArrayAppend(clients, child) < 0) {\n            virJSONValueFree(child);\n            goto error;\n        }\n    }\n\n    virObjectUnlock(srv);\n\n    return object;\n\n error:\n    virJSONValueFree(object);\n    virObjectUnlock(srv);\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueFree",
          "args": [
            "object"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "391-423",
          "snippet": "void\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvoid\nvirJSONValueFree(virJSONValuePtr value)\n{\n    size_t i;\n    if (!value)\n        return;\n\n    switch ((virJSONType) value->type) {\n    case VIR_JSON_TYPE_OBJECT:\n        for (i = 0; i < value->data.object.npairs; i++) {\n            VIR_FREE(value->data.object.pairs[i].key);\n            virJSONValueFree(value->data.object.pairs[i].value);\n        }\n        VIR_FREE(value->data.object.pairs);\n        break;\n    case VIR_JSON_TYPE_ARRAY:\n        for (i = 0; i < value->data.array.nvalues; i++)\n            virJSONValueFree(value->data.array.values[i]);\n        VIR_FREE(value->data.array.values);\n        break;\n    case VIR_JSON_TYPE_STRING:\n        VIR_FREE(value->data.string);\n        break;\n    case VIR_JSON_TYPE_NUMBER:\n        VIR_FREE(value->data.number);\n        break;\n    case VIR_JSON_TYPE_BOOLEAN:\n    case VIR_JSON_TYPE_NULL:\n        break;\n    }\n\n    VIR_FREE(value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayAppend",
          "args": [
            "clients",
            "child"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayAppendString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "792-804",
          "snippet": "int\nvirJSONValueArrayAppendString(virJSONValuePtr object,\n                              const char *value)\n{\n    virJSONValuePtr jvalue = virJSONValueNewString(value);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueArrayAppend(object, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueArrayAppendString(virJSONValuePtr object,\n                              const char *value)\n{\n    virJSONValuePtr jvalue = virJSONValueNewString(value);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueArrayAppend(object, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientPreExecRestart",
          "args": [
            "srv->clients[i]"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientPreExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "591-639",
          "snippet": "virJSONValuePtr virNetServerClientPreExecRestart(virNetServerClientPtr client)\n{\n    virJSONValuePtr object = virJSONValueNewObject();\n    virJSONValuePtr child;\n\n    virObjectLock(client);\n\n    if (virJSONValueObjectAppendNumberUlong(object, \"id\",\n                                            client->id) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendNumberInt(object, \"auth\", client->auth) < 0)\n        goto error;\n    if (virJSONValueObjectAppendBoolean(object, \"auth_pending\", client->auth_pending) < 0)\n        goto error;\n    if (virJSONValueObjectAppendBoolean(object, \"readonly\", client->readonly) < 0)\n        goto error;\n    if (virJSONValueObjectAppendNumberUint(object, \"nrequests_max\", client->nrequests_max) < 0)\n        goto error;\n\n    if (client->conn_time &&\n        virJSONValueObjectAppendNumberLong(object, \"conn_time\",\n                                           client->conn_time) < 0)\n        goto error;\n\n    if (!(child = virNetSocketPreExecRestart(client->sock)))\n        goto error;\n\n    if (virJSONValueObjectAppend(object, \"sock\", child) < 0) {\n        virJSONValueFree(child);\n        goto error;\n    }\n\n    if (!(child = client->privateDataPreExecRestart(client, client->privateData)))\n        goto error;\n\n    if (virJSONValueObjectAppend(object, \"privateData\", child) < 0) {\n        virJSONValueFree(child);\n        goto error;\n    }\n\n    virObjectUnlock(client);\n    return object;\n\n error:\n    virObjectUnlock(client);\n    virJSONValueFree(object);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvirJSONValuePtr virNetServerClientPreExecRestart(virNetServerClientPtr client)\n{\n    virJSONValuePtr object = virJSONValueNewObject();\n    virJSONValuePtr child;\n\n    virObjectLock(client);\n\n    if (virJSONValueObjectAppendNumberUlong(object, \"id\",\n                                            client->id) < 0)\n        goto error;\n\n    if (virJSONValueObjectAppendNumberInt(object, \"auth\", client->auth) < 0)\n        goto error;\n    if (virJSONValueObjectAppendBoolean(object, \"auth_pending\", client->auth_pending) < 0)\n        goto error;\n    if (virJSONValueObjectAppendBoolean(object, \"readonly\", client->readonly) < 0)\n        goto error;\n    if (virJSONValueObjectAppendNumberUint(object, \"nrequests_max\", client->nrequests_max) < 0)\n        goto error;\n\n    if (client->conn_time &&\n        virJSONValueObjectAppendNumberLong(object, \"conn_time\",\n                                           client->conn_time) < 0)\n        goto error;\n\n    if (!(child = virNetSocketPreExecRestart(client->sock)))\n        goto error;\n\n    if (virJSONValueObjectAppend(object, \"sock\", child) < 0) {\n        virJSONValueFree(child);\n        goto error;\n    }\n\n    if (!(child = client->privateDataPreExecRestart(client, client->privateData)))\n        goto error;\n\n    if (virJSONValueObjectAppend(object, \"privateData\", child) < 0) {\n        virJSONValueFree(child);\n        goto error;\n    }\n\n    virObjectUnlock(client);\n    return object;\n\n error:\n    virObjectUnlock(client);\n    virJSONValueFree(object);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppend",
          "args": [
            "object",
            "\"clients\"",
            "clients"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "741-754",
          "snippet": "int\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendBoolean(virJSONValuePtr object,\n                                const char *key,\n                                int boolean_)\n{\n    virJSONValuePtr jvalue = virJSONValueNewBoolean(boolean_);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueNewArray",
          "args": [],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "560-568",
          "snippet": "virJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServicePreExecRestart",
          "args": [
            "srv->services[i]"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServicePreExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "340-376",
          "snippet": "virJSONValuePtr virNetServerServicePreExecRestart(virNetServerServicePtr svc)\n{\n    virJSONValuePtr object = virJSONValueNewObject();\n    virJSONValuePtr socks;\n    size_t i;\n\n    if (virJSONValueObjectAppendNumberInt(object, \"auth\", svc->auth) < 0)\n        goto error;\n    if (virJSONValueObjectAppendBoolean(object, \"readonly\", svc->readonly) < 0)\n        goto error;\n    if (virJSONValueObjectAppendNumberUint(object, \"nrequests_client_max\", svc->nrequests_client_max) < 0)\n        goto error;\n\n    socks = virJSONValueNewArray();\n\n    if (virJSONValueObjectAppend(object, \"socks\", socks) < 0) {\n        virJSONValueFree(socks);\n        goto error;\n    }\n\n    for (i = 0; i < svc->nsocks; i++) {\n        virJSONValuePtr child;\n        if (!(child = virNetSocketPreExecRestart(svc->socks[i])))\n            goto error;\n\n        if (virJSONValueArrayAppend(socks, child) < 0) {\n            virJSONValueFree(child);\n            goto error;\n        }\n    }\n\n    return object;\n\n error:\n    virJSONValueFree(object);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvirJSONValuePtr virNetServerServicePreExecRestart(virNetServerServicePtr svc)\n{\n    virJSONValuePtr object = virJSONValueNewObject();\n    virJSONValuePtr socks;\n    size_t i;\n\n    if (virJSONValueObjectAppendNumberInt(object, \"auth\", svc->auth) < 0)\n        goto error;\n    if (virJSONValueObjectAppendBoolean(object, \"readonly\", svc->readonly) < 0)\n        goto error;\n    if (virJSONValueObjectAppendNumberUint(object, \"nrequests_client_max\", svc->nrequests_client_max) < 0)\n        goto error;\n\n    socks = virJSONValueNewArray();\n\n    if (virJSONValueObjectAppend(object, \"socks\", socks) < 0) {\n        virJSONValueFree(socks);\n        goto error;\n    }\n\n    for (i = 0; i < svc->nsocks; i++) {\n        virJSONValuePtr child;\n        if (!(child = virNetSocketPreExecRestart(svc->socks[i])))\n            goto error;\n\n        if (virJSONValueArrayAppend(socks, child) < 0) {\n            virJSONValueFree(child);\n            goto error;\n        }\n    }\n\n    return object;\n\n error:\n    virJSONValueFree(object);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot set next_client_id data in JSON document\")"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot set next_client_id data in JSON document\""
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppendNumberUlong",
          "args": [
            "object",
            "\"next_client_id\"",
            "srv->next_client_id"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendNumberUlong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "709-722",
          "snippet": "int\nvirJSONValueObjectAppendNumberUlong(virJSONValuePtr object,\n                                    const char *key,\n                                    unsigned long long number)\n{\n    virJSONValuePtr jvalue = virJSONValueNewNumberUlong(number);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendNumberUlong(virJSONValuePtr object,\n                                    const char *key,\n                                    unsigned long long number)\n{\n    virJSONValuePtr jvalue = virJSONValueNewNumberUlong(number);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot set keepaliveCount data in JSON document\")"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectAppendNumberUint",
          "args": [
            "object",
            "\"keepaliveCount\"",
            "srv->keepaliveCount"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectAppendNumberUint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "677-690",
          "snippet": "int\nvirJSONValueObjectAppendNumberUint(virJSONValuePtr object,\n                                   const char *key,\n                                   unsigned int number)\n{\n    virJSONValuePtr jvalue = virJSONValueNewNumberUint(number);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectAppendNumberUint(virJSONValuePtr object,\n                                   const char *key,\n                                   unsigned int number)\n{\n    virJSONValuePtr jvalue = virJSONValueNewNumberUint(number);\n    if (!jvalue)\n        return -1;\n    if (virJSONValueObjectAppend(object, key, jvalue) < 0) {\n        virJSONValueFree(jvalue);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot set keepaliveInterval data in JSON document\")"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot set max_anonymous_clients data in JSON document\")"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot set max_clients data in JSON document\")"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot set priority_workers data in JSON document\")"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadPoolGetPriorityWorkers",
          "args": [
            "srv->workers"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolGetPriorityWorkers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "334-343",
          "snippet": "size_t virThreadPoolGetPriorityWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->nPrioWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetPriorityWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->nPrioWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot set max_workers data in JSON document\")"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadPoolGetMaxWorkers",
          "args": [
            "srv->workers"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolGetMaxWorkers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "323-332",
          "snippet": "size_t virThreadPoolGetMaxWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->maxWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetMaxWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->maxWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot set min_workers data in JSON document\")"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadPoolGetMinWorkers",
          "args": [
            "srv->workers"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolGetMinWorkers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "312-321",
          "snippet": "size_t virThreadPoolGetMinWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->minWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetMinWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->minWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueNewObject",
          "args": [],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "571-579",
          "snippet": "virJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewObject(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_OBJECT;\n\n    return val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nvirJSONValuePtr virNetServerPreExecRestart(virNetServerPtr srv)\n{\n    virJSONValuePtr object = virJSONValueNewObject();\n    virJSONValuePtr clients;\n    virJSONValuePtr services;\n    size_t i;\n\n    virObjectLock(srv);\n\n    if (virJSONValueObjectAppendNumberUint(object, \"min_workers\",\n                                           virThreadPoolGetMinWorkers(srv->workers)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set min_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"max_workers\",\n                                           virThreadPoolGetMaxWorkers(srv->workers)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set max_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"priority_workers\",\n                                           virThreadPoolGetPriorityWorkers(srv->workers)) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set priority_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"max_clients\", srv->nclients_max) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set max_clients data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"max_anonymous_clients\",\n                                           srv->nclients_unauth_max) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set max_anonymous_clients data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"keepaliveInterval\", srv->keepaliveInterval) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set keepaliveInterval data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectAppendNumberUint(object, \"keepaliveCount\", srv->keepaliveCount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set keepaliveCount data in JSON document\"));\n        goto error;\n    }\n\n    if (virJSONValueObjectAppendNumberUlong(object, \"next_client_id\",\n                                            srv->next_client_id) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot set next_client_id data in JSON document\"));\n        goto error;\n    }\n\n    services = virJSONValueNewArray();\n\n    if (virJSONValueObjectAppend(object, \"services\", services) < 0) {\n        virJSONValueFree(services);\n        goto error;\n    }\n\n    for (i = 0; i < srv->nservices; i++) {\n        virJSONValuePtr child;\n        if (!(child = virNetServerServicePreExecRestart(srv->services[i])))\n            goto error;\n\n        if (virJSONValueArrayAppend(services, child) < 0) {\n            virJSONValueFree(child);\n            goto error;\n        }\n    }\n\n    clients = virJSONValueNewArray();\n\n    if (virJSONValueObjectAppend(object, \"clients\", clients) < 0) {\n        virJSONValueFree(clients);\n        goto error;\n    }\n\n    for (i = 0; i < srv->nclients; i++) {\n        virJSONValuePtr child;\n        if (!(child = virNetServerClientPreExecRestart(srv->clients[i])))\n            goto error;\n\n        if (virJSONValueArrayAppend(clients, child) < 0) {\n            virJSONValueFree(child);\n            goto error;\n        }\n    }\n\n    virObjectUnlock(srv);\n\n    return object;\n\n error:\n    virJSONValueFree(object);\n    virObjectUnlock(srv);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetServerNewPostExecRestart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "397-546",
    "snippet": "virNetServerPtr virNetServerNewPostExecRestart(virJSONValuePtr object,\n                                               const char *name,\n                                               virNetServerClientPrivNew clientPrivNew,\n                                               virNetServerClientPrivNewPostExecRestart clientPrivNewPostExecRestart,\n                                               virNetServerClientPrivPreExecRestart clientPrivPreExecRestart,\n                                               virFreeCallback clientPrivFree,\n                                               void *clientPrivOpaque)\n{\n    virNetServerPtr srv = NULL;\n    virJSONValuePtr clients;\n    virJSONValuePtr services;\n    size_t i;\n    unsigned int min_workers;\n    unsigned int max_workers;\n    unsigned int priority_workers;\n    unsigned int max_clients;\n    unsigned int max_anonymous_clients;\n    unsigned int keepaliveInterval;\n    unsigned int keepaliveCount;\n    unsigned long long next_client_id;\n\n    if (virJSONValueObjectGetNumberUint(object, \"min_workers\", &min_workers) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing min_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"max_workers\", &max_workers) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing max_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"priority_workers\", &priority_workers) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing priority_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"max_clients\", &max_clients) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing max_clients data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectHasKey(object, \"max_anonymous_clients\")) {\n        if (virJSONValueObjectGetNumberUint(object, \"max_anonymous_clients\",\n                                            &max_anonymous_clients) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed max_anonymous_clients data in JSON document\"));\n            goto error;\n        }\n    } else {\n        max_anonymous_clients = max_clients;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"keepaliveInterval\", &keepaliveInterval) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing keepaliveInterval data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"keepaliveCount\", &keepaliveCount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing keepaliveCount data in JSON document\"));\n        goto error;\n    }\n\n    if (virJSONValueObjectGetNumberUlong(object, \"next_client_id\",\n                                         &next_client_id) < 0) {\n        VIR_WARN(\"Missing next_client_id data in JSON document\");\n        next_client_id = 1;\n    }\n\n    if (!(srv = virNetServerNew(name, next_client_id,\n                                min_workers, max_workers,\n                                priority_workers, max_clients,\n                                max_anonymous_clients,\n                                keepaliveInterval, keepaliveCount,\n                                clientPrivNew, clientPrivPreExecRestart,\n                                clientPrivFree, clientPrivOpaque)))\n        goto error;\n\n    if (!(services = virJSONValueObjectGet(object, \"services\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing services data in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(services)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed services array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(services); i++) {\n        virNetServerServicePtr service;\n        virJSONValuePtr child = virJSONValueArrayGet(services, i);\n        if (!child) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing service data in JSON document\"));\n            goto error;\n        }\n\n        if (!(service = virNetServerServiceNewPostExecRestart(child)))\n            goto error;\n\n        if (virNetServerAddService(srv, service) < 0) {\n            virObjectUnref(service);\n            goto error;\n        }\n    }\n\n\n    if (!(clients = virJSONValueObjectGet(object, \"clients\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing clients data in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(clients)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed clients array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(clients); i++) {\n        virNetServerClientPtr client;\n        virJSONValuePtr child = virJSONValueArrayGet(clients, i);\n        if (!child) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing client data in JSON document\"));\n            goto error;\n        }\n\n        if (!(client = virNetServerClientNewPostExecRestart(srv,\n                                                            child,\n                                                            clientPrivNewPostExecRestart,\n                                                            clientPrivPreExecRestart,\n                                                            clientPrivFree,\n                                                            clientPrivOpaque)))\n            goto error;\n\n        if (virNetServerAddClient(srv, client) < 0) {\n            virObjectUnref(client);\n            goto error;\n        }\n        virObjectUnref(client);\n    }\n\n    return srv;\n\n error:\n    virObjectUnref(srv);\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "srv"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerAddClient",
          "args": [
            "srv",
            "client"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerAddClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "286-318",
          "snippet": "int virNetServerAddClient(virNetServerPtr srv,\n                          virNetServerClientPtr client)\n{\n    virObjectLock(srv);\n\n    if (virNetServerClientInit(client) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(srv->clients, srv->nclients, 1) < 0)\n        goto error;\n    srv->clients[srv->nclients-1] = virObjectRef(client);\n\n    virObjectLock(client);\n    if (virNetServerClientIsAuthPendingLocked(client))\n        virNetServerTrackPendingAuthLocked(srv);\n    virObjectUnlock(client);\n\n    virNetServerCheckLimits(srv);\n\n    virNetServerClientSetDispatcher(client,\n                                    virNetServerDispatchNewMessage,\n                                    srv);\n\n    virNetServerClientInitKeepAlive(client, srv->keepaliveInterval,\n                                    srv->keepaliveCount);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint virNetServerAddClient(virNetServerPtr srv,\n                          virNetServerClientPtr client)\n{\n    virObjectLock(srv);\n\n    if (virNetServerClientInit(client) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(srv->clients, srv->nclients, 1) < 0)\n        goto error;\n    srv->clients[srv->nclients-1] = virObjectRef(client);\n\n    virObjectLock(client);\n    if (virNetServerClientIsAuthPendingLocked(client))\n        virNetServerTrackPendingAuthLocked(srv);\n    virObjectUnlock(client);\n\n    virNetServerCheckLimits(srv);\n\n    virNetServerClientSetDispatcher(client,\n                                    virNetServerDispatchNewMessage,\n                                    srv);\n\n    virNetServerClientInitKeepAlive(client, srv->keepaliveInterval,\n                                    srv->keepaliveCount);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientNewPostExecRestart",
          "args": [
            "srv",
            "child",
            "clientPrivNewPostExecRestart",
            "clientPrivPreExecRestart",
            "clientPrivFree",
            "clientPrivOpaque"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientNewPostExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "471-588",
          "snippet": "virNetServerClientPtr virNetServerClientNewPostExecRestart(virNetServerPtr srv,\n                                                           virJSONValuePtr object,\n                                                           virNetServerClientPrivNewPostExecRestart privNew,\n                                                           virNetServerClientPrivPreExecRestart privPreExecRestart,\n                                                           virFreeCallback privFree,\n                                                           void *privOpaque)\n{\n    virJSONValuePtr child;\n    virNetServerClientPtr client = NULL;\n    virNetSocketPtr sock;\n    int auth;\n    bool readonly, auth_pending;\n    unsigned int nrequests_max;\n    unsigned long long id;\n    long long timestamp;\n\n    if (virJSONValueObjectGetNumberInt(object, \"auth\", &auth) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing auth field in JSON state document\"));\n        return NULL;\n    }\n\n    if (!virJSONValueObjectHasKey(object, \"auth_pending\")) {\n        auth_pending = !virNetServerClientAuthMethodImpliesAuthenticated(auth);\n    } else {\n        if (virJSONValueObjectGetBoolean(object, \"auth_pending\", &auth_pending) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed auth_pending field in JSON state document\"));\n            return NULL;\n        }\n\n        /* If the used authentication method implies that the new\n         * client is automatically authenticated, the authentication\n         * cannot be pending */\n        if (auth_pending && virNetServerClientAuthMethodImpliesAuthenticated(auth)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Invalid auth_pending and auth combination in JSON state document\"));\n            return NULL;\n        }\n    }\n\n    if (virJSONValueObjectGetBoolean(object, \"readonly\", &readonly) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing readonly field in JSON state document\"));\n        return NULL;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"nrequests_max\",\n                                        &nrequests_max) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing nrequests_client_max field in JSON state document\"));\n        return NULL;\n    }\n\n    if (!(child = virJSONValueObjectGet(object, \"sock\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing sock field in JSON state document\"));\n        return NULL;\n    }\n\n    if (!virJSONValueObjectHasKey(object, \"id\")) {\n        /* no ID found in, a new one must be generated */\n        id = virNetServerNextClientID(srv);\n    } else {\n        if (virJSONValueObjectGetNumberUlong(object, \"id\", &id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed id field in JSON state document\"));\n            return NULL;\n        }\n    }\n\n    if (!virJSONValueObjectHasKey(object, \"conn_time\")) {\n        timestamp = 0;\n    } else {\n        if (virJSONValueObjectGetNumberLong(object, \"conn_time\", &timestamp) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed conn_time field in JSON \"\n                             \"state document\"));\n            return NULL;\n        }\n    }\n\n    if (!(sock = virNetSocketNewPostExecRestart(child))) {\n        virObjectUnref(sock);\n        return NULL;\n    }\n\n    if (!(client = virNetServerClientNewInternal(id,\n                                                 sock,\n                                                 auth,\n                                                 auth_pending,\n                                                 NULL,\n                                                 readonly,\n                                                 nrequests_max,\n                                                 timestamp))) {\n        virObjectUnref(sock);\n        return NULL;\n    }\n    virObjectUnref(sock);\n\n    if (!(child = virJSONValueObjectGet(object, \"privateData\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing privateData field in JSON state document\"));\n        goto error;\n    }\n\n    if (!(client->privateData = privNew(client, child, privOpaque)))\n        goto error;\n\n    client->privateDataFreeFunc = privFree;\n    client->privateDataPreExecRestart = privPreExecRestart;\n\n\n    return client;\n\n error:\n    virObjectUnref(client);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvirNetServerClientPtr virNetServerClientNewPostExecRestart(virNetServerPtr srv,\n                                                           virJSONValuePtr object,\n                                                           virNetServerClientPrivNewPostExecRestart privNew,\n                                                           virNetServerClientPrivPreExecRestart privPreExecRestart,\n                                                           virFreeCallback privFree,\n                                                           void *privOpaque)\n{\n    virJSONValuePtr child;\n    virNetServerClientPtr client = NULL;\n    virNetSocketPtr sock;\n    int auth;\n    bool readonly, auth_pending;\n    unsigned int nrequests_max;\n    unsigned long long id;\n    long long timestamp;\n\n    if (virJSONValueObjectGetNumberInt(object, \"auth\", &auth) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing auth field in JSON state document\"));\n        return NULL;\n    }\n\n    if (!virJSONValueObjectHasKey(object, \"auth_pending\")) {\n        auth_pending = !virNetServerClientAuthMethodImpliesAuthenticated(auth);\n    } else {\n        if (virJSONValueObjectGetBoolean(object, \"auth_pending\", &auth_pending) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed auth_pending field in JSON state document\"));\n            return NULL;\n        }\n\n        /* If the used authentication method implies that the new\n         * client is automatically authenticated, the authentication\n         * cannot be pending */\n        if (auth_pending && virNetServerClientAuthMethodImpliesAuthenticated(auth)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Invalid auth_pending and auth combination in JSON state document\"));\n            return NULL;\n        }\n    }\n\n    if (virJSONValueObjectGetBoolean(object, \"readonly\", &readonly) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing readonly field in JSON state document\"));\n        return NULL;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"nrequests_max\",\n                                        &nrequests_max) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing nrequests_client_max field in JSON state document\"));\n        return NULL;\n    }\n\n    if (!(child = virJSONValueObjectGet(object, \"sock\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing sock field in JSON state document\"));\n        return NULL;\n    }\n\n    if (!virJSONValueObjectHasKey(object, \"id\")) {\n        /* no ID found in, a new one must be generated */\n        id = virNetServerNextClientID(srv);\n    } else {\n        if (virJSONValueObjectGetNumberUlong(object, \"id\", &id) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed id field in JSON state document\"));\n            return NULL;\n        }\n    }\n\n    if (!virJSONValueObjectHasKey(object, \"conn_time\")) {\n        timestamp = 0;\n    } else {\n        if (virJSONValueObjectGetNumberLong(object, \"conn_time\", &timestamp) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed conn_time field in JSON \"\n                             \"state document\"));\n            return NULL;\n        }\n    }\n\n    if (!(sock = virNetSocketNewPostExecRestart(child))) {\n        virObjectUnref(sock);\n        return NULL;\n    }\n\n    if (!(client = virNetServerClientNewInternal(id,\n                                                 sock,\n                                                 auth,\n                                                 auth_pending,\n                                                 NULL,\n                                                 readonly,\n                                                 nrequests_max,\n                                                 timestamp))) {\n        virObjectUnref(sock);\n        return NULL;\n    }\n    virObjectUnref(sock);\n\n    if (!(child = virJSONValueObjectGet(object, \"privateData\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing privateData field in JSON state document\"));\n        goto error;\n    }\n\n    if (!(client->privateData = privNew(client, child, privOpaque)))\n        goto error;\n\n    client->privateDataFreeFunc = privFree;\n    client->privateDataPreExecRestart = privPreExecRestart;\n\n\n    return client;\n\n error:\n    virObjectUnref(client);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing client data in JSON document\")"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing client data in JSON document\""
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayGet",
          "args": [
            "clients",
            "i"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1024-1035",
          "snippet": "virJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArraySize",
          "args": [
            "clients"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArraySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1017-1021",
          "snippet": "size_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nsize_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Malformed clients array\")"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueIsArray",
          "args": [
            "clients"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueIsArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1010-1014",
          "snippet": "bool\nvirJSONValueIsArray(virJSONValuePtr array)\n{\n    return array->type == VIR_JSON_TYPE_ARRAY;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nbool\nvirJSONValueIsArray(virJSONValuePtr array)\n{\n    return array->type == VIR_JSON_TYPE_ARRAY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing clients data in JSON document\")"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGet",
          "args": [
            "object",
            "\"clients\""
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1422-1426",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetArray(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_ARRAY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerAddService",
          "args": [
            "srv",
            "service"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerAddService",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "653-673",
          "snippet": "int virNetServerAddService(virNetServerPtr srv,\n                           virNetServerServicePtr svc)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->services, srv->nservices, 1) < 0)\n        goto error;\n\n    srv->services[srv->nservices-1] = virObjectRef(svc);\n\n    virNetServerServiceSetDispatcher(svc,\n                                     virNetServerDispatchNewClient,\n                                     srv);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint virNetServerAddService(virNetServerPtr srv,\n                           virNetServerServicePtr svc)\n{\n    virObjectLock(srv);\n\n    if (VIR_EXPAND_N(srv->services, srv->nservices, 1) < 0)\n        goto error;\n\n    srv->services[srv->nservices-1] = virObjectRef(svc);\n\n    virNetServerServiceSetDispatcher(svc,\n                                     virNetServerDispatchNewClient,\n                                     srv);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceNewPostExecRestart",
          "args": [
            "child"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceNewPostExecRestart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "259-337",
          "snippet": "virNetServerServicePtr virNetServerServiceNewPostExecRestart(virJSONValuePtr object)\n{\n    virNetServerServicePtr svc;\n    virJSONValuePtr socks;\n    size_t i;\n    size_t n;\n    unsigned int max;\n\n    if (virNetServerServiceInitialize() < 0)\n        return NULL;\n\n    if (!(svc = virObjectNew(virNetServerServiceClass)))\n        return NULL;\n\n    if (virJSONValueObjectGetNumberInt(object, \"auth\", &svc->auth) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing auth field in JSON state document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetBoolean(object, \"readonly\", &svc->readonly) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing readonly field in JSON state document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"nrequests_client_max\",\n                                        &max) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing nrequests_client_max field in JSON state document\"));\n        goto error;\n    }\n    svc->nrequests_client_max = max;\n\n    if (!(socks = virJSONValueObjectGet(object, \"socks\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing socks field in JSON state document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(socks)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed socks array\"));\n        goto error;\n    }\n\n    n = virJSONValueArraySize(socks);\n    if (VIR_ALLOC_N(svc->socks, n) < 0)\n        goto error;\n    svc->nsocks = n;\n\n    for (i = 0; i < svc->nsocks; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(socks, i);\n        virNetSocketPtr sock;\n\n        if (!(sock = virNetSocketNewPostExecRestart(child))) {\n            virObjectUnref(sock);\n            goto error;\n        }\n\n        svc->socks[i] = sock;\n\n        /* IO callback is initially disabled, until we're ready\n         * to deal with incoming clients */\n        virObjectRef(svc);\n        if (virNetSocketAddIOCallback(sock,\n                                      0,\n                                      virNetServerServiceAccept,\n                                      svc,\n                                      virObjectFreeCallback) < 0) {\n            virObjectUnref(svc);\n            goto error;\n        }\n    }\n\n    return svc;\n\n error:\n    virObjectUnref(svc);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetServerServiceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nstatic virClassPtr virNetServerServiceClass;\n\nvirNetServerServicePtr virNetServerServiceNewPostExecRestart(virJSONValuePtr object)\n{\n    virNetServerServicePtr svc;\n    virJSONValuePtr socks;\n    size_t i;\n    size_t n;\n    unsigned int max;\n\n    if (virNetServerServiceInitialize() < 0)\n        return NULL;\n\n    if (!(svc = virObjectNew(virNetServerServiceClass)))\n        return NULL;\n\n    if (virJSONValueObjectGetNumberInt(object, \"auth\", &svc->auth) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing auth field in JSON state document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetBoolean(object, \"readonly\", &svc->readonly) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing readonly field in JSON state document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"nrequests_client_max\",\n                                        &max) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing nrequests_client_max field in JSON state document\"));\n        goto error;\n    }\n    svc->nrequests_client_max = max;\n\n    if (!(socks = virJSONValueObjectGet(object, \"socks\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing socks field in JSON state document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(socks)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed socks array\"));\n        goto error;\n    }\n\n    n = virJSONValueArraySize(socks);\n    if (VIR_ALLOC_N(svc->socks, n) < 0)\n        goto error;\n    svc->nsocks = n;\n\n    for (i = 0; i < svc->nsocks; i++) {\n        virJSONValuePtr child = virJSONValueArrayGet(socks, i);\n        virNetSocketPtr sock;\n\n        if (!(sock = virNetSocketNewPostExecRestart(child))) {\n            virObjectUnref(sock);\n            goto error;\n        }\n\n        svc->socks[i] = sock;\n\n        /* IO callback is initially disabled, until we're ready\n         * to deal with incoming clients */\n        virObjectRef(svc);\n        if (virNetSocketAddIOCallback(sock,\n                                      0,\n                                      virNetServerServiceAccept,\n                                      svc,\n                                      virObjectFreeCallback) < 0) {\n            virObjectUnref(svc);\n            goto error;\n        }\n    }\n\n    return svc;\n\n error:\n    virObjectUnref(svc);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing service data in JSON document\")"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Malformed services array\")"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing services data in JSON document\")"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerNew",
          "args": [
            "name",
            "next_client_id",
            "min_workers",
            "max_workers",
            "priority_workers",
            "max_clients",
            "max_anonymous_clients",
            "keepaliveInterval",
            "keepaliveCount",
            "clientPrivNew",
            "clientPrivPreExecRestart",
            "clientPrivFree",
            "clientPrivOpaque"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "349-394",
          "snippet": "virNetServerPtr virNetServerNew(const char *name,\n                                unsigned long long next_client_id,\n                                size_t min_workers,\n                                size_t max_workers,\n                                size_t priority_workers,\n                                size_t max_clients,\n                                size_t max_anonymous_clients,\n                                int keepaliveInterval,\n                                unsigned int keepaliveCount,\n                                virNetServerClientPrivNew clientPrivNew,\n                                virNetServerClientPrivPreExecRestart clientPrivPreExecRestart,\n                                virFreeCallback clientPrivFree,\n                                void *clientPrivOpaque)\n{\n    virNetServerPtr srv;\n\n    if (virNetServerInitialize() < 0)\n        return NULL;\n\n    if (!(srv = virObjectLockableNew(virNetServerClass)))\n        return NULL;\n\n    if (!(srv->workers = virThreadPoolNewFull(min_workers, max_workers,\n                                              priority_workers,\n                                              virNetServerHandleJob,\n                                              \"rpc-worker\",\n                                              srv)))\n        goto error;\n\n    srv->name = g_strdup(name);\n\n    srv->next_client_id = next_client_id;\n    srv->nclients_max = max_clients;\n    srv->nclients_unauth_max = max_anonymous_clients;\n    srv->keepaliveInterval = keepaliveInterval;\n    srv->keepaliveCount = keepaliveCount;\n    srv->clientPrivNew = clientPrivNew;\n    srv->clientPrivPreExecRestart = clientPrivPreExecRestart;\n    srv->clientPrivFree = clientPrivFree;\n    srv->clientPrivOpaque = clientPrivOpaque;\n\n    return srv;\n error:\n    virObjectUnref(srv);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetServerClass;",
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic virClassPtr virNetServerClass;\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nvirNetServerPtr virNetServerNew(const char *name,\n                                unsigned long long next_client_id,\n                                size_t min_workers,\n                                size_t max_workers,\n                                size_t priority_workers,\n                                size_t max_clients,\n                                size_t max_anonymous_clients,\n                                int keepaliveInterval,\n                                unsigned int keepaliveCount,\n                                virNetServerClientPrivNew clientPrivNew,\n                                virNetServerClientPrivPreExecRestart clientPrivPreExecRestart,\n                                virFreeCallback clientPrivFree,\n                                void *clientPrivOpaque)\n{\n    virNetServerPtr srv;\n\n    if (virNetServerInitialize() < 0)\n        return NULL;\n\n    if (!(srv = virObjectLockableNew(virNetServerClass)))\n        return NULL;\n\n    if (!(srv->workers = virThreadPoolNewFull(min_workers, max_workers,\n                                              priority_workers,\n                                              virNetServerHandleJob,\n                                              \"rpc-worker\",\n                                              srv)))\n        goto error;\n\n    srv->name = g_strdup(name);\n\n    srv->next_client_id = next_client_id;\n    srv->nclients_max = max_clients;\n    srv->nclients_unauth_max = max_anonymous_clients;\n    srv->keepaliveInterval = keepaliveInterval;\n    srv->keepaliveCount = keepaliveCount;\n    srv->clientPrivNew = clientPrivNew;\n    srv->clientPrivPreExecRestart = clientPrivPreExecRestart;\n    srv->clientPrivFree = clientPrivFree;\n    srv->clientPrivOpaque = clientPrivOpaque;\n\n    return srv;\n error:\n    virObjectUnref(srv);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Missing next_client_id data in JSON document\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetNumberUlong",
          "args": [
            "object",
            "\"next_client_id\"",
            "&next_client_id"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetNumberUlong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1373-1384",
          "snippet": "int\nvirJSONValueObjectGetNumberUlong(virJSONValuePtr object,\n                                 const char *key,\n                                 unsigned long long *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberUlong(val, value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectGetNumberUlong(virJSONValuePtr object,\n                                 const char *key,\n                                 unsigned long long *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberUlong(val, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing keepaliveCount data in JSON document\")"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetNumberUint",
          "args": [
            "object",
            "\"keepaliveCount\"",
            "&keepaliveCount"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetNumberUint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1345-1356",
          "snippet": "int\nvirJSONValueObjectGetNumberUint(virJSONValuePtr object,\n                                const char *key,\n                                unsigned int *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberUint(val, value);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectGetNumberUint(virJSONValuePtr object,\n                                const char *key,\n                                unsigned int *value)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return -1;\n\n    return virJSONValueGetNumberUint(val, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing keepaliveInterval data in JSON document\")"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Malformed max_anonymous_clients data in JSON document\")"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectHasKey",
          "args": [
            "object",
            "\"max_anonymous_clients\""
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectHasKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "838-853",
          "snippet": "int\nvirJSONValueObjectHasKey(virJSONValuePtr object,\n                         const char *key)\n{\n    size_t i;\n\n    if (object->type != VIR_JSON_TYPE_OBJECT)\n        return -1;\n\n    for (i = 0; i < object->data.object.npairs; i++) {\n        if (STREQ(object->data.object.pairs[i].key, key))\n            return 1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectHasKey(virJSONValuePtr object,\n                         const char *key)\n{\n    size_t i;\n\n    if (object->type != VIR_JSON_TYPE_OBJECT)\n        return -1;\n\n    for (i = 0; i < object->data.object.npairs; i++) {\n        if (STREQ(object->data.object.pairs[i].key, key))\n            return 1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing max_clients data in JSON document\")"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing priority_workers data in JSON document\")"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing max_workers data in JSON document\")"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing min_workers data in JSON document\")"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nvirNetServerPtr virNetServerNewPostExecRestart(virJSONValuePtr object,\n                                               const char *name,\n                                               virNetServerClientPrivNew clientPrivNew,\n                                               virNetServerClientPrivNewPostExecRestart clientPrivNewPostExecRestart,\n                                               virNetServerClientPrivPreExecRestart clientPrivPreExecRestart,\n                                               virFreeCallback clientPrivFree,\n                                               void *clientPrivOpaque)\n{\n    virNetServerPtr srv = NULL;\n    virJSONValuePtr clients;\n    virJSONValuePtr services;\n    size_t i;\n    unsigned int min_workers;\n    unsigned int max_workers;\n    unsigned int priority_workers;\n    unsigned int max_clients;\n    unsigned int max_anonymous_clients;\n    unsigned int keepaliveInterval;\n    unsigned int keepaliveCount;\n    unsigned long long next_client_id;\n\n    if (virJSONValueObjectGetNumberUint(object, \"min_workers\", &min_workers) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing min_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"max_workers\", &max_workers) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing max_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"priority_workers\", &priority_workers) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing priority_workers data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"max_clients\", &max_clients) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing max_clients data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectHasKey(object, \"max_anonymous_clients\")) {\n        if (virJSONValueObjectGetNumberUint(object, \"max_anonymous_clients\",\n                                            &max_anonymous_clients) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Malformed max_anonymous_clients data in JSON document\"));\n            goto error;\n        }\n    } else {\n        max_anonymous_clients = max_clients;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"keepaliveInterval\", &keepaliveInterval) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing keepaliveInterval data in JSON document\"));\n        goto error;\n    }\n    if (virJSONValueObjectGetNumberUint(object, \"keepaliveCount\", &keepaliveCount) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing keepaliveCount data in JSON document\"));\n        goto error;\n    }\n\n    if (virJSONValueObjectGetNumberUlong(object, \"next_client_id\",\n                                         &next_client_id) < 0) {\n        VIR_WARN(\"Missing next_client_id data in JSON document\");\n        next_client_id = 1;\n    }\n\n    if (!(srv = virNetServerNew(name, next_client_id,\n                                min_workers, max_workers,\n                                priority_workers, max_clients,\n                                max_anonymous_clients,\n                                keepaliveInterval, keepaliveCount,\n                                clientPrivNew, clientPrivPreExecRestart,\n                                clientPrivFree, clientPrivOpaque)))\n        goto error;\n\n    if (!(services = virJSONValueObjectGet(object, \"services\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing services data in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(services)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed services array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(services); i++) {\n        virNetServerServicePtr service;\n        virJSONValuePtr child = virJSONValueArrayGet(services, i);\n        if (!child) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing service data in JSON document\"));\n            goto error;\n        }\n\n        if (!(service = virNetServerServiceNewPostExecRestart(child)))\n            goto error;\n\n        if (virNetServerAddService(srv, service) < 0) {\n            virObjectUnref(service);\n            goto error;\n        }\n    }\n\n\n    if (!(clients = virJSONValueObjectGet(object, \"clients\"))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing clients data in JSON document\"));\n        goto error;\n    }\n\n    if (!virJSONValueIsArray(clients)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed clients array\"));\n        goto error;\n    }\n\n    for (i = 0; i < virJSONValueArraySize(clients); i++) {\n        virNetServerClientPtr client;\n        virJSONValuePtr child = virJSONValueArrayGet(clients, i);\n        if (!child) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Missing client data in JSON document\"));\n            goto error;\n        }\n\n        if (!(client = virNetServerClientNewPostExecRestart(srv,\n                                                            child,\n                                                            clientPrivNewPostExecRestart,\n                                                            clientPrivPreExecRestart,\n                                                            clientPrivFree,\n                                                            clientPrivOpaque)))\n            goto error;\n\n        if (virNetServerAddClient(srv, client) < 0) {\n            virObjectUnref(client);\n            goto error;\n        }\n        virObjectUnref(client);\n    }\n\n    return srv;\n\n error:\n    virObjectUnref(srv);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetServerNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "349-394",
    "snippet": "virNetServerPtr virNetServerNew(const char *name,\n                                unsigned long long next_client_id,\n                                size_t min_workers,\n                                size_t max_workers,\n                                size_t priority_workers,\n                                size_t max_clients,\n                                size_t max_anonymous_clients,\n                                int keepaliveInterval,\n                                unsigned int keepaliveCount,\n                                virNetServerClientPrivNew clientPrivNew,\n                                virNetServerClientPrivPreExecRestart clientPrivPreExecRestart,\n                                virFreeCallback clientPrivFree,\n                                void *clientPrivOpaque)\n{\n    virNetServerPtr srv;\n\n    if (virNetServerInitialize() < 0)\n        return NULL;\n\n    if (!(srv = virObjectLockableNew(virNetServerClass)))\n        return NULL;\n\n    if (!(srv->workers = virThreadPoolNewFull(min_workers, max_workers,\n                                              priority_workers,\n                                              virNetServerHandleJob,\n                                              \"rpc-worker\",\n                                              srv)))\n        goto error;\n\n    srv->name = g_strdup(name);\n\n    srv->next_client_id = next_client_id;\n    srv->nclients_max = max_clients;\n    srv->nclients_unauth_max = max_anonymous_clients;\n    srv->keepaliveInterval = keepaliveInterval;\n    srv->keepaliveCount = keepaliveCount;\n    srv->clientPrivNew = clientPrivNew;\n    srv->clientPrivPreExecRestart = clientPrivPreExecRestart;\n    srv->clientPrivFree = clientPrivFree;\n    srv->clientPrivOpaque = clientPrivOpaque;\n\n    return srv;\n error:\n    virObjectUnref(srv);\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virNetServerClass;",
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "srv"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "name"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadPoolNewFull",
          "args": [
            "min_workers",
            "max_workers",
            "priority_workers",
            "virNetServerHandleJob",
            "\"rpc-worker\"",
            "srv"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolNewFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "222-272",
          "snippet": "virThreadPoolPtr\nvirThreadPoolNewFull(size_t minWorkers,\n                     size_t maxWorkers,\n                     size_t prioWorkers,\n                     virThreadPoolJobFunc func,\n                     const char *name,\n                     void *opaque)\n{\n    virThreadPoolPtr pool;\n\n    if (minWorkers > maxWorkers)\n        minWorkers = maxWorkers;\n\n    if (VIR_ALLOC(pool) < 0)\n        return NULL;\n\n    pool->jobList.tail = pool->jobList.head = NULL;\n\n    pool->jobFunc = func;\n    pool->jobName = name;\n    pool->jobOpaque = opaque;\n\n    if (virMutexInit(&pool->mutex) < 0)\n        goto error;\n    if (virCondInit(&pool->cond) < 0)\n        goto error;\n    if (virCondInit(&pool->quit_cond) < 0)\n        goto error;\n\n    pool->minWorkers = minWorkers;\n    pool->maxWorkers = maxWorkers;\n    pool->maxPrioWorkers = prioWorkers;\n\n    if (virThreadPoolExpand(pool, minWorkers, false) < 0)\n        goto error;\n\n    if (prioWorkers) {\n        if (virCondInit(&pool->prioCond) < 0)\n            goto error;\n\n        if (virThreadPoolExpand(pool, prioWorkers, true) < 0)\n            goto error;\n    }\n\n    return pool;\n\n error:\n    virThreadPoolFree(pool);\n    return NULL;\n\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nvirThreadPoolPtr\nvirThreadPoolNewFull(size_t minWorkers,\n                     size_t maxWorkers,\n                     size_t prioWorkers,\n                     virThreadPoolJobFunc func,\n                     const char *name,\n                     void *opaque)\n{\n    virThreadPoolPtr pool;\n\n    if (minWorkers > maxWorkers)\n        minWorkers = maxWorkers;\n\n    if (VIR_ALLOC(pool) < 0)\n        return NULL;\n\n    pool->jobList.tail = pool->jobList.head = NULL;\n\n    pool->jobFunc = func;\n    pool->jobName = name;\n    pool->jobOpaque = opaque;\n\n    if (virMutexInit(&pool->mutex) < 0)\n        goto error;\n    if (virCondInit(&pool->cond) < 0)\n        goto error;\n    if (virCondInit(&pool->quit_cond) < 0)\n        goto error;\n\n    pool->minWorkers = minWorkers;\n    pool->maxWorkers = maxWorkers;\n    pool->maxPrioWorkers = prioWorkers;\n\n    if (virThreadPoolExpand(pool, minWorkers, false) < 0)\n        goto error;\n\n    if (prioWorkers) {\n        if (virCondInit(&pool->prioCond) < 0)\n            goto error;\n\n        if (virThreadPoolExpand(pool, prioWorkers, true) < 0)\n            goto error;\n    }\n\n    return pool;\n\n error:\n    virThreadPoolFree(pool);\n    return NULL;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "virNetServerClass"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerInitialize",
          "args": [],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic virClassPtr virNetServerClass;\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nvirNetServerPtr virNetServerNew(const char *name,\n                                unsigned long long next_client_id,\n                                size_t min_workers,\n                                size_t max_workers,\n                                size_t priority_workers,\n                                size_t max_clients,\n                                size_t max_anonymous_clients,\n                                int keepaliveInterval,\n                                unsigned int keepaliveCount,\n                                virNetServerClientPrivNew clientPrivNew,\n                                virNetServerClientPrivPreExecRestart clientPrivPreExecRestart,\n                                virFreeCallback clientPrivFree,\n                                void *clientPrivOpaque)\n{\n    virNetServerPtr srv;\n\n    if (virNetServerInitialize() < 0)\n        return NULL;\n\n    if (!(srv = virObjectLockableNew(virNetServerClass)))\n        return NULL;\n\n    if (!(srv->workers = virThreadPoolNewFull(min_workers, max_workers,\n                                              priority_workers,\n                                              virNetServerHandleJob,\n                                              \"rpc-worker\",\n                                              srv)))\n        goto error;\n\n    srv->name = g_strdup(name);\n\n    srv->next_client_id = next_client_id;\n    srv->nclients_max = max_clients;\n    srv->nclients_unauth_max = max_anonymous_clients;\n    srv->keepaliveInterval = keepaliveInterval;\n    srv->keepaliveCount = keepaliveCount;\n    srv->clientPrivNew = clientPrivNew;\n    srv->clientPrivPreExecRestart = clientPrivPreExecRestart;\n    srv->clientPrivFree = clientPrivFree;\n    srv->clientPrivOpaque = clientPrivOpaque;\n\n    return srv;\n error:\n    virObjectUnref(srv);\n    return NULL;\n}"
  },
  {
    "function_name": "virNetServerDispatchNewClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "320-346",
    "snippet": "static int virNetServerDispatchNewClient(virNetServerServicePtr svc,\n                                         virNetSocketPtr clientsock,\n                                         void *opaque)\n{\n    virNetServerPtr srv = opaque;\n    virNetServerClientPtr client;\n\n    if (!(client = virNetServerClientNew(virNetServerNextClientID(srv),\n                                         clientsock,\n                                         virNetServerServiceGetAuth(svc),\n                                         virNetServerServiceIsReadonly(svc),\n                                         virNetServerServiceGetMaxRequests(svc),\n                                         virNetServerServiceGetTLSContext(svc),\n                                         srv->clientPrivNew,\n                                         srv->clientPrivPreExecRestart,\n                                         srv->clientPrivFree,\n                                         srv->clientPrivOpaque)))\n        return -1;\n\n    if (virNetServerAddClient(srv, client) < 0) {\n        virNetServerClientClose(client);\n        virObjectUnref(client);\n        return -1;\n    }\n    virObjectUnref(client);\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "client"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientClose",
          "args": [
            "client"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1060-1066",
          "snippet": "void\nvirNetServerClientClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    virNetServerClientCloseLocked(client);\n    virObjectUnlock(client);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid\nvirNetServerClientClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    virNetServerClientCloseLocked(client);\n    virObjectUnlock(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerAddClient",
          "args": [
            "srv",
            "client"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerAddClient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "286-318",
          "snippet": "int virNetServerAddClient(virNetServerPtr srv,\n                          virNetServerClientPtr client)\n{\n    virObjectLock(srv);\n\n    if (virNetServerClientInit(client) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(srv->clients, srv->nclients, 1) < 0)\n        goto error;\n    srv->clients[srv->nclients-1] = virObjectRef(client);\n\n    virObjectLock(client);\n    if (virNetServerClientIsAuthPendingLocked(client))\n        virNetServerTrackPendingAuthLocked(srv);\n    virObjectUnlock(client);\n\n    virNetServerCheckLimits(srv);\n\n    virNetServerClientSetDispatcher(client,\n                                    virNetServerDispatchNewMessage,\n                                    srv);\n\n    virNetServerClientInitKeepAlive(client, srv->keepaliveInterval,\n                                    srv->keepaliveCount);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint virNetServerAddClient(virNetServerPtr srv,\n                          virNetServerClientPtr client)\n{\n    virObjectLock(srv);\n\n    if (virNetServerClientInit(client) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(srv->clients, srv->nclients, 1) < 0)\n        goto error;\n    srv->clients[srv->nclients-1] = virObjectRef(client);\n\n    virObjectLock(client);\n    if (virNetServerClientIsAuthPendingLocked(client))\n        virNetServerTrackPendingAuthLocked(srv);\n    virObjectUnlock(client);\n\n    virNetServerCheckLimits(srv);\n\n    virNetServerClientSetDispatcher(client,\n                                    virNetServerDispatchNewMessage,\n                                    srv);\n\n    virNetServerClientInitKeepAlive(client, srv->keepaliveInterval,\n                                    srv->keepaliveCount);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientNew",
          "args": [
            "virNetServerNextClientID(srv)",
            "clientsock",
            "virNetServerServiceGetAuth(svc)",
            "virNetServerServiceIsReadonly(svc)",
            "virNetServerServiceGetMaxRequests(svc)",
            "virNetServerServiceGetTLSContext(svc)",
            "srv->clientPrivNew",
            "srv->clientPrivPreExecRestart",
            "srv->clientPrivFree",
            "srv->clientPrivOpaque"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "433-468",
          "snippet": "virNetServerClientPtr virNetServerClientNew(unsigned long long id,\n                                            virNetSocketPtr sock,\n                                            int auth,\n                                            bool readonly,\n                                            size_t nrequests_max,\n                                            virNetTLSContextPtr tls,\n                                            virNetServerClientPrivNew privNew,\n                                            virNetServerClientPrivPreExecRestart privPreExecRestart,\n                                            virFreeCallback privFree,\n                                            void *privOpaque)\n{\n    virNetServerClientPtr client;\n    time_t now;\n    bool auth_pending = !virNetServerClientAuthMethodImpliesAuthenticated(auth);\n\n    VIR_DEBUG(\"sock=%p auth=%d tls=%p\", sock, auth, tls);\n\n    if ((now = time(NULL)) == (time_t)-1) {\n        virReportSystemError(errno, \"%s\", _(\"failed to get current time\"));\n        return NULL;\n    }\n\n    if (!(client = virNetServerClientNewInternal(id, sock, auth, auth_pending,\n                                                 tls, readonly, nrequests_max,\n                                                 now)))\n        return NULL;\n\n    if (!(client->privateData = privNew(client, privOpaque))) {\n        virObjectUnref(client);\n        return NULL;\n    }\n    client->privateDataFreeFunc = privFree;\n    client->privateDataPreExecRestart = privPreExecRestart;\n\n    return client;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvirNetServerClientPtr virNetServerClientNew(unsigned long long id,\n                                            virNetSocketPtr sock,\n                                            int auth,\n                                            bool readonly,\n                                            size_t nrequests_max,\n                                            virNetTLSContextPtr tls,\n                                            virNetServerClientPrivNew privNew,\n                                            virNetServerClientPrivPreExecRestart privPreExecRestart,\n                                            virFreeCallback privFree,\n                                            void *privOpaque)\n{\n    virNetServerClientPtr client;\n    time_t now;\n    bool auth_pending = !virNetServerClientAuthMethodImpliesAuthenticated(auth);\n\n    VIR_DEBUG(\"sock=%p auth=%d tls=%p\", sock, auth, tls);\n\n    if ((now = time(NULL)) == (time_t)-1) {\n        virReportSystemError(errno, \"%s\", _(\"failed to get current time\"));\n        return NULL;\n    }\n\n    if (!(client = virNetServerClientNewInternal(id, sock, auth, auth_pending,\n                                                 tls, readonly, nrequests_max,\n                                                 now)))\n        return NULL;\n\n    if (!(client->privateData = privNew(client, privOpaque))) {\n        virObjectUnref(client);\n        return NULL;\n    }\n    client->privateDataFreeFunc = privFree;\n    client->privateDataPreExecRestart = privPreExecRestart;\n\n    return client;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceGetTLSContext",
          "args": [
            "svc"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceGetTLSContext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "404-407",
          "snippet": "virNetTLSContextPtr virNetServerServiceGetTLSContext(virNetServerServicePtr svc)\n{\n    return svc->tls;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nvirNetTLSContextPtr virNetServerServiceGetTLSContext(virNetServerServicePtr svc)\n{\n    return svc->tls;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceGetMaxRequests",
          "args": [
            "svc"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceGetMaxRequests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "399-402",
          "snippet": "size_t virNetServerServiceGetMaxRequests(virNetServerServicePtr svc)\n{\n    return svc->nrequests_client_max;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nsize_t virNetServerServiceGetMaxRequests(virNetServerServicePtr svc)\n{\n    return svc->nrequests_client_max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceIsReadonly",
          "args": [
            "svc"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceIsReadonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "393-396",
          "snippet": "bool virNetServerServiceIsReadonly(virNetServerServicePtr svc)\n{\n    return svc->readonly;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nbool virNetServerServiceIsReadonly(virNetServerServicePtr svc)\n{\n    return svc->readonly;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerServiceGetAuth",
          "args": [
            "svc"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerServiceGetAuth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverservice.c",
          "lines": "387-390",
          "snippet": "int virNetServerServiceGetAuth(virNetServerServicePtr svc)\n{\n    return svc->auth;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <unistd.h>",
            "#include \"virnetserverservice.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <unistd.h>\n#include \"virnetserverservice.h\"\n#include <config.h>\n\nint virNetServerServiceGetAuth(virNetServerServicePtr svc)\n{\n    return svc->auth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerNextClientID",
          "args": [
            "srv"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerNextClientID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "97-106",
          "snippet": "unsigned long long virNetServerNextClientID(virNetServerPtr srv)\n{\n    unsigned long long val;\n\n    virObjectLock(srv);\n    val = srv->next_client_id++;\n    virObjectUnlock(srv);\n\n    return val;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nunsigned long long virNetServerNextClientID(virNetServerPtr srv)\n{\n    unsigned long long val;\n\n    virObjectLock(srv);\n    val = srv->next_client_id++;\n    virObjectUnlock(srv);\n\n    return val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic int virNetServerDispatchNewClient(virNetServerServicePtr svc,\n                                         virNetSocketPtr clientsock,\n                                         void *opaque)\n{\n    virNetServerPtr srv = opaque;\n    virNetServerClientPtr client;\n\n    if (!(client = virNetServerClientNew(virNetServerNextClientID(srv),\n                                         clientsock,\n                                         virNetServerServiceGetAuth(svc),\n                                         virNetServerServiceIsReadonly(svc),\n                                         virNetServerServiceGetMaxRequests(svc),\n                                         virNetServerServiceGetTLSContext(svc),\n                                         srv->clientPrivNew,\n                                         srv->clientPrivPreExecRestart,\n                                         srv->clientPrivFree,\n                                         srv->clientPrivOpaque)))\n        return -1;\n\n    if (virNetServerAddClient(srv, client) < 0) {\n        virNetServerClientClose(client);\n        virObjectUnref(client);\n        return -1;\n    }\n    virObjectUnref(client);\n    return 0;\n}"
  },
  {
    "function_name": "virNetServerAddClient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "286-318",
    "snippet": "int virNetServerAddClient(virNetServerPtr srv,\n                          virNetServerClientPtr client)\n{\n    virObjectLock(srv);\n\n    if (virNetServerClientInit(client) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(srv->clients, srv->nclients, 1) < 0)\n        goto error;\n    srv->clients[srv->nclients-1] = virObjectRef(client);\n\n    virObjectLock(client);\n    if (virNetServerClientIsAuthPendingLocked(client))\n        virNetServerTrackPendingAuthLocked(srv);\n    virObjectUnlock(client);\n\n    virNetServerCheckLimits(srv);\n\n    virNetServerClientSetDispatcher(client,\n                                    virNetServerDispatchNewMessage,\n                                    srv);\n\n    virNetServerClientInitKeepAlive(client, srv->keepaliveInterval,\n                                    srv->keepaliveCount);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientInitKeepAlive",
          "args": [
            "client",
            "srv->keepaliveInterval",
            "srv->keepaliveCount"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientInitKeepAlive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1583-1607",
          "snippet": "int\nvirNetServerClientInitKeepAlive(virNetServerClientPtr client,\n                                int interval,\n                                unsigned int count)\n{\n    virKeepAlivePtr ka;\n    int ret = -1;\n\n    virObjectLock(client);\n\n    if (!(ka = virKeepAliveNew(interval, count, client,\n                               virNetServerClientKeepAliveSendCB,\n                               virNetServerClientKeepAliveDeadCB,\n                               virObjectFreeCallback)))\n        goto cleanup;\n    /* keepalive object has a reference to client */\n    virObjectRef(client);\n\n    client->keepalive = ka;\n\n cleanup:\n    virObjectUnlock(client);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nint\nvirNetServerClientInitKeepAlive(virNetServerClientPtr client,\n                                int interval,\n                                unsigned int count)\n{\n    virKeepAlivePtr ka;\n    int ret = -1;\n\n    virObjectLock(client);\n\n    if (!(ka = virKeepAliveNew(interval, count, client,\n                               virNetServerClientKeepAliveSendCB,\n                               virNetServerClientKeepAliveDeadCB,\n                               virObjectFreeCallback)))\n        goto cleanup;\n    /* keepalive object has a reference to client */\n    virObjectRef(client);\n\n    client->keepalive = ka;\n\n cleanup:\n    virObjectUnlock(client);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientSetDispatcher",
          "args": [
            "client",
            "virNetServerDispatchNewMessage",
            "srv"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientSetDispatcher",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "931-944",
          "snippet": "void virNetServerClientSetDispatcher(virNetServerClientPtr client,\n                                     virNetServerClientDispatchFunc func,\n                                     void *opaque)\n{\n    virObjectLock(client);\n    /* Only set dispatcher if not already set, to avoid race\n     * with dispatch code that runs without locks held\n     */\n    if (!client->dispatchFunc) {\n        client->dispatchFunc = func;\n        client->dispatchOpaque = opaque;\n    }\n    virObjectUnlock(client);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientDispatchEvent(virNetSocketPtr sock, int events, void *opaque);",
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientDispatchEvent(virNetSocketPtr sock, int events, void *opaque);\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid virNetServerClientSetDispatcher(virNetServerClientPtr client,\n                                     virNetServerClientDispatchFunc func,\n                                     void *opaque)\n{\n    virObjectLock(client);\n    /* Only set dispatcher if not already set, to avoid race\n     * with dispatch code that runs without locks held\n     */\n    if (!client->dispatchFunc) {\n        client->dispatchFunc = func;\n        client->dispatchOpaque = opaque;\n    }\n    virObjectUnlock(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerCheckLimits",
          "args": [
            "srv"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerCheckLimits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "255-284",
          "snippet": "static void\nvirNetServerCheckLimits(virNetServerPtr srv)\n{\n    VIR_DEBUG(\"Checking client-related limits to re-enable or temporarily \"\n              \"suspend services: nclients=%zu nclients_max=%zu \"\n              \"nclients_unauth=%zu nclients_unauth_max=%zu\",\n              srv->nclients, srv->nclients_max,\n              srv->nclients_unauth, srv->nclients_unauth_max);\n\n    /* Check the max_anonymous_clients and max_clients limits so that we can\n     * decide whether the services should be temporarily suspended, thus not\n     * accepting any more clients for a while or re-enabling the previously\n     * suspended services in order to accept new clients again.\n     * A new client can only be accepted if both max_clients and\n     * max_anonymous_clients wouldn't get overcommitted by accepting it.\n     */\n    if (srv->nclients >= srv->nclients_max ||\n        (srv->nclients_unauth_max &&\n         srv->nclients_unauth >= srv->nclients_unauth_max)) {\n        /* Temporarily stop accepting new clients */\n        VIR_INFO(\"Temporarily suspending services\");\n        virNetServerUpdateServicesLocked(srv, false);\n    } else if (srv->nclients < srv->nclients_max &&\n               (!srv->nclients_unauth_max ||\n                srv->nclients_unauth < srv->nclients_unauth_max)) {\n        /* Now it makes sense to accept() a new client. */\n        VIR_INFO(\"Re-enabling services\");\n        virNetServerUpdateServicesLocked(srv, true);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic void\nvirNetServerCheckLimits(virNetServerPtr srv)\n{\n    VIR_DEBUG(\"Checking client-related limits to re-enable or temporarily \"\n              \"suspend services: nclients=%zu nclients_max=%zu \"\n              \"nclients_unauth=%zu nclients_unauth_max=%zu\",\n              srv->nclients, srv->nclients_max,\n              srv->nclients_unauth, srv->nclients_unauth_max);\n\n    /* Check the max_anonymous_clients and max_clients limits so that we can\n     * decide whether the services should be temporarily suspended, thus not\n     * accepting any more clients for a while or re-enabling the previously\n     * suspended services in order to accept new clients again.\n     * A new client can only be accepted if both max_clients and\n     * max_anonymous_clients wouldn't get overcommitted by accepting it.\n     */\n    if (srv->nclients >= srv->nclients_max ||\n        (srv->nclients_unauth_max &&\n         srv->nclients_unauth >= srv->nclients_unauth_max)) {\n        /* Temporarily stop accepting new clients */\n        VIR_INFO(\"Temporarily suspending services\");\n        virNetServerUpdateServicesLocked(srv, false);\n    } else if (srv->nclients < srv->nclients_max &&\n               (!srv->nclients_unauth_max ||\n                srv->nclients_unauth < srv->nclients_unauth_max)) {\n        /* Now it makes sense to accept() a new client. */\n        VIR_INFO(\"Re-enabling services\");\n        virNetServerUpdateServicesLocked(srv, true);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerTrackPendingAuthLocked",
          "args": [
            "srv"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerTrackPendingAuthLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "947-951",
          "snippet": "static inline size_t\nvirNetServerTrackPendingAuthLocked(virNetServerPtr srv)\n{\n    return ++srv->nclients_unauth;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic inline size_t\nvirNetServerTrackPendingAuthLocked(virNetServerPtr srv)\n{\n    return ++srv->nclients_unauth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientIsAuthPendingLocked",
          "args": [
            "client"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientIsAuthPendingLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1562-1566",
          "snippet": "bool\nvirNetServerClientIsAuthPendingLocked(virNetServerClientPtr client)\n{\n    return client->auth_pending;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nbool\nvirNetServerClientIsAuthPendingLocked(virNetServerClientPtr client)\n{\n    return client->auth_pending;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "client"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "client"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "srv->clients",
            "srv->nclients",
            "1"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerClientInit",
          "args": [
            "client"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1098-1144",
          "snippet": "int virNetServerClientInit(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n\n    if (!client->tlsCtxt) {\n        /* Plain socket, so prepare to read first message */\n        if (virNetServerClientRegisterEvent(client) < 0)\n            goto error;\n    } else {\n        int ret;\n\n        if (!(client->tls = virNetTLSSessionNew(client->tlsCtxt,\n                                                NULL)))\n            goto error;\n\n        virNetSocketSetTLSSession(client->sock,\n                                  client->tls);\n\n        /* Begin the TLS handshake. */\n        virObjectLock(client->tlsCtxt);\n        ret = virNetTLSSessionHandshake(client->tls);\n        virObjectUnlock(client->tlsCtxt);\n        if (ret == 0) {\n            /* Unlikely, but ...  Next step is to check the certificate. */\n            if (virNetServerClientCheckAccess(client) < 0)\n                goto error;\n\n            /* Handshake & cert check OK,  so prepare to read first message */\n            if (virNetServerClientRegisterEvent(client) < 0)\n                goto error;\n        } else if (ret > 0) {\n            /* Most likely, need to do more handshake data */\n            if (virNetServerClientRegisterEvent(client) < 0)\n                goto error;\n        } else {\n            goto error;\n        }\n    }\n\n    virObjectUnlock(client);\n    return 0;\n\n error:\n    client->wantClose = true;\n    virObjectUnlock(client);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nint virNetServerClientInit(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n\n    if (!client->tlsCtxt) {\n        /* Plain socket, so prepare to read first message */\n        if (virNetServerClientRegisterEvent(client) < 0)\n            goto error;\n    } else {\n        int ret;\n\n        if (!(client->tls = virNetTLSSessionNew(client->tlsCtxt,\n                                                NULL)))\n            goto error;\n\n        virNetSocketSetTLSSession(client->sock,\n                                  client->tls);\n\n        /* Begin the TLS handshake. */\n        virObjectLock(client->tlsCtxt);\n        ret = virNetTLSSessionHandshake(client->tls);\n        virObjectUnlock(client->tlsCtxt);\n        if (ret == 0) {\n            /* Unlikely, but ...  Next step is to check the certificate. */\n            if (virNetServerClientCheckAccess(client) < 0)\n                goto error;\n\n            /* Handshake & cert check OK,  so prepare to read first message */\n            if (virNetServerClientRegisterEvent(client) < 0)\n                goto error;\n        } else if (ret > 0) {\n            /* Most likely, need to do more handshake data */\n            if (virNetServerClientRegisterEvent(client) < 0)\n                goto error;\n        } else {\n            goto error;\n        }\n    }\n\n    virObjectUnlock(client);\n    return 0;\n\n error:\n    client->wantClose = true;\n    virObjectUnlock(client);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nint virNetServerAddClient(virNetServerPtr srv,\n                          virNetServerClientPtr client)\n{\n    virObjectLock(srv);\n\n    if (virNetServerClientInit(client) < 0)\n        goto error;\n\n    if (VIR_EXPAND_N(srv->clients, srv->nclients, 1) < 0)\n        goto error;\n    srv->clients[srv->nclients-1] = virObjectRef(client);\n\n    virObjectLock(client);\n    if (virNetServerClientIsAuthPendingLocked(client))\n        virNetServerTrackPendingAuthLocked(srv);\n    virObjectUnlock(client);\n\n    virNetServerCheckLimits(srv);\n\n    virNetServerClientSetDispatcher(client,\n                                    virNetServerDispatchNewMessage,\n                                    srv);\n\n    virNetServerClientInitKeepAlive(client, srv->keepaliveInterval,\n                                    srv->keepaliveCount);\n\n    virObjectUnlock(srv);\n    return 0;\n\n error:\n    virObjectUnlock(srv);\n    return -1;\n}"
  },
  {
    "function_name": "virNetServerCheckLimits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "255-284",
    "snippet": "static void\nvirNetServerCheckLimits(virNetServerPtr srv)\n{\n    VIR_DEBUG(\"Checking client-related limits to re-enable or temporarily \"\n              \"suspend services: nclients=%zu nclients_max=%zu \"\n              \"nclients_unauth=%zu nclients_unauth_max=%zu\",\n              srv->nclients, srv->nclients_max,\n              srv->nclients_unauth, srv->nclients_unauth_max);\n\n    /* Check the max_anonymous_clients and max_clients limits so that we can\n     * decide whether the services should be temporarily suspended, thus not\n     * accepting any more clients for a while or re-enabling the previously\n     * suspended services in order to accept new clients again.\n     * A new client can only be accepted if both max_clients and\n     * max_anonymous_clients wouldn't get overcommitted by accepting it.\n     */\n    if (srv->nclients >= srv->nclients_max ||\n        (srv->nclients_unauth_max &&\n         srv->nclients_unauth >= srv->nclients_unauth_max)) {\n        /* Temporarily stop accepting new clients */\n        VIR_INFO(\"Temporarily suspending services\");\n        virNetServerUpdateServicesLocked(srv, false);\n    } else if (srv->nclients < srv->nclients_max &&\n               (!srv->nclients_unauth_max ||\n                srv->nclients_unauth < srv->nclients_unauth_max)) {\n        /* Now it makes sense to accept() a new client. */\n        VIR_INFO(\"Re-enabling services\");\n        virNetServerUpdateServicesLocked(srv, true);\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerUpdateServicesLocked",
          "args": [
            "srv",
            "true"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerUpdateServicesLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "888-896",
          "snippet": "static void\nvirNetServerUpdateServicesLocked(virNetServerPtr srv,\n                                 bool enabled)\n{\n    size_t i;\n\n    for (i = 0; i < srv->nservices; i++)\n        virNetServerServiceToggle(srv->services[i], enabled);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerUpdateServicesLocked(virNetServerPtr srv,\n                                             bool enabled);",
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic void virNetServerUpdateServicesLocked(virNetServerPtr srv,\n                                             bool enabled);\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic void\nvirNetServerUpdateServicesLocked(virNetServerPtr srv,\n                                 bool enabled)\n{\n    size_t i;\n\n    for (i = 0; i < srv->nservices; i++)\n        virNetServerServiceToggle(srv->services[i], enabled);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Re-enabling services\""
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Temporarily suspending services\""
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Checking client-related limits to re-enable or temporarily \"\n              \"suspend services: nclients=%zu nclients_max=%zu \"\n              \"nclients_unauth=%zu nclients_unauth_max=%zu\"",
            "srv->nclients",
            "srv->nclients_max",
            "srv->nclients_unauth",
            "srv->nclients_unauth_max"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic void\nvirNetServerCheckLimits(virNetServerPtr srv)\n{\n    VIR_DEBUG(\"Checking client-related limits to re-enable or temporarily \"\n              \"suspend services: nclients=%zu nclients_max=%zu \"\n              \"nclients_unauth=%zu nclients_unauth_max=%zu\",\n              srv->nclients, srv->nclients_max,\n              srv->nclients_unauth, srv->nclients_unauth_max);\n\n    /* Check the max_anonymous_clients and max_clients limits so that we can\n     * decide whether the services should be temporarily suspended, thus not\n     * accepting any more clients for a while or re-enabling the previously\n     * suspended services in order to accept new clients again.\n     * A new client can only be accepted if both max_clients and\n     * max_anonymous_clients wouldn't get overcommitted by accepting it.\n     */\n    if (srv->nclients >= srv->nclients_max ||\n        (srv->nclients_unauth_max &&\n         srv->nclients_unauth >= srv->nclients_unauth_max)) {\n        /* Temporarily stop accepting new clients */\n        VIR_INFO(\"Temporarily suspending services\");\n        virNetServerUpdateServicesLocked(srv, false);\n    } else if (srv->nclients < srv->nclients_max &&\n               (!srv->nclients_unauth_max ||\n                srv->nclients_unauth < srv->nclients_unauth_max)) {\n        /* Now it makes sense to accept() a new client. */\n        VIR_INFO(\"Re-enabling services\");\n        virNetServerUpdateServicesLocked(srv, true);\n    }\n}"
  },
  {
    "function_name": "virNetServerDispatchNewMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "191-243",
    "snippet": "static void\nvirNetServerDispatchNewMessage(virNetServerClientPtr client,\n                               virNetMessagePtr msg,\n                               void *opaque)\n{\n    virNetServerPtr srv = opaque;\n    virNetServerProgramPtr prog = NULL;\n    unsigned int priority = 0;\n\n    VIR_DEBUG(\"server=%p client=%p message=%p\",\n              srv, client, msg);\n\n    virObjectLock(srv);\n    prog = virNetServerGetProgramLocked(srv, msg);\n    /* we can unlock @srv since @prog can only become invalid in case\n     * of disposing @srv, but let's grab a ref first to ensure nothing\n     * disposes of it before we use it. */\n    virObjectRef(srv);\n    virObjectUnlock(srv);\n\n    if (virThreadPoolGetMaxWorkers(srv->workers) > 0)  {\n        virNetServerJobPtr job;\n\n        if (VIR_ALLOC(job) < 0)\n            goto error;\n\n        job->client = virObjectRef(client);\n        job->msg = msg;\n\n        if (prog) {\n            job->prog = virObjectRef(prog);\n            priority = virNetServerProgramGetPriority(prog, msg->header.proc);\n        }\n\n        if (virThreadPoolSendJob(srv->workers, priority, job) < 0) {\n            virObjectUnref(client);\n            VIR_FREE(job);\n            virObjectUnref(prog);\n            goto error;\n        }\n    } else {\n        if (virNetServerProcessMsg(srv, client, prog, msg) < 0)\n            goto error;\n    }\n\n    virObjectUnref(srv);\n    return;\n\n error:\n    virNetMessageFree(msg);\n    virNetServerClientClose(client);\n    virObjectUnref(srv);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "srv"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientClose",
          "args": [
            "client"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1060-1066",
          "snippet": "void\nvirNetServerClientClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    virNetServerClientCloseLocked(client);\n    virObjectUnlock(client);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid\nvirNetServerClientClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    virNetServerClientCloseLocked(client);\n    virObjectUnlock(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerProcessMsg",
          "args": [
            "srv",
            "client",
            "prog",
            "msg"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProcessMsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "108-144",
          "snippet": "static int virNetServerProcessMsg(virNetServerPtr srv,\n                                  virNetServerClientPtr client,\n                                  virNetServerProgramPtr prog,\n                                  virNetMessagePtr msg)\n{\n    if (!prog) {\n        /* Only send back an error for type == CALL. Other\n         * message types are not expecting replies, so we\n         * must just log it & drop them\n         */\n        if (msg->header.type == VIR_NET_CALL ||\n            msg->header.type == VIR_NET_CALL_WITH_FDS) {\n            if (virNetServerProgramUnknownError(client,\n                                                msg,\n                                                &msg->header) < 0)\n                return -1;\n        } else {\n            VIR_INFO(\"Dropping client message, unknown program %d version %d type %d proc %d\",\n                     msg->header.prog, msg->header.vers,\n                     msg->header.type, msg->header.proc);\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0)\n                return -1;\n        }\n        return 0;\n    }\n\n    if (virNetServerProgramDispatch(prog,\n                                    srv,\n                                    client,\n                                    msg) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic int virNetServerProcessMsg(virNetServerPtr srv,\n                                  virNetServerClientPtr client,\n                                  virNetServerProgramPtr prog,\n                                  virNetMessagePtr msg)\n{\n    if (!prog) {\n        /* Only send back an error for type == CALL. Other\n         * message types are not expecting replies, so we\n         * must just log it & drop them\n         */\n        if (msg->header.type == VIR_NET_CALL ||\n            msg->header.type == VIR_NET_CALL_WITH_FDS) {\n            if (virNetServerProgramUnknownError(client,\n                                                msg,\n                                                &msg->header) < 0)\n                return -1;\n        } else {\n            VIR_INFO(\"Dropping client message, unknown program %d version %d type %d proc %d\",\n                     msg->header.prog, msg->header.vers,\n                     msg->header.type, msg->header.proc);\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0)\n                return -1;\n        }\n        return 0;\n    }\n\n    if (virNetServerProgramDispatch(prog,\n                                    srv,\n                                    client,\n                                    msg) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "job"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadPoolSendJob",
          "args": [
            "srv->workers",
            "priority",
            "job"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolSendJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "382-426",
          "snippet": "int virThreadPoolSendJob(virThreadPoolPtr pool,\n                         unsigned int priority,\n                         void *jobData)\n{\n    virThreadPoolJobPtr job;\n\n    virMutexLock(&pool->mutex);\n    if (pool->quit)\n        goto error;\n\n    if (pool->freeWorkers - pool->jobQueueDepth <= 0 &&\n        pool->nWorkers < pool->maxWorkers &&\n        virThreadPoolExpand(pool, 1, false) < 0)\n        goto error;\n\n    if (VIR_ALLOC(job) < 0)\n        goto error;\n\n    job->data = jobData;\n    job->priority = priority;\n\n    job->prev = pool->jobList.tail;\n    if (pool->jobList.tail)\n        pool->jobList.tail->next = job;\n    pool->jobList.tail = job;\n\n    if (!pool->jobList.head)\n        pool->jobList.head = job;\n\n    if (priority && !pool->jobList.firstPrio)\n        pool->jobList.firstPrio = job;\n\n    pool->jobQueueDepth++;\n\n    virCondSignal(&pool->cond);\n    if (priority)\n        virCondSignal(&pool->prioCond);\n\n    virMutexUnlock(&pool->mutex);\n    return 0;\n\n error:\n    virMutexUnlock(&pool->mutex);\n    return -1;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nint virThreadPoolSendJob(virThreadPoolPtr pool,\n                         unsigned int priority,\n                         void *jobData)\n{\n    virThreadPoolJobPtr job;\n\n    virMutexLock(&pool->mutex);\n    if (pool->quit)\n        goto error;\n\n    if (pool->freeWorkers - pool->jobQueueDepth <= 0 &&\n        pool->nWorkers < pool->maxWorkers &&\n        virThreadPoolExpand(pool, 1, false) < 0)\n        goto error;\n\n    if (VIR_ALLOC(job) < 0)\n        goto error;\n\n    job->data = jobData;\n    job->priority = priority;\n\n    job->prev = pool->jobList.tail;\n    if (pool->jobList.tail)\n        pool->jobList.tail->next = job;\n    pool->jobList.tail = job;\n\n    if (!pool->jobList.head)\n        pool->jobList.head = job;\n\n    if (priority && !pool->jobList.firstPrio)\n        pool->jobList.firstPrio = job;\n\n    pool->jobQueueDepth++;\n\n    virCondSignal(&pool->cond);\n    if (priority)\n        virCondSignal(&pool->prioCond);\n\n    virMutexUnlock(&pool->mutex);\n    return 0;\n\n error:\n    virMutexUnlock(&pool->mutex);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerProgramGetPriority",
          "args": [
            "prog",
            "msg->header.proc"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramGetPriority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "125-135",
          "snippet": "unsigned int\nvirNetServerProgramGetPriority(virNetServerProgramPtr prog,\n                               int procedure)\n{\n    virNetServerProgramProcPtr proc = virNetServerProgramGetProc(prog, procedure);\n\n    if (!proc)\n        return 0;\n\n    return proc->priority;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nunsigned int\nvirNetServerProgramGetPriority(virNetServerProgramPtr prog,\n                               int procedure)\n{\n    virNetServerProgramProcPtr proc = virNetServerProgramGetProc(prog, procedure);\n\n    if (!proc)\n        return 0;\n\n    return proc->priority;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "prog"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "job"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadPoolGetMaxWorkers",
          "args": [
            "srv->workers"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadPoolGetMaxWorkers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthreadpool.c",
          "lines": "323-332",
          "snippet": "size_t virThreadPoolGetMaxWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->maxWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthreadpool.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virthreadpool.h\"\n#include <config.h>\n\nsize_t virThreadPoolGetMaxWorkers(virThreadPoolPtr pool)\n{\n    size_t ret;\n\n    virMutexLock(&pool->mutex);\n    ret = pool->maxWorkers;\n    virMutexUnlock(&pool->mutex);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerGetProgramLocked",
          "args": [
            "srv",
            "msg"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerGetProgramLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "179-189",
          "snippet": "static virNetServerProgramPtr\nvirNetServerGetProgramLocked(virNetServerPtr srv,\n                             virNetMessagePtr msg)\n{\n    size_t i;\n    for (i = 0; i < srv->nprograms; i++) {\n        if (virNetServerProgramMatches(srv->programs[i], msg))\n            return srv->programs[i];\n    }\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic virNetServerProgramPtr\nvirNetServerGetProgramLocked(virNetServerPtr srv,\n                             virNetMessagePtr msg)\n{\n    size_t i;\n    for (i = 0; i < srv->nprograms; i++) {\n        if (virNetServerProgramMatches(srv->programs[i], msg))\n            return srv->programs[i];\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"server=%p client=%p message=%p\"",
            "srv",
            "client",
            "msg"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic void\nvirNetServerDispatchNewMessage(virNetServerClientPtr client,\n                               virNetMessagePtr msg,\n                               void *opaque)\n{\n    virNetServerPtr srv = opaque;\n    virNetServerProgramPtr prog = NULL;\n    unsigned int priority = 0;\n\n    VIR_DEBUG(\"server=%p client=%p message=%p\",\n              srv, client, msg);\n\n    virObjectLock(srv);\n    prog = virNetServerGetProgramLocked(srv, msg);\n    /* we can unlock @srv since @prog can only become invalid in case\n     * of disposing @srv, but let's grab a ref first to ensure nothing\n     * disposes of it before we use it. */\n    virObjectRef(srv);\n    virObjectUnlock(srv);\n\n    if (virThreadPoolGetMaxWorkers(srv->workers) > 0)  {\n        virNetServerJobPtr job;\n\n        if (VIR_ALLOC(job) < 0)\n            goto error;\n\n        job->client = virObjectRef(client);\n        job->msg = msg;\n\n        if (prog) {\n            job->prog = virObjectRef(prog);\n            priority = virNetServerProgramGetPriority(prog, msg->header.proc);\n        }\n\n        if (virThreadPoolSendJob(srv->workers, priority, job) < 0) {\n            virObjectUnref(client);\n            VIR_FREE(job);\n            virObjectUnref(prog);\n            goto error;\n        }\n    } else {\n        if (virNetServerProcessMsg(srv, client, prog, msg) < 0)\n            goto error;\n    }\n\n    virObjectUnref(srv);\n    return;\n\n error:\n    virNetMessageFree(msg);\n    virNetServerClientClose(client);\n    virObjectUnref(srv);\n}"
  },
  {
    "function_name": "virNetServerGetProgramLocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "179-189",
    "snippet": "static virNetServerProgramPtr\nvirNetServerGetProgramLocked(virNetServerPtr srv,\n                             virNetMessagePtr msg)\n{\n    size_t i;\n    for (i = 0; i < srv->nprograms; i++) {\n        if (virNetServerProgramMatches(srv->programs[i], msg))\n            return srv->programs[i];\n    }\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerProgramMatches",
          "args": [
            "srv->programs[i]",
            "msg"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramMatches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "97-104",
          "snippet": "int virNetServerProgramMatches(virNetServerProgramPtr prog,\n                               virNetMessagePtr msg)\n{\n    if (prog->program == msg->header.prog &&\n        prog->version == msg->header.vers)\n        return 1;\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramMatches(virNetServerProgramPtr prog,\n                               virNetMessagePtr msg)\n{\n    if (prog->program == msg->header.prog &&\n        prog->version == msg->header.vers)\n        return 1;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic virNetServerProgramPtr\nvirNetServerGetProgramLocked(virNetServerPtr srv,\n                             virNetMessagePtr msg)\n{\n    size_t i;\n    for (i = 0; i < srv->nprograms; i++) {\n        if (virNetServerProgramMatches(srv->programs[i], msg))\n            return srv->programs[i];\n    }\n    return NULL;\n}"
  },
  {
    "function_name": "virNetServerHandleJob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "146-168",
    "snippet": "static void virNetServerHandleJob(void *jobOpaque, void *opaque)\n{\n    virNetServerPtr srv = opaque;\n    virNetServerJobPtr job = jobOpaque;\n\n    VIR_DEBUG(\"server=%p client=%p message=%p prog=%p\",\n              srv, job->client, job->msg, job->prog);\n\n    if (virNetServerProcessMsg(srv, job->client, job->prog, job->msg) < 0)\n        goto error;\n\n    virObjectUnref(job->prog);\n    virObjectUnref(job->client);\n    VIR_FREE(job);\n    return;\n\n error:\n    virObjectUnref(job->prog);\n    virNetMessageFree(job->msg);\n    virNetServerClientClose(job->client);\n    virObjectUnref(job->client);\n    VIR_FREE(job);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "job"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "job->client"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientClose",
          "args": [
            "job->client"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1060-1066",
          "snippet": "void\nvirNetServerClientClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    virNetServerClientCloseLocked(client);\n    virObjectUnlock(client);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\n\nvoid\nvirNetServerClientClose(virNetServerClientPtr client)\n{\n    virObjectLock(client);\n    virNetServerClientCloseLocked(client);\n    virObjectUnlock(client);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "job->msg"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "job"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerProcessMsg",
          "args": [
            "srv",
            "job->client",
            "job->prog",
            "job->msg"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProcessMsg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
          "lines": "108-144",
          "snippet": "static int virNetServerProcessMsg(virNetServerPtr srv,\n                                  virNetServerClientPtr client,\n                                  virNetServerProgramPtr prog,\n                                  virNetMessagePtr msg)\n{\n    if (!prog) {\n        /* Only send back an error for type == CALL. Other\n         * message types are not expecting replies, so we\n         * must just log it & drop them\n         */\n        if (msg->header.type == VIR_NET_CALL ||\n            msg->header.type == VIR_NET_CALL_WITH_FDS) {\n            if (virNetServerProgramUnknownError(client,\n                                                msg,\n                                                &msg->header) < 0)\n                return -1;\n        } else {\n            VIR_INFO(\"Dropping client message, unknown program %d version %d type %d proc %d\",\n                     msg->header.prog, msg->header.vers,\n                     msg->header.type, msg->header.proc);\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0)\n                return -1;\n        }\n        return 0;\n    }\n\n    if (virNetServerProgramDispatch(prog,\n                                    srv,\n                                    client,\n                                    msg) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserver.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
            "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic int virNetServerProcessMsg(virNetServerPtr srv,\n                                  virNetServerClientPtr client,\n                                  virNetServerProgramPtr prog,\n                                  virNetMessagePtr msg)\n{\n    if (!prog) {\n        /* Only send back an error for type == CALL. Other\n         * message types are not expecting replies, so we\n         * must just log it & drop them\n         */\n        if (msg->header.type == VIR_NET_CALL ||\n            msg->header.type == VIR_NET_CALL_WITH_FDS) {\n            if (virNetServerProgramUnknownError(client,\n                                                msg,\n                                                &msg->header) < 0)\n                return -1;\n        } else {\n            VIR_INFO(\"Dropping client message, unknown program %d version %d type %d proc %d\",\n                     msg->header.prog, msg->header.vers,\n                     msg->header.type, msg->header.proc);\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0)\n                return -1;\n        }\n        return 0;\n    }\n\n    if (virNetServerProgramDispatch(prog,\n                                    srv,\n                                    client,\n                                    msg) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"server=%p client=%p message=%p prog=%p\"",
            "srv",
            "job->client",
            "job->msg",
            "job->prog"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic void virNetServerHandleJob(void *jobOpaque, void *opaque)\n{\n    virNetServerPtr srv = opaque;\n    virNetServerJobPtr job = jobOpaque;\n\n    VIR_DEBUG(\"server=%p client=%p message=%p prog=%p\",\n              srv, job->client, job->msg, job->prog);\n\n    if (virNetServerProcessMsg(srv, job->client, job->prog, job->msg) < 0)\n        goto error;\n\n    virObjectUnref(job->prog);\n    virObjectUnref(job->client);\n    VIR_FREE(job);\n    return;\n\n error:\n    virObjectUnref(job->prog);\n    virNetMessageFree(job->msg);\n    virNetServerClientClose(job->client);\n    virObjectUnref(job->client);\n    VIR_FREE(job);\n}"
  },
  {
    "function_name": "virNetServerProcessMsg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "108-144",
    "snippet": "static int virNetServerProcessMsg(virNetServerPtr srv,\n                                  virNetServerClientPtr client,\n                                  virNetServerProgramPtr prog,\n                                  virNetMessagePtr msg)\n{\n    if (!prog) {\n        /* Only send back an error for type == CALL. Other\n         * message types are not expecting replies, so we\n         * must just log it & drop them\n         */\n        if (msg->header.type == VIR_NET_CALL ||\n            msg->header.type == VIR_NET_CALL_WITH_FDS) {\n            if (virNetServerProgramUnknownError(client,\n                                                msg,\n                                                &msg->header) < 0)\n                return -1;\n        } else {\n            VIR_INFO(\"Dropping client message, unknown program %d version %d type %d proc %d\",\n                     msg->header.prog, msg->header.vers,\n                     msg->header.type, msg->header.proc);\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0)\n                return -1;\n        }\n        return 0;\n    }\n\n    if (virNetServerProgramDispatch(prog,\n                                    srv,\n                                    client,\n                                    msg) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetServerProgramDispatch",
          "args": [
            "prog",
            "srv",
            "client",
            "msg"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramDispatchCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "362-492",
          "snippet": "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg)\n{\n    g_autofree char *arg = NULL;\n    g_autofree char *ret = NULL;\n    int rv = -1;\n    virNetServerProgramProcPtr dispatcher;\n    virNetMessageError rerr;\n    size_t i;\n    g_autoptr(virIdentity) identity = NULL;\n\n    memset(&rerr, 0, sizeof(rerr));\n\n    if (msg->header.status != VIR_NET_OK) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %u\"),\n                       msg->header.status);\n        goto error;\n    }\n\n    dispatcher = virNetServerProgramGetProc(prog, msg->header.proc);\n\n    if (!dispatcher) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"unknown procedure: %d\"),\n                       msg->header.proc);\n        goto error;\n    }\n\n    /* If the client is not authenticated, don't allow any RPC ops\n     * which are except for authentication ones */\n    if (dispatcher->needAuth &&\n        !virNetServerClientIsAuthenticated(client)) {\n        /* Explicitly *NOT* calling  remoteDispatchAuthError() because\n           we want back-compatibility with libvirt clients which don't\n           support the VIR_ERR_AUTH_FAILED error code */\n        virReportError(VIR_ERR_RPC,\n                       \"%s\", _(\"authentication required\"));\n        goto error;\n    }\n\n    if (VIR_ALLOC_N(arg, dispatcher->arg_len) < 0)\n        goto error;\n    if (VIR_ALLOC_N(ret, dispatcher->ret_len) < 0)\n        goto error;\n\n    if (virNetMessageDecodePayload(msg, dispatcher->arg_filter, arg) < 0)\n        goto error;\n\n    if (!(identity = virNetServerClientGetIdentity(client)))\n        goto error;\n\n    if (virIdentitySetCurrent(identity) < 0)\n        goto error;\n\n    /*\n     * When the RPC handler is called:\n     *\n     *  - Server object is unlocked\n     *  - Client object is unlocked\n     *\n     * Without locking, it is safe to use:\n     *\n     *   'args and 'ret'\n     */\n    rv = (dispatcher->func)(server, client, msg, &rerr, arg, ret);\n\n    if (virIdentitySetCurrent(NULL) < 0)\n        goto error;\n\n    /*\n     * If rv == 1, this indicates the dispatch func has\n     * populated 'msg' with a list of FDs to return to\n     * the caller.\n     *\n     * Otherwise we must clear out the FDs we got from\n     * the client originally.\n     *\n     */\n    if (rv != 1) {\n        for (i = 0; i < msg->nfds; i++)\n            VIR_FORCE_CLOSE(msg->fds[i]);\n        VIR_FREE(msg->fds);\n        msg->nfds = 0;\n    }\n\n    xdr_free(dispatcher->arg_filter, arg);\n\n    if (rv < 0)\n        goto error;\n\n    /* Return header. We're re-using same message object, so\n     * only need to tweak type/status fields */\n    /*msg->header.prog = msg->header.prog;*/\n    /*msg->header.vers = msg->header.vers;*/\n    /*msg->header.proc = msg->header.proc;*/\n    msg->header.type = msg->nfds ? VIR_NET_REPLY_WITH_FDS : VIR_NET_REPLY;\n    /*msg->header.serial = msg->header.serial;*/\n    msg->header.status = VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    if (virNetMessageEncodePayload(msg, dispatcher->ret_filter, ret) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    xdr_free(dispatcher->ret_filter, ret);\n\n    /* Put reply on end of tx queue to send out  */\n    return virNetServerClientSendMessage(client, msg);\n\n error:\n    /* Bad stuff (de-)serializing message, but we have an\n     * RPC error message we can send back to the client */\n    rv = virNetServerProgramSendReplyError(prog, client, msg, &rerr, &msg->header);\n\n    return rv;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg)\n{\n    g_autofree char *arg = NULL;\n    g_autofree char *ret = NULL;\n    int rv = -1;\n    virNetServerProgramProcPtr dispatcher;\n    virNetMessageError rerr;\n    size_t i;\n    g_autoptr(virIdentity) identity = NULL;\n\n    memset(&rerr, 0, sizeof(rerr));\n\n    if (msg->header.status != VIR_NET_OK) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %u\"),\n                       msg->header.status);\n        goto error;\n    }\n\n    dispatcher = virNetServerProgramGetProc(prog, msg->header.proc);\n\n    if (!dispatcher) {\n        virReportError(VIR_ERR_RPC,\n                       _(\"unknown procedure: %d\"),\n                       msg->header.proc);\n        goto error;\n    }\n\n    /* If the client is not authenticated, don't allow any RPC ops\n     * which are except for authentication ones */\n    if (dispatcher->needAuth &&\n        !virNetServerClientIsAuthenticated(client)) {\n        /* Explicitly *NOT* calling  remoteDispatchAuthError() because\n           we want back-compatibility with libvirt clients which don't\n           support the VIR_ERR_AUTH_FAILED error code */\n        virReportError(VIR_ERR_RPC,\n                       \"%s\", _(\"authentication required\"));\n        goto error;\n    }\n\n    if (VIR_ALLOC_N(arg, dispatcher->arg_len) < 0)\n        goto error;\n    if (VIR_ALLOC_N(ret, dispatcher->ret_len) < 0)\n        goto error;\n\n    if (virNetMessageDecodePayload(msg, dispatcher->arg_filter, arg) < 0)\n        goto error;\n\n    if (!(identity = virNetServerClientGetIdentity(client)))\n        goto error;\n\n    if (virIdentitySetCurrent(identity) < 0)\n        goto error;\n\n    /*\n     * When the RPC handler is called:\n     *\n     *  - Server object is unlocked\n     *  - Client object is unlocked\n     *\n     * Without locking, it is safe to use:\n     *\n     *   'args and 'ret'\n     */\n    rv = (dispatcher->func)(server, client, msg, &rerr, arg, ret);\n\n    if (virIdentitySetCurrent(NULL) < 0)\n        goto error;\n\n    /*\n     * If rv == 1, this indicates the dispatch func has\n     * populated 'msg' with a list of FDs to return to\n     * the caller.\n     *\n     * Otherwise we must clear out the FDs we got from\n     * the client originally.\n     *\n     */\n    if (rv != 1) {\n        for (i = 0; i < msg->nfds; i++)\n            VIR_FORCE_CLOSE(msg->fds[i]);\n        VIR_FREE(msg->fds);\n        msg->nfds = 0;\n    }\n\n    xdr_free(dispatcher->arg_filter, arg);\n\n    if (rv < 0)\n        goto error;\n\n    /* Return header. We're re-using same message object, so\n     * only need to tweak type/status fields */\n    /*msg->header.prog = msg->header.prog;*/\n    /*msg->header.vers = msg->header.vers;*/\n    /*msg->header.proc = msg->header.proc;*/\n    msg->header.type = msg->nfds ? VIR_NET_REPLY_WITH_FDS : VIR_NET_REPLY;\n    /*msg->header.serial = msg->header.serial;*/\n    msg->header.status = VIR_NET_OK;\n\n    if (virNetMessageEncodeHeader(msg) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    if (virNetMessageEncodePayload(msg, dispatcher->ret_filter, ret) < 0) {\n        xdr_free(dispatcher->ret_filter, ret);\n        goto error;\n    }\n\n    xdr_free(dispatcher->ret_filter, ret);\n\n    /* Put reply on end of tx queue to send out  */\n    return virNetServerClientSendMessage(client, msg);\n\n error:\n    /* Bad stuff (de-)serializing message, but we have an\n     * RPC error message we can send back to the client */\n    rv = virNetServerProgramSendReplyError(prog, client, msg, &rerr, &msg->header);\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetServerClientSendMessage",
          "args": [
            "client",
            "msg"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerClientSendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverclient.c",
          "lines": "1528-1538",
          "snippet": "int virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserver.h\"",
            "# include <sasl/sasl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virNetServerClientUpdateEvent(virNetServerClientPtr client);",
            "static virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);",
            "static int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virkeepalive.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserver.h\"\n# include <sasl/sasl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic void virNetServerClientUpdateEvent(virNetServerClientPtr client);\nstatic virNetMessagePtr virNetServerClientDispatchRead(virNetServerClientPtr client);\nstatic int virNetServerClientSendMessageLocked(virNetServerClientPtr client,\n                                               virNetMessagePtr msg);\n\nint virNetServerClientSendMessage(virNetServerClientPtr client,\n                                  virNetMessagePtr msg)\n{\n    int ret;\n\n    virObjectLock(client);\n    ret = virNetServerClientSendMessageLocked(client, msg);\n    virObjectUnlock(client);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageClear",
          "args": [
            "msg"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "69-78",
          "snippet": "void virNetMessageClear(virNetMessagePtr msg)\n{\n    bool tracked = msg->tracked;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu\", msg, msg->nfds);\n\n    virNetMessageClearPayload(msg);\n    memset(msg, 0, sizeof(*msg));\n    msg->tracked = tracked;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageClear(virNetMessagePtr msg)\n{\n    bool tracked = msg->tracked;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu\", msg, msg->nfds);\n\n    virNetMessageClearPayload(msg);\n    memset(msg, 0, sizeof(*msg));\n    msg->tracked = tracked;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"Dropping client message, unknown program %d version %d type %d proc %d\"",
            "msg->header.prog",
            "msg->header.vers",
            "msg->header.type",
            "msg->header.proc"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetServerProgramUnknownError",
          "args": [
            "client",
            "msg",
            "&msg->header"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "virNetServerProgramUnknownError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserverprogram.c",
          "lines": "228-246",
          "snippet": "int virNetServerProgramUnknownError(virNetServerClientPtr client,\n                                    virNetMessagePtr msg,\n                                    virNetMessageHeaderPtr req)\n{\n    virNetMessageError rerr;\n\n    virReportError(VIR_ERR_RPC,\n                   _(\"Cannot find program %d version %d\"), req->prog, req->vers);\n\n    memset(&rerr, 0, sizeof(rerr));\n    return virNetServerProgramSendError(req->prog,\n                                        req->vers,\n                                        client,\n                                        msg,\n                                        &rerr,\n                                        req->proc,\n                                        VIR_NET_REPLY,\n                                        req->serial);\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetserverclient.h\"",
            "#include \"virnetserverprogram.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetserverclient.h\"\n#include \"virnetserverprogram.h\"\n#include <config.h>\n\nstatic int\nvirNetServerProgramDispatchCall(virNetServerProgramPtr prog,\n                                virNetServerPtr server,\n                                virNetServerClientPtr client,\n                                virNetMessagePtr msg);\n\nint virNetServerProgramUnknownError(virNetServerClientPtr client,\n                                    virNetMessagePtr msg,\n                                    virNetMessageHeaderPtr req)\n{\n    virNetMessageError rerr;\n\n    virReportError(VIR_ERR_RPC,\n                   _(\"Cannot find program %d version %d\"), req->prog, req->vers);\n\n    memset(&rerr, 0, sizeof(rerr));\n    return virNetServerProgramSendError(req->prog,\n                                        req->vers,\n                                        client,\n                                        msg,\n                                        &rerr,\n                                        req->proc,\n                                        VIR_NET_REPLY,\n                                        req->serial);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nstatic int virNetServerProcessMsg(virNetServerPtr srv,\n                                  virNetServerClientPtr client,\n                                  virNetServerProgramPtr prog,\n                                  virNetMessagePtr msg)\n{\n    if (!prog) {\n        /* Only send back an error for type == CALL. Other\n         * message types are not expecting replies, so we\n         * must just log it & drop them\n         */\n        if (msg->header.type == VIR_NET_CALL ||\n            msg->header.type == VIR_NET_CALL_WITH_FDS) {\n            if (virNetServerProgramUnknownError(client,\n                                                msg,\n                                                &msg->header) < 0)\n                return -1;\n        } else {\n            VIR_INFO(\"Dropping client message, unknown program %d version %d type %d proc %d\",\n                     msg->header.prog, msg->header.vers,\n                     msg->header.type, msg->header.proc);\n            /* Send a dummy reply to free up 'msg' & unblock client rx */\n            virNetMessageClear(msg);\n            msg->header.type = VIR_NET_REPLY;\n            if (virNetServerClientSendMessage(client, msg) < 0)\n                return -1;\n        }\n        return 0;\n    }\n\n    if (virNetServerProgramDispatch(prog,\n                                    srv,\n                                    client,\n                                    msg) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetServerNextClientID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "97-106",
    "snippet": "unsigned long long virNetServerNextClientID(virNetServerPtr srv)\n{\n    unsigned long long val;\n\n    virObjectLock(srv);\n    val = srv->next_client_id++;\n    virObjectUnlock(srv);\n\n    return val;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);",
      "static inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "srv"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "srv"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic inline size_t virNetServerTrackPendingAuthLocked(virNetServerPtr srv);\nstatic inline size_t virNetServerTrackCompletedAuthLocked(virNetServerPtr srv);\n\nunsigned long long virNetServerNextClientID(virNetServerPtr srv)\n{\n    unsigned long long val;\n\n    virObjectLock(srv);\n    val = srv->next_client_id++;\n    virObjectUnlock(srv);\n\n    return val;\n}"
  },
  {
    "function_name": "virNetServerOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetserver.c",
    "lines": "87-93",
    "snippet": "static int virNetServerOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetServer, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virstring.h\"",
      "#include \"virthreadpool.h\"",
      "#include \"virthread.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"virnetserver.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virNetServer",
            "virClassForObjectLockable()"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthreadpool.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virnetserver.h\"\n#include <config.h>\n\nstatic int virNetServerOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetServer, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}"
  }
]