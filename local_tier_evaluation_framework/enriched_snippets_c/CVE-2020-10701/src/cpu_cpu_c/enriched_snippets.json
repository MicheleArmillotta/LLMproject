[
  {
    "function_name": "virCPUArchIsSupported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "1110-1124",
    "snippet": "bool\nvirCPUArchIsSupported(virArch arch)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        for (j = 0; j < drivers[i]->narch; j++) {\n            if (arch == drivers[i]->arch[j])\n                return true;\n        }\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "drivers"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nbool\nvirCPUArchIsSupported(virArch arch)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        for (j = 0; j < drivers[i]->narch; j++) {\n            if (arch == drivers[i]->arch[j])\n                return true;\n        }\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virCPUDataAddFeature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "1080-1100",
    "snippet": "int\nvirCPUDataAddFeature(virCPUDataPtr cpuData,\n                     const char *name)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpuData=%p, name=%s\",\n              virArchToString(cpuData->arch), cpuData, name);\n\n    if (!(driver = cpuGetSubDriver(cpuData->arch)))\n        return -1;\n\n    if (!driver->dataAddFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot add guest CPU feature for %s architecture\"),\n                       virArchToString(cpuData->arch));\n        return -1;\n    }\n\n    return driver->dataAddFeature(cpuData, name);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "driver->dataAddFeature",
          "args": [
            "cpuData",
            "name"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"cannot add guest CPU feature for %s architecture\")",
            "virArchToString(cpuData->arch)"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "cpuData->arch"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot add guest CPU feature for %s architecture\""
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "cpuData->arch"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s, cpuData=%p, name=%s\"",
            "virArchToString(cpuData->arch)",
            "cpuData",
            "name"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUDataAddFeature(virCPUDataPtr cpuData,\n                     const char *name)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpuData=%p, name=%s\",\n              virArchToString(cpuData->arch), cpuData, name);\n\n    if (!(driver = cpuGetSubDriver(cpuData->arch)))\n        return -1;\n\n    if (!driver->dataAddFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot add guest CPU feature for %s architecture\"),\n                       virArchToString(cpuData->arch));\n        return -1;\n    }\n\n    return driver->dataAddFeature(cpuData, name);\n}"
  },
  {
    "function_name": "virCPUValidateFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "1051-1067",
    "snippet": "int\nvirCPUValidateFeatures(virArch arch,\n                       virCPUDefPtr cpu)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, nfeatures=%zu\",\n              virArchToString(arch), cpu, cpu->nfeatures);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (driver->validateFeatures)\n        return driver->validateFeatures(cpu);\n    else\n        return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "driver->validateFeatures",
          "args": [
            "cpu"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "arch"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s, cpu=%p, nfeatures=%zu\"",
            "virArchToString(arch)",
            "cpu",
            "cpu->nfeatures"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUValidateFeatures(virArch arch,\n                       virCPUDefPtr cpu)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, nfeatures=%zu\",\n              virArchToString(arch), cpu, cpu->nfeatures);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (driver->validateFeatures)\n        return driver->validateFeatures(cpu);\n    else\n        return 0;\n}"
  },
  {
    "function_name": "virCPUCopyMigratable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "1022-1038",
    "snippet": "virCPUDefPtr\nvirCPUCopyMigratable(virArch arch,\n                     virCPUDefPtr cpu)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, model=%s\",\n              virArchToString(arch), cpu, NULLSTR(cpu->model));\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return NULL;\n\n    if (driver->copyMigratable)\n        return driver->copyMigratable(cpu);\n    else\n        return virCPUDefCopy(cpu);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefCopy",
          "args": [
            "cpu"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "269-285",
          "snippet": "virCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "driver->copyMigratable",
          "args": [
            "cpu"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "arch"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s, cpu=%p, model=%s\"",
            "virArchToString(arch)",
            "cpu",
            "NULLSTR(cpu->model)"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cpu->model"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUCopyMigratable(virArch arch,\n                     virCPUDefPtr cpu)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, model=%s\",\n              virArchToString(arch), cpu, NULLSTR(cpu->model));\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return NULL;\n\n    if (driver->copyMigratable)\n        return driver->copyMigratable(cpu);\n    else\n        return virCPUDefCopy(cpu);\n}"
  },
  {
    "function_name": "virCPUExpandFeatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "986-1007",
    "snippet": "int\nvirCPUExpandFeatures(virArch arch,\n                     virCPUDefPtr cpu)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, model=%s, nfeatures=%zu\",\n              virArchToString(arch), cpu, NULLSTR(cpu->model), cpu->nfeatures);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (driver->expandFeatures &&\n        driver->expandFeatures(cpu) < 0)\n        return -1;\n\n    qsort(cpu->features, cpu->nfeatures, sizeof(*cpu->features),\n          virCPUFeatureCompare);\n\n    VIR_DEBUG(\"nfeatures=%zu\", cpu->nfeatures);\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"nfeatures=%zu\"",
            "cpu->nfeatures"
          ],
          "line": 1005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "cpu->features",
            "cpu->nfeatures",
            "sizeof(*cpu->features)",
            "virCPUFeatureCompare"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver->expandFeatures",
          "args": [
            "cpu"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "arch"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s, cpu=%p, model=%s, nfeatures=%zu\"",
            "virArchToString(arch)",
            "cpu",
            "NULLSTR(cpu->model)",
            "cpu->nfeatures"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cpu->model"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUExpandFeatures(virArch arch,\n                     virCPUDefPtr cpu)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, model=%s, nfeatures=%zu\",\n              virArchToString(arch), cpu, NULLSTR(cpu->model), cpu->nfeatures);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (driver->expandFeatures &&\n        driver->expandFeatures(cpu) < 0)\n        return -1;\n\n    qsort(cpu->features, cpu->nfeatures, sizeof(*cpu->features),\n          virCPUFeatureCompare);\n\n    VIR_DEBUG(\"nfeatures=%zu\", cpu->nfeatures);\n    return 0;\n}"
  },
  {
    "function_name": "virCPUFeatureCompare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "960-968",
    "snippet": "static int\nvirCPUFeatureCompare(const void *p1,\n                     const void *p2)\n{\n    const virCPUFeatureDef *f1 = p1;\n    const virCPUFeatureDef *f2 = p2;\n\n    return strcmp(f1->name, f2->name);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "f1->name",
            "f2->name"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUFeatureCompare(const void *p1,\n                     const void *p2)\n{\n    const virCPUFeatureDef *f1 = p1;\n    const virCPUFeatureDef *f2 = p2;\n\n    return strcmp(f1->name, f2->name);\n}"
  },
  {
    "function_name": "virCPUConvertLegacy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "937-957",
    "snippet": "int\nvirCPUConvertLegacy(virArch arch,\n                    virCPUDefPtr cpu)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, model=%s\",\n              virArchToString(arch), cpu, NULLSTR(cpu->model));\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->convertLegacy)\n        return 0;\n\n    if (driver->convertLegacy(cpu) < 0)\n        return -1;\n\n    VIR_DEBUG(\"model=%s\", NULLSTR(cpu->model));\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"model=%s\"",
            "NULLSTR(cpu->model)"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cpu->model"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver->convertLegacy",
          "args": [
            "cpu"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "arch"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s, cpu=%p, model=%s\"",
            "virArchToString(arch)",
            "cpu",
            "NULLSTR(cpu->model)"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cpu->model"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUConvertLegacy(virArch arch,\n                    virCPUDefPtr cpu)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, model=%s\",\n              virArchToString(arch), cpu, NULLSTR(cpu->model));\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->convertLegacy)\n        return 0;\n\n    if (driver->convertLegacy(cpu) < 0)\n        return -1;\n\n    VIR_DEBUG(\"model=%s\", NULLSTR(cpu->model));\n    return 0;\n}"
  },
  {
    "function_name": "virCPUTranslate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "883-922",
    "snippet": "int\nvirCPUTranslate(virArch arch,\n                virCPUDefPtr cpu,\n                virDomainCapsCPUModelsPtr models)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, model=%s, models=%p\",\n              virArchToString(arch), cpu, NULLSTR(cpu->model), models);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (cpu->mode == VIR_CPU_MODE_HOST_MODEL ||\n        cpu->mode == VIR_CPU_MODE_HOST_PASSTHROUGH)\n        return 0;\n\n    if (virCPUModelIsAllowed(cpu->model, models))\n        return 0;\n\n    if (cpu->fallback != VIR_CPU_FALLBACK_ALLOW) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"CPU model %s is not supported by hypervisor\"),\n                       cpu->model);\n        return -1;\n    }\n\n    if (!driver->translate) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot translate CPU model %s to a supported model\"),\n                       cpu->model);\n        return -1;\n    }\n\n    if (driver->translate(cpu, models) < 0)\n        return -1;\n\n    VIR_DEBUG(\"model=%s\", NULLSTR(cpu->model));\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"model=%s\"",
            "NULLSTR(cpu->model)"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cpu->model"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver->translate",
          "args": [
            "cpu",
            "models"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"cannot translate CPU model %s to a supported model\")",
            "cpu->model"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot translate CPU model %s to a supported model\""
          ],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"CPU model %s is not supported by hypervisor\")",
            "cpu->model"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUModelIsAllowed",
          "args": [
            "cpu->model",
            "models"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUModelIsAllowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "823-831",
          "snippet": "bool\nvirCPUModelIsAllowed(const char *model,\n                     virDomainCapsCPUModelsPtr models)\n{\n    if (!models)\n        return true;\n\n    return !!virDomainCapsCPUModelsGet(models, model);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nbool\nvirCPUModelIsAllowed(const char *model,\n                     virDomainCapsCPUModelsPtr models)\n{\n    if (!models)\n        return true;\n\n    return !!virDomainCapsCPUModelsGet(models, model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "arch"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s, cpu=%p, model=%s, models=%p\"",
            "virArchToString(arch)",
            "cpu",
            "NULLSTR(cpu->model)",
            "models"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cpu->model"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUTranslate(virArch arch,\n                virCPUDefPtr cpu,\n                virDomainCapsCPUModelsPtr models)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, model=%s, models=%p\",\n              virArchToString(arch), cpu, NULLSTR(cpu->model), models);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (cpu->mode == VIR_CPU_MODE_HOST_MODEL ||\n        cpu->mode == VIR_CPU_MODE_HOST_PASSTHROUGH)\n        return 0;\n\n    if (virCPUModelIsAllowed(cpu->model, models))\n        return 0;\n\n    if (cpu->fallback != VIR_CPU_FALLBACK_ALLOW) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"CPU model %s is not supported by hypervisor\"),\n                       cpu->model);\n        return -1;\n    }\n\n    if (!driver->translate) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot translate CPU model %s to a supported model\"),\n                       cpu->model);\n        return -1;\n    }\n\n    if (driver->translate(cpu, models) < 0)\n        return -1;\n\n    VIR_DEBUG(\"model=%s\", NULLSTR(cpu->model));\n    return 0;\n}"
  },
  {
    "function_name": "virCPUGetModels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "848-865",
    "snippet": "int\nvirCPUGetModels(virArch arch, char ***models)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s\", virArchToString(arch));\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->getModels) {\n        if (models)\n            *models = NULL;\n        return 0;\n    }\n\n    return driver->getModels(models);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "driver->getModels",
          "args": [
            "models"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "arch"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s\"",
            "virArchToString(arch)"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUGetModels(virArch arch, char ***models)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s\", virArchToString(arch));\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->getModels) {\n        if (models)\n            *models = NULL;\n        return 0;\n    }\n\n    return driver->getModels(models);\n}"
  },
  {
    "function_name": "virCPUModelIsAllowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "823-831",
    "snippet": "bool\nvirCPUModelIsAllowed(const char *model,\n                     virDomainCapsCPUModelsPtr models)\n{\n    if (!models)\n        return true;\n\n    return !!virDomainCapsCPUModelsGet(models, model);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainCapsCPUModelsGet",
          "args": [
            "models",
            "model"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCapsCPUModelsGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_capabilities.c",
          "lines": "225-240",
          "snippet": "virDomainCapsCPUModelPtr\nvirDomainCapsCPUModelsGet(virDomainCapsCPUModelsPtr cpuModels,\n                          const char *name)\n{\n    size_t i;\n\n    if (!cpuModels)\n        return NULL;\n\n    for (i = 0; i < cpuModels->nmodels; i++) {\n        if (STREQ(cpuModels->models[i].name, name))\n            return cpuModels->models + i;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"device_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"domain_capabilities.h\"\n#include \"device_conf.h\"\n#include <config.h>\n\nvirDomainCapsCPUModelPtr\nvirDomainCapsCPUModelsGet(virDomainCapsCPUModelsPtr cpuModels,\n                          const char *name)\n{\n    size_t i;\n\n    if (!cpuModels)\n        return NULL;\n\n    for (i = 0; i < cpuModels->nmodels; i++) {\n        if (STREQ(cpuModels->models[i].name, name))\n            return cpuModels->models + i;\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nbool\nvirCPUModelIsAllowed(const char *model,\n                     virDomainCapsCPUModelsPtr models)\n{\n    if (!models)\n        return true;\n\n    return !!virDomainCapsCPUModelsGet(models, model);\n}"
  },
  {
    "function_name": "virCPUDataParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "771-810",
    "snippet": "virCPUDataPtr\nvirCPUDataParse(const char *xmlStr)\n{\n    struct cpuArchDriver *driver;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    virCPUDataPtr data = NULL;\n    char *arch = NULL;\n\n    VIR_DEBUG(\"xmlStr=%s\", xmlStr);\n\n    if (!(xml = virXMLParseStringCtxt(xmlStr, _(\"CPU data\"), &ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot parse CPU data\"));\n        goto cleanup;\n    }\n\n    if (!(arch = virXPathString(\"string(/cpudata/@arch)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing CPU data architecture\"));\n        goto cleanup;\n    }\n\n    if (!(driver = cpuGetSubDriverByName(arch)))\n        goto cleanup;\n\n    if (!driver->dataParse) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot parse %s CPU data\"), arch);\n        goto cleanup;\n    }\n\n    data = driver->dataParse(ctxt);\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(xml);\n    VIR_FREE(arch);\n    return data;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "arch"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "xml"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "ctxt"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver->dataParse",
          "args": [
            "ctxt"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"cannot parse %s CPU data\")",
            "arch"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot parse %s CPU data\""
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriverByName",
          "args": [
            "arch"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing CPU data architecture\")"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(/cpudata/@arch)\"",
            "ctxt"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot parse CPU data\")"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLParseStringCtxt",
          "args": [
            "xmlStr",
            "_(\"CPU data\")",
            "&ctxt"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"xmlStr=%s\"",
            "xmlStr"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDataPtr\nvirCPUDataParse(const char *xmlStr)\n{\n    struct cpuArchDriver *driver;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    virCPUDataPtr data = NULL;\n    char *arch = NULL;\n\n    VIR_DEBUG(\"xmlStr=%s\", xmlStr);\n\n    if (!(xml = virXMLParseStringCtxt(xmlStr, _(\"CPU data\"), &ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot parse CPU data\"));\n        goto cleanup;\n    }\n\n    if (!(arch = virXPathString(\"string(/cpudata/@arch)\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing CPU data architecture\"));\n        goto cleanup;\n    }\n\n    if (!(driver = cpuGetSubDriverByName(arch)))\n        goto cleanup;\n\n    if (!driver->dataParse) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot parse %s CPU data\"), arch);\n        goto cleanup;\n    }\n\n    data = driver->dataParse(ctxt);\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(xml);\n    VIR_FREE(arch);\n    return data;\n}"
  },
  {
    "function_name": "virCPUDataFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "741-759",
    "snippet": "char *\nvirCPUDataFormat(const virCPUData *data)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"data=%p\", data);\n\n    if (!(driver = cpuGetSubDriver(data->arch)))\n        return NULL;\n\n    if (!driver->dataFormat) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot format %s CPU data\"),\n                       virArchToString(data->arch));\n        return NULL;\n    }\n\n    return driver->dataFormat(data);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "driver->dataFormat",
          "args": [
            "data"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"cannot format %s CPU data\")",
            "virArchToString(data->arch)"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "data->arch"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot format %s CPU data\""
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "data->arch"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"data=%p\"",
            "data"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nchar *\nvirCPUDataFormat(const virCPUData *data)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"data=%p\", data);\n\n    if (!(driver = cpuGetSubDriver(data->arch)))\n        return NULL;\n\n    if (!driver->dataFormat) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot format %s CPU data\"),\n                       virArchToString(data->arch));\n        return NULL;\n    }\n\n    return driver->dataFormat(data);\n}"
  },
  {
    "function_name": "virCPUDataCheckFeature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "709-729",
    "snippet": "int\nvirCPUDataCheckFeature(const virCPUData *data,\n                       const char *feature)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, data=%p, feature=%s\",\n              virArchToString(data->arch), data, feature);\n\n    if (!(driver = cpuGetSubDriver(data->arch)))\n        return -1;\n\n    if (!driver->dataCheckFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot check guest CPU feature for %s architecture\"),\n                       virArchToString(data->arch));\n        return -1;\n    }\n\n    return driver->dataCheckFeature(data, feature);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "driver->dataCheckFeature",
          "args": [
            "data",
            "feature"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"cannot check guest CPU feature for %s architecture\")",
            "virArchToString(data->arch)"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "data->arch"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot check guest CPU feature for %s architecture\""
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "data->arch"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s, data=%p, feature=%s\"",
            "virArchToString(data->arch)",
            "data",
            "feature"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUDataCheckFeature(const virCPUData *data,\n                       const char *feature)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, data=%p, feature=%s\",\n              virArchToString(data->arch), data, feature);\n\n    if (!(driver = cpuGetSubDriver(data->arch)))\n        return -1;\n\n    if (!driver->dataCheckFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot check guest CPU feature for %s architecture\"),\n                       virArchToString(data->arch));\n        return -1;\n    }\n\n    return driver->dataCheckFeature(data, feature);\n}"
  },
  {
    "function_name": "virCPUCheckFeature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "674-695",
    "snippet": "int\nvirCPUCheckFeature(virArch arch,\n                   const virCPUDef *cpu,\n                   const char *feature)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, feature=%s\",\n              virArchToString(arch), cpu, feature);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->checkFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot check guest CPU feature for %s architecture\"),\n                       virArchToString(arch));\n        return -1;\n    }\n\n    return driver->checkFeature(cpu, feature);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "driver->checkFeature",
          "args": [
            "cpu",
            "feature"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"cannot check guest CPU feature for %s architecture\")",
            "virArchToString(arch)"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot check guest CPU feature for %s architecture\""
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "arch"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s, cpu=%p, feature=%s\"",
            "virArchToString(arch)",
            "cpu",
            "feature"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUCheckFeature(virArch arch,\n                   const virCPUDef *cpu,\n                   const char *feature)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, feature=%s\",\n              virArchToString(arch), cpu, feature);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->checkFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot check guest CPU feature for %s architecture\"),\n                       virArchToString(arch));\n        return -1;\n    }\n\n    return driver->checkFeature(cpu, feature);\n}"
  },
  {
    "function_name": "virCPUUpdateLive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "633-659",
    "snippet": "int\nvirCPUUpdateLive(virArch arch,\n                 virCPUDefPtr cpu,\n                 virCPUDataPtr dataEnabled,\n                 virCPUDataPtr dataDisabled)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, dataEnabled=%p, dataDisabled=%p\",\n              virArchToString(arch), cpu, dataEnabled, dataDisabled);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->updateLive)\n        return 1;\n\n    if (cpu->mode == VIR_CPU_MODE_CUSTOM ||\n        cpu->check == VIR_CPU_CHECK_FULL) {\n        if (driver->updateLive(cpu, dataEnabled, dataDisabled) < 0)\n            return -1;\n\n        return 0;\n    }\n\n    return 1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "driver->updateLive",
          "args": [
            "cpu",
            "dataEnabled",
            "dataDisabled"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "arch"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s, cpu=%p, dataEnabled=%p, dataDisabled=%p\"",
            "virArchToString(arch)",
            "cpu",
            "dataEnabled",
            "dataDisabled"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUUpdateLive(virArch arch,\n                 virCPUDefPtr cpu,\n                 virCPUDataPtr dataEnabled,\n                 virCPUDataPtr dataDisabled)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, dataEnabled=%p, dataDisabled=%p\",\n              virArchToString(arch), cpu, dataEnabled, dataDisabled);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->updateLive)\n        return 1;\n\n    if (cpu->mode == VIR_CPU_MODE_CUSTOM ||\n        cpu->check == VIR_CPU_CHECK_FULL) {\n        if (driver->updateLive(cpu, dataEnabled, dataDisabled) < 0)\n            return -1;\n\n        return 0;\n    }\n\n    return 1;\n}"
  },
  {
    "function_name": "virCPUUpdate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "562-612",
    "snippet": "int\nvirCPUUpdate(virArch arch,\n             virCPUDefPtr guest,\n             const virCPUDef *host)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, guest=%p mode=%s model=%s, host=%p model=%s\",\n              virArchToString(arch), guest, virCPUModeTypeToString(guest->mode),\n              NULLSTR(guest->model), host, NULLSTR(host ? host->model : NULL));\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (guest->mode == VIR_CPU_MODE_HOST_PASSTHROUGH)\n        return 0;\n\n    if (guest->mode == VIR_CPU_MODE_CUSTOM &&\n        guest->match != VIR_CPU_MATCH_MINIMUM) {\n        size_t i;\n        bool optional = false;\n\n        for (i = 0; i < guest->nfeatures; i++) {\n            if (guest->features[i].policy == VIR_CPU_FEATURE_OPTIONAL) {\n                optional = true;\n                break;\n            }\n        }\n\n        if (!optional)\n            return 0;\n    }\n\n    /* We get here if guest CPU is either\n     *  - host-model\n     *  - custom with minimum match\n     *  - custom with optional features\n     */\n    if (!driver->update) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot update guest CPU for %s architecture\"),\n                       virArchToString(arch));\n        return -1;\n    }\n\n    if (driver->update(guest, host) < 0)\n        return -1;\n\n    VIR_DEBUG(\"model=%s\", NULLSTR(guest->model));\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"model=%s\"",
            "NULLSTR(guest->model)"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "guest->model"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver->update",
          "args": [
            "guest",
            "host"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"cannot update guest CPU for %s architecture\")",
            "virArchToString(arch)"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot update guest CPU for %s architecture\""
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "arch"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s, guest=%p mode=%s model=%s, host=%p model=%s\"",
            "virArchToString(arch)",
            "guest",
            "virCPUModeTypeToString(guest->mode)",
            "NULLSTR(guest->model)",
            "host",
            "NULLSTR(host ? host->model : NULL)"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "host ? host->model : NULL"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "guest->model"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUModeTypeToString",
          "args": [
            "guest->mode"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUUpdate(virArch arch,\n             virCPUDefPtr guest,\n             const virCPUDef *host)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, guest=%p mode=%s model=%s, host=%p model=%s\",\n              virArchToString(arch), guest, virCPUModeTypeToString(guest->mode),\n              NULLSTR(guest->model), host, NULLSTR(host ? host->model : NULL));\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (guest->mode == VIR_CPU_MODE_HOST_PASSTHROUGH)\n        return 0;\n\n    if (guest->mode == VIR_CPU_MODE_CUSTOM &&\n        guest->match != VIR_CPU_MATCH_MINIMUM) {\n        size_t i;\n        bool optional = false;\n\n        for (i = 0; i < guest->nfeatures; i++) {\n            if (guest->features[i].policy == VIR_CPU_FEATURE_OPTIONAL) {\n                optional = true;\n                break;\n            }\n        }\n\n        if (!optional)\n            return 0;\n    }\n\n    /* We get here if guest CPU is either\n     *  - host-model\n     *  - custom with minimum match\n     *  - custom with optional features\n     */\n    if (!driver->update) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot update guest CPU for %s architecture\"),\n                       virArchToString(arch));\n        return -1;\n    }\n\n    if (driver->update(guest, host) < 0)\n        return -1;\n\n    VIR_DEBUG(\"model=%s\", NULLSTR(guest->model));\n    return 0;\n}"
  },
  {
    "function_name": "virCPUBaseline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "483-543",
    "snippet": "virCPUDefPtr\nvirCPUBaseline(virArch arch,\n               virCPUDefPtr *cpus,\n               unsigned int ncpus,\n               virDomainCapsCPUModelsPtr models,\n               const char **features,\n               bool migratable)\n{\n    struct cpuArchDriver *driver;\n    size_t i;\n\n    VIR_DEBUG(\"arch=%s, ncpus=%u, models=%p, features=%p, migratable=%d\",\n              virArchToString(arch), ncpus, models, features, migratable);\n    if (cpus) {\n        for (i = 0; i < ncpus; i++)\n            VIR_DEBUG(\"cpus[%zu]=%p\", i, cpus[i]);\n    }\n    if (models) {\n        for (i = 0; i < models->nmodels; i++)\n            VIR_DEBUG(\"models[%zu]=%s\", i, models->models[i].name);\n    }\n\n    if (!cpus && ncpus != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"nonzero ncpus doesn't match with NULL cpus\"));\n        return NULL;\n    }\n\n    if (ncpus < 1) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"no CPUs given\"));\n        return NULL;\n    }\n\n    for (i = 0; i < ncpus; i++) {\n        if (!cpus[i]) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"invalid CPU definition at index %zu\"), i);\n            return NULL;\n        }\n        if (!cpus[i]->model) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"no CPU model specified at index %zu\"), i);\n            return NULL;\n        }\n    }\n\n    if (arch == VIR_ARCH_NONE)\n        arch = cpus[0]->arch;\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return NULL;\n\n    if (!driver->baseline) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot compute baseline CPU of %s architecture\"),\n                       virArchToString(arch));\n        return NULL;\n    }\n\n    return driver->baseline(cpus, ncpus, models, features, migratable);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "driver->baseline",
          "args": [
            "cpus",
            "ncpus",
            "models",
            "features",
            "migratable"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"cannot compute baseline CPU of %s architecture\")",
            "virArchToString(arch)"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot compute baseline CPU of %s architecture\""
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "arch"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"no CPU model specified at index %zu\")",
            "i"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"invalid CPU definition at index %zu\")",
            "i"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"no CPUs given\")"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"nonzero ncpus doesn't match with NULL cpus\")"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"models[%zu]=%s\"",
            "i",
            "models->models[i].name"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cpus[%zu]=%p\"",
            "i",
            "cpus[i]"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s, ncpus=%u, models=%p, features=%p, migratable=%d\"",
            "virArchToString(arch)",
            "ncpus",
            "models",
            "features",
            "migratable"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUBaseline(virArch arch,\n               virCPUDefPtr *cpus,\n               unsigned int ncpus,\n               virDomainCapsCPUModelsPtr models,\n               const char **features,\n               bool migratable)\n{\n    struct cpuArchDriver *driver;\n    size_t i;\n\n    VIR_DEBUG(\"arch=%s, ncpus=%u, models=%p, features=%p, migratable=%d\",\n              virArchToString(arch), ncpus, models, features, migratable);\n    if (cpus) {\n        for (i = 0; i < ncpus; i++)\n            VIR_DEBUG(\"cpus[%zu]=%p\", i, cpus[i]);\n    }\n    if (models) {\n        for (i = 0; i < models->nmodels; i++)\n            VIR_DEBUG(\"models[%zu]=%s\", i, models->models[i].name);\n    }\n\n    if (!cpus && ncpus != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"nonzero ncpus doesn't match with NULL cpus\"));\n        return NULL;\n    }\n\n    if (ncpus < 1) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"no CPUs given\"));\n        return NULL;\n    }\n\n    for (i = 0; i < ncpus; i++) {\n        if (!cpus[i]) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"invalid CPU definition at index %zu\"), i);\n            return NULL;\n        }\n        if (!cpus[i]->model) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"no CPU model specified at index %zu\"), i);\n            return NULL;\n        }\n    }\n\n    if (arch == VIR_ARCH_NONE)\n        arch = cpus[0]->arch;\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return NULL;\n\n    if (!driver->baseline) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot compute baseline CPU of %s architecture\"),\n                       virArchToString(arch));\n        return NULL;\n    }\n\n    return driver->baseline(cpus, ncpus, models, features, migratable);\n}"
  },
  {
    "function_name": "virCPUProbeHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "454-463",
    "snippet": "virCPUDefPtr\nvirCPUProbeHost(virArch arch)\n{\n    virNodeInfo nodeinfo;\n\n    if (virCapabilitiesGetNodeInfo(&nodeinfo) < 0)\n        return NULL;\n\n    return virCPUGetHost(arch, VIR_CPU_TYPE_HOST, &nodeinfo, NULL);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUGetHost",
          "args": [
            "arch",
            "VIR_CPU_TYPE_HOST",
            "&nodeinfo",
            "NULL"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUGetHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "380-451",
          "snippet": "virCPUDefPtr\nvirCPUGetHost(virArch arch,\n              virCPUType type,\n              virNodeInfoPtr nodeInfo,\n              virDomainCapsCPUModelsPtr models)\n{\n    struct cpuArchDriver *driver;\n    virCPUDefPtr cpu = NULL;\n\n    VIR_DEBUG(\"arch=%s, type=%s, nodeInfo=%p, models=%p\",\n              virArchToString(arch), virCPUTypeToString(type), nodeInfo,\n              models);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return NULL;\n\n    cpu = virCPUDefNew();\n\n    switch (type) {\n    case VIR_CPU_TYPE_HOST:\n        cpu->arch = arch;\n        cpu->type = type;\n        break;\n\n    case VIR_CPU_TYPE_GUEST:\n        if (nodeInfo) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"cannot set topology for CPU type '%s'\"),\n                           virCPUTypeToString(type));\n            goto error;\n        }\n        cpu->type = type;\n        break;\n\n    case VIR_CPU_TYPE_AUTO:\n    case VIR_CPU_TYPE_LAST:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported CPU type: %s\"),\n                       virCPUTypeToString(type));\n        goto error;\n    }\n\n    if (nodeInfo) {\n        cpu->sockets = nodeInfo->sockets;\n        cpu->dies = 1;\n        cpu->cores = nodeInfo->cores;\n        cpu->threads = nodeInfo->threads;\n    }\n\n    /* Try to get the host CPU model, but don't really fail if nodeInfo is\n     * filled in.\n     */\n    if (driver->getHost) {\n        if (driver->getHost(cpu, models) < 0 &&\n            !nodeInfo)\n            goto error;\n    } else if (nodeInfo) {\n        VIR_DEBUG(\"cannot detect host CPU model for %s architecture\",\n                  virArchToString(arch));\n    } else {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot detect host CPU model for %s architecture\"),\n                       virArchToString(arch));\n        goto error;\n    }\n\n    return cpu;\n\n error:\n    virCPUDefFree(cpu);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUGetHost(virArch arch,\n              virCPUType type,\n              virNodeInfoPtr nodeInfo,\n              virDomainCapsCPUModelsPtr models)\n{\n    struct cpuArchDriver *driver;\n    virCPUDefPtr cpu = NULL;\n\n    VIR_DEBUG(\"arch=%s, type=%s, nodeInfo=%p, models=%p\",\n              virArchToString(arch), virCPUTypeToString(type), nodeInfo,\n              models);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return NULL;\n\n    cpu = virCPUDefNew();\n\n    switch (type) {\n    case VIR_CPU_TYPE_HOST:\n        cpu->arch = arch;\n        cpu->type = type;\n        break;\n\n    case VIR_CPU_TYPE_GUEST:\n        if (nodeInfo) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"cannot set topology for CPU type '%s'\"),\n                           virCPUTypeToString(type));\n            goto error;\n        }\n        cpu->type = type;\n        break;\n\n    case VIR_CPU_TYPE_AUTO:\n    case VIR_CPU_TYPE_LAST:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported CPU type: %s\"),\n                       virCPUTypeToString(type));\n        goto error;\n    }\n\n    if (nodeInfo) {\n        cpu->sockets = nodeInfo->sockets;\n        cpu->dies = 1;\n        cpu->cores = nodeInfo->cores;\n        cpu->threads = nodeInfo->threads;\n    }\n\n    /* Try to get the host CPU model, but don't really fail if nodeInfo is\n     * filled in.\n     */\n    if (driver->getHost) {\n        if (driver->getHost(cpu, models) < 0 &&\n            !nodeInfo)\n            goto error;\n    } else if (nodeInfo) {\n        VIR_DEBUG(\"cannot detect host CPU model for %s architecture\",\n                  virArchToString(arch));\n    } else {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot detect host CPU model for %s architecture\"),\n                       virArchToString(arch));\n        goto error;\n    }\n\n    return cpu;\n\n error:\n    virCPUDefFree(cpu);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesGetNodeInfo",
          "args": [
            "&nodeinfo"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesGetNodeInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1434-1456",
          "snippet": "int\nvirCapabilitiesGetNodeInfo(virNodeInfoPtr nodeinfo)\n{\n    virArch hostarch = virArchFromHost();\n    unsigned long long memorybytes;\n\n    memset(nodeinfo, 0, sizeof(*nodeinfo));\n\n    if (virStrcpyStatic(nodeinfo->model, virArchToString(hostarch)) < 0)\n        return -1;\n\n    if (virHostMemGetInfo(&memorybytes, NULL) < 0)\n        return -1;\n    nodeinfo->memory = memorybytes / 1024;\n\n    if (virHostCPUGetInfo(hostarch,\n                          &nodeinfo->cpus, &nodeinfo->mhz,\n                          &nodeinfo->nodes, &nodeinfo->sockets,\n                          &nodeinfo->cores, &nodeinfo->threads) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirCapabilitiesGetNodeInfo(virNodeInfoPtr nodeinfo)\n{\n    virArch hostarch = virArchFromHost();\n    unsigned long long memorybytes;\n\n    memset(nodeinfo, 0, sizeof(*nodeinfo));\n\n    if (virStrcpyStatic(nodeinfo->model, virArchToString(hostarch)) < 0)\n        return -1;\n\n    if (virHostMemGetInfo(&memorybytes, NULL) < 0)\n        return -1;\n    nodeinfo->memory = memorybytes / 1024;\n\n    if (virHostCPUGetInfo(hostarch,\n                          &nodeinfo->cpus, &nodeinfo->mhz,\n                          &nodeinfo->nodes, &nodeinfo->sockets,\n                          &nodeinfo->cores, &nodeinfo->threads) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUProbeHost(virArch arch)\n{\n    virNodeInfo nodeinfo;\n\n    if (virCapabilitiesGetNodeInfo(&nodeinfo) < 0)\n        return NULL;\n\n    return virCPUGetHost(arch, VIR_CPU_TYPE_HOST, &nodeinfo, NULL);\n}"
  },
  {
    "function_name": "virCPUGetHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "380-451",
    "snippet": "virCPUDefPtr\nvirCPUGetHost(virArch arch,\n              virCPUType type,\n              virNodeInfoPtr nodeInfo,\n              virDomainCapsCPUModelsPtr models)\n{\n    struct cpuArchDriver *driver;\n    virCPUDefPtr cpu = NULL;\n\n    VIR_DEBUG(\"arch=%s, type=%s, nodeInfo=%p, models=%p\",\n              virArchToString(arch), virCPUTypeToString(type), nodeInfo,\n              models);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return NULL;\n\n    cpu = virCPUDefNew();\n\n    switch (type) {\n    case VIR_CPU_TYPE_HOST:\n        cpu->arch = arch;\n        cpu->type = type;\n        break;\n\n    case VIR_CPU_TYPE_GUEST:\n        if (nodeInfo) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"cannot set topology for CPU type '%s'\"),\n                           virCPUTypeToString(type));\n            goto error;\n        }\n        cpu->type = type;\n        break;\n\n    case VIR_CPU_TYPE_AUTO:\n    case VIR_CPU_TYPE_LAST:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported CPU type: %s\"),\n                       virCPUTypeToString(type));\n        goto error;\n    }\n\n    if (nodeInfo) {\n        cpu->sockets = nodeInfo->sockets;\n        cpu->dies = 1;\n        cpu->cores = nodeInfo->cores;\n        cpu->threads = nodeInfo->threads;\n    }\n\n    /* Try to get the host CPU model, but don't really fail if nodeInfo is\n     * filled in.\n     */\n    if (driver->getHost) {\n        if (driver->getHost(cpu, models) < 0 &&\n            !nodeInfo)\n            goto error;\n    } else if (nodeInfo) {\n        VIR_DEBUG(\"cannot detect host CPU model for %s architecture\",\n                  virArchToString(arch));\n    } else {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot detect host CPU model for %s architecture\"),\n                       virArchToString(arch));\n        goto error;\n    }\n\n    return cpu;\n\n error:\n    virCPUDefFree(cpu);\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "cpu"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"cannot detect host CPU model for %s architecture\")",
            "virArchToString(arch)"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot detect host CPU model for %s architecture\""
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cannot detect host CPU model for %s architecture\"",
            "virArchToString(arch)"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver->getHost",
          "args": [
            "cpu",
            "models"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"unsupported CPU type: %s\")",
            "virCPUTypeToString(type)"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUTypeToString",
          "args": [
            "type"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"cannot set topology for CPU type '%s'\")",
            "virCPUTypeToString(type)"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUTypeToString",
          "args": [
            "type"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDefNew",
          "args": [],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "85-90",
          "snippet": "virCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "arch"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s, type=%s, nodeInfo=%p, models=%p\"",
            "virArchToString(arch)",
            "virCPUTypeToString(type)",
            "nodeInfo",
            "models"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUTypeToString",
          "args": [
            "type"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUGetHost(virArch arch,\n              virCPUType type,\n              virNodeInfoPtr nodeInfo,\n              virDomainCapsCPUModelsPtr models)\n{\n    struct cpuArchDriver *driver;\n    virCPUDefPtr cpu = NULL;\n\n    VIR_DEBUG(\"arch=%s, type=%s, nodeInfo=%p, models=%p\",\n              virArchToString(arch), virCPUTypeToString(type), nodeInfo,\n              models);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return NULL;\n\n    cpu = virCPUDefNew();\n\n    switch (type) {\n    case VIR_CPU_TYPE_HOST:\n        cpu->arch = arch;\n        cpu->type = type;\n        break;\n\n    case VIR_CPU_TYPE_GUEST:\n        if (nodeInfo) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"cannot set topology for CPU type '%s'\"),\n                           virCPUTypeToString(type));\n            goto error;\n        }\n        cpu->type = type;\n        break;\n\n    case VIR_CPU_TYPE_AUTO:\n    case VIR_CPU_TYPE_LAST:\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"unsupported CPU type: %s\"),\n                       virCPUTypeToString(type));\n        goto error;\n    }\n\n    if (nodeInfo) {\n        cpu->sockets = nodeInfo->sockets;\n        cpu->dies = 1;\n        cpu->cores = nodeInfo->cores;\n        cpu->threads = nodeInfo->threads;\n    }\n\n    /* Try to get the host CPU model, but don't really fail if nodeInfo is\n     * filled in.\n     */\n    if (driver->getHost) {\n        if (driver->getHost(cpu, models) < 0 &&\n            !nodeInfo)\n            goto error;\n    } else if (nodeInfo) {\n        VIR_DEBUG(\"cannot detect host CPU model for %s architecture\",\n                  virArchToString(arch));\n    } else {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot detect host CPU model for %s architecture\"),\n                       virArchToString(arch));\n        goto error;\n    }\n\n    return cpu;\n\n error:\n    virCPUDefFree(cpu);\n    return NULL;\n}"
  },
  {
    "function_name": "virCPUGetHostIsSupported",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "339-347",
    "snippet": "bool\nvirCPUGetHostIsSupported(virArch arch)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s\", virArchToString(arch));\n\n    return (driver = cpuGetSubDriver(arch)) && driver->getHost;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "arch"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s\"",
            "virArchToString(arch)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nbool\nvirCPUGetHostIsSupported(virArch arch)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s\", virArchToString(arch));\n\n    return (driver = cpuGetSubDriver(arch)) && driver->getHost;\n}"
  },
  {
    "function_name": "virCPUDataFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "313-327",
    "snippet": "void\nvirCPUDataFree(virCPUDataPtr data)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"data=%p\", data);\n\n    if (!data)\n        return;\n\n    if ((driver = cpuGetSubDriver(data->arch)) && driver->dataFree)\n        driver->dataFree(data);\n    else\n        VIR_FREE(data);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "driver->dataFree",
          "args": [
            "data"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "data->arch"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"data=%p\"",
            "data"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvoid\nvirCPUDataFree(virCPUDataPtr data)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"data=%p\", data);\n\n    if (!data)\n        return;\n\n    if ((driver = cpuGetSubDriver(data->arch)) && driver->dataFree)\n        driver->dataFree(data);\n    else\n        VIR_FREE(data);\n}"
  },
  {
    "function_name": "virCPUDataNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "290-301",
    "snippet": "virCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "data"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}"
  },
  {
    "function_name": "cpuEncode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "247-282",
    "snippet": "int\ncpuEncode(virArch arch,\n          const virCPUDef *cpu,\n          virCPUDataPtr *forced,\n          virCPUDataPtr *required,\n          virCPUDataPtr *optional,\n          virCPUDataPtr *disabled,\n          virCPUDataPtr *forbidden,\n          virCPUDataPtr *vendor)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, forced=%p, required=%p, \"\n              \"optional=%p, disabled=%p, forbidden=%p, vendor=%p\",\n              virArchToString(arch), cpu, forced, required,\n              optional, disabled, forbidden, vendor);\n\n    if (!cpu->model) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"no guest CPU model specified\"));\n        return -1;\n    }\n\n    if ((driver = cpuGetSubDriver(arch)) == NULL)\n        return -1;\n\n    if (driver->encode == NULL) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot encode CPU data for %s architecture\"),\n                       virArchToString(arch));\n        return -1;\n    }\n\n    return driver->encode(arch, cpu, forced, required,\n                          optional, disabled, forbidden, vendor);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "driver->encode",
          "args": [
            "arch",
            "cpu",
            "forced",
            "required",
            "optional",
            "disabled",
            "forbidden",
            "vendor"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"cannot encode CPU data for %s architecture\")",
            "virArchToString(arch)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot encode CPU data for %s architecture\""
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "arch"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"no guest CPU model specified\")"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s, cpu=%p, forced=%p, required=%p, \"\n              \"optional=%p, disabled=%p, forbidden=%p, vendor=%p\"",
            "virArchToString(arch)",
            "cpu",
            "forced",
            "required",
            "optional",
            "disabled",
            "forbidden",
            "vendor"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\ncpuEncode(virArch arch,\n          const virCPUDef *cpu,\n          virCPUDataPtr *forced,\n          virCPUDataPtr *required,\n          virCPUDataPtr *optional,\n          virCPUDataPtr *disabled,\n          virCPUDataPtr *forbidden,\n          virCPUDataPtr *vendor)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, forced=%p, required=%p, \"\n              \"optional=%p, disabled=%p, forbidden=%p, vendor=%p\",\n              virArchToString(arch), cpu, forced, required,\n              optional, disabled, forbidden, vendor);\n\n    if (!cpu->model) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"no guest CPU model specified\"));\n        return -1;\n    }\n\n    if ((driver = cpuGetSubDriver(arch)) == NULL)\n        return -1;\n\n    if (driver->encode == NULL) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot encode CPU data for %s architecture\"),\n                       virArchToString(arch));\n        return -1;\n    }\n\n    return driver->encode(arch, cpu, forced, required,\n                          optional, disabled, forbidden, vendor);\n}"
  },
  {
    "function_name": "cpuDecode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "193-225",
    "snippet": "int\ncpuDecode(virCPUDefPtr cpu,\n          const virCPUData *data,\n          virDomainCapsCPUModelsPtr models)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"cpu=%p, data=%p, models=%p\", cpu, data, models);\n    if (models) {\n        size_t i;\n        for (i = 0; i < models->nmodels; i++)\n            VIR_DEBUG(\"models[%zu]=%s\", i, models->models[i].name);\n    }\n\n    if (cpu->type > VIR_CPU_TYPE_GUEST ||\n        cpu->mode != VIR_CPU_MODE_CUSTOM) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"invalid CPU definition stub\"));\n        return -1;\n    }\n\n    if ((driver = cpuGetSubDriver(data->arch)) == NULL)\n        return -1;\n\n    if (driver->decode == NULL) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot decode CPU data for %s architecture\"),\n                       virArchToString(cpu->arch));\n        return -1;\n    }\n\n    return driver->decode(cpu, data, models);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "driver->decode",
          "args": [
            "cpu",
            "data",
            "models"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"cannot decode CPU data for %s architecture\")",
            "virArchToString(cpu->arch)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "cpu->arch"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot decode CPU data for %s architecture\""
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "data->arch"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"invalid CPU definition stub\")"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"models[%zu]=%s\"",
            "i",
            "models->models[i].name"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cpu=%p, data=%p, models=%p\"",
            "cpu",
            "data",
            "models"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\ncpuDecode(virCPUDefPtr cpu,\n          const virCPUData *data,\n          virDomainCapsCPUModelsPtr models)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"cpu=%p, data=%p, models=%p\", cpu, data, models);\n    if (models) {\n        size_t i;\n        for (i = 0; i < models->nmodels; i++)\n            VIR_DEBUG(\"models[%zu]=%s\", i, models->models[i].name);\n    }\n\n    if (cpu->type > VIR_CPU_TYPE_GUEST ||\n        cpu->mode != VIR_CPU_MODE_CUSTOM) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"invalid CPU definition stub\"));\n        return -1;\n    }\n\n    if ((driver = cpuGetSubDriver(data->arch)) == NULL)\n        return -1;\n\n    if (driver->decode == NULL) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot decode CPU data for %s architecture\"),\n                       virArchToString(cpu->arch));\n        return -1;\n    }\n\n    return driver->decode(cpu, data, models);\n}"
  },
  {
    "function_name": "virCPUCompare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "149-171",
    "snippet": "virCPUCompareResult\nvirCPUCompare(virArch arch,\n              virCPUDefPtr host,\n              virCPUDefPtr cpu,\n              bool failIncompatible)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, host=%p, cpu=%p\",\n              virArchToString(arch), host, cpu);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return VIR_CPU_COMPARE_ERROR;\n\n    if (!driver->compare) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot compare CPUs of %s architecture\"),\n                       virArchToString(arch));\n        return VIR_CPU_COMPARE_ERROR;\n    }\n\n    return driver->compare(host, cpu, failIncompatible);\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "driver->compare",
          "args": [
            "host",
            "cpu",
            "failIncompatible"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"cannot compare CPUs of %s architecture\")",
            "virArchToString(arch)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot compare CPUs of %s architecture\""
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuGetSubDriver",
          "args": [
            "arch"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "cpuGetSubDriverByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "74-88",
          "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s, host=%p, cpu=%p\"",
            "virArchToString(arch)",
            "host",
            "cpu"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUCompareResult\nvirCPUCompare(virArch arch,\n              virCPUDefPtr host,\n              virCPUDefPtr cpu,\n              bool failIncompatible)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, host=%p, cpu=%p\",\n              virArchToString(arch), host, cpu);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return VIR_CPU_COMPARE_ERROR;\n\n    if (!driver->compare) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot compare CPUs of %s architecture\"),\n                       virArchToString(arch));\n        return VIR_CPU_COMPARE_ERROR;\n    }\n\n    return driver->compare(host, cpu, failIncompatible);\n}"
  },
  {
    "function_name": "virCPUCompareXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "108-129",
    "snippet": "virCPUCompareResult\nvirCPUCompareXML(virArch arch,\n                 virCPUDefPtr host,\n                 const char *xml,\n                 bool failIncompatible)\n{\n    virCPUDefPtr cpu = NULL;\n    virCPUCompareResult ret = VIR_CPU_COMPARE_ERROR;\n\n    VIR_DEBUG(\"arch=%s, host=%p, xml=%s\",\n              virArchToString(arch), host, NULLSTR(xml));\n\n    if (virCPUDefParseXMLString(xml, VIR_CPU_TYPE_AUTO, &cpu) < 0)\n        goto cleanup;\n\n    ret = virCPUCompare(arch, host, cpu, failIncompatible);\n\n cleanup:\n    virCPUDefFree(cpu);\n\n    return ret;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "cpu"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUCompare",
          "args": [
            "arch",
            "host",
            "cpu",
            "failIncompatible"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUCompare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "149-171",
          "snippet": "virCPUCompareResult\nvirCPUCompare(virArch arch,\n              virCPUDefPtr host,\n              virCPUDefPtr cpu,\n              bool failIncompatible)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, host=%p, cpu=%p\",\n              virArchToString(arch), host, cpu);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return VIR_CPU_COMPARE_ERROR;\n\n    if (!driver->compare) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot compare CPUs of %s architecture\"),\n                       virArchToString(arch));\n        return VIR_CPU_COMPARE_ERROR;\n    }\n\n    return driver->compare(host, cpu, failIncompatible);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUCompareResult\nvirCPUCompare(virArch arch,\n              virCPUDefPtr host,\n              virCPUDefPtr cpu,\n              bool failIncompatible)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, host=%p, cpu=%p\",\n              virArchToString(arch), host, cpu);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return VIR_CPU_COMPARE_ERROR;\n\n    if (!driver->compare) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot compare CPUs of %s architecture\"),\n                       virArchToString(arch));\n        return VIR_CPU_COMPARE_ERROR;\n    }\n\n    return driver->compare(host, cpu, failIncompatible);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefParseXMLString",
          "args": [
            "xml",
            "VIR_CPU_TYPE_AUTO",
            "&cpu"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefParseXMLString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "288-314",
          "snippet": "int\nvirCPUDefParseXMLString(const char *xml,\n                        virCPUType type,\n                        virCPUDefPtr *cpu)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    int ret = -1;\n\n    if (!xml) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"missing CPU definition\"));\n        goto cleanup;\n    }\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"(CPU_definition)\"), &ctxt)))\n        goto cleanup;\n\n    if (virCPUDefParseXML(ctxt, NULL, type, cpu) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    xmlFreeDoc(doc);\n    xmlXPathFreeContext(ctxt);\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirCPUDefParseXMLString(const char *xml,\n                        virCPUType type,\n                        virCPUDefPtr *cpu)\n{\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    int ret = -1;\n\n    if (!xml) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"missing CPU definition\"));\n        goto cleanup;\n    }\n\n    if (!(doc = virXMLParseStringCtxt(xml, _(\"(CPU_definition)\"), &ctxt)))\n        goto cleanup;\n\n    if (virCPUDefParseXML(ctxt, NULL, type, cpu) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    xmlFreeDoc(doc);\n    xmlXPathFreeContext(ctxt);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"arch=%s, host=%p, xml=%s\"",
            "virArchToString(arch)",
            "host",
            "NULLSTR(xml)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "xml"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUCompareResult\nvirCPUCompareXML(virArch arch,\n                 virCPUDefPtr host,\n                 const char *xml,\n                 bool failIncompatible)\n{\n    virCPUDefPtr cpu = NULL;\n    virCPUCompareResult ret = VIR_CPU_COMPARE_ERROR;\n\n    VIR_DEBUG(\"arch=%s, host=%p, xml=%s\",\n              virArchToString(arch), host, NULLSTR(xml));\n\n    if (virCPUDefParseXMLString(xml, VIR_CPU_TYPE_AUTO, &cpu) < 0)\n        goto cleanup;\n\n    ret = virCPUCompare(arch, host, cpu, failIncompatible);\n\n cleanup:\n    virCPUDefFree(cpu);\n\n    return ret;\n}"
  },
  {
    "function_name": "cpuGetSubDriverByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "74-88",
    "snippet": "static struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"CPU driver '%s' does not exist\")",
            "name"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"CPU driver '%s' does not exist\""
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "name",
            "drivers[i]->name"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "drivers"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriverByName(const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        if (STREQ_NULLABLE(name, drivers[i]->name))\n            return drivers[i];\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"CPU driver '%s' does not exist\"),\n                   name);\n    return NULL;\n}"
  },
  {
    "function_name": "cpuGetSubDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
    "lines": "48-71",
    "snippet": "static struct cpuArchDriver *\ncpuGetSubDriver(virArch arch)\n{\n    size_t i;\n    size_t j;\n\n    if (arch == VIR_ARCH_NONE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"undefined hardware architecture\"));\n        return NULL;\n    }\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        for (j = 0; j < drivers[i]->narch; j++) {\n            if (arch == drivers[i]->arch[j])\n                return drivers[i];\n        }\n    }\n\n    virReportError(VIR_ERR_NO_SUPPORT,\n                   _(\"'%s' architecture is not supported by CPU driver\"),\n                   virArchToString(arch));\n    return NULL;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"capabilities.h\"",
      "#include \"cpu_arm.h\"",
      "#include \"cpu_s390.h\"",
      "#include \"cpu_ppc64.h\"",
      "#include \"cpu_x86.h\"",
      "#include \"cpu_map.h\"",
      "#include \"cpu.h\"",
      "#include \"virxml.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "_(\"'%s' architecture is not supported by CPU driver\")",
            "virArchToString(arch)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "arch"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"'%s' architecture is not supported by CPU driver\""
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "drivers"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"undefined hardware architecture\")"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct cpuArchDriver *drivers[] = {\n    &cpuDriverX86,\n    &cpuDriverPPC64,\n    &cpuDriverS390,\n    &cpuDriverArm,\n};\n\nstatic struct cpuArchDriver *\ncpuGetSubDriver(virArch arch)\n{\n    size_t i;\n    size_t j;\n\n    if (arch == VIR_ARCH_NONE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"undefined hardware architecture\"));\n        return NULL;\n    }\n\n    for (i = 0; i < G_N_ELEMENTS(drivers); i++) {\n        for (j = 0; j < drivers[i]->narch; j++) {\n            if (arch == drivers[i]->arch[j])\n                return drivers[i];\n        }\n    }\n\n    virReportError(VIR_ERR_NO_SUPPORT,\n                   _(\"'%s' architecture is not supported by CPU driver\"),\n                   virArchToString(arch));\n    return NULL;\n}"
  }
]