[
  {
    "function_name": "vboxGetNetworkDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "935-942",
    "snippet": "virNetworkDriverPtr vboxGetNetworkDriver(uint32_t uVersion)\n{\n    /* Install gVBoxAPI according to the vbox API version. */\n    int result = 0;\n    installUniformedAPI(gVBoxAPI, result);\n    if (result < 0) return NULL;\n    return &vboxNetworkDriver;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;",
      "virNetworkDriver vboxNetworkDriver = {\n    .connectNumOfNetworks = vboxConnectNumOfNetworks, /* 0.6.4 */\n    .connectListNetworks = vboxConnectListNetworks, /* 0.6.4 */\n    .connectNumOfDefinedNetworks = vboxConnectNumOfDefinedNetworks, /* 0.6.4 */\n    .connectListDefinedNetworks = vboxConnectListDefinedNetworks, /* 0.6.4 */\n    .networkLookupByUUID = vboxNetworkLookupByUUID, /* 0.6.4 */\n    .networkLookupByName = vboxNetworkLookupByName, /* 0.6.4 */\n    .networkCreateXML = vboxNetworkCreateXML, /* 0.6.4 */\n    .networkDefineXML = vboxNetworkDefineXML, /* 0.6.4 */\n    .networkUndefine = vboxNetworkUndefine, /* 0.6.4 */\n    .networkCreate = vboxNetworkCreate, /* 0.6.4 */\n    .networkDestroy = vboxNetworkDestroy, /* 0.6.4 */\n    .networkGetXMLDesc = vboxNetworkGetXMLDesc, /* 0.6.4 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "installUniformedAPI",
          "args": [
            "gVBoxAPI",
            "result"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\nvirNetworkDriver vboxNetworkDriver = {\n    .connectNumOfNetworks = vboxConnectNumOfNetworks, /* 0.6.4 */\n    .connectListNetworks = vboxConnectListNetworks, /* 0.6.4 */\n    .connectNumOfDefinedNetworks = vboxConnectNumOfDefinedNetworks, /* 0.6.4 */\n    .connectListDefinedNetworks = vboxConnectListDefinedNetworks, /* 0.6.4 */\n    .networkLookupByUUID = vboxNetworkLookupByUUID, /* 0.6.4 */\n    .networkLookupByName = vboxNetworkLookupByName, /* 0.6.4 */\n    .networkCreateXML = vboxNetworkCreateXML, /* 0.6.4 */\n    .networkDefineXML = vboxNetworkDefineXML, /* 0.6.4 */\n    .networkUndefine = vboxNetworkUndefine, /* 0.6.4 */\n    .networkCreate = vboxNetworkCreate, /* 0.6.4 */\n    .networkDestroy = vboxNetworkDestroy, /* 0.6.4 */\n    .networkGetXMLDesc = vboxNetworkGetXMLDesc, /* 0.6.4 */\n};\n\nvirNetworkDriverPtr vboxGetNetworkDriver(uint32_t uVersion)\n{\n    /* Install gVBoxAPI according to the vbox API version. */\n    int result = 0;\n    installUniformedAPI(gVBoxAPI, result);\n    if (result < 0) return NULL;\n    return &vboxNetworkDriver;\n}"
  },
  {
    "function_name": "vboxNetworkGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "759-918",
    "snippet": "static char *vboxNetworkGetXMLDesc(virNetworkPtr network, unsigned int flags)\n{\n    vboxDriverPtr data = network->conn->privateData;\n    virNetworkDefPtr def = NULL;\n    virNetworkIPDefPtr ipdef = NULL;\n    char *networkNameUtf8 = NULL;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    PRUint32 interfaceType = 0;\n    PRUnichar *networkNameUtf16 = NULL;\n    IDHCPServer *dhcpServer = NULL;\n    vboxIID vboxnet0IID;\n    IHost *host = NULL;\n    char *ret = NULL;\n    nsresult rc;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&vboxnet0IID);\n    virCheckFlags(0, NULL);\n\n    if (VIR_ALLOC(def) < 0)\n        goto cleanup;\n    if (VIR_ALLOC(ipdef) < 0)\n        goto cleanup;\n    def->ips = ipdef;\n    def->nips = 1;\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\", network->name);\n\n    VBOX_UTF8_TO_UTF16(network->name, &networkInterfaceNameUtf16);\n\n    gVBoxAPI.UIHost.FindHostNetworkInterfaceByName(host, networkInterfaceNameUtf16, &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n    if (interfaceType != HostNetworkInterfaceType_HostOnly)\n        goto cleanup;\n\n    def->name = g_strdup(network->name);\n\n    rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &vboxnet0IID);\n    if (NS_FAILED(rc))\n        goto cleanup;\n    vboxIIDToUUID(&vboxnet0IID, def->uuid);\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    def->forward.type = VIR_NETWORK_FORWARD_NONE;\n\n    gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                      networkNameUtf16,\n                                                      &dhcpServer);\n    if (dhcpServer) {\n        ipdef->nranges = 1;\n        if (VIR_ALLOC_N(ipdef->ranges, ipdef->nranges) >= 0) {\n            PRUnichar *ipAddressUtf16 = NULL;\n            PRUnichar *networkMaskUtf16 = NULL;\n            PRUnichar *fromIPAddressUtf16 = NULL;\n            PRUnichar *toIPAddressUtf16 = NULL;\n            bool errorOccurred = false;\n\n            gVBoxAPI.UIDHCPServer.GetIPAddress(dhcpServer, &ipAddressUtf16);\n            gVBoxAPI.UIDHCPServer.GetNetworkMask(dhcpServer, &networkMaskUtf16);\n            gVBoxAPI.UIDHCPServer.GetLowerIP(dhcpServer, &fromIPAddressUtf16);\n            gVBoxAPI.UIDHCPServer.GetUpperIP(dhcpServer, &toIPAddressUtf16);\n            /* Currently virtualbox supports only one dhcp server per network\n             * with contigious address space from start to end\n             */\n            if (vboxSocketParseAddrUtf16(data, ipAddressUtf16,\n                                         &ipdef->address) < 0 ||\n                vboxSocketParseAddrUtf16(data, networkMaskUtf16,\n                                         &ipdef->netmask) < 0 ||\n                vboxSocketParseAddrUtf16(data, fromIPAddressUtf16,\n                                         &ipdef->ranges[0].start) < 0 ||\n                vboxSocketParseAddrUtf16(data, toIPAddressUtf16,\n                                         &ipdef->ranges[0].end) < 0) {\n                errorOccurred = true;\n            }\n\n            VBOX_UTF16_FREE(ipAddressUtf16);\n            VBOX_UTF16_FREE(networkMaskUtf16);\n            VBOX_UTF16_FREE(fromIPAddressUtf16);\n            VBOX_UTF16_FREE(toIPAddressUtf16);\n\n            if (errorOccurred)\n                goto cleanup;\n        } else {\n            ipdef->nranges = 0;\n        }\n\n        ipdef->nhosts = 1;\n        if (VIR_ALLOC_N(ipdef->hosts, ipdef->nhosts) >= 0) {\n            PRUnichar *macAddressUtf16 = NULL;\n            PRUnichar *ipAddressUtf16 = NULL;\n            bool errorOccurred = false;\n\n            ipdef->hosts[0].name = g_strdup(network->name);\n            gVBoxAPI.UIHNInterface.GetHardwareAddress(networkInterface, &macAddressUtf16);\n            gVBoxAPI.UIHNInterface.GetIPAddress(networkInterface, &ipAddressUtf16);\n\n            VBOX_UTF16_TO_UTF8(macAddressUtf16, &ipdef->hosts[0].mac);\n\n            if (vboxSocketParseAddrUtf16(data, ipAddressUtf16,\n                                         &ipdef->hosts[0].ip) < 0) {\n                errorOccurred = true;\n            }\n\n            VBOX_UTF16_FREE(macAddressUtf16);\n            VBOX_UTF16_FREE(ipAddressUtf16);\n\n            if (errorOccurred)\n                goto cleanup;\n        } else {\n            ipdef->nhosts = 0;\n        }\n    } else {\n        PRUnichar *networkMaskUtf16 = NULL;\n        PRUnichar *ipAddressUtf16 = NULL;\n        bool errorOccurred = false;\n\n        gVBoxAPI.UIHNInterface.GetNetworkMask(networkInterface, &networkMaskUtf16);\n        gVBoxAPI.UIHNInterface.GetIPAddress(networkInterface, &ipAddressUtf16);\n\n        if (vboxSocketParseAddrUtf16(data, networkMaskUtf16,\n                                     &ipdef->netmask) < 0 ||\n            vboxSocketParseAddrUtf16(data, ipAddressUtf16,\n                                     &ipdef->address) < 0) {\n            errorOccurred = true;\n        }\n\n        VBOX_UTF16_FREE(networkMaskUtf16);\n        VBOX_UTF16_FREE(ipAddressUtf16);\n\n        if (errorOccurred)\n            goto cleanup;\n    }\n\n    DEBUGIID(\"Network UUID\", &vboxnet0IID);\n    ret = virNetworkDefFormat(def, NULL, 0);\n\n cleanup:\n    vboxIIDUnalloc(&vboxnet0IID);\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    virNetworkDefFree(def);\n    VIR_FREE(networkNameUtf8);\n    VBOX_RELEASE(dhcpServer);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "dhcpServer"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "networkNameUtf8"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefFree",
          "args": [
            "def"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "235-274",
          "snippet": "void\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "host"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "networkInterfaceNameUtf16"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "networkInterface"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "networkNameUtf16"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&vboxnet0IID"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefFormat",
          "args": [
            "def",
            "NULL",
            "0"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2673-2688",
          "snippet": "char *\nvirNetworkDefFormat(const virNetworkDef *def,\n                    virNetworkXMLOptionPtr xmlopt,\n                    unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkDefFormatBuf(&buf, def, xmlopt, flags) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirNetworkDefFormat(const virNetworkDef *def,\n                    virNetworkXMLOptionPtr xmlopt,\n                    unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virNetworkDefFormatBuf(&buf, def, xmlopt, flags) < 0)\n        goto error;\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUGIID",
          "args": [
            "\"Network UUID\"",
            "&vboxnet0IID"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "ipAddressUtf16"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "networkMaskUtf16"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxSocketParseAddrUtf16",
          "args": [
            "data",
            "ipAddressUtf16",
            "&ipdef->address"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "vboxSocketParseAddrUtf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
          "lines": "739-757",
          "snippet": "static int\nvboxSocketParseAddrUtf16(vboxDriverPtr data, const PRUnichar *utf16,\n                         virSocketAddrPtr addr)\n{\n    int result = -1;\n    char *utf8 = NULL;\n\n    VBOX_UTF16_TO_UTF8(utf16, &utf8);\n\n    if (virSocketAddrParse(addr, utf8, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    VBOX_UTF8_FREE(utf8);\n\n    return result;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"network_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvboxSocketParseAddrUtf16(vboxDriverPtr data, const PRUnichar *utf16,\n                         virSocketAddrPtr addr)\n{\n    int result = -1;\n    char *utf8 = NULL;\n\n    VBOX_UTF16_TO_UTF8(utf16, &utf8);\n\n    if (virSocketAddrParse(addr, utf8, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    VBOX_UTF8_FREE(utf8);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetIPAddress",
          "args": [
            "networkInterface",
            "&ipAddressUtf16"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetNetworkMask",
          "args": [
            "networkInterface",
            "&networkMaskUtf16"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "ipAddressUtf16"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "macAddressUtf16"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "macAddressUtf16",
            "&ipdef->hosts[0].mac"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetIPAddress",
          "args": [
            "networkInterface",
            "&ipAddressUtf16"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetHardwareAddress",
          "args": [
            "networkInterface",
            "&macAddressUtf16"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "network->name"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ipdef->hosts",
            "ipdef->nhosts"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "toIPAddressUtf16"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "fromIPAddressUtf16"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "networkMaskUtf16"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "ipAddressUtf16"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIDHCPServer.GetUpperIP",
          "args": [
            "dhcpServer",
            "&toIPAddressUtf16"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIDHCPServer.GetLowerIP",
          "args": [
            "dhcpServer",
            "&fromIPAddressUtf16"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIDHCPServer.GetNetworkMask",
          "args": [
            "dhcpServer",
            "&networkMaskUtf16"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIDHCPServer.GetIPAddress",
          "args": [
            "dhcpServer",
            "&ipAddressUtf16"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "ipdef->ranges",
            "ipdef->nranges"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName",
          "args": [
            "data->vboxObj",
            "networkNameUtf16",
            "&dhcpServer"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "networkNameUtf8",
            "&networkNameUtf16"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDToUUID",
          "args": [
            "&vboxnet0IID",
            "def->uuid"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetId",
          "args": [
            "networkInterface",
            "&vboxnet0IID"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetInterfaceType",
          "args": [
            "networkInterface",
            "&interfaceType"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHost.FindHostNetworkInterfaceByName",
          "args": [
            "host",
            "networkInterfaceNameUtf16",
            "&networkInterface"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "network->name",
            "&networkInterfaceNameUtf16"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ipdef"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&vboxnet0IID"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetHost",
          "args": [
            "data->vboxObj",
            "&host"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic char *vboxNetworkGetXMLDesc(virNetworkPtr network, unsigned int flags)\n{\n    vboxDriverPtr data = network->conn->privateData;\n    virNetworkDefPtr def = NULL;\n    virNetworkIPDefPtr ipdef = NULL;\n    char *networkNameUtf8 = NULL;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    PRUint32 interfaceType = 0;\n    PRUnichar *networkNameUtf16 = NULL;\n    IDHCPServer *dhcpServer = NULL;\n    vboxIID vboxnet0IID;\n    IHost *host = NULL;\n    char *ret = NULL;\n    nsresult rc;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&vboxnet0IID);\n    virCheckFlags(0, NULL);\n\n    if (VIR_ALLOC(def) < 0)\n        goto cleanup;\n    if (VIR_ALLOC(ipdef) < 0)\n        goto cleanup;\n    def->ips = ipdef;\n    def->nips = 1;\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\", network->name);\n\n    VBOX_UTF8_TO_UTF16(network->name, &networkInterfaceNameUtf16);\n\n    gVBoxAPI.UIHost.FindHostNetworkInterfaceByName(host, networkInterfaceNameUtf16, &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n    if (interfaceType != HostNetworkInterfaceType_HostOnly)\n        goto cleanup;\n\n    def->name = g_strdup(network->name);\n\n    rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &vboxnet0IID);\n    if (NS_FAILED(rc))\n        goto cleanup;\n    vboxIIDToUUID(&vboxnet0IID, def->uuid);\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    def->forward.type = VIR_NETWORK_FORWARD_NONE;\n\n    gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                      networkNameUtf16,\n                                                      &dhcpServer);\n    if (dhcpServer) {\n        ipdef->nranges = 1;\n        if (VIR_ALLOC_N(ipdef->ranges, ipdef->nranges) >= 0) {\n            PRUnichar *ipAddressUtf16 = NULL;\n            PRUnichar *networkMaskUtf16 = NULL;\n            PRUnichar *fromIPAddressUtf16 = NULL;\n            PRUnichar *toIPAddressUtf16 = NULL;\n            bool errorOccurred = false;\n\n            gVBoxAPI.UIDHCPServer.GetIPAddress(dhcpServer, &ipAddressUtf16);\n            gVBoxAPI.UIDHCPServer.GetNetworkMask(dhcpServer, &networkMaskUtf16);\n            gVBoxAPI.UIDHCPServer.GetLowerIP(dhcpServer, &fromIPAddressUtf16);\n            gVBoxAPI.UIDHCPServer.GetUpperIP(dhcpServer, &toIPAddressUtf16);\n            /* Currently virtualbox supports only one dhcp server per network\n             * with contigious address space from start to end\n             */\n            if (vboxSocketParseAddrUtf16(data, ipAddressUtf16,\n                                         &ipdef->address) < 0 ||\n                vboxSocketParseAddrUtf16(data, networkMaskUtf16,\n                                         &ipdef->netmask) < 0 ||\n                vboxSocketParseAddrUtf16(data, fromIPAddressUtf16,\n                                         &ipdef->ranges[0].start) < 0 ||\n                vboxSocketParseAddrUtf16(data, toIPAddressUtf16,\n                                         &ipdef->ranges[0].end) < 0) {\n                errorOccurred = true;\n            }\n\n            VBOX_UTF16_FREE(ipAddressUtf16);\n            VBOX_UTF16_FREE(networkMaskUtf16);\n            VBOX_UTF16_FREE(fromIPAddressUtf16);\n            VBOX_UTF16_FREE(toIPAddressUtf16);\n\n            if (errorOccurred)\n                goto cleanup;\n        } else {\n            ipdef->nranges = 0;\n        }\n\n        ipdef->nhosts = 1;\n        if (VIR_ALLOC_N(ipdef->hosts, ipdef->nhosts) >= 0) {\n            PRUnichar *macAddressUtf16 = NULL;\n            PRUnichar *ipAddressUtf16 = NULL;\n            bool errorOccurred = false;\n\n            ipdef->hosts[0].name = g_strdup(network->name);\n            gVBoxAPI.UIHNInterface.GetHardwareAddress(networkInterface, &macAddressUtf16);\n            gVBoxAPI.UIHNInterface.GetIPAddress(networkInterface, &ipAddressUtf16);\n\n            VBOX_UTF16_TO_UTF8(macAddressUtf16, &ipdef->hosts[0].mac);\n\n            if (vboxSocketParseAddrUtf16(data, ipAddressUtf16,\n                                         &ipdef->hosts[0].ip) < 0) {\n                errorOccurred = true;\n            }\n\n            VBOX_UTF16_FREE(macAddressUtf16);\n            VBOX_UTF16_FREE(ipAddressUtf16);\n\n            if (errorOccurred)\n                goto cleanup;\n        } else {\n            ipdef->nhosts = 0;\n        }\n    } else {\n        PRUnichar *networkMaskUtf16 = NULL;\n        PRUnichar *ipAddressUtf16 = NULL;\n        bool errorOccurred = false;\n\n        gVBoxAPI.UIHNInterface.GetNetworkMask(networkInterface, &networkMaskUtf16);\n        gVBoxAPI.UIHNInterface.GetIPAddress(networkInterface, &ipAddressUtf16);\n\n        if (vboxSocketParseAddrUtf16(data, networkMaskUtf16,\n                                     &ipdef->netmask) < 0 ||\n            vboxSocketParseAddrUtf16(data, ipAddressUtf16,\n                                     &ipdef->address) < 0) {\n            errorOccurred = true;\n        }\n\n        VBOX_UTF16_FREE(networkMaskUtf16);\n        VBOX_UTF16_FREE(ipAddressUtf16);\n\n        if (errorOccurred)\n            goto cleanup;\n    }\n\n    DEBUGIID(\"Network UUID\", &vboxnet0IID);\n    ret = virNetworkDefFormat(def, NULL, 0);\n\n cleanup:\n    vboxIIDUnalloc(&vboxnet0IID);\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    virNetworkDefFree(def);\n    VIR_FREE(networkNameUtf8);\n    VBOX_RELEASE(dhcpServer);\n    return ret;\n}"
  },
  {
    "function_name": "vboxSocketParseAddrUtf16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "739-757",
    "snippet": "static int\nvboxSocketParseAddrUtf16(vboxDriverPtr data, const PRUnichar *utf16,\n                         virSocketAddrPtr addr)\n{\n    int result = -1;\n    char *utf8 = NULL;\n\n    VBOX_UTF16_TO_UTF8(utf16, &utf8);\n\n    if (virSocketAddrParse(addr, utf8, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    VBOX_UTF8_FREE(utf8);\n\n    return result;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "utf8"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrParse",
          "args": [
            "addr",
            "utf8",
            "AF_UNSPEC"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "135-158",
          "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "utf16",
            "&utf8"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nvboxSocketParseAddrUtf16(vboxDriverPtr data, const PRUnichar *utf16,\n                         virSocketAddrPtr addr)\n{\n    int result = -1;\n    char *utf8 = NULL;\n\n    VBOX_UTF16_TO_UTF8(utf16, &utf8);\n\n    if (virSocketAddrParse(addr, utf8, AF_UNSPEC) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    VBOX_UTF8_FREE(utf8);\n\n    return result;\n}"
  },
  {
    "function_name": "vboxNetworkCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "668-737",
    "snippet": "static int vboxNetworkCreate(virNetworkPtr network)\n{\n    vboxDriverPtr data = network->conn->privateData;\n    char *networkNameUtf8 = NULL;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    PRUnichar *networkNameUtf16 = NULL;\n    IDHCPServer *dhcpServer = NULL;\n    PRUnichar *trunkTypeUtf16 = NULL;\n    PRUint32 interfaceType = 0;\n    IHost *host = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    /* Current limitation of the function for VirtualBox 2.2.* is\n     * that the default hostonly network \"vboxnet0\" is always active\n     * and thus all this functions does is start the dhcp server,\n     * but the network can still be used without starting the dhcp\n     * server by giving the machine static IP\n     */\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\", network->name);\n\n    VBOX_UTF8_TO_UTF16(network->name, &networkInterfaceNameUtf16);\n\n    gVBoxAPI.UIHost.FindHostNetworkInterfaceByName(host, networkInterfaceNameUtf16, &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n    if (interfaceType != HostNetworkInterfaceType_HostOnly)\n        goto cleanup;\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                      networkNameUtf16,\n                                                      &dhcpServer);\n    if (!dhcpServer)\n        goto cleanup;\n\n    gVBoxAPI.UIDHCPServer.SetEnabled(dhcpServer, PR_TRUE);\n\n    VBOX_UTF8_TO_UTF16(\"netflt\", &trunkTypeUtf16);\n\n    gVBoxAPI.UIDHCPServer.Start(dhcpServer,\n                                networkNameUtf16,\n                                networkInterfaceNameUtf16,\n                                trunkTypeUtf16);\n\n    VBOX_UTF16_FREE(trunkTypeUtf16);\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(dhcpServer);\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    VIR_FREE(networkNameUtf8);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "networkNameUtf8"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "host"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "networkInterfaceNameUtf16"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "networkInterface"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "networkNameUtf16"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "dhcpServer"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "trunkTypeUtf16"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIDHCPServer.Start",
          "args": [
            "dhcpServer",
            "networkNameUtf16",
            "networkInterfaceNameUtf16",
            "trunkTypeUtf16"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"netflt\"",
            "&trunkTypeUtf16"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIDHCPServer.SetEnabled",
          "args": [
            "dhcpServer",
            "PR_TRUE"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName",
          "args": [
            "data->vboxObj",
            "networkNameUtf16",
            "&dhcpServer"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "networkNameUtf8",
            "&networkNameUtf16"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetInterfaceType",
          "args": [
            "networkInterface",
            "&interfaceType"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHost.FindHostNetworkInterfaceByName",
          "args": [
            "host",
            "networkInterfaceNameUtf16",
            "&networkInterface"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "network->name",
            "&networkInterfaceNameUtf16"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"HostInterfaceNetworking-%s\"",
            "network->name"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetHost",
          "args": [
            "data->vboxObj",
            "&host"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxNetworkCreate(virNetworkPtr network)\n{\n    vboxDriverPtr data = network->conn->privateData;\n    char *networkNameUtf8 = NULL;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    PRUnichar *networkNameUtf16 = NULL;\n    IDHCPServer *dhcpServer = NULL;\n    PRUnichar *trunkTypeUtf16 = NULL;\n    PRUint32 interfaceType = 0;\n    IHost *host = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    /* Current limitation of the function for VirtualBox 2.2.* is\n     * that the default hostonly network \"vboxnet0\" is always active\n     * and thus all this functions does is start the dhcp server,\n     * but the network can still be used without starting the dhcp\n     * server by giving the machine static IP\n     */\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\", network->name);\n\n    VBOX_UTF8_TO_UTF16(network->name, &networkInterfaceNameUtf16);\n\n    gVBoxAPI.UIHost.FindHostNetworkInterfaceByName(host, networkInterfaceNameUtf16, &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n    if (interfaceType != HostNetworkInterfaceType_HostOnly)\n        goto cleanup;\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                      networkNameUtf16,\n                                                      &dhcpServer);\n    if (!dhcpServer)\n        goto cleanup;\n\n    gVBoxAPI.UIDHCPServer.SetEnabled(dhcpServer, PR_TRUE);\n\n    VBOX_UTF8_TO_UTF16(\"netflt\", &trunkTypeUtf16);\n\n    gVBoxAPI.UIDHCPServer.Start(dhcpServer,\n                                networkNameUtf16,\n                                networkInterfaceNameUtf16,\n                                trunkTypeUtf16);\n\n    VBOX_UTF16_FREE(trunkTypeUtf16);\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(dhcpServer);\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    VIR_FREE(networkNameUtf8);\n    return ret;\n}"
  },
  {
    "function_name": "vboxNetworkDestroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "663-666",
    "snippet": "static int vboxNetworkDestroy(virNetworkPtr network)\n{\n    return vboxNetworkUndefineDestroy(network, false);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxNetworkUndefineDestroy",
          "args": [
            "network",
            "false"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "vboxNetworkUndefineDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
          "lines": "563-656",
          "snippet": "static int\nvboxNetworkUndefineDestroy(virNetworkPtr network, bool removeinterface)\n{\n    vboxDriverPtr data = network->conn->privateData;\n    char *networkNameUtf8 = NULL;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    PRUnichar *networkNameUtf16 = NULL;\n    IDHCPServer *dhcpServer = NULL;\n    PRUint32 interfaceType = 0;\n    IHost *host = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    /* Current limitation of the function for VirtualBox 2.2.* is\n     * that you can't delete the default hostonly adaptor namely:\n     * vboxnet0 and thus all this functions does is remove the\n     * dhcp server configuration, but the network can still be used\n     * by giving the machine static IP and also it will still\n     * show up in the net-list in virsh\n     */\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\", network->name);\n\n    VBOX_UTF8_TO_UTF16(network->name, &networkInterfaceNameUtf16);\n\n    gVBoxAPI.UIHost.FindHostNetworkInterfaceByName(host, networkInterfaceNameUtf16, &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n    if (interfaceType != HostNetworkInterfaceType_HostOnly)\n        goto cleanup;\n\n    if (removeinterface) {\n        vboxIID iid;\n        IProgress *progress = NULL;\n        nsresult rc;\n        resultCodeUnion resultCode;\n\n        VBOX_IID_INITIALIZE(&iid);\n        rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &iid);\n\n        if (NS_FAILED(rc))\n            goto cleanup;\n\n        gVBoxAPI.UIHost.RemoveHostOnlyNetworkInterface(host, &iid, &progress);\n        vboxIIDUnalloc(&iid);\n\n        if (!progress)\n            goto cleanup;\n\n        gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n        gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n        if (RC_FAILED(resultCode)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Error while removing hostonly network interface, rc=%08x\"),\n                           resultCode.uResultCode);\n            goto cleanup;\n        }\n        VBOX_RELEASE(progress);\n    }\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                      networkNameUtf16,\n                                                      &dhcpServer);\n    if (!dhcpServer)\n        goto cleanup;\n\n    gVBoxAPI.UIDHCPServer.SetEnabled(dhcpServer, PR_FALSE);\n    gVBoxAPI.UIDHCPServer.Stop(dhcpServer);\n    if (removeinterface)\n        gVBoxAPI.UIVirtualBox.RemoveDHCPServer(data->vboxObj, dhcpServer);\n    ret = 0;\n    VBOX_RELEASE(dhcpServer);\n\n cleanup:\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    VIR_FREE(networkNameUtf8);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"network_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxNetworkUndefineDestroy(virNetworkPtr network, bool removeinterface)\n{\n    vboxDriverPtr data = network->conn->privateData;\n    char *networkNameUtf8 = NULL;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    PRUnichar *networkNameUtf16 = NULL;\n    IDHCPServer *dhcpServer = NULL;\n    PRUint32 interfaceType = 0;\n    IHost *host = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    /* Current limitation of the function for VirtualBox 2.2.* is\n     * that you can't delete the default hostonly adaptor namely:\n     * vboxnet0 and thus all this functions does is remove the\n     * dhcp server configuration, but the network can still be used\n     * by giving the machine static IP and also it will still\n     * show up in the net-list in virsh\n     */\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\", network->name);\n\n    VBOX_UTF8_TO_UTF16(network->name, &networkInterfaceNameUtf16);\n\n    gVBoxAPI.UIHost.FindHostNetworkInterfaceByName(host, networkInterfaceNameUtf16, &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n    if (interfaceType != HostNetworkInterfaceType_HostOnly)\n        goto cleanup;\n\n    if (removeinterface) {\n        vboxIID iid;\n        IProgress *progress = NULL;\n        nsresult rc;\n        resultCodeUnion resultCode;\n\n        VBOX_IID_INITIALIZE(&iid);\n        rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &iid);\n\n        if (NS_FAILED(rc))\n            goto cleanup;\n\n        gVBoxAPI.UIHost.RemoveHostOnlyNetworkInterface(host, &iid, &progress);\n        vboxIIDUnalloc(&iid);\n\n        if (!progress)\n            goto cleanup;\n\n        gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n        gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n        if (RC_FAILED(resultCode)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Error while removing hostonly network interface, rc=%08x\"),\n                           resultCode.uResultCode);\n            goto cleanup;\n        }\n        VBOX_RELEASE(progress);\n    }\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                      networkNameUtf16,\n                                                      &dhcpServer);\n    if (!dhcpServer)\n        goto cleanup;\n\n    gVBoxAPI.UIDHCPServer.SetEnabled(dhcpServer, PR_FALSE);\n    gVBoxAPI.UIDHCPServer.Stop(dhcpServer);\n    if (removeinterface)\n        gVBoxAPI.UIVirtualBox.RemoveDHCPServer(data->vboxObj, dhcpServer);\n    ret = 0;\n    VBOX_RELEASE(dhcpServer);\n\n cleanup:\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    VIR_FREE(networkNameUtf8);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int vboxNetworkDestroy(virNetworkPtr network)\n{\n    return vboxNetworkUndefineDestroy(network, false);\n}"
  },
  {
    "function_name": "vboxNetworkUndefine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "658-661",
    "snippet": "static int vboxNetworkUndefine(virNetworkPtr network)\n{\n    return vboxNetworkUndefineDestroy(network, true);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxNetworkUndefineDestroy",
          "args": [
            "network",
            "true"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "vboxNetworkUndefineDestroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
          "lines": "563-656",
          "snippet": "static int\nvboxNetworkUndefineDestroy(virNetworkPtr network, bool removeinterface)\n{\n    vboxDriverPtr data = network->conn->privateData;\n    char *networkNameUtf8 = NULL;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    PRUnichar *networkNameUtf16 = NULL;\n    IDHCPServer *dhcpServer = NULL;\n    PRUint32 interfaceType = 0;\n    IHost *host = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    /* Current limitation of the function for VirtualBox 2.2.* is\n     * that you can't delete the default hostonly adaptor namely:\n     * vboxnet0 and thus all this functions does is remove the\n     * dhcp server configuration, but the network can still be used\n     * by giving the machine static IP and also it will still\n     * show up in the net-list in virsh\n     */\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\", network->name);\n\n    VBOX_UTF8_TO_UTF16(network->name, &networkInterfaceNameUtf16);\n\n    gVBoxAPI.UIHost.FindHostNetworkInterfaceByName(host, networkInterfaceNameUtf16, &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n    if (interfaceType != HostNetworkInterfaceType_HostOnly)\n        goto cleanup;\n\n    if (removeinterface) {\n        vboxIID iid;\n        IProgress *progress = NULL;\n        nsresult rc;\n        resultCodeUnion resultCode;\n\n        VBOX_IID_INITIALIZE(&iid);\n        rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &iid);\n\n        if (NS_FAILED(rc))\n            goto cleanup;\n\n        gVBoxAPI.UIHost.RemoveHostOnlyNetworkInterface(host, &iid, &progress);\n        vboxIIDUnalloc(&iid);\n\n        if (!progress)\n            goto cleanup;\n\n        gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n        gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n        if (RC_FAILED(resultCode)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Error while removing hostonly network interface, rc=%08x\"),\n                           resultCode.uResultCode);\n            goto cleanup;\n        }\n        VBOX_RELEASE(progress);\n    }\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                      networkNameUtf16,\n                                                      &dhcpServer);\n    if (!dhcpServer)\n        goto cleanup;\n\n    gVBoxAPI.UIDHCPServer.SetEnabled(dhcpServer, PR_FALSE);\n    gVBoxAPI.UIDHCPServer.Stop(dhcpServer);\n    if (removeinterface)\n        gVBoxAPI.UIVirtualBox.RemoveDHCPServer(data->vboxObj, dhcpServer);\n    ret = 0;\n    VBOX_RELEASE(dhcpServer);\n\n cleanup:\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    VIR_FREE(networkNameUtf8);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"network_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxNetworkUndefineDestroy(virNetworkPtr network, bool removeinterface)\n{\n    vboxDriverPtr data = network->conn->privateData;\n    char *networkNameUtf8 = NULL;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    PRUnichar *networkNameUtf16 = NULL;\n    IDHCPServer *dhcpServer = NULL;\n    PRUint32 interfaceType = 0;\n    IHost *host = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    /* Current limitation of the function for VirtualBox 2.2.* is\n     * that you can't delete the default hostonly adaptor namely:\n     * vboxnet0 and thus all this functions does is remove the\n     * dhcp server configuration, but the network can still be used\n     * by giving the machine static IP and also it will still\n     * show up in the net-list in virsh\n     */\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\", network->name);\n\n    VBOX_UTF8_TO_UTF16(network->name, &networkInterfaceNameUtf16);\n\n    gVBoxAPI.UIHost.FindHostNetworkInterfaceByName(host, networkInterfaceNameUtf16, &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n    if (interfaceType != HostNetworkInterfaceType_HostOnly)\n        goto cleanup;\n\n    if (removeinterface) {\n        vboxIID iid;\n        IProgress *progress = NULL;\n        nsresult rc;\n        resultCodeUnion resultCode;\n\n        VBOX_IID_INITIALIZE(&iid);\n        rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &iid);\n\n        if (NS_FAILED(rc))\n            goto cleanup;\n\n        gVBoxAPI.UIHost.RemoveHostOnlyNetworkInterface(host, &iid, &progress);\n        vboxIIDUnalloc(&iid);\n\n        if (!progress)\n            goto cleanup;\n\n        gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n        gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n        if (RC_FAILED(resultCode)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Error while removing hostonly network interface, rc=%08x\"),\n                           resultCode.uResultCode);\n            goto cleanup;\n        }\n        VBOX_RELEASE(progress);\n    }\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                      networkNameUtf16,\n                                                      &dhcpServer);\n    if (!dhcpServer)\n        goto cleanup;\n\n    gVBoxAPI.UIDHCPServer.SetEnabled(dhcpServer, PR_FALSE);\n    gVBoxAPI.UIDHCPServer.Stop(dhcpServer);\n    if (removeinterface)\n        gVBoxAPI.UIVirtualBox.RemoveDHCPServer(data->vboxObj, dhcpServer);\n    ret = 0;\n    VBOX_RELEASE(dhcpServer);\n\n cleanup:\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    VIR_FREE(networkNameUtf8);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int vboxNetworkUndefine(virNetworkPtr network)\n{\n    return vboxNetworkUndefineDestroy(network, true);\n}"
  },
  {
    "function_name": "vboxNetworkUndefineDestroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "563-656",
    "snippet": "static int\nvboxNetworkUndefineDestroy(virNetworkPtr network, bool removeinterface)\n{\n    vboxDriverPtr data = network->conn->privateData;\n    char *networkNameUtf8 = NULL;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    PRUnichar *networkNameUtf16 = NULL;\n    IDHCPServer *dhcpServer = NULL;\n    PRUint32 interfaceType = 0;\n    IHost *host = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    /* Current limitation of the function for VirtualBox 2.2.* is\n     * that you can't delete the default hostonly adaptor namely:\n     * vboxnet0 and thus all this functions does is remove the\n     * dhcp server configuration, but the network can still be used\n     * by giving the machine static IP and also it will still\n     * show up in the net-list in virsh\n     */\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\", network->name);\n\n    VBOX_UTF8_TO_UTF16(network->name, &networkInterfaceNameUtf16);\n\n    gVBoxAPI.UIHost.FindHostNetworkInterfaceByName(host, networkInterfaceNameUtf16, &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n    if (interfaceType != HostNetworkInterfaceType_HostOnly)\n        goto cleanup;\n\n    if (removeinterface) {\n        vboxIID iid;\n        IProgress *progress = NULL;\n        nsresult rc;\n        resultCodeUnion resultCode;\n\n        VBOX_IID_INITIALIZE(&iid);\n        rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &iid);\n\n        if (NS_FAILED(rc))\n            goto cleanup;\n\n        gVBoxAPI.UIHost.RemoveHostOnlyNetworkInterface(host, &iid, &progress);\n        vboxIIDUnalloc(&iid);\n\n        if (!progress)\n            goto cleanup;\n\n        gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n        gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n        if (RC_FAILED(resultCode)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Error while removing hostonly network interface, rc=%08x\"),\n                           resultCode.uResultCode);\n            goto cleanup;\n        }\n        VBOX_RELEASE(progress);\n    }\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                      networkNameUtf16,\n                                                      &dhcpServer);\n    if (!dhcpServer)\n        goto cleanup;\n\n    gVBoxAPI.UIDHCPServer.SetEnabled(dhcpServer, PR_FALSE);\n    gVBoxAPI.UIDHCPServer.Stop(dhcpServer);\n    if (removeinterface)\n        gVBoxAPI.UIVirtualBox.RemoveDHCPServer(data->vboxObj, dhcpServer);\n    ret = 0;\n    VBOX_RELEASE(dhcpServer);\n\n cleanup:\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    VIR_FREE(networkNameUtf8);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "networkNameUtf8"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "host"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "networkInterfaceNameUtf16"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "networkInterface"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "networkNameUtf16"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "dhcpServer"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.RemoveDHCPServer",
          "args": [
            "data->vboxObj",
            "dhcpServer"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIDHCPServer.Stop",
          "args": [
            "dhcpServer"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIDHCPServer.SetEnabled",
          "args": [
            "dhcpServer",
            "PR_FALSE"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName",
          "args": [
            "data->vboxObj",
            "networkNameUtf16",
            "&dhcpServer"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "networkNameUtf8",
            "&networkNameUtf16"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "progress"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Error while removing hostonly network interface, rc=%08x\")",
            "resultCode.uResultCode"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Error while removing hostonly network interface, rc=%08x\""
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RC_FAILED",
          "args": [
            "resultCode"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.GetResultCode",
          "args": [
            "progress",
            "&resultCode"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.WaitForCompletion",
          "args": [
            "progress",
            "-1"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHost.RemoveHostOnlyNetworkInterface",
          "args": [
            "host",
            "&iid",
            "&progress"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetId",
          "args": [
            "networkInterface",
            "&iid"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetInterfaceType",
          "args": [
            "networkInterface",
            "&interfaceType"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHost.FindHostNetworkInterfaceByName",
          "args": [
            "host",
            "networkInterfaceNameUtf16",
            "&networkInterface"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "network->name",
            "&networkInterfaceNameUtf16"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"HostInterfaceNetworking-%s\"",
            "network->name"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetHost",
          "args": [
            "data->vboxObj",
            "&host"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxNetworkUndefineDestroy(virNetworkPtr network, bool removeinterface)\n{\n    vboxDriverPtr data = network->conn->privateData;\n    char *networkNameUtf8 = NULL;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    PRUnichar *networkNameUtf16 = NULL;\n    IDHCPServer *dhcpServer = NULL;\n    PRUint32 interfaceType = 0;\n    IHost *host = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    /* Current limitation of the function for VirtualBox 2.2.* is\n     * that you can't delete the default hostonly adaptor namely:\n     * vboxnet0 and thus all this functions does is remove the\n     * dhcp server configuration, but the network can still be used\n     * by giving the machine static IP and also it will still\n     * show up in the net-list in virsh\n     */\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\", network->name);\n\n    VBOX_UTF8_TO_UTF16(network->name, &networkInterfaceNameUtf16);\n\n    gVBoxAPI.UIHost.FindHostNetworkInterfaceByName(host, networkInterfaceNameUtf16, &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n    if (interfaceType != HostNetworkInterfaceType_HostOnly)\n        goto cleanup;\n\n    if (removeinterface) {\n        vboxIID iid;\n        IProgress *progress = NULL;\n        nsresult rc;\n        resultCodeUnion resultCode;\n\n        VBOX_IID_INITIALIZE(&iid);\n        rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &iid);\n\n        if (NS_FAILED(rc))\n            goto cleanup;\n\n        gVBoxAPI.UIHost.RemoveHostOnlyNetworkInterface(host, &iid, &progress);\n        vboxIIDUnalloc(&iid);\n\n        if (!progress)\n            goto cleanup;\n\n        gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n        gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n        if (RC_FAILED(resultCode)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Error while removing hostonly network interface, rc=%08x\"),\n                           resultCode.uResultCode);\n            goto cleanup;\n        }\n        VBOX_RELEASE(progress);\n    }\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                      networkNameUtf16,\n                                                      &dhcpServer);\n    if (!dhcpServer)\n        goto cleanup;\n\n    gVBoxAPI.UIDHCPServer.SetEnabled(dhcpServer, PR_FALSE);\n    gVBoxAPI.UIDHCPServer.Stop(dhcpServer);\n    if (removeinterface)\n        gVBoxAPI.UIVirtualBox.RemoveDHCPServer(data->vboxObj, dhcpServer);\n    ret = 0;\n    VBOX_RELEASE(dhcpServer);\n\n cleanup:\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    VIR_FREE(networkNameUtf8);\n    return ret;\n}"
  },
  {
    "function_name": "vboxNetworkDefineXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "558-561",
    "snippet": "static virNetworkPtr vboxNetworkDefineXML(virConnectPtr conn, const char *xml)\n{\n    return vboxNetworkDefineCreateXML(conn, xml, false);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxNetworkDefineCreateXML",
          "args": [
            "conn",
            "xml",
            "false"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "vboxNetworkDefineCreateXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
          "lines": "369-551",
          "snippet": "static virNetworkPtr\nvboxNetworkDefineCreateXML(virConnectPtr conn, const char *xml, bool start)\n{\n    vboxDriverPtr data = conn->privateData;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    char *networkInterfaceNameUtf8 = NULL;\n    PRUnichar *networkNameUtf16 = NULL;\n    char *networkNameUtf8 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    virNetworkDefPtr def = virNetworkDefParseString(xml, NULL);\n    virNetworkIPDefPtr ipdef = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    vboxIID vboxnetiid;\n    virSocketAddr netmask;\n    IHost *host = NULL;\n    virNetworkPtr ret = NULL;\n    nsresult rc;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&vboxnetiid);\n\n    if ((!def) ||\n        (def->forward.type != VIR_NETWORK_FORWARD_NONE) ||\n        (def->nips == 0 || !def->ips))\n        goto cleanup;\n\n    /* Look for the first IPv4 IP address definition and use that.\n     * If there weren't any IPv4 addresses, ignore the network (since it's\n     * required below to have an IPv4 address)\n    */\n    ipdef = virNetworkDefGetIPByIndex(def, AF_INET, 0);\n    if (!ipdef)\n        goto cleanup;\n\n    if (virNetworkIPDefNetmask(ipdef, &netmask) < 0)\n        goto cleanup;\n\n    /* the current limitation of hostonly network is that you can't\n     * assign a name to it and it defaults to vboxnet*, for e.g:\n     * vboxnet0, vboxnet1, etc. Also the UUID is assigned to it\n     * automatically depending on the mac address and thus both\n     * these parameters are ignored here for now.\n     *\n     * If the vbox is in 2.x and the def->name not equal to vboxnet0,\n     * the function call will fail and the networkInterface set to\n     * NULL. (We can't assign a new name to hostonly network, only\n     * take the given name, say vboxnet0)\n     */\n    gVBoxAPI.UIHost.CreateHostOnlyNetworkInterface(data, host, def->name,\n                                                   &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetName(networkInterface, &networkInterfaceNameUtf16);\n    if (!networkInterfaceNameUtf16)\n        goto cleanup;\n\n    VBOX_UTF16_TO_UTF8(networkInterfaceNameUtf16, &networkInterfaceNameUtf8);\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\",\n                                      networkInterfaceNameUtf8);\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    /* Currently support only one dhcp server per network\n     * with contigious address space from start to end\n     */\n    if ((ipdef->nranges >= 1) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->ranges[0].start) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->ranges[0].end)) {\n        IDHCPServer *dhcpServer = NULL;\n\n        gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                          networkNameUtf16,\n                                                          &dhcpServer);\n        if (!dhcpServer) {\n            /* create a dhcp server */\n            gVBoxAPI.UIVirtualBox.CreateDHCPServer(data->vboxObj,\n                                                   networkNameUtf16,\n                                                   &dhcpServer);\n            VIR_DEBUG(\"couldn't find dhcp server so creating one\");\n        }\n        if (dhcpServer) {\n            PRUnichar *ipAddressUtf16 = NULL;\n            PRUnichar *networkMaskUtf16 = NULL;\n            PRUnichar *fromIPAddressUtf16 = NULL;\n            PRUnichar *toIPAddressUtf16 = NULL;\n            PRUnichar *trunkTypeUtf16 = NULL;\n\n            ipAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->address);\n            networkMaskUtf16 = vboxSocketFormatAddrUtf16(data, &netmask);\n            fromIPAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->ranges[0].start);\n            toIPAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->ranges[0].end);\n\n            if (ipAddressUtf16 == NULL || networkMaskUtf16 == NULL ||\n                fromIPAddressUtf16 == NULL || toIPAddressUtf16 == NULL) {\n                VBOX_UTF16_FREE(ipAddressUtf16);\n                VBOX_UTF16_FREE(networkMaskUtf16);\n                VBOX_UTF16_FREE(fromIPAddressUtf16);\n                VBOX_UTF16_FREE(toIPAddressUtf16);\n                VBOX_RELEASE(dhcpServer);\n                goto cleanup;\n            }\n\n            VBOX_UTF8_TO_UTF16(\"netflt\", &trunkTypeUtf16);\n\n            gVBoxAPI.UIDHCPServer.SetEnabled(dhcpServer, PR_TRUE);\n\n            gVBoxAPI.UIDHCPServer.SetConfiguration(dhcpServer,\n                                                   ipAddressUtf16,\n                                                   networkMaskUtf16,\n                                                   fromIPAddressUtf16,\n                                                   toIPAddressUtf16);\n\n            if (start)\n                gVBoxAPI.UIDHCPServer.Start(dhcpServer,\n                                            networkNameUtf16,\n                                            networkInterfaceNameUtf16,\n                                            trunkTypeUtf16);\n\n            VBOX_UTF16_FREE(ipAddressUtf16);\n            VBOX_UTF16_FREE(networkMaskUtf16);\n            VBOX_UTF16_FREE(fromIPAddressUtf16);\n            VBOX_UTF16_FREE(toIPAddressUtf16);\n            VBOX_UTF16_FREE(trunkTypeUtf16);\n            VBOX_RELEASE(dhcpServer);\n        }\n    }\n\n    if ((ipdef->nhosts >= 1) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->hosts[0].ip)) {\n        PRUnichar *ipAddressUtf16 = NULL;\n        PRUnichar *networkMaskUtf16 = NULL;\n\n        ipAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->hosts[0].ip);\n        networkMaskUtf16 = vboxSocketFormatAddrUtf16(data, &netmask);\n\n        if (ipAddressUtf16 == NULL || networkMaskUtf16 == NULL) {\n            VBOX_UTF16_FREE(ipAddressUtf16);\n            VBOX_UTF16_FREE(networkMaskUtf16);\n            goto cleanup;\n        }\n\n        /* Current drawback is that since EnableStaticIpConfig() sets\n         * IP and enables the interface so even if the dhcpserver is not\n         * started the interface is still up and running\n         */\n        gVBoxAPI.UIHNInterface.EnableStaticIPConfig(networkInterface,\n                                                    ipAddressUtf16,\n                                                    networkMaskUtf16);\n\n        VBOX_UTF16_FREE(ipAddressUtf16);\n        VBOX_UTF16_FREE(networkMaskUtf16);\n    } else {\n        gVBoxAPI.UIHNInterface.EnableDynamicIPConfig(networkInterface);\n        gVBoxAPI.UIHNInterface.DHCPRediscover(networkInterface);\n    }\n\n    rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &vboxnetiid);\n    if (NS_FAILED(rc))\n        goto cleanup;\n    vboxIIDToUUID(&vboxnetiid, uuid);\n    DEBUGIID(\"Real Network UUID\", &vboxnetiid);\n    vboxIIDUnalloc(&vboxnetiid);\n    ret = virGetNetwork(conn, networkInterfaceNameUtf8, uuid);\n\n cleanup:\n    VIR_FREE(networkNameUtf8);\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF8_FREE(networkInterfaceNameUtf8);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    virNetworkDefFree(def);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"network_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virNetworkPtr\nvboxNetworkDefineCreateXML(virConnectPtr conn, const char *xml, bool start)\n{\n    vboxDriverPtr data = conn->privateData;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    char *networkInterfaceNameUtf8 = NULL;\n    PRUnichar *networkNameUtf16 = NULL;\n    char *networkNameUtf8 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    virNetworkDefPtr def = virNetworkDefParseString(xml, NULL);\n    virNetworkIPDefPtr ipdef = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    vboxIID vboxnetiid;\n    virSocketAddr netmask;\n    IHost *host = NULL;\n    virNetworkPtr ret = NULL;\n    nsresult rc;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&vboxnetiid);\n\n    if ((!def) ||\n        (def->forward.type != VIR_NETWORK_FORWARD_NONE) ||\n        (def->nips == 0 || !def->ips))\n        goto cleanup;\n\n    /* Look for the first IPv4 IP address definition and use that.\n     * If there weren't any IPv4 addresses, ignore the network (since it's\n     * required below to have an IPv4 address)\n    */\n    ipdef = virNetworkDefGetIPByIndex(def, AF_INET, 0);\n    if (!ipdef)\n        goto cleanup;\n\n    if (virNetworkIPDefNetmask(ipdef, &netmask) < 0)\n        goto cleanup;\n\n    /* the current limitation of hostonly network is that you can't\n     * assign a name to it and it defaults to vboxnet*, for e.g:\n     * vboxnet0, vboxnet1, etc. Also the UUID is assigned to it\n     * automatically depending on the mac address and thus both\n     * these parameters are ignored here for now.\n     *\n     * If the vbox is in 2.x and the def->name not equal to vboxnet0,\n     * the function call will fail and the networkInterface set to\n     * NULL. (We can't assign a new name to hostonly network, only\n     * take the given name, say vboxnet0)\n     */\n    gVBoxAPI.UIHost.CreateHostOnlyNetworkInterface(data, host, def->name,\n                                                   &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetName(networkInterface, &networkInterfaceNameUtf16);\n    if (!networkInterfaceNameUtf16)\n        goto cleanup;\n\n    VBOX_UTF16_TO_UTF8(networkInterfaceNameUtf16, &networkInterfaceNameUtf8);\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\",\n                                      networkInterfaceNameUtf8);\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    /* Currently support only one dhcp server per network\n     * with contigious address space from start to end\n     */\n    if ((ipdef->nranges >= 1) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->ranges[0].start) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->ranges[0].end)) {\n        IDHCPServer *dhcpServer = NULL;\n\n        gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                          networkNameUtf16,\n                                                          &dhcpServer);\n        if (!dhcpServer) {\n            /* create a dhcp server */\n            gVBoxAPI.UIVirtualBox.CreateDHCPServer(data->vboxObj,\n                                                   networkNameUtf16,\n                                                   &dhcpServer);\n            VIR_DEBUG(\"couldn't find dhcp server so creating one\");\n        }\n        if (dhcpServer) {\n            PRUnichar *ipAddressUtf16 = NULL;\n            PRUnichar *networkMaskUtf16 = NULL;\n            PRUnichar *fromIPAddressUtf16 = NULL;\n            PRUnichar *toIPAddressUtf16 = NULL;\n            PRUnichar *trunkTypeUtf16 = NULL;\n\n            ipAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->address);\n            networkMaskUtf16 = vboxSocketFormatAddrUtf16(data, &netmask);\n            fromIPAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->ranges[0].start);\n            toIPAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->ranges[0].end);\n\n            if (ipAddressUtf16 == NULL || networkMaskUtf16 == NULL ||\n                fromIPAddressUtf16 == NULL || toIPAddressUtf16 == NULL) {\n                VBOX_UTF16_FREE(ipAddressUtf16);\n                VBOX_UTF16_FREE(networkMaskUtf16);\n                VBOX_UTF16_FREE(fromIPAddressUtf16);\n                VBOX_UTF16_FREE(toIPAddressUtf16);\n                VBOX_RELEASE(dhcpServer);\n                goto cleanup;\n            }\n\n            VBOX_UTF8_TO_UTF16(\"netflt\", &trunkTypeUtf16);\n\n            gVBoxAPI.UIDHCPServer.SetEnabled(dhcpServer, PR_TRUE);\n\n            gVBoxAPI.UIDHCPServer.SetConfiguration(dhcpServer,\n                                                   ipAddressUtf16,\n                                                   networkMaskUtf16,\n                                                   fromIPAddressUtf16,\n                                                   toIPAddressUtf16);\n\n            if (start)\n                gVBoxAPI.UIDHCPServer.Start(dhcpServer,\n                                            networkNameUtf16,\n                                            networkInterfaceNameUtf16,\n                                            trunkTypeUtf16);\n\n            VBOX_UTF16_FREE(ipAddressUtf16);\n            VBOX_UTF16_FREE(networkMaskUtf16);\n            VBOX_UTF16_FREE(fromIPAddressUtf16);\n            VBOX_UTF16_FREE(toIPAddressUtf16);\n            VBOX_UTF16_FREE(trunkTypeUtf16);\n            VBOX_RELEASE(dhcpServer);\n        }\n    }\n\n    if ((ipdef->nhosts >= 1) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->hosts[0].ip)) {\n        PRUnichar *ipAddressUtf16 = NULL;\n        PRUnichar *networkMaskUtf16 = NULL;\n\n        ipAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->hosts[0].ip);\n        networkMaskUtf16 = vboxSocketFormatAddrUtf16(data, &netmask);\n\n        if (ipAddressUtf16 == NULL || networkMaskUtf16 == NULL) {\n            VBOX_UTF16_FREE(ipAddressUtf16);\n            VBOX_UTF16_FREE(networkMaskUtf16);\n            goto cleanup;\n        }\n\n        /* Current drawback is that since EnableStaticIpConfig() sets\n         * IP and enables the interface so even if the dhcpserver is not\n         * started the interface is still up and running\n         */\n        gVBoxAPI.UIHNInterface.EnableStaticIPConfig(networkInterface,\n                                                    ipAddressUtf16,\n                                                    networkMaskUtf16);\n\n        VBOX_UTF16_FREE(ipAddressUtf16);\n        VBOX_UTF16_FREE(networkMaskUtf16);\n    } else {\n        gVBoxAPI.UIHNInterface.EnableDynamicIPConfig(networkInterface);\n        gVBoxAPI.UIHNInterface.DHCPRediscover(networkInterface);\n    }\n\n    rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &vboxnetiid);\n    if (NS_FAILED(rc))\n        goto cleanup;\n    vboxIIDToUUID(&vboxnetiid, uuid);\n    DEBUGIID(\"Real Network UUID\", &vboxnetiid);\n    vboxIIDUnalloc(&vboxnetiid);\n    ret = virGetNetwork(conn, networkInterfaceNameUtf8, uuid);\n\n cleanup:\n    VIR_FREE(networkNameUtf8);\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF8_FREE(networkInterfaceNameUtf8);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    virNetworkDefFree(def);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virNetworkPtr vboxNetworkDefineXML(virConnectPtr conn, const char *xml)\n{\n    return vboxNetworkDefineCreateXML(conn, xml, false);\n}"
  },
  {
    "function_name": "vboxNetworkCreateXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "553-556",
    "snippet": "static virNetworkPtr vboxNetworkCreateXML(virConnectPtr conn, const char *xml)\n{\n    return vboxNetworkDefineCreateXML(conn, xml, true);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxNetworkDefineCreateXML",
          "args": [
            "conn",
            "xml",
            "true"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "vboxNetworkDefineCreateXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
          "lines": "369-551",
          "snippet": "static virNetworkPtr\nvboxNetworkDefineCreateXML(virConnectPtr conn, const char *xml, bool start)\n{\n    vboxDriverPtr data = conn->privateData;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    char *networkInterfaceNameUtf8 = NULL;\n    PRUnichar *networkNameUtf16 = NULL;\n    char *networkNameUtf8 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    virNetworkDefPtr def = virNetworkDefParseString(xml, NULL);\n    virNetworkIPDefPtr ipdef = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    vboxIID vboxnetiid;\n    virSocketAddr netmask;\n    IHost *host = NULL;\n    virNetworkPtr ret = NULL;\n    nsresult rc;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&vboxnetiid);\n\n    if ((!def) ||\n        (def->forward.type != VIR_NETWORK_FORWARD_NONE) ||\n        (def->nips == 0 || !def->ips))\n        goto cleanup;\n\n    /* Look for the first IPv4 IP address definition and use that.\n     * If there weren't any IPv4 addresses, ignore the network (since it's\n     * required below to have an IPv4 address)\n    */\n    ipdef = virNetworkDefGetIPByIndex(def, AF_INET, 0);\n    if (!ipdef)\n        goto cleanup;\n\n    if (virNetworkIPDefNetmask(ipdef, &netmask) < 0)\n        goto cleanup;\n\n    /* the current limitation of hostonly network is that you can't\n     * assign a name to it and it defaults to vboxnet*, for e.g:\n     * vboxnet0, vboxnet1, etc. Also the UUID is assigned to it\n     * automatically depending on the mac address and thus both\n     * these parameters are ignored here for now.\n     *\n     * If the vbox is in 2.x and the def->name not equal to vboxnet0,\n     * the function call will fail and the networkInterface set to\n     * NULL. (We can't assign a new name to hostonly network, only\n     * take the given name, say vboxnet0)\n     */\n    gVBoxAPI.UIHost.CreateHostOnlyNetworkInterface(data, host, def->name,\n                                                   &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetName(networkInterface, &networkInterfaceNameUtf16);\n    if (!networkInterfaceNameUtf16)\n        goto cleanup;\n\n    VBOX_UTF16_TO_UTF8(networkInterfaceNameUtf16, &networkInterfaceNameUtf8);\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\",\n                                      networkInterfaceNameUtf8);\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    /* Currently support only one dhcp server per network\n     * with contigious address space from start to end\n     */\n    if ((ipdef->nranges >= 1) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->ranges[0].start) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->ranges[0].end)) {\n        IDHCPServer *dhcpServer = NULL;\n\n        gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                          networkNameUtf16,\n                                                          &dhcpServer);\n        if (!dhcpServer) {\n            /* create a dhcp server */\n            gVBoxAPI.UIVirtualBox.CreateDHCPServer(data->vboxObj,\n                                                   networkNameUtf16,\n                                                   &dhcpServer);\n            VIR_DEBUG(\"couldn't find dhcp server so creating one\");\n        }\n        if (dhcpServer) {\n            PRUnichar *ipAddressUtf16 = NULL;\n            PRUnichar *networkMaskUtf16 = NULL;\n            PRUnichar *fromIPAddressUtf16 = NULL;\n            PRUnichar *toIPAddressUtf16 = NULL;\n            PRUnichar *trunkTypeUtf16 = NULL;\n\n            ipAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->address);\n            networkMaskUtf16 = vboxSocketFormatAddrUtf16(data, &netmask);\n            fromIPAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->ranges[0].start);\n            toIPAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->ranges[0].end);\n\n            if (ipAddressUtf16 == NULL || networkMaskUtf16 == NULL ||\n                fromIPAddressUtf16 == NULL || toIPAddressUtf16 == NULL) {\n                VBOX_UTF16_FREE(ipAddressUtf16);\n                VBOX_UTF16_FREE(networkMaskUtf16);\n                VBOX_UTF16_FREE(fromIPAddressUtf16);\n                VBOX_UTF16_FREE(toIPAddressUtf16);\n                VBOX_RELEASE(dhcpServer);\n                goto cleanup;\n            }\n\n            VBOX_UTF8_TO_UTF16(\"netflt\", &trunkTypeUtf16);\n\n            gVBoxAPI.UIDHCPServer.SetEnabled(dhcpServer, PR_TRUE);\n\n            gVBoxAPI.UIDHCPServer.SetConfiguration(dhcpServer,\n                                                   ipAddressUtf16,\n                                                   networkMaskUtf16,\n                                                   fromIPAddressUtf16,\n                                                   toIPAddressUtf16);\n\n            if (start)\n                gVBoxAPI.UIDHCPServer.Start(dhcpServer,\n                                            networkNameUtf16,\n                                            networkInterfaceNameUtf16,\n                                            trunkTypeUtf16);\n\n            VBOX_UTF16_FREE(ipAddressUtf16);\n            VBOX_UTF16_FREE(networkMaskUtf16);\n            VBOX_UTF16_FREE(fromIPAddressUtf16);\n            VBOX_UTF16_FREE(toIPAddressUtf16);\n            VBOX_UTF16_FREE(trunkTypeUtf16);\n            VBOX_RELEASE(dhcpServer);\n        }\n    }\n\n    if ((ipdef->nhosts >= 1) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->hosts[0].ip)) {\n        PRUnichar *ipAddressUtf16 = NULL;\n        PRUnichar *networkMaskUtf16 = NULL;\n\n        ipAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->hosts[0].ip);\n        networkMaskUtf16 = vboxSocketFormatAddrUtf16(data, &netmask);\n\n        if (ipAddressUtf16 == NULL || networkMaskUtf16 == NULL) {\n            VBOX_UTF16_FREE(ipAddressUtf16);\n            VBOX_UTF16_FREE(networkMaskUtf16);\n            goto cleanup;\n        }\n\n        /* Current drawback is that since EnableStaticIpConfig() sets\n         * IP and enables the interface so even if the dhcpserver is not\n         * started the interface is still up and running\n         */\n        gVBoxAPI.UIHNInterface.EnableStaticIPConfig(networkInterface,\n                                                    ipAddressUtf16,\n                                                    networkMaskUtf16);\n\n        VBOX_UTF16_FREE(ipAddressUtf16);\n        VBOX_UTF16_FREE(networkMaskUtf16);\n    } else {\n        gVBoxAPI.UIHNInterface.EnableDynamicIPConfig(networkInterface);\n        gVBoxAPI.UIHNInterface.DHCPRediscover(networkInterface);\n    }\n\n    rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &vboxnetiid);\n    if (NS_FAILED(rc))\n        goto cleanup;\n    vboxIIDToUUID(&vboxnetiid, uuid);\n    DEBUGIID(\"Real Network UUID\", &vboxnetiid);\n    vboxIIDUnalloc(&vboxnetiid);\n    ret = virGetNetwork(conn, networkInterfaceNameUtf8, uuid);\n\n cleanup:\n    VIR_FREE(networkNameUtf8);\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF8_FREE(networkInterfaceNameUtf8);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    virNetworkDefFree(def);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"network_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virNetworkPtr\nvboxNetworkDefineCreateXML(virConnectPtr conn, const char *xml, bool start)\n{\n    vboxDriverPtr data = conn->privateData;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    char *networkInterfaceNameUtf8 = NULL;\n    PRUnichar *networkNameUtf16 = NULL;\n    char *networkNameUtf8 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    virNetworkDefPtr def = virNetworkDefParseString(xml, NULL);\n    virNetworkIPDefPtr ipdef = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    vboxIID vboxnetiid;\n    virSocketAddr netmask;\n    IHost *host = NULL;\n    virNetworkPtr ret = NULL;\n    nsresult rc;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&vboxnetiid);\n\n    if ((!def) ||\n        (def->forward.type != VIR_NETWORK_FORWARD_NONE) ||\n        (def->nips == 0 || !def->ips))\n        goto cleanup;\n\n    /* Look for the first IPv4 IP address definition and use that.\n     * If there weren't any IPv4 addresses, ignore the network (since it's\n     * required below to have an IPv4 address)\n    */\n    ipdef = virNetworkDefGetIPByIndex(def, AF_INET, 0);\n    if (!ipdef)\n        goto cleanup;\n\n    if (virNetworkIPDefNetmask(ipdef, &netmask) < 0)\n        goto cleanup;\n\n    /* the current limitation of hostonly network is that you can't\n     * assign a name to it and it defaults to vboxnet*, for e.g:\n     * vboxnet0, vboxnet1, etc. Also the UUID is assigned to it\n     * automatically depending on the mac address and thus both\n     * these parameters are ignored here for now.\n     *\n     * If the vbox is in 2.x and the def->name not equal to vboxnet0,\n     * the function call will fail and the networkInterface set to\n     * NULL. (We can't assign a new name to hostonly network, only\n     * take the given name, say vboxnet0)\n     */\n    gVBoxAPI.UIHost.CreateHostOnlyNetworkInterface(data, host, def->name,\n                                                   &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetName(networkInterface, &networkInterfaceNameUtf16);\n    if (!networkInterfaceNameUtf16)\n        goto cleanup;\n\n    VBOX_UTF16_TO_UTF8(networkInterfaceNameUtf16, &networkInterfaceNameUtf8);\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\",\n                                      networkInterfaceNameUtf8);\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    /* Currently support only one dhcp server per network\n     * with contigious address space from start to end\n     */\n    if ((ipdef->nranges >= 1) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->ranges[0].start) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->ranges[0].end)) {\n        IDHCPServer *dhcpServer = NULL;\n\n        gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                          networkNameUtf16,\n                                                          &dhcpServer);\n        if (!dhcpServer) {\n            /* create a dhcp server */\n            gVBoxAPI.UIVirtualBox.CreateDHCPServer(data->vboxObj,\n                                                   networkNameUtf16,\n                                                   &dhcpServer);\n            VIR_DEBUG(\"couldn't find dhcp server so creating one\");\n        }\n        if (dhcpServer) {\n            PRUnichar *ipAddressUtf16 = NULL;\n            PRUnichar *networkMaskUtf16 = NULL;\n            PRUnichar *fromIPAddressUtf16 = NULL;\n            PRUnichar *toIPAddressUtf16 = NULL;\n            PRUnichar *trunkTypeUtf16 = NULL;\n\n            ipAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->address);\n            networkMaskUtf16 = vboxSocketFormatAddrUtf16(data, &netmask);\n            fromIPAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->ranges[0].start);\n            toIPAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->ranges[0].end);\n\n            if (ipAddressUtf16 == NULL || networkMaskUtf16 == NULL ||\n                fromIPAddressUtf16 == NULL || toIPAddressUtf16 == NULL) {\n                VBOX_UTF16_FREE(ipAddressUtf16);\n                VBOX_UTF16_FREE(networkMaskUtf16);\n                VBOX_UTF16_FREE(fromIPAddressUtf16);\n                VBOX_UTF16_FREE(toIPAddressUtf16);\n                VBOX_RELEASE(dhcpServer);\n                goto cleanup;\n            }\n\n            VBOX_UTF8_TO_UTF16(\"netflt\", &trunkTypeUtf16);\n\n            gVBoxAPI.UIDHCPServer.SetEnabled(dhcpServer, PR_TRUE);\n\n            gVBoxAPI.UIDHCPServer.SetConfiguration(dhcpServer,\n                                                   ipAddressUtf16,\n                                                   networkMaskUtf16,\n                                                   fromIPAddressUtf16,\n                                                   toIPAddressUtf16);\n\n            if (start)\n                gVBoxAPI.UIDHCPServer.Start(dhcpServer,\n                                            networkNameUtf16,\n                                            networkInterfaceNameUtf16,\n                                            trunkTypeUtf16);\n\n            VBOX_UTF16_FREE(ipAddressUtf16);\n            VBOX_UTF16_FREE(networkMaskUtf16);\n            VBOX_UTF16_FREE(fromIPAddressUtf16);\n            VBOX_UTF16_FREE(toIPAddressUtf16);\n            VBOX_UTF16_FREE(trunkTypeUtf16);\n            VBOX_RELEASE(dhcpServer);\n        }\n    }\n\n    if ((ipdef->nhosts >= 1) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->hosts[0].ip)) {\n        PRUnichar *ipAddressUtf16 = NULL;\n        PRUnichar *networkMaskUtf16 = NULL;\n\n        ipAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->hosts[0].ip);\n        networkMaskUtf16 = vboxSocketFormatAddrUtf16(data, &netmask);\n\n        if (ipAddressUtf16 == NULL || networkMaskUtf16 == NULL) {\n            VBOX_UTF16_FREE(ipAddressUtf16);\n            VBOX_UTF16_FREE(networkMaskUtf16);\n            goto cleanup;\n        }\n\n        /* Current drawback is that since EnableStaticIpConfig() sets\n         * IP and enables the interface so even if the dhcpserver is not\n         * started the interface is still up and running\n         */\n        gVBoxAPI.UIHNInterface.EnableStaticIPConfig(networkInterface,\n                                                    ipAddressUtf16,\n                                                    networkMaskUtf16);\n\n        VBOX_UTF16_FREE(ipAddressUtf16);\n        VBOX_UTF16_FREE(networkMaskUtf16);\n    } else {\n        gVBoxAPI.UIHNInterface.EnableDynamicIPConfig(networkInterface);\n        gVBoxAPI.UIHNInterface.DHCPRediscover(networkInterface);\n    }\n\n    rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &vboxnetiid);\n    if (NS_FAILED(rc))\n        goto cleanup;\n    vboxIIDToUUID(&vboxnetiid, uuid);\n    DEBUGIID(\"Real Network UUID\", &vboxnetiid);\n    vboxIIDUnalloc(&vboxnetiid);\n    ret = virGetNetwork(conn, networkInterfaceNameUtf8, uuid);\n\n cleanup:\n    VIR_FREE(networkNameUtf8);\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF8_FREE(networkInterfaceNameUtf8);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    virNetworkDefFree(def);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virNetworkPtr vboxNetworkCreateXML(virConnectPtr conn, const char *xml)\n{\n    return vboxNetworkDefineCreateXML(conn, xml, true);\n}"
  },
  {
    "function_name": "vboxNetworkDefineCreateXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "369-551",
    "snippet": "static virNetworkPtr\nvboxNetworkDefineCreateXML(virConnectPtr conn, const char *xml, bool start)\n{\n    vboxDriverPtr data = conn->privateData;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    char *networkInterfaceNameUtf8 = NULL;\n    PRUnichar *networkNameUtf16 = NULL;\n    char *networkNameUtf8 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    virNetworkDefPtr def = virNetworkDefParseString(xml, NULL);\n    virNetworkIPDefPtr ipdef = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    vboxIID vboxnetiid;\n    virSocketAddr netmask;\n    IHost *host = NULL;\n    virNetworkPtr ret = NULL;\n    nsresult rc;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&vboxnetiid);\n\n    if ((!def) ||\n        (def->forward.type != VIR_NETWORK_FORWARD_NONE) ||\n        (def->nips == 0 || !def->ips))\n        goto cleanup;\n\n    /* Look for the first IPv4 IP address definition and use that.\n     * If there weren't any IPv4 addresses, ignore the network (since it's\n     * required below to have an IPv4 address)\n    */\n    ipdef = virNetworkDefGetIPByIndex(def, AF_INET, 0);\n    if (!ipdef)\n        goto cleanup;\n\n    if (virNetworkIPDefNetmask(ipdef, &netmask) < 0)\n        goto cleanup;\n\n    /* the current limitation of hostonly network is that you can't\n     * assign a name to it and it defaults to vboxnet*, for e.g:\n     * vboxnet0, vboxnet1, etc. Also the UUID is assigned to it\n     * automatically depending on the mac address and thus both\n     * these parameters are ignored here for now.\n     *\n     * If the vbox is in 2.x and the def->name not equal to vboxnet0,\n     * the function call will fail and the networkInterface set to\n     * NULL. (We can't assign a new name to hostonly network, only\n     * take the given name, say vboxnet0)\n     */\n    gVBoxAPI.UIHost.CreateHostOnlyNetworkInterface(data, host, def->name,\n                                                   &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetName(networkInterface, &networkInterfaceNameUtf16);\n    if (!networkInterfaceNameUtf16)\n        goto cleanup;\n\n    VBOX_UTF16_TO_UTF8(networkInterfaceNameUtf16, &networkInterfaceNameUtf8);\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\",\n                                      networkInterfaceNameUtf8);\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    /* Currently support only one dhcp server per network\n     * with contigious address space from start to end\n     */\n    if ((ipdef->nranges >= 1) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->ranges[0].start) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->ranges[0].end)) {\n        IDHCPServer *dhcpServer = NULL;\n\n        gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                          networkNameUtf16,\n                                                          &dhcpServer);\n        if (!dhcpServer) {\n            /* create a dhcp server */\n            gVBoxAPI.UIVirtualBox.CreateDHCPServer(data->vboxObj,\n                                                   networkNameUtf16,\n                                                   &dhcpServer);\n            VIR_DEBUG(\"couldn't find dhcp server so creating one\");\n        }\n        if (dhcpServer) {\n            PRUnichar *ipAddressUtf16 = NULL;\n            PRUnichar *networkMaskUtf16 = NULL;\n            PRUnichar *fromIPAddressUtf16 = NULL;\n            PRUnichar *toIPAddressUtf16 = NULL;\n            PRUnichar *trunkTypeUtf16 = NULL;\n\n            ipAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->address);\n            networkMaskUtf16 = vboxSocketFormatAddrUtf16(data, &netmask);\n            fromIPAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->ranges[0].start);\n            toIPAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->ranges[0].end);\n\n            if (ipAddressUtf16 == NULL || networkMaskUtf16 == NULL ||\n                fromIPAddressUtf16 == NULL || toIPAddressUtf16 == NULL) {\n                VBOX_UTF16_FREE(ipAddressUtf16);\n                VBOX_UTF16_FREE(networkMaskUtf16);\n                VBOX_UTF16_FREE(fromIPAddressUtf16);\n                VBOX_UTF16_FREE(toIPAddressUtf16);\n                VBOX_RELEASE(dhcpServer);\n                goto cleanup;\n            }\n\n            VBOX_UTF8_TO_UTF16(\"netflt\", &trunkTypeUtf16);\n\n            gVBoxAPI.UIDHCPServer.SetEnabled(dhcpServer, PR_TRUE);\n\n            gVBoxAPI.UIDHCPServer.SetConfiguration(dhcpServer,\n                                                   ipAddressUtf16,\n                                                   networkMaskUtf16,\n                                                   fromIPAddressUtf16,\n                                                   toIPAddressUtf16);\n\n            if (start)\n                gVBoxAPI.UIDHCPServer.Start(dhcpServer,\n                                            networkNameUtf16,\n                                            networkInterfaceNameUtf16,\n                                            trunkTypeUtf16);\n\n            VBOX_UTF16_FREE(ipAddressUtf16);\n            VBOX_UTF16_FREE(networkMaskUtf16);\n            VBOX_UTF16_FREE(fromIPAddressUtf16);\n            VBOX_UTF16_FREE(toIPAddressUtf16);\n            VBOX_UTF16_FREE(trunkTypeUtf16);\n            VBOX_RELEASE(dhcpServer);\n        }\n    }\n\n    if ((ipdef->nhosts >= 1) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->hosts[0].ip)) {\n        PRUnichar *ipAddressUtf16 = NULL;\n        PRUnichar *networkMaskUtf16 = NULL;\n\n        ipAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->hosts[0].ip);\n        networkMaskUtf16 = vboxSocketFormatAddrUtf16(data, &netmask);\n\n        if (ipAddressUtf16 == NULL || networkMaskUtf16 == NULL) {\n            VBOX_UTF16_FREE(ipAddressUtf16);\n            VBOX_UTF16_FREE(networkMaskUtf16);\n            goto cleanup;\n        }\n\n        /* Current drawback is that since EnableStaticIpConfig() sets\n         * IP and enables the interface so even if the dhcpserver is not\n         * started the interface is still up and running\n         */\n        gVBoxAPI.UIHNInterface.EnableStaticIPConfig(networkInterface,\n                                                    ipAddressUtf16,\n                                                    networkMaskUtf16);\n\n        VBOX_UTF16_FREE(ipAddressUtf16);\n        VBOX_UTF16_FREE(networkMaskUtf16);\n    } else {\n        gVBoxAPI.UIHNInterface.EnableDynamicIPConfig(networkInterface);\n        gVBoxAPI.UIHNInterface.DHCPRediscover(networkInterface);\n    }\n\n    rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &vboxnetiid);\n    if (NS_FAILED(rc))\n        goto cleanup;\n    vboxIIDToUUID(&vboxnetiid, uuid);\n    DEBUGIID(\"Real Network UUID\", &vboxnetiid);\n    vboxIIDUnalloc(&vboxnetiid);\n    ret = virGetNetwork(conn, networkInterfaceNameUtf8, uuid);\n\n cleanup:\n    VIR_FREE(networkNameUtf8);\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF8_FREE(networkInterfaceNameUtf8);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    virNetworkDefFree(def);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetworkDefFree",
          "args": [
            "def"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "235-274",
          "snippet": "void\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirNetworkDefFree(virNetworkDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    VIR_FREE(def->name);\n    VIR_FREE(def->bridge);\n    VIR_FREE(def->bridgeZone);\n    VIR_FREE(def->domain);\n\n    virNetworkForwardDefClear(&def->forward);\n\n    for (i = 0; i < def->nips && def->ips; i++)\n        virNetworkIPDefClear(&def->ips[i]);\n    VIR_FREE(def->ips);\n\n    for (i = 0; i < def->nroutes && def->routes; i++)\n        virNetDevIPRouteFree(def->routes[i]);\n    VIR_FREE(def->routes);\n\n    for (i = 0; i < def->nPortGroups && def->portGroups; i++)\n        virPortGroupDefClear(&def->portGroups[i]);\n    VIR_FREE(def->portGroups);\n\n    virNetworkDNSDefClear(&def->dns);\n\n    VIR_FREE(def->virtPortProfile);\n\n    virNetDevBandwidthFree(def->bandwidth);\n    virNetDevVlanClear(&def->vlan);\n\n    xmlFreeNode(def->metadata);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "host"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "networkInterfaceNameUtf16"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "networkInterfaceNameUtf8"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "networkInterface"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "networkNameUtf16"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "networkNameUtf8"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetNetwork",
          "args": [
            "conn",
            "networkInterfaceNameUtf8",
            "uuid"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "virGetNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "341-366",
          "snippet": "virNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virNetworkClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virNetworkClass;\n\nvirNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&vboxnetiid"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUGIID",
          "args": [
            "\"Real Network UUID\"",
            "&vboxnetiid"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDToUUID",
          "args": [
            "&vboxnetiid",
            "uuid"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetId",
          "args": [
            "networkInterface",
            "&vboxnetiid"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.DHCPRediscover",
          "args": [
            "networkInterface"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.EnableDynamicIPConfig",
          "args": [
            "networkInterface"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "networkMaskUtf16"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "ipAddressUtf16"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.EnableStaticIPConfig",
          "args": [
            "networkInterface",
            "ipAddressUtf16",
            "networkMaskUtf16"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "networkMaskUtf16"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "ipAddressUtf16"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxSocketFormatAddrUtf16",
          "args": [
            "data",
            "&netmask"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "vboxSocketFormatAddrUtf16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
          "lines": "352-367",
          "snippet": "static PRUnichar *\nvboxSocketFormatAddrUtf16(vboxDriverPtr data, virSocketAddrPtr addr)\n{\n    char *utf8 = NULL;\n    PRUnichar *utf16 = NULL;\n\n    utf8 = virSocketAddrFormat(addr);\n\n    if (utf8 == NULL)\n        return NULL;\n\n    VBOX_UTF8_TO_UTF16(utf8, &utf16);\n    VIR_FREE(utf8);\n\n    return utf16;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"network_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic PRUnichar *\nvboxSocketFormatAddrUtf16(vboxDriverPtr data, virSocketAddrPtr addr)\n{\n    char *utf8 = NULL;\n    PRUnichar *utf16 = NULL;\n\n    utf8 = virSocketAddrFormat(addr);\n\n    if (utf8 == NULL)\n        return NULL;\n\n    VBOX_UTF8_TO_UTF16(utf8, &utf16);\n    VIR_FREE(utf8);\n\n    return utf16;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&ipdef->hosts[0].ip"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "dhcpServer"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "trunkTypeUtf16"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "toIPAddressUtf16"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "fromIPAddressUtf16"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "networkMaskUtf16"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "ipAddressUtf16"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIDHCPServer.Start",
          "args": [
            "dhcpServer",
            "networkNameUtf16",
            "networkInterfaceNameUtf16",
            "trunkTypeUtf16"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIDHCPServer.SetConfiguration",
          "args": [
            "dhcpServer",
            "ipAddressUtf16",
            "networkMaskUtf16",
            "fromIPAddressUtf16",
            "toIPAddressUtf16"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIDHCPServer.SetEnabled",
          "args": [
            "dhcpServer",
            "PR_TRUE"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"netflt\"",
            "&trunkTypeUtf16"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "dhcpServer"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "toIPAddressUtf16"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "fromIPAddressUtf16"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "networkMaskUtf16"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "ipAddressUtf16"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"couldn't find dhcp server so creating one\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.CreateDHCPServer",
          "args": [
            "data->vboxObj",
            "networkNameUtf16",
            "&dhcpServer"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName",
          "args": [
            "data->vboxObj",
            "networkNameUtf16",
            "&dhcpServer"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&ipdef->ranges[0].end"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "&ipdef->ranges[0].start"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "networkNameUtf8",
            "&networkNameUtf16"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"HostInterfaceNetworking-%s\"",
            "networkInterfaceNameUtf8"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "networkInterfaceNameUtf16",
            "&networkInterfaceNameUtf8"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetName",
          "args": [
            "networkInterface",
            "&networkInterfaceNameUtf16"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHost.CreateHostOnlyNetworkInterface",
          "args": [
            "data",
            "host",
            "def->name",
            "&networkInterface"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkIPDefNetmask",
          "args": [
            "ipdef",
            "&netmask"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkIPDefNetmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "380-390",
          "snippet": "int virNetworkIPDefNetmask(const virNetworkIPDef *def,\n                           virSocketAddrPtr netmask)\n{\n    if (VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET)) {\n        *netmask = def->netmask;\n        return 0;\n    }\n\n    return virSocketAddrPrefixToNetmask(virNetworkIPDefPrefix(def), netmask,\n                                        VIR_SOCKET_ADDR_FAMILY(&def->address));\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetworkIPDefNetmask(const virNetworkIPDef *def,\n                           virSocketAddrPtr netmask)\n{\n    if (VIR_SOCKET_ADDR_IS_FAMILY(&def->netmask, AF_INET)) {\n        *netmask = def->netmask;\n        return 0;\n    }\n\n    return virSocketAddrPrefixToNetmask(virNetworkIPDefPrefix(def), netmask,\n                                        VIR_SOCKET_ADDR_FAMILY(&def->address));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetworkDefGetIPByIndex",
          "args": [
            "def",
            "AF_INET",
            "0"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefGetIPByIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "311-333",
          "snippet": "virNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkIPDefPtr\nvirNetworkDefGetIPByIndex(const virNetworkDef *def,\n                          int family,\n                          size_t n)\n{\n    size_t i;\n\n    if (!def->ips || n >= def->nips)\n        return NULL;\n\n    if (family == AF_UNSPEC)\n        return &def->ips[n];\n\n    /* find the nth ip of type \"family\" */\n    for (i = 0; i < def->nips; i++) {\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&def->ips[i].address, family)\n            && (n-- <= 0)) {\n            return &def->ips[i];\n        }\n    }\n    /* failed to find enough of the right family */\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&vboxnetiid"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetHost",
          "args": [
            "data->vboxObj",
            "&host"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetworkDefParseString",
          "args": [
            "xml",
            "NULL"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "virNetworkDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/network_conf.c",
          "lines": "2114-2119",
          "snippet": "virNetworkDefPtr\nvirNetworkDefParseString(const char *xmlStr,\n                         virNetworkXMLOptionPtr xmlopt)\n{\n    return virNetworkDefParse(xmlStr, NULL, xmlopt);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"network_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"network_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetworkDefPtr\nvirNetworkDefParseString(const char *xmlStr,\n                         virNetworkXMLOptionPtr xmlopt)\n{\n    return virNetworkDefParse(xmlStr, NULL, xmlopt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virNetworkPtr\nvboxNetworkDefineCreateXML(virConnectPtr conn, const char *xml, bool start)\n{\n    vboxDriverPtr data = conn->privateData;\n    PRUnichar *networkInterfaceNameUtf16 = NULL;\n    char *networkInterfaceNameUtf8 = NULL;\n    PRUnichar *networkNameUtf16 = NULL;\n    char *networkNameUtf8 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    virNetworkDefPtr def = virNetworkDefParseString(xml, NULL);\n    virNetworkIPDefPtr ipdef = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    vboxIID vboxnetiid;\n    virSocketAddr netmask;\n    IHost *host = NULL;\n    virNetworkPtr ret = NULL;\n    nsresult rc;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&vboxnetiid);\n\n    if ((!def) ||\n        (def->forward.type != VIR_NETWORK_FORWARD_NONE) ||\n        (def->nips == 0 || !def->ips))\n        goto cleanup;\n\n    /* Look for the first IPv4 IP address definition and use that.\n     * If there weren't any IPv4 addresses, ignore the network (since it's\n     * required below to have an IPv4 address)\n    */\n    ipdef = virNetworkDefGetIPByIndex(def, AF_INET, 0);\n    if (!ipdef)\n        goto cleanup;\n\n    if (virNetworkIPDefNetmask(ipdef, &netmask) < 0)\n        goto cleanup;\n\n    /* the current limitation of hostonly network is that you can't\n     * assign a name to it and it defaults to vboxnet*, for e.g:\n     * vboxnet0, vboxnet1, etc. Also the UUID is assigned to it\n     * automatically depending on the mac address and thus both\n     * these parameters are ignored here for now.\n     *\n     * If the vbox is in 2.x and the def->name not equal to vboxnet0,\n     * the function call will fail and the networkInterface set to\n     * NULL. (We can't assign a new name to hostonly network, only\n     * take the given name, say vboxnet0)\n     */\n    gVBoxAPI.UIHost.CreateHostOnlyNetworkInterface(data, host, def->name,\n                                                   &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetName(networkInterface, &networkInterfaceNameUtf16);\n    if (!networkInterfaceNameUtf16)\n        goto cleanup;\n\n    VBOX_UTF16_TO_UTF8(networkInterfaceNameUtf16, &networkInterfaceNameUtf8);\n\n    networkNameUtf8 = g_strdup_printf(\"HostInterfaceNetworking-%s\",\n                                      networkInterfaceNameUtf8);\n\n    VBOX_UTF8_TO_UTF16(networkNameUtf8, &networkNameUtf16);\n\n    /* Currently support only one dhcp server per network\n     * with contigious address space from start to end\n     */\n    if ((ipdef->nranges >= 1) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->ranges[0].start) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->ranges[0].end)) {\n        IDHCPServer *dhcpServer = NULL;\n\n        gVBoxAPI.UIVirtualBox.FindDHCPServerByNetworkName(data->vboxObj,\n                                                          networkNameUtf16,\n                                                          &dhcpServer);\n        if (!dhcpServer) {\n            /* create a dhcp server */\n            gVBoxAPI.UIVirtualBox.CreateDHCPServer(data->vboxObj,\n                                                   networkNameUtf16,\n                                                   &dhcpServer);\n            VIR_DEBUG(\"couldn't find dhcp server so creating one\");\n        }\n        if (dhcpServer) {\n            PRUnichar *ipAddressUtf16 = NULL;\n            PRUnichar *networkMaskUtf16 = NULL;\n            PRUnichar *fromIPAddressUtf16 = NULL;\n            PRUnichar *toIPAddressUtf16 = NULL;\n            PRUnichar *trunkTypeUtf16 = NULL;\n\n            ipAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->address);\n            networkMaskUtf16 = vboxSocketFormatAddrUtf16(data, &netmask);\n            fromIPAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->ranges[0].start);\n            toIPAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->ranges[0].end);\n\n            if (ipAddressUtf16 == NULL || networkMaskUtf16 == NULL ||\n                fromIPAddressUtf16 == NULL || toIPAddressUtf16 == NULL) {\n                VBOX_UTF16_FREE(ipAddressUtf16);\n                VBOX_UTF16_FREE(networkMaskUtf16);\n                VBOX_UTF16_FREE(fromIPAddressUtf16);\n                VBOX_UTF16_FREE(toIPAddressUtf16);\n                VBOX_RELEASE(dhcpServer);\n                goto cleanup;\n            }\n\n            VBOX_UTF8_TO_UTF16(\"netflt\", &trunkTypeUtf16);\n\n            gVBoxAPI.UIDHCPServer.SetEnabled(dhcpServer, PR_TRUE);\n\n            gVBoxAPI.UIDHCPServer.SetConfiguration(dhcpServer,\n                                                   ipAddressUtf16,\n                                                   networkMaskUtf16,\n                                                   fromIPAddressUtf16,\n                                                   toIPAddressUtf16);\n\n            if (start)\n                gVBoxAPI.UIDHCPServer.Start(dhcpServer,\n                                            networkNameUtf16,\n                                            networkInterfaceNameUtf16,\n                                            trunkTypeUtf16);\n\n            VBOX_UTF16_FREE(ipAddressUtf16);\n            VBOX_UTF16_FREE(networkMaskUtf16);\n            VBOX_UTF16_FREE(fromIPAddressUtf16);\n            VBOX_UTF16_FREE(toIPAddressUtf16);\n            VBOX_UTF16_FREE(trunkTypeUtf16);\n            VBOX_RELEASE(dhcpServer);\n        }\n    }\n\n    if ((ipdef->nhosts >= 1) &&\n        VIR_SOCKET_ADDR_VALID(&ipdef->hosts[0].ip)) {\n        PRUnichar *ipAddressUtf16 = NULL;\n        PRUnichar *networkMaskUtf16 = NULL;\n\n        ipAddressUtf16 = vboxSocketFormatAddrUtf16(data, &ipdef->hosts[0].ip);\n        networkMaskUtf16 = vboxSocketFormatAddrUtf16(data, &netmask);\n\n        if (ipAddressUtf16 == NULL || networkMaskUtf16 == NULL) {\n            VBOX_UTF16_FREE(ipAddressUtf16);\n            VBOX_UTF16_FREE(networkMaskUtf16);\n            goto cleanup;\n        }\n\n        /* Current drawback is that since EnableStaticIpConfig() sets\n         * IP and enables the interface so even if the dhcpserver is not\n         * started the interface is still up and running\n         */\n        gVBoxAPI.UIHNInterface.EnableStaticIPConfig(networkInterface,\n                                                    ipAddressUtf16,\n                                                    networkMaskUtf16);\n\n        VBOX_UTF16_FREE(ipAddressUtf16);\n        VBOX_UTF16_FREE(networkMaskUtf16);\n    } else {\n        gVBoxAPI.UIHNInterface.EnableDynamicIPConfig(networkInterface);\n        gVBoxAPI.UIHNInterface.DHCPRediscover(networkInterface);\n    }\n\n    rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &vboxnetiid);\n    if (NS_FAILED(rc))\n        goto cleanup;\n    vboxIIDToUUID(&vboxnetiid, uuid);\n    DEBUGIID(\"Real Network UUID\", &vboxnetiid);\n    vboxIIDUnalloc(&vboxnetiid);\n    ret = virGetNetwork(conn, networkInterfaceNameUtf8, uuid);\n\n cleanup:\n    VIR_FREE(networkNameUtf8);\n    VBOX_UTF16_FREE(networkNameUtf16);\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF8_FREE(networkInterfaceNameUtf8);\n    VBOX_UTF16_FREE(networkInterfaceNameUtf16);\n    VBOX_RELEASE(host);\n    virNetworkDefFree(def);\n    return ret;\n}"
  },
  {
    "function_name": "vboxSocketFormatAddrUtf16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "352-367",
    "snippet": "static PRUnichar *\nvboxSocketFormatAddrUtf16(vboxDriverPtr data, virSocketAddrPtr addr)\n{\n    char *utf8 = NULL;\n    PRUnichar *utf16 = NULL;\n\n    utf8 = virSocketAddrFormat(addr);\n\n    if (utf8 == NULL)\n        return NULL;\n\n    VBOX_UTF8_TO_UTF16(utf8, &utf16);\n    VIR_FREE(utf8);\n\n    return utf16;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "utf8"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "utf8",
            "&utf16"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "addr"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic PRUnichar *\nvboxSocketFormatAddrUtf16(vboxDriverPtr data, virSocketAddrPtr addr)\n{\n    char *utf8 = NULL;\n    PRUnichar *utf16 = NULL;\n\n    utf8 = virSocketAddrFormat(addr);\n\n    if (utf8 == NULL)\n        return NULL;\n\n    VBOX_UTF8_TO_UTF16(utf8, &utf16);\n    VIR_FREE(utf8);\n\n    return utf16;\n}"
  },
  {
    "function_name": "vboxNetworkLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "303-350",
    "snippet": "static virNetworkPtr vboxNetworkLookupByName(virConnectPtr conn, const char *name)\n{\n    vboxDriverPtr data = conn->privateData;\n    PRUnichar *nameUtf16 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    PRUint32 interfaceType = 0;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    vboxIID iid;\n    IHost *host = NULL;\n    virNetworkPtr ret = NULL;\n    nsresult rc;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    VBOX_UTF8_TO_UTF16(name, &nameUtf16);\n\n    gVBoxAPI.UIHost.FindHostNetworkInterfaceByName(host, nameUtf16, &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n    if (interfaceType != HostNetworkInterfaceType_HostOnly)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &iid);\n    if (NS_FAILED(rc))\n        goto cleanup;\n    vboxIIDToUUID(&iid, uuid);\n    ret = virGetNetwork(conn, name, uuid);\n\n    VIR_DEBUG(\"Network Name: %s\", name);\n    DEBUGIID(\"Network UUID\", &iid);\n    vboxIIDUnalloc(&iid);\n\n cleanup:\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF16_FREE(nameUtf16);\n    VBOX_RELEASE(host);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "host"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "nameUtf16"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "networkInterface"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUGIID",
          "args": [
            "\"Network UUID\"",
            "&iid"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Network Name: %s\"",
            "name"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetNetwork",
          "args": [
            "conn",
            "name",
            "uuid"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "virGetNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "341-366",
          "snippet": "virNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virNetworkClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virNetworkClass;\n\nvirNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxIIDToUUID",
          "args": [
            "&iid",
            "uuid"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetId",
          "args": [
            "networkInterface",
            "&iid"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetInterfaceType",
          "args": [
            "networkInterface",
            "&interfaceType"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHost.FindHostNetworkInterfaceByName",
          "args": [
            "host",
            "nameUtf16",
            "&networkInterface"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "name",
            "&nameUtf16"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetHost",
          "args": [
            "data->vboxObj",
            "&host"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virNetworkPtr vboxNetworkLookupByName(virConnectPtr conn, const char *name)\n{\n    vboxDriverPtr data = conn->privateData;\n    PRUnichar *nameUtf16 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    PRUint32 interfaceType = 0;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    vboxIID iid;\n    IHost *host = NULL;\n    virNetworkPtr ret = NULL;\n    nsresult rc;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    VBOX_UTF8_TO_UTF16(name, &nameUtf16);\n\n    gVBoxAPI.UIHost.FindHostNetworkInterfaceByName(host, nameUtf16, &networkInterface);\n\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n    if (interfaceType != HostNetworkInterfaceType_HostOnly)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIHNInterface.GetId(networkInterface, &iid);\n    if (NS_FAILED(rc))\n        goto cleanup;\n    vboxIIDToUUID(&iid, uuid);\n    ret = virGetNetwork(conn, name, uuid);\n\n    VIR_DEBUG(\"Network Name: %s\", name);\n    DEBUGIID(\"Network UUID\", &iid);\n    vboxIIDUnalloc(&iid);\n\n cleanup:\n    VBOX_RELEASE(networkInterface);\n    VBOX_UTF16_FREE(nameUtf16);\n    VBOX_RELEASE(host);\n    return ret;\n}"
  },
  {
    "function_name": "vboxNetworkLookupByUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "251-301",
    "snippet": "static virNetworkPtr vboxNetworkLookupByUUID(virConnectPtr conn, const unsigned char *uuid)\n{\n    vboxDriverPtr data = conn->privateData;\n    PRUint32 interfaceType = 0;\n    char *nameUtf8 = NULL;\n    PRUnichar *nameUtf16 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    vboxIID iid;\n    IHost *host = NULL;\n    virNetworkPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    vboxIIDFromUUID(&iid, uuid);\n\n    /* TODO: \"internal\" networks are just strings and\n     * thus can't do much with them\n     */\n\n    gVBoxAPI.UIHost.FindHostNetworkInterfaceById(host, &iid,\n                                                 &networkInterface);\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n    if (interfaceType != HostNetworkInterfaceType_HostOnly)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetName(networkInterface, &nameUtf16);\n    VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n\n    ret = virGetNetwork(conn, nameUtf8, uuid);\n\n    VIR_DEBUG(\"Network Name: %s\", nameUtf8);\n    DEBUGIID(\"Network UUID\", &iid);\n    VBOX_UTF8_FREE(nameUtf8);\n    VBOX_UTF16_FREE(nameUtf16);\n\n cleanup:\n    VBOX_RELEASE(networkInterface);\n    VBOX_RELEASE(host);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "host"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "networkInterface"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "nameUtf16"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "nameUtf8"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUGIID",
          "args": [
            "\"Network UUID\"",
            "&iid"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Network Name: %s\"",
            "nameUtf8"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetNetwork",
          "args": [
            "conn",
            "nameUtf8",
            "uuid"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "virGetNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "341-366",
          "snippet": "virNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virNetworkClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virNetworkClass;\n\nvirNetworkPtr\nvirGetNetwork(virConnectPtr conn, const char *name, const unsigned char *uuid)\n{\n    virNetworkPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virNetworkClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "nameUtf16",
            "&nameUtf8"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetName",
          "args": [
            "networkInterface",
            "&nameUtf16"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetInterfaceType",
          "args": [
            "networkInterface",
            "&interfaceType"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHost.FindHostNetworkInterfaceById",
          "args": [
            "host",
            "&iid",
            "&networkInterface"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDFromUUID",
          "args": [
            "&iid",
            "uuid"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetHost",
          "args": [
            "data->vboxObj",
            "&host"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virNetworkPtr vboxNetworkLookupByUUID(virConnectPtr conn, const unsigned char *uuid)\n{\n    vboxDriverPtr data = conn->privateData;\n    PRUint32 interfaceType = 0;\n    char *nameUtf8 = NULL;\n    PRUnichar *nameUtf16 = NULL;\n    IHostNetworkInterface *networkInterface = NULL;\n    vboxIID iid;\n    IHost *host = NULL;\n    virNetworkPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    vboxIIDFromUUID(&iid, uuid);\n\n    /* TODO: \"internal\" networks are just strings and\n     * thus can't do much with them\n     */\n\n    gVBoxAPI.UIHost.FindHostNetworkInterfaceById(host, &iid,\n                                                 &networkInterface);\n    if (!networkInterface)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n    if (interfaceType != HostNetworkInterfaceType_HostOnly)\n        goto cleanup;\n\n    gVBoxAPI.UIHNInterface.GetName(networkInterface, &nameUtf16);\n    VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n\n    ret = virGetNetwork(conn, nameUtf8, uuid);\n\n    VIR_DEBUG(\"Network Name: %s\", nameUtf8);\n    DEBUGIID(\"Network UUID\", &iid);\n    VBOX_UTF8_FREE(nameUtf8);\n    VBOX_UTF16_FREE(nameUtf16);\n\n cleanup:\n    VBOX_RELEASE(networkInterface);\n    VBOX_RELEASE(host);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxConnectListDefinedNetworks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "194-249",
    "snippet": "static int vboxConnectListDefinedNetworks(virConnectPtr conn, char **const names, int nnames)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray networkInterfaces = VBOX_ARRAY_INITIALIZER;\n    IHost *host = NULL;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    gVBoxAPI.UArray.vboxArrayGet(&networkInterfaces, host,\n                                 gVBoxAPI.UArray.handleHostGetNetworkInterfaces(host));\n\n    ret = 0;\n    for (i = 0; (ret < nnames) && (i < networkInterfaces.count); i++) {\n        IHostNetworkInterface *networkInterface = networkInterfaces.items[i];\n        PRUint32 interfaceType = 0;\n        char *nameUtf8 = NULL;\n        PRUnichar *nameUtf16 = NULL;\n        PRUint32 status = HostNetworkInterfaceStatus_Unknown;\n\n        if (!networkInterface)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n        if (interfaceType != HostNetworkInterfaceType_HostOnly)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetStatus(networkInterface, &status);\n\n        if (status != HostNetworkInterfaceStatus_Down)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetName(networkInterface, &nameUtf16);\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n\n        VIR_DEBUG(\"nnames[%d]: %s\", ret, nameUtf8);\n        names[ret] = g_strdup(nameUtf8);\n        ret++;\n\n        VBOX_UTF8_FREE(nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&networkInterfaces);\n\n    VBOX_RELEASE(host);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "host"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&networkInterfaces"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "nameUtf16"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "nameUtf8"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "nameUtf8"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"nnames[%d]: %s\"",
            "ret",
            "nameUtf8"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "nameUtf16",
            "&nameUtf8"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetName",
          "args": [
            "networkInterface",
            "&nameUtf16"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetStatus",
          "args": [
            "networkInterface",
            "&status"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetInterfaceType",
          "args": [
            "networkInterface",
            "&interfaceType"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&networkInterfaces",
            "host",
            "gVBoxAPI.UArray.handleHostGetNetworkInterfaces(host)"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleHostGetNetworkInterfaces",
          "args": [
            "host"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetHost",
          "args": [
            "data->vboxObj",
            "&host"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxConnectListDefinedNetworks(virConnectPtr conn, char **const names, int nnames)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray networkInterfaces = VBOX_ARRAY_INITIALIZER;\n    IHost *host = NULL;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    gVBoxAPI.UArray.vboxArrayGet(&networkInterfaces, host,\n                                 gVBoxAPI.UArray.handleHostGetNetworkInterfaces(host));\n\n    ret = 0;\n    for (i = 0; (ret < nnames) && (i < networkInterfaces.count); i++) {\n        IHostNetworkInterface *networkInterface = networkInterfaces.items[i];\n        PRUint32 interfaceType = 0;\n        char *nameUtf8 = NULL;\n        PRUnichar *nameUtf16 = NULL;\n        PRUint32 status = HostNetworkInterfaceStatus_Unknown;\n\n        if (!networkInterface)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n        if (interfaceType != HostNetworkInterfaceType_HostOnly)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetStatus(networkInterface, &status);\n\n        if (status != HostNetworkInterfaceStatus_Down)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetName(networkInterface, &nameUtf16);\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n\n        VIR_DEBUG(\"nnames[%d]: %s\", ret, nameUtf8);\n        names[ret] = g_strdup(nameUtf8);\n        ret++;\n\n        VBOX_UTF8_FREE(nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&networkInterfaces);\n\n    VBOX_RELEASE(host);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxConnectNumOfDefinedNetworks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "149-192",
    "snippet": "static int vboxConnectNumOfDefinedNetworks(virConnectPtr conn)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray networkInterfaces = VBOX_ARRAY_INITIALIZER;\n    IHost *host = NULL;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    gVBoxAPI.UArray.vboxArrayGet(&networkInterfaces, host,\n                                 gVBoxAPI.UArray.handleHostGetNetworkInterfaces(host));\n\n    ret = 0;\n    for (i = 0; i < networkInterfaces.count; i++) {\n        IHostNetworkInterface *networkInterface = networkInterfaces.items[i];\n        PRUint32 status = HostNetworkInterfaceStatus_Unknown;\n        PRUint32 interfaceType = 0;\n\n        if (!networkInterface)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n        if (interfaceType != HostNetworkInterfaceType_HostOnly)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetStatus(networkInterface, &status);\n\n        if (status == HostNetworkInterfaceStatus_Down)\n            ret++;\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&networkInterfaces);\n\n    VBOX_RELEASE(host);\n\n    VIR_DEBUG(\"numActive: %d\", ret);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"numActive: %d\"",
            "ret"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "host"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&networkInterfaces"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetStatus",
          "args": [
            "networkInterface",
            "&status"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetInterfaceType",
          "args": [
            "networkInterface",
            "&interfaceType"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&networkInterfaces",
            "host",
            "gVBoxAPI.UArray.handleHostGetNetworkInterfaces(host)"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleHostGetNetworkInterfaces",
          "args": [
            "host"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetHost",
          "args": [
            "data->vboxObj",
            "&host"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxConnectNumOfDefinedNetworks(virConnectPtr conn)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray networkInterfaces = VBOX_ARRAY_INITIALIZER;\n    IHost *host = NULL;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    gVBoxAPI.UArray.vboxArrayGet(&networkInterfaces, host,\n                                 gVBoxAPI.UArray.handleHostGetNetworkInterfaces(host));\n\n    ret = 0;\n    for (i = 0; i < networkInterfaces.count; i++) {\n        IHostNetworkInterface *networkInterface = networkInterfaces.items[i];\n        PRUint32 status = HostNetworkInterfaceStatus_Unknown;\n        PRUint32 interfaceType = 0;\n\n        if (!networkInterface)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n        if (interfaceType != HostNetworkInterfaceType_HostOnly)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetStatus(networkInterface, &status);\n\n        if (status == HostNetworkInterfaceStatus_Down)\n            ret++;\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&networkInterfaces);\n\n    VBOX_RELEASE(host);\n\n    VIR_DEBUG(\"numActive: %d\", ret);\n    return ret;\n}"
  },
  {
    "function_name": "vboxConnectListNetworks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "92-147",
    "snippet": "static int vboxConnectListNetworks(virConnectPtr conn, char **const names, int nnames)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray networkInterfaces = VBOX_ARRAY_INITIALIZER;\n    IHost *host = NULL;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    gVBoxAPI.UArray.vboxArrayGet(&networkInterfaces, host,\n                                 gVBoxAPI.UArray.handleHostGetNetworkInterfaces(host));\n\n    ret = 0;\n    for (i = 0; (ret < nnames) && (i < networkInterfaces.count); i++) {\n        IHostNetworkInterface *networkInterface = networkInterfaces.items[i];\n        char *nameUtf8 = NULL;\n        PRUnichar *nameUtf16 = NULL;\n        PRUint32 interfaceType = 0;\n        PRUint32 status = HostNetworkInterfaceStatus_Unknown;\n\n        if (!networkInterface)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n        if (interfaceType != HostNetworkInterfaceType_HostOnly)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetStatus(networkInterface, &status);\n\n        if (status != HostNetworkInterfaceStatus_Up)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetName(networkInterface, &nameUtf16);\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n\n        VIR_DEBUG(\"nnames[%d]: %s\", ret, nameUtf8);\n        names[ret] = g_strdup(nameUtf8);\n        ret++;\n\n        VBOX_UTF8_FREE(nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&networkInterfaces);\n\n    VBOX_RELEASE(host);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "host"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&networkInterfaces"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "nameUtf16"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "nameUtf8"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "nameUtf8"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"nnames[%d]: %s\"",
            "ret",
            "nameUtf8"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "nameUtf16",
            "&nameUtf8"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetName",
          "args": [
            "networkInterface",
            "&nameUtf16"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetStatus",
          "args": [
            "networkInterface",
            "&status"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetInterfaceType",
          "args": [
            "networkInterface",
            "&interfaceType"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&networkInterfaces",
            "host",
            "gVBoxAPI.UArray.handleHostGetNetworkInterfaces(host)"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleHostGetNetworkInterfaces",
          "args": [
            "host"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetHost",
          "args": [
            "data->vboxObj",
            "&host"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxConnectListNetworks(virConnectPtr conn, char **const names, int nnames)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray networkInterfaces = VBOX_ARRAY_INITIALIZER;\n    IHost *host = NULL;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    gVBoxAPI.UArray.vboxArrayGet(&networkInterfaces, host,\n                                 gVBoxAPI.UArray.handleHostGetNetworkInterfaces(host));\n\n    ret = 0;\n    for (i = 0; (ret < nnames) && (i < networkInterfaces.count); i++) {\n        IHostNetworkInterface *networkInterface = networkInterfaces.items[i];\n        char *nameUtf8 = NULL;\n        PRUnichar *nameUtf16 = NULL;\n        PRUint32 interfaceType = 0;\n        PRUint32 status = HostNetworkInterfaceStatus_Unknown;\n\n        if (!networkInterface)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n\n        if (interfaceType != HostNetworkInterfaceType_HostOnly)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetStatus(networkInterface, &status);\n\n        if (status != HostNetworkInterfaceStatus_Up)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetName(networkInterface, &nameUtf16);\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n\n        VIR_DEBUG(\"nnames[%d]: %s\", ret, nameUtf8);\n        names[ret] = g_strdup(nameUtf8);\n        ret++;\n\n        VBOX_UTF8_FREE(nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&networkInterfaces);\n\n    VBOX_RELEASE(host);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxConnectNumOfNetworks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_network.c",
    "lines": "47-90",
    "snippet": "static int vboxConnectNumOfNetworks(virConnectPtr conn)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray networkInterfaces = VBOX_ARRAY_INITIALIZER;\n    IHost *host = NULL;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    gVBoxAPI.UArray.vboxArrayGet(&networkInterfaces, host,\n                                 gVBoxAPI.UArray.handleHostGetNetworkInterfaces(host));\n\n    ret = 0;\n    for (i = 0; i < networkInterfaces.count; i++) {\n        IHostNetworkInterface *networkInterface = networkInterfaces.items[i];\n        PRUint32 status = HostNetworkInterfaceStatus_Unknown;\n        PRUint32 interfaceType = 0;\n\n        if (!networkInterface)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n        if (interfaceType != HostNetworkInterfaceType_HostOnly)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetStatus(networkInterface, &status);\n\n        if (status == HostNetworkInterfaceStatus_Up)\n            ret++;\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&networkInterfaces);\n\n    VBOX_RELEASE(host);\n\n    VIR_DEBUG(\"numActive: %d\", ret);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"network_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"numActive: %d\"",
            "ret"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "host"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&networkInterfaces"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetStatus",
          "args": [
            "networkInterface",
            "&status"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIHNInterface.GetInterfaceType",
          "args": [
            "networkInterface",
            "&interfaceType"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&networkInterfaces",
            "host",
            "gVBoxAPI.UArray.handleHostGetNetworkInterfaces(host)"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleHostGetNetworkInterfaces",
          "args": [
            "host"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetHost",
          "args": [
            "data->vboxObj",
            "&host"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"network_conf.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxConnectNumOfNetworks(virConnectPtr conn)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray networkInterfaces = VBOX_ARRAY_INITIALIZER;\n    IHost *host = NULL;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIVirtualBox.GetHost(data->vboxObj, &host);\n    if (!host)\n        return ret;\n\n    gVBoxAPI.UArray.vboxArrayGet(&networkInterfaces, host,\n                                 gVBoxAPI.UArray.handleHostGetNetworkInterfaces(host));\n\n    ret = 0;\n    for (i = 0; i < networkInterfaces.count; i++) {\n        IHostNetworkInterface *networkInterface = networkInterfaces.items[i];\n        PRUint32 status = HostNetworkInterfaceStatus_Unknown;\n        PRUint32 interfaceType = 0;\n\n        if (!networkInterface)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetInterfaceType(networkInterface, &interfaceType);\n        if (interfaceType != HostNetworkInterfaceType_HostOnly)\n            continue;\n\n        gVBoxAPI.UIHNInterface.GetStatus(networkInterface, &status);\n\n        if (status == HostNetworkInterfaceStatus_Up)\n            ret++;\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&networkInterfaces);\n\n    VBOX_RELEASE(host);\n\n    VIR_DEBUG(\"numActive: %d\", ret);\n    return ret;\n}"
  }
]