[
  {
    "function_name": "esxInterfaceIsActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_interface_driver.c",
    "lines": "239-244",
    "snippet": "static int\nesxInterfaceIsActive(virInterfacePtr iface G_GNUC_UNUSED)\n{\n    /* ESX interfaces are always active */\n    return 1;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"interface_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_private.h\"\n#include \"virsocketaddr.h\"\n#include \"interface_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxInterfaceIsActive(virInterfacePtr iface G_GNUC_UNUSED)\n{\n    /* ESX interfaces are always active */\n    return 1;\n}"
  },
  {
    "function_name": "esxInterfaceGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_interface_driver.c",
    "lines": "160-235",
    "snippet": "static char *\nesxInterfaceGetXMLDesc(virInterfacePtr iface, unsigned int flags)\n{\n    char *xml = NULL;\n    esxPrivate *priv = iface->conn->privateData;\n    esxVI_PhysicalNic *physicalNic = NULL;\n    virInterfaceDef def;\n    bool hasAddress = false;\n    virInterfaceProtocolDefPtr protocols;\n    virInterfaceProtocolDef protocol;\n    virSocketAddr socketAddress;\n    virInterfaceIPDefPtr ips;\n    virInterfaceIPDef ip;\n\n    virCheckFlags(VIR_INTERFACE_XML_INACTIVE, NULL);\n\n    memset(&def, 0, sizeof(def));\n    memset(&protocol, 0, sizeof(protocol));\n    memset(&socketAddress, 0, sizeof(socketAddress));\n    memset(&ip, 0, sizeof(ip));\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupPhysicalNicByMACAddress(priv->primary, iface->mac,\n                                            &physicalNic,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        return NULL;\n    }\n\n    def.type = VIR_INTERFACE_TYPE_ETHERNET;\n    def.name = physicalNic->device;\n    def.mac = physicalNic->mac;\n    def.startmode = VIR_INTERFACE_START_ONBOOT;\n\n    /* FIXME: Add support for IPv6, requires to use vSphere API 4.0 */\n    if (physicalNic->spec->ip) {\n        protocol.family = (char *)\"ipv4\";\n\n        if (physicalNic->spec->ip->dhcp == esxVI_Boolean_True)\n            protocol.dhcp = 1;\n\n        if (physicalNic->spec->ip->ipAddress &&\n            physicalNic->spec->ip->subnetMask &&\n            strlen(physicalNic->spec->ip->ipAddress) > 0 &&\n            strlen(physicalNic->spec->ip->subnetMask) > 0) {\n            hasAddress = true;\n        }\n\n        if (protocol.dhcp || hasAddress) {\n            protocols = &protocol;\n            def.nprotos = 1;\n            def.protos = &protocols;\n        }\n\n        if (hasAddress &&\n            !(protocol.dhcp && (flags & VIR_INTERFACE_XML_INACTIVE))) {\n            ips = &ip;\n            protocol.nips = 1;\n            protocol.ips = &ips;\n\n            if (virSocketAddrParseIPv4(&socketAddress,\n                                       physicalNic->spec->ip->subnetMask) < 0) {\n                goto cleanup;\n            }\n\n            ip.address = physicalNic->spec->ip->ipAddress;\n            ip.prefix = virSocketAddrGetNumNetmaskBits(&socketAddress);\n        }\n    }\n\n    xml = virInterfaceDefFormat(&def);\n\n cleanup:\n    esxVI_PhysicalNic_Free(&physicalNic);\n\n    return xml;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"interface_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_PhysicalNic_Free",
          "args": [
            "&physicalNic"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virInterfaceDefFormat",
          "args": [
            "&def"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "virInterfaceDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/interface_conf.c",
          "lines": "1130-1140",
          "snippet": "char *\nvirInterfaceDefFormat(const virInterfaceDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virInterfaceDefDevFormat(&buf, def, VIR_INTERFACE_TYPE_LAST) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"interface_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"interface_conf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nchar *\nvirInterfaceDefFormat(const virInterfaceDef *def)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    if (virInterfaceDefDevFormat(&buf, def, VIR_INTERFACE_TYPE_LAST) < 0) {\n        virBufferFreeAndReset(&buf);\n        return NULL;\n    }\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetNumNetmaskBits",
          "args": [
            "&socketAddress"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetNumNetmaskBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1009-1084",
          "snippet": "int virSocketAddrGetNumNetmaskBits(const virSocketAddr *netmask)\n{\n    size_t i, j;\n    int c = 0;\n\n    if (netmask->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 tm;\n        uint8_t bit;\n\n        if (virSocketAddrGetIPv4Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 4; i++)\n            if (tm[i] == 0xff)\n                c += 8;\n            else\n                break;\n\n        if (c == 8 * 4)\n            return c;\n\n        j = i << 3;\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                return -1;\n            j++;\n        }\n\n        return c;\n    } else if (netmask->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 tm;\n        uint16_t bit;\n\n        if (virSocketAddrGetIPv6Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 8; i++)\n            if (tm[i] == 0xffff)\n                c += 16;\n            else\n                break;\n\n        if (c == 16 * 8)\n            return c;\n\n        j = i << 4;\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4]) & bit)\n                return -1;\n            j++;\n        }\n\n        return c;\n    }\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrGetNumNetmaskBits(const virSocketAddr *netmask)\n{\n    size_t i, j;\n    int c = 0;\n\n    if (netmask->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 tm;\n        uint8_t bit;\n\n        if (virSocketAddrGetIPv4Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 4; i++)\n            if (tm[i] == 0xff)\n                c += 8;\n            else\n                break;\n\n        if (c == 8 * 4)\n            return c;\n\n        j = i << 3;\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                return -1;\n            j++;\n        }\n\n        return c;\n    } else if (netmask->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 tm;\n        uint16_t bit;\n\n        if (virSocketAddrGetIPv6Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 8; i++)\n            if (tm[i] == 0xffff)\n                c += 16;\n            else\n                break;\n\n        if (c == 16 * 8)\n            return c;\n\n        j = i << 4;\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4]) & bit)\n                return -1;\n            j++;\n        }\n\n        return c;\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrParseIPv4",
          "args": [
            "&socketAddress",
            "physicalNic->spec->ip->subnetMask"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParseIPv4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "215-219",
          "snippet": "int\nvirSocketAddrParseIPv4(virSocketAddrPtr addr, const char *val)\n{\n    return virSocketAddrParse(addr, val, AF_INET);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrParseIPv4(virSocketAddrPtr addr, const char *val)\n{\n    return virSocketAddrParse(addr, val, AF_INET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "physicalNic->spec->ip->subnetMask"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "physicalNic->spec->ip->ipAddress"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupPhysicalNicByMACAddress",
          "args": [
            "priv->primary",
            "iface->mac",
            "&physicalNic",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupPhysicalNicByMACAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3937-3977",
          "snippet": "int\nesxVI_LookupPhysicalNicByMACAddress(esxVI_Context *ctx, const char *mac,\n                                    esxVI_PhysicalNic **physicalNic,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNic);\n\n    if (esxVI_LookupPhysicalNicList(ctx, &physicalNicList) < 0)\n        goto cleanup;\n\n    /* Search for a matching physical NIC */\n    for (candidate = physicalNicList; candidate;\n         candidate = candidate->_next) {\n        if (STRCASEEQ(candidate->mac, mac)) {\n            if (esxVI_PhysicalNic_DeepCopy(physicalNic, candidate) < 0)\n                goto cleanup;\n\n            /* Found physical NIC with matching MAC address */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*physicalNic) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"Could not find physical NIC with MAC address '%s'\"), mac);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_PhysicalNic_Free(&physicalNicList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupPhysicalNicByMACAddress(esxVI_Context *ctx, const char *mac,\n                                    esxVI_PhysicalNic **physicalNic,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNic);\n\n    if (esxVI_LookupPhysicalNicList(ctx, &physicalNicList) < 0)\n        goto cleanup;\n\n    /* Search for a matching physical NIC */\n    for (candidate = physicalNicList; candidate;\n         candidate = candidate->_next) {\n        if (STRCASEEQ(candidate->mac, mac)) {\n            if (esxVI_PhysicalNic_DeepCopy(physicalNic, candidate) < 0)\n                goto cleanup;\n\n            /* Found physical NIC with matching MAC address */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*physicalNic) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"Could not find physical NIC with MAC address '%s'\"), mac);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_PhysicalNic_Free(&physicalNicList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ip",
            "0",
            "sizeof(ip)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&socketAddress",
            "0",
            "sizeof(socketAddress)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&protocol",
            "0",
            "sizeof(protocol)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&def",
            "0",
            "sizeof(def)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_INTERFACE_XML_INACTIVE",
            "NULL"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_private.h\"\n#include \"virsocketaddr.h\"\n#include \"interface_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nesxInterfaceGetXMLDesc(virInterfacePtr iface, unsigned int flags)\n{\n    char *xml = NULL;\n    esxPrivate *priv = iface->conn->privateData;\n    esxVI_PhysicalNic *physicalNic = NULL;\n    virInterfaceDef def;\n    bool hasAddress = false;\n    virInterfaceProtocolDefPtr protocols;\n    virInterfaceProtocolDef protocol;\n    virSocketAddr socketAddress;\n    virInterfaceIPDefPtr ips;\n    virInterfaceIPDef ip;\n\n    virCheckFlags(VIR_INTERFACE_XML_INACTIVE, NULL);\n\n    memset(&def, 0, sizeof(def));\n    memset(&protocol, 0, sizeof(protocol));\n    memset(&socketAddress, 0, sizeof(socketAddress));\n    memset(&ip, 0, sizeof(ip));\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupPhysicalNicByMACAddress(priv->primary, iface->mac,\n                                            &physicalNic,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        return NULL;\n    }\n\n    def.type = VIR_INTERFACE_TYPE_ETHERNET;\n    def.name = physicalNic->device;\n    def.mac = physicalNic->mac;\n    def.startmode = VIR_INTERFACE_START_ONBOOT;\n\n    /* FIXME: Add support for IPv6, requires to use vSphere API 4.0 */\n    if (physicalNic->spec->ip) {\n        protocol.family = (char *)\"ipv4\";\n\n        if (physicalNic->spec->ip->dhcp == esxVI_Boolean_True)\n            protocol.dhcp = 1;\n\n        if (physicalNic->spec->ip->ipAddress &&\n            physicalNic->spec->ip->subnetMask &&\n            strlen(physicalNic->spec->ip->ipAddress) > 0 &&\n            strlen(physicalNic->spec->ip->subnetMask) > 0) {\n            hasAddress = true;\n        }\n\n        if (protocol.dhcp || hasAddress) {\n            protocols = &protocol;\n            def.nprotos = 1;\n            def.protos = &protocols;\n        }\n\n        if (hasAddress &&\n            !(protocol.dhcp && (flags & VIR_INTERFACE_XML_INACTIVE))) {\n            ips = &ip;\n            protocol.nips = 1;\n            protocol.ips = &ips;\n\n            if (virSocketAddrParseIPv4(&socketAddress,\n                                       physicalNic->spec->ip->subnetMask) < 0) {\n                goto cleanup;\n            }\n\n            ip.address = physicalNic->spec->ip->ipAddress;\n            ip.prefix = virSocketAddrGetNumNetmaskBits(&socketAddress);\n        }\n    }\n\n    xml = virInterfaceDefFormat(&def);\n\n cleanup:\n    esxVI_PhysicalNic_Free(&physicalNic);\n\n    return xml;\n}"
  },
  {
    "function_name": "esxInterfaceLookupByMACString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_interface_driver.c",
    "lines": "138-156",
    "snippet": "static virInterfacePtr\nesxInterfaceLookupByMACString(virConnectPtr conn, const char *mac)\n{\n    virInterfacePtr iface = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_PhysicalNic *physicalNic = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupPhysicalNicByMACAddress(priv->primary, mac, &physicalNic,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        return NULL;\n    }\n\n    iface = virGetInterface(conn, physicalNic->device, physicalNic->mac);\n\n    esxVI_PhysicalNic_Free(&physicalNic);\n\n    return iface;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"interface_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_PhysicalNic_Free",
          "args": [
            "&physicalNic"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetInterface",
          "args": [
            "conn",
            "physicalNic->device",
            "physicalNic->mac"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "virGetInterface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "460-488",
          "snippet": "virInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virInterfaceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virInterfaceClass;\n\nvirInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupPhysicalNicByMACAddress",
          "args": [
            "priv->primary",
            "mac",
            "&physicalNic",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupPhysicalNicByMACAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3937-3977",
          "snippet": "int\nesxVI_LookupPhysicalNicByMACAddress(esxVI_Context *ctx, const char *mac,\n                                    esxVI_PhysicalNic **physicalNic,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNic);\n\n    if (esxVI_LookupPhysicalNicList(ctx, &physicalNicList) < 0)\n        goto cleanup;\n\n    /* Search for a matching physical NIC */\n    for (candidate = physicalNicList; candidate;\n         candidate = candidate->_next) {\n        if (STRCASEEQ(candidate->mac, mac)) {\n            if (esxVI_PhysicalNic_DeepCopy(physicalNic, candidate) < 0)\n                goto cleanup;\n\n            /* Found physical NIC with matching MAC address */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*physicalNic) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"Could not find physical NIC with MAC address '%s'\"), mac);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_PhysicalNic_Free(&physicalNicList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupPhysicalNicByMACAddress(esxVI_Context *ctx, const char *mac,\n                                    esxVI_PhysicalNic **physicalNic,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNic);\n\n    if (esxVI_LookupPhysicalNicList(ctx, &physicalNicList) < 0)\n        goto cleanup;\n\n    /* Search for a matching physical NIC */\n    for (candidate = physicalNicList; candidate;\n         candidate = candidate->_next) {\n        if (STRCASEEQ(candidate->mac, mac)) {\n            if (esxVI_PhysicalNic_DeepCopy(physicalNic, candidate) < 0)\n                goto cleanup;\n\n            /* Found physical NIC with matching MAC address */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*physicalNic) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"Could not find physical NIC with MAC address '%s'\"), mac);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_PhysicalNic_Free(&physicalNicList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_private.h\"\n#include \"virsocketaddr.h\"\n#include \"interface_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virInterfacePtr\nesxInterfaceLookupByMACString(virConnectPtr conn, const char *mac)\n{\n    virInterfacePtr iface = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_PhysicalNic *physicalNic = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupPhysicalNicByMACAddress(priv->primary, mac, &physicalNic,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        return NULL;\n    }\n\n    iface = virGetInterface(conn, physicalNic->device, physicalNic->mac);\n\n    esxVI_PhysicalNic_Free(&physicalNic);\n\n    return iface;\n}"
  },
  {
    "function_name": "esxInterfaceLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_interface_driver.c",
    "lines": "116-134",
    "snippet": "static virInterfacePtr\nesxInterfaceLookupByName(virConnectPtr conn, const char *name)\n{\n    virInterfacePtr iface = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_PhysicalNic *physicalNic = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupPhysicalNicByMACAddress(priv->primary, name, &physicalNic,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        return NULL;\n    }\n\n    iface = virGetInterface(conn, physicalNic->device, physicalNic->mac);\n\n    esxVI_PhysicalNic_Free(&physicalNic);\n\n    return iface;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"interface_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_PhysicalNic_Free",
          "args": [
            "&physicalNic"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetInterface",
          "args": [
            "conn",
            "physicalNic->device",
            "physicalNic->mac"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "virGetInterface",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "460-488",
          "snippet": "virInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virInterfaceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virInterfaceClass;\n\nvirInterfacePtr\nvirGetInterface(virConnectPtr conn, const char *name, const char *mac)\n{\n    virInterfacePtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n\n    /* a NULL mac from caller is okay. Treat it as blank */\n    if (mac == NULL)\n       mac = \"\";\n\n    if (!(ret = virObjectNew(virInterfaceClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n    ret->mac = g_strdup(mac);\n\n    ret->conn = virObjectRef(conn);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupPhysicalNicByMACAddress",
          "args": [
            "priv->primary",
            "name",
            "&physicalNic",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupPhysicalNicByMACAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3937-3977",
          "snippet": "int\nesxVI_LookupPhysicalNicByMACAddress(esxVI_Context *ctx, const char *mac,\n                                    esxVI_PhysicalNic **physicalNic,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNic);\n\n    if (esxVI_LookupPhysicalNicList(ctx, &physicalNicList) < 0)\n        goto cleanup;\n\n    /* Search for a matching physical NIC */\n    for (candidate = physicalNicList; candidate;\n         candidate = candidate->_next) {\n        if (STRCASEEQ(candidate->mac, mac)) {\n            if (esxVI_PhysicalNic_DeepCopy(physicalNic, candidate) < 0)\n                goto cleanup;\n\n            /* Found physical NIC with matching MAC address */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*physicalNic) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"Could not find physical NIC with MAC address '%s'\"), mac);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_PhysicalNic_Free(&physicalNicList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupPhysicalNicByMACAddress(esxVI_Context *ctx, const char *mac,\n                                    esxVI_PhysicalNic **physicalNic,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNic);\n\n    if (esxVI_LookupPhysicalNicList(ctx, &physicalNicList) < 0)\n        goto cleanup;\n\n    /* Search for a matching physical NIC */\n    for (candidate = physicalNicList; candidate;\n         candidate = candidate->_next) {\n        if (STRCASEEQ(candidate->mac, mac)) {\n            if (esxVI_PhysicalNic_DeepCopy(physicalNic, candidate) < 0)\n                goto cleanup;\n\n            /* Found physical NIC with matching MAC address */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*physicalNic) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_INTERFACE,\n                       _(\"Could not find physical NIC with MAC address '%s'\"), mac);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_PhysicalNic_Free(&physicalNicList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_private.h\"\n#include \"virsocketaddr.h\"\n#include \"interface_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virInterfacePtr\nesxInterfaceLookupByName(virConnectPtr conn, const char *name)\n{\n    virInterfacePtr iface = NULL;\n    esxPrivate *priv = conn->privateData;\n    esxVI_PhysicalNic *physicalNic = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupPhysicalNicByMACAddress(priv->primary, name, &physicalNic,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        return NULL;\n    }\n\n    iface = virGetInterface(conn, physicalNic->device, physicalNic->mac);\n\n    esxVI_PhysicalNic_Free(&physicalNic);\n\n    return iface;\n}"
  },
  {
    "function_name": "esxConnectListDefinedInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_interface_driver.c",
    "lines": "105-112",
    "snippet": "static int\nesxConnectListDefinedInterfaces(virConnectPtr conn G_GNUC_UNUSED,\n                                char **const names G_GNUC_UNUSED,\n                                int maxnames G_GNUC_UNUSED)\n{\n    /* ESX interfaces are always active */\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"interface_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_private.h\"\n#include \"virsocketaddr.h\"\n#include \"interface_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectListDefinedInterfaces(virConnectPtr conn G_GNUC_UNUSED,\n                                char **const names G_GNUC_UNUSED,\n                                int maxnames G_GNUC_UNUSED)\n{\n    /* ESX interfaces are always active */\n    return 0;\n}"
  },
  {
    "function_name": "esxConnectNumOfDefinedInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_interface_driver.c",
    "lines": "96-101",
    "snippet": "static int\nesxConnectNumOfDefinedInterfaces(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* ESX interfaces are always active */\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"interface_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_private.h\"\n#include \"virsocketaddr.h\"\n#include \"interface_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectNumOfDefinedInterfaces(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* ESX interfaces are always active */\n    return 0;\n}"
  },
  {
    "function_name": "esxConnectListInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_interface_driver.c",
    "lines": "66-92",
    "snippet": "static int\nesxConnectListInterfaces(virConnectPtr conn, char **const names, int maxnames)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *physicalNic = NULL;\n    int count = 0;\n\n    if (maxnames == 0)\n        return 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupPhysicalNicList(priv->primary, &physicalNicList) < 0) {\n        return -1;\n    }\n\n    for (physicalNic = physicalNicList; physicalNic;\n         physicalNic = physicalNic->_next) {\n        names[count] = g_strdup(physicalNic->device);\n\n        ++count;\n    }\n\n    esxVI_PhysicalNic_Free(&physicalNicList);\n\n    return count;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"interface_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_PhysicalNic_Free",
          "args": [
            "&physicalNicList"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "physicalNic->device"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupPhysicalNicList",
          "args": [
            "priv->primary",
            "&physicalNicList"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupPhysicalNicList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3852-3889",
          "snippet": "int\nesxVI_LookupPhysicalNicList(esxVI_Context *ctx,\n                            esxVI_PhysicalNic **physicalNicList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNicList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.pnic\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.pnic\")) {\n            if (esxVI_PhysicalNic_CastListFromAnyType(dynamicProperty->val,\n                                                      physicalNicList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupPhysicalNicList(esxVI_Context *ctx,\n                            esxVI_PhysicalNic **physicalNicList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNicList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.pnic\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.pnic\")) {\n            if (esxVI_PhysicalNic_CastListFromAnyType(dynamicProperty->val,\n                                                      physicalNicList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_private.h\"\n#include \"virsocketaddr.h\"\n#include \"interface_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectListInterfaces(virConnectPtr conn, char **const names, int maxnames)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *physicalNic = NULL;\n    int count = 0;\n\n    if (maxnames == 0)\n        return 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupPhysicalNicList(priv->primary, &physicalNicList) < 0) {\n        return -1;\n    }\n\n    for (physicalNic = physicalNicList; physicalNic;\n         physicalNic = physicalNic->_next) {\n        names[count] = g_strdup(physicalNic->device);\n\n        ++count;\n    }\n\n    esxVI_PhysicalNic_Free(&physicalNicList);\n\n    return count;\n}"
  },
  {
    "function_name": "esxConnectNumOfInterfaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_interface_driver.c",
    "lines": "41-62",
    "snippet": "static int\nesxConnectNumOfInterfaces(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *physicalNic = NULL;\n    int count = 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupPhysicalNicList(priv->primary, &physicalNicList) < 0) {\n        return -1;\n    }\n\n    for (physicalNic = physicalNicList; physicalNic;\n         physicalNic = physicalNic->_next) {\n        ++count;\n    }\n\n    esxVI_PhysicalNic_Free(&physicalNicList);\n\n    return count;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_private.h\"",
      "#include \"virsocketaddr.h\"",
      "#include \"interface_conf.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_PhysicalNic_Free",
          "args": [
            "&physicalNicList"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupPhysicalNicList",
          "args": [
            "priv->primary",
            "&physicalNicList"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupPhysicalNicList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3852-3889",
          "snippet": "int\nesxVI_LookupPhysicalNicList(esxVI_Context *ctx,\n                            esxVI_PhysicalNic **physicalNicList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNicList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.pnic\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.pnic\")) {\n            if (esxVI_PhysicalNic_CastListFromAnyType(dynamicProperty->val,\n                                                      physicalNicList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupPhysicalNicList(esxVI_Context *ctx,\n                            esxVI_PhysicalNic **physicalNicList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(physicalNicList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.network.pnic\") < 0 ||\n        esxVI_LookupHostSystemProperties(ctx, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.network.pnic\")) {\n            if (esxVI_PhysicalNic_CastListFromAnyType(dynamicProperty->val,\n                                                      physicalNicList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_private.h\"\n#include \"virsocketaddr.h\"\n#include \"interface_conf.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectNumOfInterfaces(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_PhysicalNic *physicalNicList = NULL;\n    esxVI_PhysicalNic *physicalNic = NULL;\n    int count = 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0 ||\n        esxVI_LookupPhysicalNicList(priv->primary, &physicalNicList) < 0) {\n        return -1;\n    }\n\n    for (physicalNic = physicalNicList; physicalNic;\n         physicalNic = physicalNic->_next) {\n        ++count;\n    }\n\n    esxVI_PhysicalNic_Free(&physicalNicList);\n\n    return count;\n}"
  }
]