[
  {
    "function_name": "virQEMUBuildQemuImgKeySecretOpts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
    "lines": "320-355",
    "snippet": "void\nvirQEMUBuildQemuImgKeySecretOpts(virBufferPtr buf,\n                                 virStorageEncryptionInfoDefPtr encinfo,\n                                 const char *alias)\n{\n    virBufferAsprintf(buf, \"key-secret=%s,\", alias);\n\n    if (!encinfo->cipher_name)\n        return;\n\n    virBufferAddLit(buf, \"cipher-alg=\");\n    virQEMUBuildBufferEscapeComma(buf, encinfo->cipher_name);\n    virBufferAsprintf(buf, \"-%u,\", encinfo->cipher_size);\n    if (encinfo->cipher_mode) {\n        virBufferAddLit(buf, \"cipher-mode=\");\n        virQEMUBuildBufferEscapeComma(buf, encinfo->cipher_mode);\n        virBufferAddLit(buf, \",\");\n    }\n    if (encinfo->cipher_hash) {\n        virBufferAddLit(buf, \"hash-alg=\");\n        virQEMUBuildBufferEscapeComma(buf, encinfo->cipher_hash);\n        virBufferAddLit(buf, \",\");\n    }\n    if (!encinfo->ivgen_name)\n        return;\n\n    virBufferAddLit(buf, \"ivgen-alg=\");\n    virQEMUBuildBufferEscapeComma(buf, encinfo->ivgen_name);\n    virBufferAddLit(buf, \",\");\n\n    if (encinfo->ivgen_hash) {\n        virBufferAddLit(buf, \"ivgen-hash-alg=\");\n        virQEMUBuildBufferEscapeComma(buf, encinfo->ivgen_hash);\n        virBufferAddLit(buf, \",\");\n    }\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\",\""
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUBuildBufferEscapeComma",
          "args": [
            "buf",
            "encinfo->ivgen_hash"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUBuildBufferEscapeComma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
          "lines": "293-297",
          "snippet": "void\nvirQEMUBuildBufferEscapeComma(virBufferPtr buf, const char *str)\n{\n    virBufferEscape(buf, ',', \",\", \"%s\", str);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nvoid\nvirQEMUBuildBufferEscapeComma(virBufferPtr buf, const char *str)\n{\n    virBufferEscape(buf, ',', \",\", \"%s\", str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"ivgen-hash-alg=\""
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\",\""
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"ivgen-alg=\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\",\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"hash-alg=\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\",\""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"cipher-mode=\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"-%u,\"",
            "encinfo->cipher_size"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"cipher-alg=\""
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nvoid\nvirQEMUBuildQemuImgKeySecretOpts(virBufferPtr buf,\n                                 virStorageEncryptionInfoDefPtr encinfo,\n                                 const char *alias)\n{\n    virBufferAsprintf(buf, \"key-secret=%s,\", alias);\n\n    if (!encinfo->cipher_name)\n        return;\n\n    virBufferAddLit(buf, \"cipher-alg=\");\n    virQEMUBuildBufferEscapeComma(buf, encinfo->cipher_name);\n    virBufferAsprintf(buf, \"-%u,\", encinfo->cipher_size);\n    if (encinfo->cipher_mode) {\n        virBufferAddLit(buf, \"cipher-mode=\");\n        virQEMUBuildBufferEscapeComma(buf, encinfo->cipher_mode);\n        virBufferAddLit(buf, \",\");\n    }\n    if (encinfo->cipher_hash) {\n        virBufferAddLit(buf, \"hash-alg=\");\n        virQEMUBuildBufferEscapeComma(buf, encinfo->cipher_hash);\n        virBufferAddLit(buf, \",\");\n    }\n    if (!encinfo->ivgen_name)\n        return;\n\n    virBufferAddLit(buf, \"ivgen-alg=\");\n    virQEMUBuildBufferEscapeComma(buf, encinfo->ivgen_name);\n    virBufferAddLit(buf, \",\");\n\n    if (encinfo->ivgen_hash) {\n        virBufferAddLit(buf, \"ivgen-hash-alg=\");\n        virQEMUBuildBufferEscapeComma(buf, encinfo->ivgen_hash);\n        virBufferAddLit(buf, \",\");\n    }\n}"
  },
  {
    "function_name": "virQEMUBuildBufferEscapeComma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
    "lines": "293-297",
    "snippet": "void\nvirQEMUBuildBufferEscapeComma(virBufferPtr buf, const char *str)\n{\n    virBufferEscape(buf, ',', \",\", \"%s\", str);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferEscape",
          "args": [
            "buf",
            "','",
            "\",\"",
            "\"%s\"",
            "str"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "491-522",
          "snippet": "void\nvirBufferEscape(virBufferPtr buf, char escape, const char *toescape,\n                const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, toescape) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 2);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (strchr(toescape, *cur))\n            *out++ = escape;\n        *out++ = *cur;\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscape(virBufferPtr buf, char escape, const char *toescape,\n                const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, toescape) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 2);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (strchr(toescape, *cur))\n            *out++ = escape;\n        *out++ = *cur;\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nvoid\nvirQEMUBuildBufferEscapeComma(virBufferPtr buf, const char *str)\n{\n    virBufferEscape(buf, ',', \",\", \"%s\", str);\n}"
  },
  {
    "function_name": "virQEMUBuildDriveCommandlineFromJSON",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
    "lines": "267-282",
    "snippet": "char *\nvirQEMUBuildDriveCommandlineFromJSON(virJSONValuePtr srcdef)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *ret = NULL;\n\n    if (virQEMUBuildCommandLineJSON(srcdef, &buf,\n                                    virQEMUBuildCommandLineJSONArrayNumbered) < 0)\n        goto cleanup;\n\n    ret = virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUBuildCommandLineJSON",
          "args": [
            "srcdef",
            "&buf",
            "virQEMUBuildCommandLineJSONArrayNumbered"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUBuildCommandLineJSON",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
          "lines": "215-226",
          "snippet": "int\nvirQEMUBuildCommandLineJSON(virJSONValuePtr value,\n                            virBufferPtr buf,\n                            virQEMUBuildCommandLineJSONArrayFormatFunc array)\n{\n    if (virQEMUBuildCommandLineJSONRecurse(NULL, value, buf, array, false) < 0)\n        return -1;\n\n    virBufferTrim(buf, \",\");\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nint\nvirQEMUBuildCommandLineJSON(virJSONValuePtr value,\n                            virBufferPtr buf,\n                            virQEMUBuildCommandLineJSONArrayFormatFunc array)\n{\n    if (virQEMUBuildCommandLineJSONRecurse(NULL, value, buf, array, false) < 0)\n        return -1;\n\n    virBufferTrim(buf, \",\");\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nchar *\nvirQEMUBuildDriveCommandlineFromJSON(virJSONValuePtr srcdef)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *ret = NULL;\n\n    if (virQEMUBuildCommandLineJSON(srcdef, &buf,\n                                    virQEMUBuildCommandLineJSONArrayNumbered) < 0)\n        goto cleanup;\n\n    ret = virBufferContentAndReset(&buf);\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return ret;\n}"
  },
  {
    "function_name": "virQEMUBuildObjectCommandlineFromJSON",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
    "lines": "255-264",
    "snippet": "int\nvirQEMUBuildObjectCommandlineFromJSON(virBufferPtr buf,\n                                      virJSONValuePtr objprops)\n{\n    const char *type = virJSONValueObjectGetString(objprops, \"qom-type\");\n    const char *alias = virJSONValueObjectGetString(objprops, \"id\");\n    virJSONValuePtr props = virJSONValueObjectGetObject(objprops, \"props\");\n\n    return virQEMUBuildObjectCommandlineFromJSONInternal(buf, type, alias, props);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUBuildObjectCommandlineFromJSONInternal",
          "args": [
            "buf",
            "type",
            "alias",
            "props"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUBuildObjectCommandlineFromJSONInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
          "lines": "229-252",
          "snippet": "static int\nvirQEMUBuildObjectCommandlineFromJSONInternal(virBufferPtr buf,\n                                              const char *type,\n                                              const char *alias,\n                                              virJSONValuePtr props)\n{\n    if (!type || !alias) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'type'(%s) or 'alias'(%s) field of QOM 'object'\"),\n                       NULLSTR(type), NULLSTR(alias));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"%s,id=%s\", type, alias);\n\n    if (props) {\n        virBufferAddLit(buf, \",\");\n        if (virQEMUBuildCommandLineJSON(props, buf,\n                                virQEMUBuildCommandLineJSONArrayBitmap) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nstatic int\nvirQEMUBuildObjectCommandlineFromJSONInternal(virBufferPtr buf,\n                                              const char *type,\n                                              const char *alias,\n                                              virJSONValuePtr props)\n{\n    if (!type || !alias) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'type'(%s) or 'alias'(%s) field of QOM 'object'\"),\n                       NULLSTR(type), NULLSTR(alias));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"%s,id=%s\", type, alias);\n\n    if (props) {\n        virBufferAddLit(buf, \",\");\n        if (virQEMUBuildCommandLineJSON(props, buf,\n                                virQEMUBuildCommandLineJSONArrayBitmap) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetObject",
          "args": [
            "objprops",
            "\"props\""
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetObject",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1415-1419",
          "snippet": "virJSONValuePtr\nvirJSONValueObjectGetObject(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_OBJECT);\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueObjectGetObject(virJSONValuePtr object, const char *key)\n{\n    return virJSONValueObjectGetByType(object, key, VIR_JSON_TYPE_OBJECT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectGetString",
          "args": [
            "objprops",
            "\"id\""
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectGetStringOrNumber",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1313-1328",
          "snippet": "const char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueObjectGetStringOrNumber(virJSONValuePtr object,\n                                    const char *key)\n{\n    virJSONValuePtr val = virJSONValueObjectGet(object, key);\n\n    if (!val)\n        return NULL;\n\n    if (val->type == VIR_JSON_TYPE_STRING)\n        return val->data.string;\n    else if (val->type == VIR_JSON_TYPE_NUMBER)\n        return val->data.number;\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nint\nvirQEMUBuildObjectCommandlineFromJSON(virBufferPtr buf,\n                                      virJSONValuePtr objprops)\n{\n    const char *type = virJSONValueObjectGetString(objprops, \"qom-type\");\n    const char *alias = virJSONValueObjectGetString(objprops, \"id\");\n    virJSONValuePtr props = virJSONValueObjectGetObject(objprops, \"props\");\n\n    return virQEMUBuildObjectCommandlineFromJSONInternal(buf, type, alias, props);\n}"
  },
  {
    "function_name": "virQEMUBuildObjectCommandlineFromJSONInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
    "lines": "229-252",
    "snippet": "static int\nvirQEMUBuildObjectCommandlineFromJSONInternal(virBufferPtr buf,\n                                              const char *type,\n                                              const char *alias,\n                                              virJSONValuePtr props)\n{\n    if (!type || !alias) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'type'(%s) or 'alias'(%s) field of QOM 'object'\"),\n                       NULLSTR(type), NULLSTR(alias));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"%s,id=%s\", type, alias);\n\n    if (props) {\n        virBufferAddLit(buf, \",\");\n        if (virQEMUBuildCommandLineJSON(props, buf,\n                                virQEMUBuildCommandLineJSONArrayBitmap) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUBuildCommandLineJSON",
          "args": [
            "props",
            "buf",
            "virQEMUBuildCommandLineJSONArrayBitmap"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUBuildCommandLineJSON",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
          "lines": "215-226",
          "snippet": "int\nvirQEMUBuildCommandLineJSON(virJSONValuePtr value,\n                            virBufferPtr buf,\n                            virQEMUBuildCommandLineJSONArrayFormatFunc array)\n{\n    if (virQEMUBuildCommandLineJSONRecurse(NULL, value, buf, array, false) < 0)\n        return -1;\n\n    virBufferTrim(buf, \",\");\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nint\nvirQEMUBuildCommandLineJSON(virJSONValuePtr value,\n                            virBufferPtr buf,\n                            virQEMUBuildCommandLineJSONArrayFormatFunc array)\n{\n    if (virQEMUBuildCommandLineJSONRecurse(NULL, value, buf, array, false) < 0)\n        return -1;\n\n    virBufferTrim(buf, \",\");\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\",\""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"%s,id=%s\"",
            "type",
            "alias"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing 'type'(%s) or 'alias'(%s) field of QOM 'object'\")",
            "NULLSTR(type)",
            "NULLSTR(alias)"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "alias"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "type"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing 'type'(%s) or 'alias'(%s) field of QOM 'object'\""
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nstatic int\nvirQEMUBuildObjectCommandlineFromJSONInternal(virBufferPtr buf,\n                                              const char *type,\n                                              const char *alias,\n                                              virJSONValuePtr props)\n{\n    if (!type || !alias) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'type'(%s) or 'alias'(%s) field of QOM 'object'\"),\n                       NULLSTR(type), NULLSTR(alias));\n        return -1;\n    }\n\n    virBufferAsprintf(buf, \"%s,id=%s\", type, alias);\n\n    if (props) {\n        virBufferAddLit(buf, \",\");\n        if (virQEMUBuildCommandLineJSON(props, buf,\n                                virQEMUBuildCommandLineJSONArrayBitmap) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUBuildCommandLineJSON",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
    "lines": "215-226",
    "snippet": "int\nvirQEMUBuildCommandLineJSON(virJSONValuePtr value,\n                            virBufferPtr buf,\n                            virQEMUBuildCommandLineJSONArrayFormatFunc array)\n{\n    if (virQEMUBuildCommandLineJSONRecurse(NULL, value, buf, array, false) < 0)\n        return -1;\n\n    virBufferTrim(buf, \",\");\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferTrim",
          "args": [
            "buf",
            "\",\""
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferTrimLen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "698-708",
          "snippet": "void\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferTrimLen(virBufferPtr buf, int len)\n{\n    if (!buf || !buf->str)\n        return;\n\n    if (len > buf->str->len)\n        return;\n\n    g_string_truncate(buf->str, buf->str->len - len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUBuildCommandLineJSONRecurse",
          "args": [
            "NULL",
            "value",
            "buf",
            "array",
            "false"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUBuildCommandLineJSONRecurse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
          "lines": "126-201",
          "snippet": "static int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested)\n{\n    struct virQEMUCommandLineJSONIteratorData data = { key, buf, arrayFunc };\n    virJSONType type = virJSONValueGetType(value);\n    virJSONValuePtr elem;\n    bool tmp;\n    size_t i;\n\n    if (!key && type != VIR_JSON_TYPE_OBJECT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"only JSON objects can be top level\"));\n        return -1;\n    }\n\n    switch (type) {\n    case VIR_JSON_TYPE_STRING:\n        virBufferAsprintf(buf, \"%s=\", key);\n        virQEMUBuildBufferEscapeComma(buf, virJSONValueGetString(value));\n        virBufferAddLit(buf, \",\");\n        break;\n\n    case VIR_JSON_TYPE_NUMBER:\n        virBufferAsprintf(buf, \"%s=%s,\", key, virJSONValueGetNumberString(value));\n        break;\n\n    case VIR_JSON_TYPE_BOOLEAN:\n        virJSONValueGetBoolean(value, &tmp);\n        if (tmp)\n            virBufferAsprintf(buf, \"%s=yes,\", key);\n        else\n            virBufferAsprintf(buf, \"%s=no,\", key);\n\n        break;\n\n    case VIR_JSON_TYPE_ARRAY:\n        if (nested) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"nested JSON array to commandline conversion is \"\n                             \"not supported\"));\n            return -1;\n        }\n\n        if (!arrayFunc || arrayFunc(key, value, buf) < 0) {\n            /* fallback, treat the array as a non-bitmap, adding the key\n             * for each member */\n            for (i = 0; i < virJSONValueArraySize(value); i++) {\n                elem = virJSONValueArrayGet((virJSONValuePtr)value, i);\n\n                /* recurse to avoid duplicating code */\n                if (virQEMUBuildCommandLineJSONRecurse(key, elem, buf,\n                                                       arrayFunc, true) < 0)\n                    return -1;\n            }\n        }\n        break;\n\n    case VIR_JSON_TYPE_OBJECT:\n        if (virJSONValueObjectForeachKeyValue(value,\n                                              virQEMUBuildCommandLineJSONIterate,\n                                              &data) < 0)\n            return -1;\n        break;\n\n    case VIR_JSON_TYPE_NULL:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"NULL JSON type can't be converted to commandline\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nstatic int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested);\n\nstatic int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested)\n{\n    struct virQEMUCommandLineJSONIteratorData data = { key, buf, arrayFunc };\n    virJSONType type = virJSONValueGetType(value);\n    virJSONValuePtr elem;\n    bool tmp;\n    size_t i;\n\n    if (!key && type != VIR_JSON_TYPE_OBJECT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"only JSON objects can be top level\"));\n        return -1;\n    }\n\n    switch (type) {\n    case VIR_JSON_TYPE_STRING:\n        virBufferAsprintf(buf, \"%s=\", key);\n        virQEMUBuildBufferEscapeComma(buf, virJSONValueGetString(value));\n        virBufferAddLit(buf, \",\");\n        break;\n\n    case VIR_JSON_TYPE_NUMBER:\n        virBufferAsprintf(buf, \"%s=%s,\", key, virJSONValueGetNumberString(value));\n        break;\n\n    case VIR_JSON_TYPE_BOOLEAN:\n        virJSONValueGetBoolean(value, &tmp);\n        if (tmp)\n            virBufferAsprintf(buf, \"%s=yes,\", key);\n        else\n            virBufferAsprintf(buf, \"%s=no,\", key);\n\n        break;\n\n    case VIR_JSON_TYPE_ARRAY:\n        if (nested) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"nested JSON array to commandline conversion is \"\n                             \"not supported\"));\n            return -1;\n        }\n\n        if (!arrayFunc || arrayFunc(key, value, buf) < 0) {\n            /* fallback, treat the array as a non-bitmap, adding the key\n             * for each member */\n            for (i = 0; i < virJSONValueArraySize(value); i++) {\n                elem = virJSONValueArrayGet((virJSONValuePtr)value, i);\n\n                /* recurse to avoid duplicating code */\n                if (virQEMUBuildCommandLineJSONRecurse(key, elem, buf,\n                                                       arrayFunc, true) < 0)\n                    return -1;\n            }\n        }\n        break;\n\n    case VIR_JSON_TYPE_OBJECT:\n        if (virJSONValueObjectForeachKeyValue(value,\n                                              virQEMUBuildCommandLineJSONIterate,\n                                              &data) < 0)\n            return -1;\n        break;\n\n    case VIR_JSON_TYPE_NULL:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"NULL JSON type can't be converted to commandline\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nint\nvirQEMUBuildCommandLineJSON(virJSONValuePtr value,\n                            virBufferPtr buf,\n                            virQEMUBuildCommandLineJSONArrayFormatFunc array)\n{\n    if (virQEMUBuildCommandLineJSONRecurse(NULL, value, buf, array, false) < 0)\n        return -1;\n\n    virBufferTrim(buf, \",\");\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUBuildCommandLineJSONRecurse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
    "lines": "126-201",
    "snippet": "static int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested)\n{\n    struct virQEMUCommandLineJSONIteratorData data = { key, buf, arrayFunc };\n    virJSONType type = virJSONValueGetType(value);\n    virJSONValuePtr elem;\n    bool tmp;\n    size_t i;\n\n    if (!key && type != VIR_JSON_TYPE_OBJECT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"only JSON objects can be top level\"));\n        return -1;\n    }\n\n    switch (type) {\n    case VIR_JSON_TYPE_STRING:\n        virBufferAsprintf(buf, \"%s=\", key);\n        virQEMUBuildBufferEscapeComma(buf, virJSONValueGetString(value));\n        virBufferAddLit(buf, \",\");\n        break;\n\n    case VIR_JSON_TYPE_NUMBER:\n        virBufferAsprintf(buf, \"%s=%s,\", key, virJSONValueGetNumberString(value));\n        break;\n\n    case VIR_JSON_TYPE_BOOLEAN:\n        virJSONValueGetBoolean(value, &tmp);\n        if (tmp)\n            virBufferAsprintf(buf, \"%s=yes,\", key);\n        else\n            virBufferAsprintf(buf, \"%s=no,\", key);\n\n        break;\n\n    case VIR_JSON_TYPE_ARRAY:\n        if (nested) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"nested JSON array to commandline conversion is \"\n                             \"not supported\"));\n            return -1;\n        }\n\n        if (!arrayFunc || arrayFunc(key, value, buf) < 0) {\n            /* fallback, treat the array as a non-bitmap, adding the key\n             * for each member */\n            for (i = 0; i < virJSONValueArraySize(value); i++) {\n                elem = virJSONValueArrayGet((virJSONValuePtr)value, i);\n\n                /* recurse to avoid duplicating code */\n                if (virQEMUBuildCommandLineJSONRecurse(key, elem, buf,\n                                                       arrayFunc, true) < 0)\n                    return -1;\n            }\n        }\n        break;\n\n    case VIR_JSON_TYPE_OBJECT:\n        if (virJSONValueObjectForeachKeyValue(value,\n                                              virQEMUBuildCommandLineJSONIterate,\n                                              &data) < 0)\n            return -1;\n        break;\n\n    case VIR_JSON_TYPE_NULL:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"NULL JSON type can't be converted to commandline\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"NULL JSON type can't be converted to commandline\")"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"NULL JSON type can't be converted to commandline\""
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueObjectForeachKeyValue",
          "args": [
            "value",
            "virQEMUBuildCommandLineJSONIterate",
            "&data"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueObjectForeachKeyValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1469-1487",
          "snippet": "int\nvirJSONValueObjectForeachKeyValue(virJSONValuePtr object,\n                                  virJSONValueObjectIteratorFunc cb,\n                                  void *opaque)\n{\n    size_t i;\n\n    if (object->type != VIR_JSON_TYPE_OBJECT)\n        return -1;\n\n    for (i = 0; i < object->data.object.npairs; i++) {\n        virJSONObjectPairPtr elem = object->data.object.pairs + i;\n\n        if (cb(elem->key, elem->value, opaque) < 0)\n            return -2;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueObjectForeachKeyValue(virJSONValuePtr object,\n                                  virJSONValueObjectIteratorFunc cb,\n                                  void *opaque)\n{\n    size_t i;\n\n    if (object->type != VIR_JSON_TYPE_OBJECT)\n        return -1;\n\n    for (i = 0; i < object->data.object.npairs; i++) {\n        virJSONObjectPairPtr elem = object->data.object.pairs + i;\n\n        if (cb(elem->key, elem->value, opaque) < 0)\n            return -2;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUBuildCommandLineJSONRecurse",
          "args": [
            "key",
            "elem",
            "buf",
            "arrayFunc",
            "true"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUBuildCommandLineJSONRecurse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
          "lines": "126-201",
          "snippet": "static int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested)\n{\n    struct virQEMUCommandLineJSONIteratorData data = { key, buf, arrayFunc };\n    virJSONType type = virJSONValueGetType(value);\n    virJSONValuePtr elem;\n    bool tmp;\n    size_t i;\n\n    if (!key && type != VIR_JSON_TYPE_OBJECT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"only JSON objects can be top level\"));\n        return -1;\n    }\n\n    switch (type) {\n    case VIR_JSON_TYPE_STRING:\n        virBufferAsprintf(buf, \"%s=\", key);\n        virQEMUBuildBufferEscapeComma(buf, virJSONValueGetString(value));\n        virBufferAddLit(buf, \",\");\n        break;\n\n    case VIR_JSON_TYPE_NUMBER:\n        virBufferAsprintf(buf, \"%s=%s,\", key, virJSONValueGetNumberString(value));\n        break;\n\n    case VIR_JSON_TYPE_BOOLEAN:\n        virJSONValueGetBoolean(value, &tmp);\n        if (tmp)\n            virBufferAsprintf(buf, \"%s=yes,\", key);\n        else\n            virBufferAsprintf(buf, \"%s=no,\", key);\n\n        break;\n\n    case VIR_JSON_TYPE_ARRAY:\n        if (nested) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"nested JSON array to commandline conversion is \"\n                             \"not supported\"));\n            return -1;\n        }\n\n        if (!arrayFunc || arrayFunc(key, value, buf) < 0) {\n            /* fallback, treat the array as a non-bitmap, adding the key\n             * for each member */\n            for (i = 0; i < virJSONValueArraySize(value); i++) {\n                elem = virJSONValueArrayGet((virJSONValuePtr)value, i);\n\n                /* recurse to avoid duplicating code */\n                if (virQEMUBuildCommandLineJSONRecurse(key, elem, buf,\n                                                       arrayFunc, true) < 0)\n                    return -1;\n            }\n        }\n        break;\n\n    case VIR_JSON_TYPE_OBJECT:\n        if (virJSONValueObjectForeachKeyValue(value,\n                                              virQEMUBuildCommandLineJSONIterate,\n                                              &data) < 0)\n            return -1;\n        break;\n\n    case VIR_JSON_TYPE_NULL:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"NULL JSON type can't be converted to commandline\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayGet",
          "args": [
            "(virJSONValuePtr)value",
            "i"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1024-1035",
          "snippet": "virJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArraySize",
          "args": [
            "value"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArraySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1017-1021",
          "snippet": "size_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nsize_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arrayFunc",
          "args": [
            "key",
            "value",
            "buf"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"nested JSON array to commandline conversion is \"\n                             \"not supported\")"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"%s=no,\"",
            "key"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueGetBoolean",
          "args": [
            "value",
            "&tmp"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueGetBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1190-1199",
          "snippet": "int\nvirJSONValueGetBoolean(virJSONValuePtr val,\n                       bool *value)\n{\n    if (val->type != VIR_JSON_TYPE_BOOLEAN)\n        return -1;\n\n    *value = val->data.boolean;\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueGetBoolean(virJSONValuePtr val,\n                       bool *value)\n{\n    if (val->type != VIR_JSON_TYPE_BOOLEAN)\n        return -1;\n\n    *value = val->data.boolean;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueGetNumberString",
          "args": [
            "value"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueGetNumberString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1125-1132",
          "snippet": "const char *\nvirJSONValueGetNumberString(virJSONValuePtr number)\n{\n    if (number->type != VIR_JSON_TYPE_NUMBER)\n        return NULL;\n\n    return number->data.number;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueGetNumberString(virJSONValuePtr number)\n{\n    if (number->type != VIR_JSON_TYPE_NUMBER)\n        return NULL;\n\n    return number->data.number;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\",\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUBuildBufferEscapeComma",
          "args": [
            "buf",
            "virJSONValueGetString(value)"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUBuildBufferEscapeComma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
          "lines": "293-297",
          "snippet": "void\nvirQEMUBuildBufferEscapeComma(virBufferPtr buf, const char *str)\n{\n    virBufferEscape(buf, ',', \",\", \"%s\", str);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nvoid\nvirQEMUBuildBufferEscapeComma(virBufferPtr buf, const char *str)\n{\n    virBufferEscape(buf, ',', \",\", \"%s\", str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueGetString",
          "args": [
            "value"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueGetString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1115-1122",
          "snippet": "const char *\nvirJSONValueGetString(virJSONValuePtr string)\n{\n    if (string->type != VIR_JSON_TYPE_STRING)\n        return NULL;\n\n    return string->data.string;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nconst char *\nvirJSONValueGetString(virJSONValuePtr string)\n{\n    if (string->type != VIR_JSON_TYPE_STRING)\n        return NULL;\n\n    return string->data.string;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"only JSON objects can be top level\")"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virJSONValueGetType",
          "args": [
            "value"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "101-105",
          "snippet": "virJSONType\nvirJSONValueGetType(const virJSONValue *value)\n{\n    return value->type;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONType\nvirJSONValueGetType(const virJSONValue *value)\n{\n    return value->type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nstatic int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested);\n\nstatic int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested)\n{\n    struct virQEMUCommandLineJSONIteratorData data = { key, buf, arrayFunc };\n    virJSONType type = virJSONValueGetType(value);\n    virJSONValuePtr elem;\n    bool tmp;\n    size_t i;\n\n    if (!key && type != VIR_JSON_TYPE_OBJECT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"only JSON objects can be top level\"));\n        return -1;\n    }\n\n    switch (type) {\n    case VIR_JSON_TYPE_STRING:\n        virBufferAsprintf(buf, \"%s=\", key);\n        virQEMUBuildBufferEscapeComma(buf, virJSONValueGetString(value));\n        virBufferAddLit(buf, \",\");\n        break;\n\n    case VIR_JSON_TYPE_NUMBER:\n        virBufferAsprintf(buf, \"%s=%s,\", key, virJSONValueGetNumberString(value));\n        break;\n\n    case VIR_JSON_TYPE_BOOLEAN:\n        virJSONValueGetBoolean(value, &tmp);\n        if (tmp)\n            virBufferAsprintf(buf, \"%s=yes,\", key);\n        else\n            virBufferAsprintf(buf, \"%s=no,\", key);\n\n        break;\n\n    case VIR_JSON_TYPE_ARRAY:\n        if (nested) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"nested JSON array to commandline conversion is \"\n                             \"not supported\"));\n            return -1;\n        }\n\n        if (!arrayFunc || arrayFunc(key, value, buf) < 0) {\n            /* fallback, treat the array as a non-bitmap, adding the key\n             * for each member */\n            for (i = 0; i < virJSONValueArraySize(value); i++) {\n                elem = virJSONValueArrayGet((virJSONValuePtr)value, i);\n\n                /* recurse to avoid duplicating code */\n                if (virQEMUBuildCommandLineJSONRecurse(key, elem, buf,\n                                                       arrayFunc, true) < 0)\n                    return -1;\n            }\n        }\n        break;\n\n    case VIR_JSON_TYPE_OBJECT:\n        if (virJSONValueObjectForeachKeyValue(value,\n                                              virQEMUBuildCommandLineJSONIterate,\n                                              &data) < 0)\n            return -1;\n        break;\n\n    case VIR_JSON_TYPE_NULL:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"NULL JSON type can't be converted to commandline\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUBuildCommandLineJSONIterate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
    "lines": "105-123",
    "snippet": "static int\nvirQEMUBuildCommandLineJSONIterate(const char *key,\n                                   virJSONValuePtr value,\n                                   void *opaque)\n{\n    struct virQEMUCommandLineJSONIteratorData *data = opaque;\n\n    if (data->prefix) {\n        g_autofree char *tmpkey = NULL;\n\n        tmpkey = g_strdup_printf(\"%s.%s\", data->prefix, key);\n\n        return virQEMUBuildCommandLineJSONRecurse(tmpkey, value, data->buf,\n                                                  data->arrayFunc, false);\n    } else {\n        return virQEMUBuildCommandLineJSONRecurse(key, value, data->buf,\n                                                  data->arrayFunc, false);\n    }\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUBuildCommandLineJSONRecurse",
          "args": [
            "key",
            "value",
            "data->buf",
            "data->arrayFunc",
            "false"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUBuildCommandLineJSONRecurse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
          "lines": "126-201",
          "snippet": "static int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested)\n{\n    struct virQEMUCommandLineJSONIteratorData data = { key, buf, arrayFunc };\n    virJSONType type = virJSONValueGetType(value);\n    virJSONValuePtr elem;\n    bool tmp;\n    size_t i;\n\n    if (!key && type != VIR_JSON_TYPE_OBJECT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"only JSON objects can be top level\"));\n        return -1;\n    }\n\n    switch (type) {\n    case VIR_JSON_TYPE_STRING:\n        virBufferAsprintf(buf, \"%s=\", key);\n        virQEMUBuildBufferEscapeComma(buf, virJSONValueGetString(value));\n        virBufferAddLit(buf, \",\");\n        break;\n\n    case VIR_JSON_TYPE_NUMBER:\n        virBufferAsprintf(buf, \"%s=%s,\", key, virJSONValueGetNumberString(value));\n        break;\n\n    case VIR_JSON_TYPE_BOOLEAN:\n        virJSONValueGetBoolean(value, &tmp);\n        if (tmp)\n            virBufferAsprintf(buf, \"%s=yes,\", key);\n        else\n            virBufferAsprintf(buf, \"%s=no,\", key);\n\n        break;\n\n    case VIR_JSON_TYPE_ARRAY:\n        if (nested) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"nested JSON array to commandline conversion is \"\n                             \"not supported\"));\n            return -1;\n        }\n\n        if (!arrayFunc || arrayFunc(key, value, buf) < 0) {\n            /* fallback, treat the array as a non-bitmap, adding the key\n             * for each member */\n            for (i = 0; i < virJSONValueArraySize(value); i++) {\n                elem = virJSONValueArrayGet((virJSONValuePtr)value, i);\n\n                /* recurse to avoid duplicating code */\n                if (virQEMUBuildCommandLineJSONRecurse(key, elem, buf,\n                                                       arrayFunc, true) < 0)\n                    return -1;\n            }\n        }\n        break;\n\n    case VIR_JSON_TYPE_OBJECT:\n        if (virJSONValueObjectForeachKeyValue(value,\n                                              virQEMUBuildCommandLineJSONIterate,\n                                              &data) < 0)\n            return -1;\n        break;\n\n    case VIR_JSON_TYPE_NULL:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"NULL JSON type can't be converted to commandline\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nstatic int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested);\n\nstatic int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested)\n{\n    struct virQEMUCommandLineJSONIteratorData data = { key, buf, arrayFunc };\n    virJSONType type = virJSONValueGetType(value);\n    virJSONValuePtr elem;\n    bool tmp;\n    size_t i;\n\n    if (!key && type != VIR_JSON_TYPE_OBJECT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"only JSON objects can be top level\"));\n        return -1;\n    }\n\n    switch (type) {\n    case VIR_JSON_TYPE_STRING:\n        virBufferAsprintf(buf, \"%s=\", key);\n        virQEMUBuildBufferEscapeComma(buf, virJSONValueGetString(value));\n        virBufferAddLit(buf, \",\");\n        break;\n\n    case VIR_JSON_TYPE_NUMBER:\n        virBufferAsprintf(buf, \"%s=%s,\", key, virJSONValueGetNumberString(value));\n        break;\n\n    case VIR_JSON_TYPE_BOOLEAN:\n        virJSONValueGetBoolean(value, &tmp);\n        if (tmp)\n            virBufferAsprintf(buf, \"%s=yes,\", key);\n        else\n            virBufferAsprintf(buf, \"%s=no,\", key);\n\n        break;\n\n    case VIR_JSON_TYPE_ARRAY:\n        if (nested) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"nested JSON array to commandline conversion is \"\n                             \"not supported\"));\n            return -1;\n        }\n\n        if (!arrayFunc || arrayFunc(key, value, buf) < 0) {\n            /* fallback, treat the array as a non-bitmap, adding the key\n             * for each member */\n            for (i = 0; i < virJSONValueArraySize(value); i++) {\n                elem = virJSONValueArrayGet((virJSONValuePtr)value, i);\n\n                /* recurse to avoid duplicating code */\n                if (virQEMUBuildCommandLineJSONRecurse(key, elem, buf,\n                                                       arrayFunc, true) < 0)\n                    return -1;\n            }\n        }\n        break;\n\n    case VIR_JSON_TYPE_OBJECT:\n        if (virJSONValueObjectForeachKeyValue(value,\n                                              virQEMUBuildCommandLineJSONIterate,\n                                              &data) < 0)\n            return -1;\n        break;\n\n    case VIR_JSON_TYPE_NULL:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"NULL JSON type can't be converted to commandline\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s.%s\"",
            "data->prefix",
            "key"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nstatic int\nvirQEMUBuildCommandLineJSONIterate(const char *key,\n                                   virJSONValuePtr value,\n                                   void *opaque)\n{\n    struct virQEMUCommandLineJSONIteratorData *data = opaque;\n\n    if (data->prefix) {\n        g_autofree char *tmpkey = NULL;\n\n        tmpkey = g_strdup_printf(\"%s.%s\", data->prefix, key);\n\n        return virQEMUBuildCommandLineJSONRecurse(tmpkey, value, data->buf,\n                                                  data->arrayFunc, false);\n    } else {\n        return virQEMUBuildCommandLineJSONRecurse(key, value, data->buf,\n                                                  data->arrayFunc, false);\n    }\n}"
  },
  {
    "function_name": "virQEMUBuildCommandLineJSONArrayNumbered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
    "lines": "80-101",
    "snippet": "int\nvirQEMUBuildCommandLineJSONArrayNumbered(const char *key,\n                                         virJSONValuePtr array,\n                                         virBufferPtr buf)\n{\n    virJSONValuePtr member;\n    size_t i;\n\n    for (i = 0; i < virJSONValueArraySize(array); i++) {\n        member = virJSONValueArrayGet((virJSONValuePtr) array, i);\n        g_autofree char *prefix = NULL;\n\n        prefix = g_strdup_printf(\"%s.%zu\", key, i);\n\n        if (virQEMUBuildCommandLineJSONRecurse(prefix, member, buf,\n                                               virQEMUBuildCommandLineJSONArrayNumbered,\n                                               true) < 0)\n            return 0;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virQEMUBuildCommandLineJSONRecurse",
          "args": [
            "prefix",
            "member",
            "buf",
            "virQEMUBuildCommandLineJSONArrayNumbered",
            "true"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUBuildCommandLineJSONRecurse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
          "lines": "126-201",
          "snippet": "static int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested)\n{\n    struct virQEMUCommandLineJSONIteratorData data = { key, buf, arrayFunc };\n    virJSONType type = virJSONValueGetType(value);\n    virJSONValuePtr elem;\n    bool tmp;\n    size_t i;\n\n    if (!key && type != VIR_JSON_TYPE_OBJECT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"only JSON objects can be top level\"));\n        return -1;\n    }\n\n    switch (type) {\n    case VIR_JSON_TYPE_STRING:\n        virBufferAsprintf(buf, \"%s=\", key);\n        virQEMUBuildBufferEscapeComma(buf, virJSONValueGetString(value));\n        virBufferAddLit(buf, \",\");\n        break;\n\n    case VIR_JSON_TYPE_NUMBER:\n        virBufferAsprintf(buf, \"%s=%s,\", key, virJSONValueGetNumberString(value));\n        break;\n\n    case VIR_JSON_TYPE_BOOLEAN:\n        virJSONValueGetBoolean(value, &tmp);\n        if (tmp)\n            virBufferAsprintf(buf, \"%s=yes,\", key);\n        else\n            virBufferAsprintf(buf, \"%s=no,\", key);\n\n        break;\n\n    case VIR_JSON_TYPE_ARRAY:\n        if (nested) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"nested JSON array to commandline conversion is \"\n                             \"not supported\"));\n            return -1;\n        }\n\n        if (!arrayFunc || arrayFunc(key, value, buf) < 0) {\n            /* fallback, treat the array as a non-bitmap, adding the key\n             * for each member */\n            for (i = 0; i < virJSONValueArraySize(value); i++) {\n                elem = virJSONValueArrayGet((virJSONValuePtr)value, i);\n\n                /* recurse to avoid duplicating code */\n                if (virQEMUBuildCommandLineJSONRecurse(key, elem, buf,\n                                                       arrayFunc, true) < 0)\n                    return -1;\n            }\n        }\n        break;\n\n    case VIR_JSON_TYPE_OBJECT:\n        if (virJSONValueObjectForeachKeyValue(value,\n                                              virQEMUBuildCommandLineJSONIterate,\n                                              &data) < 0)\n            return -1;\n        break;\n\n    case VIR_JSON_TYPE_NULL:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"NULL JSON type can't be converted to commandline\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virqemu.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nstatic int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested);\n\nstatic int\nvirQEMUBuildCommandLineJSONRecurse(const char *key,\n                                   virJSONValuePtr value,\n                                   virBufferPtr buf,\n                                   virQEMUBuildCommandLineJSONArrayFormatFunc arrayFunc,\n                                   bool nested)\n{\n    struct virQEMUCommandLineJSONIteratorData data = { key, buf, arrayFunc };\n    virJSONType type = virJSONValueGetType(value);\n    virJSONValuePtr elem;\n    bool tmp;\n    size_t i;\n\n    if (!key && type != VIR_JSON_TYPE_OBJECT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"only JSON objects can be top level\"));\n        return -1;\n    }\n\n    switch (type) {\n    case VIR_JSON_TYPE_STRING:\n        virBufferAsprintf(buf, \"%s=\", key);\n        virQEMUBuildBufferEscapeComma(buf, virJSONValueGetString(value));\n        virBufferAddLit(buf, \",\");\n        break;\n\n    case VIR_JSON_TYPE_NUMBER:\n        virBufferAsprintf(buf, \"%s=%s,\", key, virJSONValueGetNumberString(value));\n        break;\n\n    case VIR_JSON_TYPE_BOOLEAN:\n        virJSONValueGetBoolean(value, &tmp);\n        if (tmp)\n            virBufferAsprintf(buf, \"%s=yes,\", key);\n        else\n            virBufferAsprintf(buf, \"%s=no,\", key);\n\n        break;\n\n    case VIR_JSON_TYPE_ARRAY:\n        if (nested) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"nested JSON array to commandline conversion is \"\n                             \"not supported\"));\n            return -1;\n        }\n\n        if (!arrayFunc || arrayFunc(key, value, buf) < 0) {\n            /* fallback, treat the array as a non-bitmap, adding the key\n             * for each member */\n            for (i = 0; i < virJSONValueArraySize(value); i++) {\n                elem = virJSONValueArrayGet((virJSONValuePtr)value, i);\n\n                /* recurse to avoid duplicating code */\n                if (virQEMUBuildCommandLineJSONRecurse(key, elem, buf,\n                                                       arrayFunc, true) < 0)\n                    return -1;\n            }\n        }\n        break;\n\n    case VIR_JSON_TYPE_OBJECT:\n        if (virJSONValueObjectForeachKeyValue(value,\n                                              virQEMUBuildCommandLineJSONIterate,\n                                              &data) < 0)\n            return -1;\n        break;\n\n    case VIR_JSON_TYPE_NULL:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"NULL JSON type can't be converted to commandline\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s.%zu\"",
            "key",
            "i"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArrayGet",
          "args": [
            "(virJSONValuePtr) array",
            "i"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1024-1035",
          "snippet": "virJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueArrayGet(virJSONValuePtr array,\n                     unsigned int element)\n{\n    if (array->type != VIR_JSON_TYPE_ARRAY)\n        return NULL;\n\n    if (element >= array->data.array.nvalues)\n        return NULL;\n\n    return array->data.array.values[element];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueArraySize",
          "args": [
            "array"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueArraySize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1017-1021",
          "snippet": "size_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nsize_t\nvirJSONValueArraySize(const virJSONValue *array)\n{\n    return array->data.array.nvalues;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nint\nvirQEMUBuildCommandLineJSONArrayNumbered(const char *key,\n                                         virJSONValuePtr array,\n                                         virBufferPtr buf)\n{\n    virJSONValuePtr member;\n    size_t i;\n\n    for (i = 0; i < virJSONValueArraySize(array); i++) {\n        member = virJSONValueArrayGet((virJSONValuePtr) array, i);\n        g_autofree char *prefix = NULL;\n\n        prefix = g_strdup_printf(\"%s.%zu\", key, i);\n\n        if (virQEMUBuildCommandLineJSONRecurse(prefix, member, buf,\n                                               virQEMUBuildCommandLineJSONArrayNumbered,\n                                               true) < 0)\n            return 0;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virQEMUBuildCommandLineJSONArrayBitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virqemu.c",
    "lines": "52-77",
    "snippet": "int\nvirQEMUBuildCommandLineJSONArrayBitmap(const char *key,\n                                       virJSONValuePtr array,\n                                       virBufferPtr buf)\n{\n    ssize_t pos = -1;\n    ssize_t end;\n    g_autoptr(virBitmap) bitmap = NULL;\n\n    if (virJSONValueGetArrayAsBitmap(array, &bitmap) < 0)\n        return -1;\n\n    while ((pos = virBitmapNextSetBit(bitmap, pos)) > -1) {\n        if ((end = virBitmapNextClearBit(bitmap, pos)) < 0)\n            end = virBitmapLastSetBit(bitmap) + 1;\n\n        if (end - 1 > pos) {\n            virBufferAsprintf(buf, \"%s=%zd-%zd,\", key, pos, end - 1);\n            pos = end;\n        } else {\n            virBufferAsprintf(buf, \"%s=%zd,\", key, pos);\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virqemu.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virbuffer.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\"%s=%zd,\"",
            "key",
            "pos"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapLastSetBit",
          "args": [
            "bitmap"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapLastSetBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1025-1064",
          "snippet": "ssize_t\nvirBitmapLastSetBit(virBitmapPtr bitmap)\n{\n    ssize_t i;\n    int unusedBits;\n    ssize_t sz;\n    unsigned long bits;\n\n    /* If bitmap is empty then there is no set bit */\n    if (bitmap->map_len == 0)\n        return -1;\n\n    unusedBits = bitmap->map_len * VIR_BITMAP_BITS_PER_UNIT - bitmap->nbits;\n\n    sz = bitmap->map_len - 1;\n    if (unusedBits > 0) {\n        bits = bitmap->map[sz] & (VIR_BITMAP_BIT(VIR_BITMAP_BITS_PER_UNIT - unusedBits) - 1);\n        if (bits != 0)\n            goto found;\n\n        sz--;\n    }\n\n    for (; sz >= 0; sz--) {\n        bits = bitmap->map[sz];\n        if (bits != 0)\n            goto found;\n    }\n\n    /* Only reached if no set bit was found */\n    return -1;\n\n found:\n    for (i = VIR_BITMAP_BITS_PER_UNIT - 1; i >= 0; i--) {\n        if (bits & 1UL << i)\n            return i + sz * VIR_BITMAP_BITS_PER_UNIT;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapLastSetBit(virBitmapPtr bitmap)\n{\n    ssize_t i;\n    int unusedBits;\n    ssize_t sz;\n    unsigned long bits;\n\n    /* If bitmap is empty then there is no set bit */\n    if (bitmap->map_len == 0)\n        return -1;\n\n    unusedBits = bitmap->map_len * VIR_BITMAP_BITS_PER_UNIT - bitmap->nbits;\n\n    sz = bitmap->map_len - 1;\n    if (unusedBits > 0) {\n        bits = bitmap->map[sz] & (VIR_BITMAP_BIT(VIR_BITMAP_BITS_PER_UNIT - unusedBits) - 1);\n        if (bits != 0)\n            goto found;\n\n        sz--;\n    }\n\n    for (; sz >= 0; sz--) {\n        bits = bitmap->map[sz];\n        if (bits != 0)\n            goto found;\n    }\n\n    /* Only reached if no set bit was found */\n    return -1;\n\n found:\n    for (i = VIR_BITMAP_BITS_PER_UNIT - 1; i >= 0; i--) {\n        if (bits & 1UL << i)\n            return i + sz * VIR_BITMAP_BITS_PER_UNIT;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNextClearBit",
          "args": [
            "bitmap",
            "pos"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextClearBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1078-1113",
          "snippet": "ssize_t\nvirBitmapNextClearBit(virBitmapPtr bitmap,\n                      ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = ~bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = ~bitmap->map[nl];\n\n    if (nl == bitmap->map_len - 1) {\n        /* Ensure tail bits are ignored.  */\n        int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n        if (tail)\n            bits &= -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n    }\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextClearBit(virBitmapPtr bitmap,\n                      ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = ~bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = ~bitmap->map[nl];\n\n    if (nl == bitmap->map_len - 1) {\n        /* Ensure tail bits are ignored.  */\n        int tail = bitmap->nbits % VIR_BITMAP_BITS_PER_UNIT;\n\n        if (tail)\n            bits &= -1UL >> (VIR_BITMAP_BITS_PER_UNIT - tail);\n    }\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBitmapNextSetBit",
          "args": [
            "bitmap",
            "pos"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNextSetBit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "986-1014",
          "snippet": "ssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\n#define VIR_BITMAP_BITS_PER_UNIT  ((int) sizeof(unsigned long) * CHAR_BIT)\n\nssize_t\nvirBitmapNextSetBit(virBitmapPtr bitmap,\n                    ssize_t pos)\n{\n    size_t nl;\n    size_t nb;\n    unsigned long bits;\n\n    if (pos < 0)\n        pos = -1;\n\n    pos++;\n\n    if (pos >= bitmap->nbits)\n        return -1;\n\n    nl = pos / VIR_BITMAP_BITS_PER_UNIT;\n    nb = pos % VIR_BITMAP_BITS_PER_UNIT;\n\n    bits = bitmap->map[nl] & ~((1UL << nb) - 1);\n\n    while (bits == 0 && ++nl < bitmap->map_len)\n        bits = bitmap->map[nl];\n\n    if (bits == 0)\n        return -1;\n\n    return __builtin_ffsl(bits) - 1 + nl * VIR_BITMAP_BITS_PER_UNIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueGetArrayAsBitmap",
          "args": [
            "array",
            "&bitmap"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueGetArrayAsBitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "1215-1252",
          "snippet": "int\nvirJSONValueGetArrayAsBitmap(const virJSONValue *val,\n                             virBitmapPtr *bitmap)\n{\n    virJSONValuePtr elem;\n    size_t i;\n    g_autofree unsigned long long *elems = NULL;\n    unsigned long long maxelem = 0;\n\n    *bitmap = NULL;\n\n    if (val->type != VIR_JSON_TYPE_ARRAY)\n        return -1;\n\n    if (VIR_ALLOC_N_QUIET(elems, val->data.array.nvalues) < 0)\n        return -1;\n\n    /* first pass converts array members to numbers and finds the maximum */\n    for (i = 0; i < val->data.array.nvalues; i++) {\n        elem = val->data.array.values[i];\n\n        if (elem->type != VIR_JSON_TYPE_NUMBER ||\n            virStrToLong_ullp(elem->data.number, NULL, 10, &elems[i]) < 0)\n            return -1;\n\n        if (elems[i] > maxelem)\n            maxelem = elems[i];\n    }\n\n    if (!(*bitmap = virBitmapNewQuiet(maxelem + 1)))\n        return -1;\n\n    /* second pass sets the correct bits in the map */\n    for (i = 0; i < val->data.array.nvalues; i++)\n        ignore_value(virBitmapSetBit(*bitmap, elems[i]));\n\n    return 0;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nint\nvirJSONValueGetArrayAsBitmap(const virJSONValue *val,\n                             virBitmapPtr *bitmap)\n{\n    virJSONValuePtr elem;\n    size_t i;\n    g_autofree unsigned long long *elems = NULL;\n    unsigned long long maxelem = 0;\n\n    *bitmap = NULL;\n\n    if (val->type != VIR_JSON_TYPE_ARRAY)\n        return -1;\n\n    if (VIR_ALLOC_N_QUIET(elems, val->data.array.nvalues) < 0)\n        return -1;\n\n    /* first pass converts array members to numbers and finds the maximum */\n    for (i = 0; i < val->data.array.nvalues; i++) {\n        elem = val->data.array.values[i];\n\n        if (elem->type != VIR_JSON_TYPE_NUMBER ||\n            virStrToLong_ullp(elem->data.number, NULL, 10, &elems[i]) < 0)\n            return -1;\n\n        if (elems[i] > maxelem)\n            maxelem = elems[i];\n    }\n\n    if (!(*bitmap = virBitmapNewQuiet(maxelem + 1)))\n        return -1;\n\n    /* second pass sets the correct bits in the map */\n    for (i = 0; i < val->data.array.nvalues; i++)\n        ignore_value(virBitmapSetBit(*bitmap, elems[i]));\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virqemu.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include <config.h>\n\nint\nvirQEMUBuildCommandLineJSONArrayBitmap(const char *key,\n                                       virJSONValuePtr array,\n                                       virBufferPtr buf)\n{\n    ssize_t pos = -1;\n    ssize_t end;\n    g_autoptr(virBitmap) bitmap = NULL;\n\n    if (virJSONValueGetArrayAsBitmap(array, &bitmap) < 0)\n        return -1;\n\n    while ((pos = virBitmapNextSetBit(bitmap, pos)) > -1) {\n        if ((end = virBitmapNextClearBit(bitmap, pos)) < 0)\n            end = virBitmapLastSetBit(bitmap) + 1;\n\n        if (end - 1 > pos) {\n            virBufferAsprintf(buf, \"%s=%zd-%zd,\", key, pos, end - 1);\n            pos = end;\n        } else {\n            virBufferAsprintf(buf, \"%s=%zd,\", key, pos);\n        }\n    }\n\n    return 0;\n}"
  }
]