[
  {
    "function_name": "libxlDomainMigrationSrcConfirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "1375-1429",
    "snippet": "int\nlibxlDomainMigrationSrcConfirm(libxlDriverPrivatePtr driver,\n                               virDomainObjPtr vm,\n                               unsigned int flags,\n                               int cancelled)\n{\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    virObjectEventPtr event = NULL;\n    int ret = -1;\n\n    if (cancelled) {\n        /* Resume lock process that was paused in MigrationSrcPerform */\n        virDomainLockProcessResume(driver->lockManager,\n                                   \"xen:///system\",\n                                   vm,\n                                   priv->lockState);\n        if (libxl_domain_resume(cfg->ctx, vm->def->id, 1, 0) == 0) {\n            ret = 0;\n        } else {\n            VIR_DEBUG(\"Unable to resume domain '%s' after failed migration\",\n                      vm->def->name);\n            virDomainObjSetState(vm, VIR_DOMAIN_PAUSED,\n                                 VIR_DOMAIN_PAUSED_MIGRATION);\n            event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_SUSPENDED,\n                                     VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED);\n            ignore_value(virDomainObjSave(vm, driver->xmlopt, cfg->stateDir));\n        }\n        goto cleanup;\n    }\n\n    libxlDomainDestroyInternal(driver, vm);\n    libxlDomainCleanup(driver, vm);\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF,\n                         VIR_DOMAIN_SHUTOFF_MIGRATED);\n    event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_STOPPED,\n                                              VIR_DOMAIN_EVENT_STOPPED_MIGRATED);\n\n    VIR_DEBUG(\"Domain '%s' successfully migrated\", vm->def->name);\n\n    if (flags & VIR_MIGRATE_UNDEFINE_SOURCE)\n        virDomainDeleteConfig(cfg->configDir, cfg->autostartDir, vm);\n\n    if (!vm->persistent || (flags & VIR_MIGRATE_UNDEFINE_SOURCE))\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n\n cleanup:\n    /* EndJob for corresponding BeginJob in begin phase */\n    libxlDomainObjEndJob(driver, vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectUnref(cfg);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->domainEventState",
            "event"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjEndJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjEndJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "167-179",
          "snippet": "void\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nlibxlDomainObjPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nvoid\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListRemove",
          "args": [
            "driver->domains",
            "vm"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "401-413",
          "snippet": "void\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDeleteConfig",
          "args": [
            "cfg->configDir",
            "cfg->autostartDir",
            "vm"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeleteConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29726-29753",
          "snippet": "int\nvirDomainDeleteConfig(const char *configDir,\n                      const char *autostartDir,\n                      virDomainObjPtr dom)\n{\n    g_autofree char *configFile = NULL;\n    g_autofree char *autostartLink = NULL;\n\n    if ((configFile = virDomainConfigFile(configDir, dom->def->name)) == NULL)\n        return -1;\n    if ((autostartLink = virDomainConfigFile(autostartDir,\n                                             dom->def->name)) == NULL)\n        return -1;\n\n    /* Not fatal if this doesn't work */\n    unlink(autostartLink);\n    dom->autostart = 0;\n\n    if (unlink(configFile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"cannot remove config %s\"),\n                             configFile);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeleteConfig(const char *configDir,\n                      const char *autostartDir,\n                      virDomainObjPtr dom)\n{\n    g_autofree char *configFile = NULL;\n    g_autofree char *autostartLink = NULL;\n\n    if ((configFile = virDomainConfigFile(configDir, dom->def->name)) == NULL)\n        return -1;\n    if ((autostartLink = virDomainConfigFile(autostartDir,\n                                             dom->def->name)) == NULL)\n        return -1;\n\n    /* Not fatal if this doesn't work */\n    unlink(autostartLink);\n    dom->autostart = 0;\n\n    if (unlink(configFile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"cannot remove config %s\"),\n                             configFile);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Domain '%s' successfully migrated\"",
            "vm->def->name"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainEventLifecycleNewFromObj",
          "args": [
            "vm",
            "VIR_DOMAIN_EVENT_STOPPED",
            "VIR_DOMAIN_EVENT_STOPPED_MIGRATED"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventLifecycleNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "610-616",
          "snippet": "virObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_SHUTOFF",
            "VIR_DOMAIN_SHUTOFF_MIGRATED"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainCleanup",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "837-935",
          "snippet": "void\nlibxlDomainCleanup(libxlDriverPrivatePtr driver,\n                   virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    int vnc_port;\n    char *file;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    virConnectPtr conn = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virHostdevReAttachDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                    vm->def, hostdev_flags, NULL);\n\n    VIR_FREE(priv->lockState);\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n    libxlLoggerCloseFile(cfg->logger, vm->def->id);\n    vm->def->id = -1;\n\n    if (priv->deathW) {\n        libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n        priv->deathW = NULL;\n    }\n\n    priv->ignoreDeathEvent = false;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC &&\n        vm->def->graphics[0]->data.vnc.autoport) {\n        vnc_port = vm->def->graphics[0]->data.vnc.port;\n        if (vnc_port >= LIBXL_VNC_PORT_MIN) {\n            if (virPortAllocatorRelease(vnc_port) < 0)\n                VIR_DEBUG(\"Could not mark port %d as unused\", vnc_port);\n        }\n    }\n\n    if ((vm->def->nnets)) {\n        size_t i;\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n\n            if (net->ifname &&\n                STRPREFIX(net->ifname, LIBXL_GENERATED_PREFIX_XEN))\n                VIR_FREE(net->ifname);\n\n            /* cleanup actual device */\n            virDomainNetRemoveHostdev(vm->def, net);\n            if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n                if (conn || (conn = virGetConnectNetwork()))\n                    virDomainNetReleaseActualDevice(conn, vm->def, net);\n                else\n                    VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n            }\n        }\n    }\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_DEBUG(\"Failed to remove domain XML for %s\", vm->def->name);\n    VIR_FREE(file);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(conn);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nlibxlDomainCleanup(libxlDriverPrivatePtr driver,\n                   virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    int vnc_port;\n    char *file;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    virConnectPtr conn = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virHostdevReAttachDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                    vm->def, hostdev_flags, NULL);\n\n    VIR_FREE(priv->lockState);\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n    libxlLoggerCloseFile(cfg->logger, vm->def->id);\n    vm->def->id = -1;\n\n    if (priv->deathW) {\n        libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n        priv->deathW = NULL;\n    }\n\n    priv->ignoreDeathEvent = false;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC &&\n        vm->def->graphics[0]->data.vnc.autoport) {\n        vnc_port = vm->def->graphics[0]->data.vnc.port;\n        if (vnc_port >= LIBXL_VNC_PORT_MIN) {\n            if (virPortAllocatorRelease(vnc_port) < 0)\n                VIR_DEBUG(\"Could not mark port %d as unused\", vnc_port);\n        }\n    }\n\n    if ((vm->def->nnets)) {\n        size_t i;\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n\n            if (net->ifname &&\n                STRPREFIX(net->ifname, LIBXL_GENERATED_PREFIX_XEN))\n                VIR_FREE(net->ifname);\n\n            /* cleanup actual device */\n            virDomainNetRemoveHostdev(vm->def, net);\n            if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n                if (conn || (conn = virGetConnectNetwork()))\n                    virDomainNetReleaseActualDevice(conn, vm->def, net);\n                else\n                    VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n            }\n        }\n    }\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_DEBUG(\"Failed to remove domain XML for %s\", vm->def->name);\n    VIR_FREE(file);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(conn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainDestroyInternal",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainDestroyInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "808-830",
          "snippet": "int\nlibxlDomainDestroyInternal(libxlDriverPrivatePtr driver,\n                           virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* Ignore next LIBXL_EVENT_TYPE_DOMAIN_DEATH as the caller will handle\n     * domain death appropriately already (having more info, like the reason).\n     */\n    priv->ignoreDeathEvent = true;\n    /* Unlock virDomainObj during destroy, which can take considerable\n     * time on large memory domains.\n     */\n    virObjectUnlock(vm);\n    ret = libxl_domain_destroy(cfg->ctx, vm->def->id, NULL);\n    virObjectLock(vm);\n    if (ret)\n        priv->ignoreDeathEvent = false;\n\n    return ret;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainDestroyInternal(libxlDriverPrivatePtr driver,\n                           virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* Ignore next LIBXL_EVENT_TYPE_DOMAIN_DEATH as the caller will handle\n     * domain death appropriately already (having more info, like the reason).\n     */\n    priv->ignoreDeathEvent = true;\n    /* Unlock virDomainObj during destroy, which can take considerable\n     * time on large memory domains.\n     */\n    virObjectUnlock(vm);\n    ret = libxl_domain_destroy(cfg->ctx, vm->def->id, NULL);\n    virObjectLock(vm);\n    if (ret)\n        priv->ignoreDeathEvent = false;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virDomainObjSave(vm, driver->xmlopt, cfg->stateDir)"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjSave",
          "args": [
            "vm",
            "driver->xmlopt",
            "cfg->stateDir"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29706-29723",
          "snippet": "int\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjDispose(void *obj);",
            "static void virDomainXMLOptionDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virDomainObjDispose(void *obj);\nstatic void virDomainXMLOptionDispose(void *obj);\n\nint\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Unable to resume domain '%s' after failed migration\"",
            "vm->def->name"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_domain_resume",
          "args": [
            "cfg->ctx",
            "vm->def->id",
            "1",
            "0"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainLockProcessResume",
          "args": [
            "driver->lockManager",
            "\"xen:///system\"",
            "vm",
            "priv->lockState"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainLockProcessResume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/domain_lock.c",
          "lines": "215-233",
          "snippet": "int virDomainLockProcessResume(virLockManagerPluginPtr plugin,\n                               const char *uri,\n                               virDomainObjPtr dom,\n                               const char *state)\n{\n    virLockManagerPtr lock;\n    int ret;\n\n    VIR_DEBUG(\"plugin=%p dom=%p state=%s\",\n              plugin, dom, NULLSTR(state));\n\n    if (!(lock = virDomainLockManagerNew(plugin, uri, dom, true, 0)))\n        return -1;\n\n    ret = virLockManagerAcquire(lock, state, 0, dom->def->onLockFailure, NULL);\n    virLockManagerFree(lock);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_lock.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"domain_lock.h\"\n#include <config.h>\n\nint virDomainLockProcessResume(virLockManagerPluginPtr plugin,\n                               const char *uri,\n                               virDomainObjPtr dom,\n                               const char *state)\n{\n    virLockManagerPtr lock;\n    int ret;\n\n    VIR_DEBUG(\"plugin=%p dom=%p state=%s\",\n              plugin, dom, NULLSTR(state));\n\n    if (!(lock = virDomainLockManagerNew(plugin, uri, dom, true, 0)))\n        return -1;\n\n    ret = virLockManagerAcquire(lock, state, 0, dom->def->onLockFailure, NULL);\n    virLockManagerFree(lock);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nlibxlDomainMigrationSrcConfirm(libxlDriverPrivatePtr driver,\n                               virDomainObjPtr vm,\n                               unsigned int flags,\n                               int cancelled)\n{\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    virObjectEventPtr event = NULL;\n    int ret = -1;\n\n    if (cancelled) {\n        /* Resume lock process that was paused in MigrationSrcPerform */\n        virDomainLockProcessResume(driver->lockManager,\n                                   \"xen:///system\",\n                                   vm,\n                                   priv->lockState);\n        if (libxl_domain_resume(cfg->ctx, vm->def->id, 1, 0) == 0) {\n            ret = 0;\n        } else {\n            VIR_DEBUG(\"Unable to resume domain '%s' after failed migration\",\n                      vm->def->name);\n            virDomainObjSetState(vm, VIR_DOMAIN_PAUSED,\n                                 VIR_DOMAIN_PAUSED_MIGRATION);\n            event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_SUSPENDED,\n                                     VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED);\n            ignore_value(virDomainObjSave(vm, driver->xmlopt, cfg->stateDir));\n        }\n        goto cleanup;\n    }\n\n    libxlDomainDestroyInternal(driver, vm);\n    libxlDomainCleanup(driver, vm);\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF,\n                         VIR_DOMAIN_SHUTOFF_MIGRATED);\n    event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_STOPPED,\n                                              VIR_DOMAIN_EVENT_STOPPED_MIGRATED);\n\n    VIR_DEBUG(\"Domain '%s' successfully migrated\", vm->def->name);\n\n    if (flags & VIR_MIGRATE_UNDEFINE_SOURCE)\n        virDomainDeleteConfig(cfg->configDir, cfg->autostartDir, vm);\n\n    if (!vm->persistent || (flags & VIR_MIGRATE_UNDEFINE_SOURCE))\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n\n cleanup:\n    /* EndJob for corresponding BeginJob in begin phase */\n    libxlDomainObjEndJob(driver, vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectUnref(cfg);\n    return ret;\n}"
  },
  {
    "function_name": "libxlDomainMigrationDstFinish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "1274-1373",
    "snippet": "virDomainPtr\nlibxlDomainMigrationDstFinish(virConnectPtr dconn,\n                              virDomainObjPtr vm,\n                              unsigned int flags,\n                              int cancelled)\n{\n    libxlDriverPrivatePtr driver = dconn->privateData;\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    virObjectEventPtr event = NULL;\n    virDomainPtr dom = NULL;\n\n    if (priv->migrationDstReceiveThr) {\n        virObjectUnlock(vm);\n        virThreadJoin(priv->migrationDstReceiveThr);\n        virObjectLock(vm);\n        VIR_FREE(priv->migrationDstReceiveThr);\n    }\n\n    virPortAllocatorRelease(priv->migrationPort);\n    priv->migrationPort = 0;\n\n    if (cancelled)\n        goto cleanup;\n\n    /* Check if domain is alive */\n    if (!virDomainObjIsActive(vm)) {\n        /* Migration failed if domain is inactive */\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       \"%s\", _(\"Migration failed. Domain is not running \"\n                               \"on destination host\"));\n        goto cleanup;\n    }\n\n    /* Unpause if requested */\n    if (!(flags & VIR_MIGRATE_PAUSED)) {\n        if (libxl_domain_unpause(cfg->ctx, vm->def->id) != 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Failed to unpause domain\"));\n            goto cleanup;\n        }\n\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_MIGRATED);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_RESUMED,\n                                         VIR_DOMAIN_EVENT_RESUMED_MIGRATED);\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_USER);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_SUSPENDED,\n                                         VIR_DOMAIN_EVENT_SUSPENDED_PAUSED);\n    }\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n    event = NULL;\n\n    if (flags & VIR_MIGRATE_PERSIST_DEST) {\n        unsigned int oldPersist = vm->persistent;\n        virDomainDefPtr vmdef;\n\n        vm->persistent = 1;\n        if (!(vmdef = virDomainObjGetPersistentDef(driver->xmlopt, vm, NULL)))\n            goto cleanup;\n\n        if (virDomainDefSave(vmdef, driver->xmlopt, cfg->configDir) < 0)\n            goto cleanup;\n\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_DEFINED,\n                                         oldPersist ?\n                                         VIR_DOMAIN_EVENT_DEFINED_UPDATED :\n                                         VIR_DOMAIN_EVENT_DEFINED_ADDED);\n        virObjectEventStateQueue(driver->domainEventState, event);\n        event = NULL;\n    }\n\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        goto cleanup;\n\n    dom = virGetDomain(dconn, vm->def->name, vm->def->uuid, vm->def->id);\n\n cleanup:\n    if (dom == NULL) {\n        libxlDomainDestroyInternal(driver, vm);\n        libxlDomainCleanup(driver, vm);\n        virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_FAILED);\n        event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_STOPPED,\n                                         VIR_DOMAIN_EVENT_STOPPED_FAILED);\n        if (!vm->persistent)\n            virDomainObjListRemove(driver->domains, vm);\n    }\n\n    /* EndJob for corresponding BeginJob in prepare phase */\n    libxlDomainObjEndJob(driver, vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectUnref(cfg);\n    return dom;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->domainEventState",
            "event"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjEndJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjEndJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "167-179",
          "snippet": "void\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nlibxlDomainObjPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nvoid\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListRemove",
          "args": [
            "driver->domains",
            "vm"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "401-413",
          "snippet": "void\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventLifecycleNewFromObj",
          "args": [
            "vm",
            "VIR_DOMAIN_EVENT_STOPPED",
            "VIR_DOMAIN_EVENT_STOPPED_FAILED"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventLifecycleNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "610-616",
          "snippet": "virObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_SHUTOFF",
            "VIR_DOMAIN_SHUTOFF_FAILED"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainCleanup",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainCleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "837-935",
          "snippet": "void\nlibxlDomainCleanup(libxlDriverPrivatePtr driver,\n                   virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    int vnc_port;\n    char *file;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    virConnectPtr conn = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virHostdevReAttachDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                    vm->def, hostdev_flags, NULL);\n\n    VIR_FREE(priv->lockState);\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n    libxlLoggerCloseFile(cfg->logger, vm->def->id);\n    vm->def->id = -1;\n\n    if (priv->deathW) {\n        libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n        priv->deathW = NULL;\n    }\n\n    priv->ignoreDeathEvent = false;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC &&\n        vm->def->graphics[0]->data.vnc.autoport) {\n        vnc_port = vm->def->graphics[0]->data.vnc.port;\n        if (vnc_port >= LIBXL_VNC_PORT_MIN) {\n            if (virPortAllocatorRelease(vnc_port) < 0)\n                VIR_DEBUG(\"Could not mark port %d as unused\", vnc_port);\n        }\n    }\n\n    if ((vm->def->nnets)) {\n        size_t i;\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n\n            if (net->ifname &&\n                STRPREFIX(net->ifname, LIBXL_GENERATED_PREFIX_XEN))\n                VIR_FREE(net->ifname);\n\n            /* cleanup actual device */\n            virDomainNetRemoveHostdev(vm->def, net);\n            if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n                if (conn || (conn = virGetConnectNetwork()))\n                    virDomainNetReleaseActualDevice(conn, vm->def, net);\n                else\n                    VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n            }\n        }\n    }\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_DEBUG(\"Failed to remove domain XML for %s\", vm->def->name);\n    VIR_FREE(file);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(conn);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nlibxlDomainCleanup(libxlDriverPrivatePtr driver,\n                   virDomainObjPtr vm)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    int vnc_port;\n    char *file;\n    virHostdevManagerPtr hostdev_mgr = driver->hostdevMgr;\n    unsigned int hostdev_flags = VIR_HOSTDEV_SP_PCI;\n    virConnectPtr conn = NULL;\n\n#ifdef LIBXL_HAVE_PVUSB\n    hostdev_flags |= VIR_HOSTDEV_SP_USB;\n#endif\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virHostdevReAttachDomainDevices(hostdev_mgr, LIBXL_DRIVER_NAME,\n                                    vm->def, hostdev_flags, NULL);\n\n    VIR_FREE(priv->lockState);\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n    libxlLoggerCloseFile(cfg->logger, vm->def->id);\n    vm->def->id = -1;\n\n    if (priv->deathW) {\n        libxl_evdisable_domain_death(cfg->ctx, priv->deathW);\n        priv->deathW = NULL;\n    }\n\n    priv->ignoreDeathEvent = false;\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    if ((vm->def->ngraphics == 1) &&\n        vm->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC &&\n        vm->def->graphics[0]->data.vnc.autoport) {\n        vnc_port = vm->def->graphics[0]->data.vnc.port;\n        if (vnc_port >= LIBXL_VNC_PORT_MIN) {\n            if (virPortAllocatorRelease(vnc_port) < 0)\n                VIR_DEBUG(\"Could not mark port %d as unused\", vnc_port);\n        }\n    }\n\n    if ((vm->def->nnets)) {\n        size_t i;\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n\n            if (net->ifname &&\n                STRPREFIX(net->ifname, LIBXL_GENERATED_PREFIX_XEN))\n                VIR_FREE(net->ifname);\n\n            /* cleanup actual device */\n            virDomainNetRemoveHostdev(vm->def, net);\n            if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n                if (conn || (conn = virGetConnectNetwork()))\n                    virDomainNetReleaseActualDevice(conn, vm->def, net);\n                else\n                    VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n            }\n        }\n    }\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_DEBUG(\"Failed to remove domain XML for %s\", vm->def->name);\n    VIR_FREE(file);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml = virDomainDefFormat(vm->def, driver->xmlopt, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_LIBXL, vm->def->name,\n                                 VIR_HOOK_LIBXL_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n        VIR_FREE(xml);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n    virObjectUnref(conn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainDestroyInternal",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainDestroyInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "808-830",
          "snippet": "int\nlibxlDomainDestroyInternal(libxlDriverPrivatePtr driver,\n                           virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* Ignore next LIBXL_EVENT_TYPE_DOMAIN_DEATH as the caller will handle\n     * domain death appropriately already (having more info, like the reason).\n     */\n    priv->ignoreDeathEvent = true;\n    /* Unlock virDomainObj during destroy, which can take considerable\n     * time on large memory domains.\n     */\n    virObjectUnlock(vm);\n    ret = libxl_domain_destroy(cfg->ctx, vm->def->id, NULL);\n    virObjectLock(vm);\n    if (ret)\n        priv->ignoreDeathEvent = false;\n\n    return ret;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainDestroyInternal(libxlDriverPrivatePtr driver,\n                           virDomainObjPtr vm)\n{\n    g_autoptr(libxlDriverConfig) cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* Ignore next LIBXL_EVENT_TYPE_DOMAIN_DEATH as the caller will handle\n     * domain death appropriately already (having more info, like the reason).\n     */\n    priv->ignoreDeathEvent = true;\n    /* Unlock virDomainObj during destroy, which can take considerable\n     * time on large memory domains.\n     */\n    virObjectUnlock(vm);\n    ret = libxl_domain_destroy(cfg->ctx, vm->def->id, NULL);\n    virObjectLock(vm);\n    if (ret)\n        priv->ignoreDeathEvent = false;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "dconn",
            "vm->def->name",
            "vm->def->uuid",
            "vm->def->id"
          ],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSave",
          "args": [
            "vm",
            "driver->xmlopt",
            "cfg->stateDir"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29706-29723",
          "snippet": "int\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjDispose(void *obj);",
            "static void virDomainXMLOptionDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virDomainObjDispose(void *obj);\nstatic void virDomainXMLOptionDispose(void *obj);\n\nint\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSave",
          "args": [
            "vmdef",
            "driver->xmlopt",
            "cfg->configDir"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29693-29704",
          "snippet": "int\nvirDomainDefSave(virDomainDefPtr def,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *configDir)\n{\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainDefFormat(def, xmlopt, VIR_DOMAIN_DEF_FORMAT_SECURE)))\n        return -1;\n\n    return virDomainDefSaveXML(def, configDir, xml);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSave(virDomainDefPtr def,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *configDir)\n{\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainDefFormat(def, xmlopt, VIR_DOMAIN_DEF_FORMAT_SECURE)))\n        return -1;\n\n    return virDomainDefSaveXML(def, configDir, xml);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjGetPersistentDef",
          "args": [
            "driver->xmlopt",
            "vm",
            "NULL"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetPersistentDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3757-3770",
          "snippet": "virDomainDefPtr\nvirDomainObjGetPersistentDef(virDomainXMLOptionPtr xmlopt,\n                             virDomainObjPtr domain,\n                             void *parseOpaque)\n{\n    if (virDomainObjIsActive(domain) &&\n        virDomainObjSetDefTransient(xmlopt, domain, parseOpaque) < 0)\n        return NULL;\n\n    if (domain->newDef)\n        return domain->newDef;\n    else\n        return domain->def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainObjGetPersistentDef(virDomainXMLOptionPtr xmlopt,\n                             virDomainObjPtr domain,\n                             void *parseOpaque)\n{\n    if (virDomainObjIsActive(domain) &&\n        virDomainObjSetDefTransient(xmlopt, domain, parseOpaque) < 0)\n        return NULL;\n\n    if (domain->newDef)\n        return domain->newDef;\n    else\n        return domain->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Failed to unpause domain\")"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to unpause domain\""
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_domain_unpause",
          "args": [
            "cfg->ctx",
            "vm->def->id"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Migration failed. Domain is not running \"\n                               \"on destination host\")"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPortAllocatorRelease",
          "args": [
            "priv->migrationPort"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "256-281",
          "snippet": "int\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->migrationDstReceiveThr"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadJoin",
          "args": [
            "priv->migrationDstReceiveThr"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadJoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "326-329",
          "snippet": "void virThreadJoin(virThreadPtr thread)\n{\n    pthread_join(thread->thread, NULL);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virThreadJoin(virThreadPtr thread)\n{\n    pthread_join(thread->thread, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainPtr\nlibxlDomainMigrationDstFinish(virConnectPtr dconn,\n                              virDomainObjPtr vm,\n                              unsigned int flags,\n                              int cancelled)\n{\n    libxlDriverPrivatePtr driver = dconn->privateData;\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    virObjectEventPtr event = NULL;\n    virDomainPtr dom = NULL;\n\n    if (priv->migrationDstReceiveThr) {\n        virObjectUnlock(vm);\n        virThreadJoin(priv->migrationDstReceiveThr);\n        virObjectLock(vm);\n        VIR_FREE(priv->migrationDstReceiveThr);\n    }\n\n    virPortAllocatorRelease(priv->migrationPort);\n    priv->migrationPort = 0;\n\n    if (cancelled)\n        goto cleanup;\n\n    /* Check if domain is alive */\n    if (!virDomainObjIsActive(vm)) {\n        /* Migration failed if domain is inactive */\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       \"%s\", _(\"Migration failed. Domain is not running \"\n                               \"on destination host\"));\n        goto cleanup;\n    }\n\n    /* Unpause if requested */\n    if (!(flags & VIR_MIGRATE_PAUSED)) {\n        if (libxl_domain_unpause(cfg->ctx, vm->def->id) != 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Failed to unpause domain\"));\n            goto cleanup;\n        }\n\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_MIGRATED);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_RESUMED,\n                                         VIR_DOMAIN_EVENT_RESUMED_MIGRATED);\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_USER);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_SUSPENDED,\n                                         VIR_DOMAIN_EVENT_SUSPENDED_PAUSED);\n    }\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n    event = NULL;\n\n    if (flags & VIR_MIGRATE_PERSIST_DEST) {\n        unsigned int oldPersist = vm->persistent;\n        virDomainDefPtr vmdef;\n\n        vm->persistent = 1;\n        if (!(vmdef = virDomainObjGetPersistentDef(driver->xmlopt, vm, NULL)))\n            goto cleanup;\n\n        if (virDomainDefSave(vmdef, driver->xmlopt, cfg->configDir) < 0)\n            goto cleanup;\n\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_DEFINED,\n                                         oldPersist ?\n                                         VIR_DOMAIN_EVENT_DEFINED_UPDATED :\n                                         VIR_DOMAIN_EVENT_DEFINED_ADDED);\n        virObjectEventStateQueue(driver->domainEventState, event);\n        event = NULL;\n    }\n\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        goto cleanup;\n\n    dom = virGetDomain(dconn, vm->def->name, vm->def->uuid, vm->def->id);\n\n cleanup:\n    if (dom == NULL) {\n        libxlDomainDestroyInternal(driver, vm);\n        libxlDomainCleanup(driver, vm);\n        virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF,\n                             VIR_DOMAIN_SHUTOFF_FAILED);\n        event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_STOPPED,\n                                         VIR_DOMAIN_EVENT_STOPPED_FAILED);\n        if (!vm->persistent)\n            virDomainObjListRemove(driver->domains, vm);\n    }\n\n    /* EndJob for corresponding BeginJob in prepare phase */\n    libxlDomainObjEndJob(driver, vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectUnref(cfg);\n    return dom;\n}"
  },
  {
    "function_name": "libxlDomainMigrationSrcPerform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "1210-1272",
    "snippet": "int\nlibxlDomainMigrationSrcPerform(libxlDriverPrivatePtr driver,\n                               virDomainObjPtr vm,\n                               const char *dom_xml G_GNUC_UNUSED,\n                               const char *dconnuri G_GNUC_UNUSED,\n                               const char *uri_str,\n                               const char *dname G_GNUC_UNUSED,\n                               unsigned int flags)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    char *hostname = NULL;\n    unsigned short port = 0;\n    char portstr[100];\n    virURIPtr uri = NULL;\n    virNetSocketPtr sock;\n    int sockfd = -1;\n    int ret = -1;\n\n    /* parse dst host:port from uri */\n    uri = virURIParse(uri_str);\n    if (uri == NULL || uri->server == NULL || uri->port == 0)\n        goto cleanup;\n\n    hostname = uri->server;\n    port = uri->port;\n    g_snprintf(portstr, sizeof(portstr), \"%d\", port);\n\n    /* socket connect to dst host:port */\n    if (virNetSocketNewConnectTCP(hostname, portstr,\n                                  AF_UNSPEC,\n                                  &sock) < 0)\n        goto cleanup;\n\n    if (virNetSocketSetBlocking(sock, true) < 0) {\n        virObjectUnref(sock);\n        goto cleanup;\n    }\n\n    sockfd = virNetSocketDupFD(sock, true);\n    virObjectUnref(sock);\n\n    /* suspend vm and send saved data to dst through socket fd */\n    virObjectUnlock(vm);\n    ret = libxlDoMigrateSrcSend(driver, vm, flags, sockfd);\n    virObjectLock(vm);\n\n    if (ret == 0) {\n        if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n            VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n        VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n    } else {\n        /*\n         * Confirm phase will not be executed if perform fails. End the\n         * job started in begin phase.\n         */\n        libxlDomainObjEndJob(driver, vm);\n    }\n\n cleanup:\n    VIR_FORCE_CLOSE(sockfd);\n    virURIFree(uri);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virURIFree",
          "args": [
            "uri"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "virURIFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "277-298",
          "snippet": "void virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvoid virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "sockfd"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainObjEndJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjEndJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "167-179",
          "snippet": "void\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nlibxlDomainObjPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nvoid\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Preserving lock state '%s'\"",
            "NULLSTR(priv->lockState)"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "priv->lockState"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to release lease on %s\"",
            "vm->def->name"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainLockProcessPause",
          "args": [
            "driver->lockManager",
            "vm",
            "&priv->lockState"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainLockProcessPause",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/domain_lock.c",
          "lines": "196-213",
          "snippet": "int virDomainLockProcessPause(virLockManagerPluginPtr plugin,\n                              virDomainObjPtr dom,\n                              char **state)\n{\n    virLockManagerPtr lock;\n    int ret;\n\n    VIR_DEBUG(\"plugin=%p dom=%p state=%p\",\n              plugin, dom, state);\n\n    if (!(lock = virDomainLockManagerNew(plugin, NULL, dom, true, 0)))\n        return -1;\n\n    ret = virLockManagerRelease(lock, state, 0);\n    virLockManagerFree(lock);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_lock.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"domain_lock.h\"\n#include <config.h>\n\nint virDomainLockProcessPause(virLockManagerPluginPtr plugin,\n                              virDomainObjPtr dom,\n                              char **state)\n{\n    virLockManagerPtr lock;\n    int ret;\n\n    VIR_DEBUG(\"plugin=%p dom=%p state=%p\",\n              plugin, dom, state);\n\n    if (!(lock = virDomainLockManagerNew(plugin, NULL, dom, true, 0)))\n        return -1;\n\n    ret = virLockManagerRelease(lock, state, 0);\n    virLockManagerFree(lock);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDoMigrateSrcSend",
          "args": [
            "driver",
            "vm",
            "flags",
            "sockfd"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDoMigrateSrcSend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "345-368",
          "snippet": "static int\nlibxlDoMigrateSrcSend(libxlDriverPrivatePtr driver,\n                      virDomainObjPtr vm,\n                      unsigned long flags,\n                      int sockfd)\n{\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    int xl_flags = 0;\n    int ret;\n\n    if (flags & VIR_MIGRATE_LIVE)\n        xl_flags = LIBXL_SUSPEND_LIVE;\n\n    ret = libxl_domain_suspend(cfg->ctx, vm->def->id, sockfd,\n                               xl_flags, NULL);\n    if (ret != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to send migration data to destination host\"));\n        ret = -1;\n    }\n\n    virObjectUnref(cfg);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nlibxlDoMigrateSrcSend(libxlDriverPrivatePtr driver,\n                      virDomainObjPtr vm,\n                      unsigned long flags,\n                      int sockfd)\n{\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    int xl_flags = 0;\n    int ret;\n\n    if (flags & VIR_MIGRATE_LIVE)\n        xl_flags = LIBXL_SUSPEND_LIVE;\n\n    ret = libxl_domain_suspend(cfg->ctx, vm->def->id, sockfd,\n                               xl_flags, NULL);\n    if (ret != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to send migration data to destination host\"));\n        ret = -1;\n    }\n\n    virObjectUnref(cfg);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sock"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketDupFD",
          "args": [
            "sock",
            "true"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketDupFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1386-1412",
          "snippet": "int virNetSocketDupFD(virNetSocketPtr sock, bool cloexec)\n{\n    int fd;\n\n#ifdef F_DUPFD_CLOEXEC\n    if (cloexec)\n        fd = fcntl(sock->fd, F_DUPFD_CLOEXEC, 0);\n    else\n#endif /* F_DUPFD_CLOEXEC */\n        fd = dup(sock->fd);\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to copy socket file handle\"));\n        return -1;\n    }\n#ifndef F_DUPFD_CLOEXEC\n    if (cloexec &&\n        virSetCloseExec(fd < 0)) {\n        int saveerr = errno;\n        closesocket(fd);\n        errno = saveerr;\n        return -1;\n    }\n#endif /* F_DUPFD_CLOEXEC */\n\n    return fd;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketDupFD(virNetSocketPtr sock, bool cloexec)\n{\n    int fd;\n\n#ifdef F_DUPFD_CLOEXEC\n    if (cloexec)\n        fd = fcntl(sock->fd, F_DUPFD_CLOEXEC, 0);\n    else\n#endif /* F_DUPFD_CLOEXEC */\n        fd = dup(sock->fd);\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to copy socket file handle\"));\n        return -1;\n    }\n#ifndef F_DUPFD_CLOEXEC\n    if (cloexec &&\n        virSetCloseExec(fd < 0)) {\n        int saveerr = errno;\n        closesocket(fd);\n        errno = saveerr;\n        return -1;\n    }\n#endif /* F_DUPFD_CLOEXEC */\n\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketSetBlocking",
          "args": [
            "sock",
            "true"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketSetBlocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1632-1640",
          "snippet": "int virNetSocketSetBlocking(virNetSocketPtr sock,\n                            bool blocking)\n{\n    int ret;\n    virObjectLock(sock);\n    ret = virSetBlocking(sock->fd, blocking);\n    virObjectUnlock(sock);\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketSetBlocking(virNetSocketPtr sock,\n                            bool blocking)\n{\n    int ret;\n    virObjectLock(sock);\n    ret = virSetBlocking(sock->fd, blocking);\n    virObjectUnlock(sock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNewConnectTCP",
          "args": [
            "hostname",
            "portstr",
            "AF_UNSPEC",
            "&sock"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewConnectTCP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "558-640",
          "snippet": "int virNetSocketNewConnectTCP(const char *nodename,\n                              const char *service,\n                              int family,\n                              virNetSocketPtr *retsock)\n{\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    struct addrinfo *runp;\n    int savedErrno = ENOENT;\n\n    *retsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG | AI_V4MAPPED;\n    hints.ai_socktype = SOCK_STREAM;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    runp = ai;\n    while (runp) {\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, false) < 0)\n            VIR_WARN(\"Unable to enable port reuse\");\n\n        if (connect(fd, runp->ai_addr, runp->ai_addrlen) >= 0)\n            break;\n\n        savedErrno = errno;\n        closesocket(fd);\n        fd = -1;\n        runp = runp->ai_next;\n    }\n\n    if (fd == -1) {\n        virReportSystemError(savedErrno,\n                             _(\"unable to connect to server at '%s:%s'\"),\n                             nodename, service);\n        goto error;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto error;\n    }\n\n    remoteAddr.len = sizeof(remoteAddr.data);\n    if (getpeername(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get remote socket name\"));\n        goto error;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, &remoteAddr, true, fd, -1, 0, false)))\n        goto error;\n\n    freeaddrinfo(ai);\n\n    return 0;\n\n error:\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectTCP(const char *nodename,\n                              const char *service,\n                              int family,\n                              virNetSocketPtr *retsock)\n{\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    struct addrinfo *runp;\n    int savedErrno = ENOENT;\n\n    *retsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG | AI_V4MAPPED;\n    hints.ai_socktype = SOCK_STREAM;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    runp = ai;\n    while (runp) {\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, false) < 0)\n            VIR_WARN(\"Unable to enable port reuse\");\n\n        if (connect(fd, runp->ai_addr, runp->ai_addrlen) >= 0)\n            break;\n\n        savedErrno = errno;\n        closesocket(fd);\n        fd = -1;\n        runp = runp->ai_next;\n    }\n\n    if (fd == -1) {\n        virReportSystemError(savedErrno,\n                             _(\"unable to connect to server at '%s:%s'\"),\n                             nodename, service);\n        goto error;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto error;\n    }\n\n    remoteAddr.len = sizeof(remoteAddr.data);\n    if (getpeername(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get remote socket name\"));\n        goto error;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, &remoteAddr, true, fd, -1, 0, false)))\n        goto error;\n\n    freeaddrinfo(ai);\n\n    return 0;\n\n error:\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "portstr",
            "sizeof(portstr)",
            "\"%d\"",
            "port"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virURIParse",
          "args": [
            "uri_str"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "virURIParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "143-194",
          "snippet": "virURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvirURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nlibxlDomainMigrationSrcPerform(libxlDriverPrivatePtr driver,\n                               virDomainObjPtr vm,\n                               const char *dom_xml G_GNUC_UNUSED,\n                               const char *dconnuri G_GNUC_UNUSED,\n                               const char *uri_str,\n                               const char *dname G_GNUC_UNUSED,\n                               unsigned int flags)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    char *hostname = NULL;\n    unsigned short port = 0;\n    char portstr[100];\n    virURIPtr uri = NULL;\n    virNetSocketPtr sock;\n    int sockfd = -1;\n    int ret = -1;\n\n    /* parse dst host:port from uri */\n    uri = virURIParse(uri_str);\n    if (uri == NULL || uri->server == NULL || uri->port == 0)\n        goto cleanup;\n\n    hostname = uri->server;\n    port = uri->port;\n    g_snprintf(portstr, sizeof(portstr), \"%d\", port);\n\n    /* socket connect to dst host:port */\n    if (virNetSocketNewConnectTCP(hostname, portstr,\n                                  AF_UNSPEC,\n                                  &sock) < 0)\n        goto cleanup;\n\n    if (virNetSocketSetBlocking(sock, true) < 0) {\n        virObjectUnref(sock);\n        goto cleanup;\n    }\n\n    sockfd = virNetSocketDupFD(sock, true);\n    virObjectUnref(sock);\n\n    /* suspend vm and send saved data to dst through socket fd */\n    virObjectUnlock(vm);\n    ret = libxlDoMigrateSrcSend(driver, vm, flags, sockfd);\n    virObjectLock(vm);\n\n    if (ret == 0) {\n        if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n            VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n        VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n    } else {\n        /*\n         * Confirm phase will not be executed if perform fails. End the\n         * job started in begin phase.\n         */\n        libxlDomainObjEndJob(driver, vm);\n    }\n\n cleanup:\n    VIR_FORCE_CLOSE(sockfd);\n    virURIFree(uri);\n    return ret;\n}"
  },
  {
    "function_name": "libxlDomainMigrationSrcPerformP2P",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "1147-1208",
    "snippet": "int\nlibxlDomainMigrationSrcPerformP2P(libxlDriverPrivatePtr driver,\n                                  virDomainObjPtr vm,\n                                  virConnectPtr sconn,\n                                  const char *xmlin,\n                                  const char *dconnuri,\n                                  const char *uri_str G_GNUC_UNUSED,\n                                  const char *dname,\n                                  unsigned int flags)\n{\n    int ret = -1;\n    bool useParams;\n    virConnectPtr dconn = NULL;\n    virErrorPtr orig_err = NULL;\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n\n    virObjectUnlock(vm);\n    dconn = virConnectOpenAuth(dconnuri, &virConnectAuthConfig, 0);\n    virObjectLock(vm);\n\n    if (dconn == NULL) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Failed to connect to remote libvirt URI %s: %s\"),\n                       dconnuri, virGetLastErrorMessage());\n        return ret;\n    }\n\n    if (virConnectSetKeepAlive(dconn, cfg->keepAliveInterval,\n                               cfg->keepAliveCount) < 0)\n        goto cleanup;\n\n    virObjectUnlock(vm);\n    useParams = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                         VIR_DRV_FEATURE_MIGRATION_PARAMS);\n    virObjectLock(vm);\n\n    if (!useParams) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Destination libvirt does not support migration with extensible parameters\"));\n        goto cleanup;\n    }\n\n    ret = libxlDoMigrateSrcP2P(driver, vm, sconn, xmlin, dconn, dconnuri,\n                               dname, uri_str, flags);\n\n    if (ret < 0) {\n        /*\n         * Confirm phase will not be executed if perform fails. End the\n         * job started in begin phase.\n         */\n        libxlDomainObjEndJob(driver, vm);\n    }\n\n cleanup:\n    virErrorPreserveLast(&orig_err);\n    virObjectUnlock(vm);\n    virObjectUnref(dconn);\n    virObjectUnref(cfg);\n    virObjectLock(vm);\n    virErrorRestore(&orig_err);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virConnectAuth virConnectAuthConfig = {\n    .credtype = virConnectCredType,\n    .ncredtype = G_N_ELEMENTS(virConnectCredType),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&orig_err"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&orig_err"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjEndJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjEndJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "167-179",
          "snippet": "void\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nlibxlDomainObjPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nvoid\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDoMigrateSrcP2P",
          "args": [
            "driver",
            "vm",
            "sconn",
            "xmlin",
            "dconn",
            "dconnuri",
            "dname",
            "uri_str",
            "flags"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDoMigrateSrcP2P",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "977-1130",
          "snippet": "static int\nlibxlDoMigrateSrcP2P(libxlDriverPrivatePtr driver,\n                     virDomainObjPtr vm,\n                     virConnectPtr sconn,\n                     const char *xmlin,\n                     virConnectPtr dconn,\n                     const char *dconnuri G_GNUC_UNUSED,\n                     const char *dname,\n                     const char *uri,\n                     unsigned int flags)\n{\n    virDomainPtr ddomain = NULL;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int maxparams = 0;\n    char *uri_out = NULL;\n    char *dom_xml = NULL;\n    unsigned long destflags;\n    char *cookieout = NULL;\n    int cookieoutlen;\n    bool cancelled = true;\n    bool notify_source = true;\n    virErrorPtr orig_err = NULL;\n    int ret = -1;\n    /* For tunnel migration */\n    virStreamPtr st = NULL;\n    struct libxlTunnelControl *tc = NULL;\n\n    if (dname &&\n        virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, dname) < 0)\n        goto cleanup;\n\n    if (uri &&\n        virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_URI, uri) < 0)\n        goto cleanup;\n\n    dom_xml = libxlDomainMigrationSrcBegin(sconn, vm, xmlin,\n                                           &cookieout, &cookieoutlen);\n    /*\n     * If dom_xml is non-NULL the begin phase has succeeded, and the\n     * confirm phase must be called to cleanup the migration operation.\n     */\n    if (!dom_xml)\n        goto cleanup;\n\n    if (virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_DEST_XML, dom_xml) < 0)\n        goto confirm;\n\n    /* We don't require the destination to have P2P support\n     * as it looks to be normal migration from the receiver perspective.\n     */\n    destflags = flags & ~(VIR_MIGRATE_PEER2PEER);\n\n    VIR_DEBUG(\"Prepare3\");\n    virObjectUnlock(vm);\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        if (!(st = virStreamNew(dconn, 0)))\n            goto confirm;\n        ret = dconn->driver->domainMigratePrepareTunnel3Params\n            (dconn, st, params, nparams, cookieout, cookieoutlen, NULL, NULL, destflags);\n    } else {\n        ret = dconn->driver->domainMigratePrepare3Params\n            (dconn, params, nparams, cookieout, cookieoutlen, NULL, NULL, &uri_out, destflags);\n    }\n    virObjectLock(vm);\n\n    if (ret == -1)\n        goto confirm;\n\n    if (!(flags & VIR_MIGRATE_TUNNELLED)) {\n        if (uri_out) {\n            if (virTypedParamsReplaceString(&params, &nparams,\n                                            VIR_MIGRATE_PARAM_URI, uri_out) < 0) {\n                virErrorPreserveLast(&orig_err);\n                goto finish;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"domainMigratePrepare3 did not set uri\"));\n            goto finish;\n        }\n    }\n\n    VIR_DEBUG(\"Perform3 uri=%s\", NULLSTR(uri_out));\n    if (flags & VIR_MIGRATE_TUNNELLED)\n        ret = libxlMigrationSrcStartTunnel(driver, vm, flags, st, &tc);\n    else\n        ret = libxlDomainMigrationSrcPerform(driver, vm, NULL, NULL,\n                                             uri_out, NULL, flags);\n    if (ret < 0) {\n        notify_source = false;\n        virErrorPreserveLast(&orig_err);\n    }\n\n    cancelled = (ret < 0);\n\n finish:\n    VIR_DEBUG(\"Finish3 ret=%d\", ret);\n    if (virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, NULL) <= 0 &&\n        virTypedParamsReplaceString(&params, &nparams,\n                                    VIR_MIGRATE_PARAM_DEST_NAME,\n                                    vm->def->name) < 0) {\n        ddomain = NULL;\n    } else {\n        virObjectUnlock(vm);\n        ddomain = dconn->driver->domainMigrateFinish3Params\n            (dconn, params, nparams, NULL, 0, NULL, NULL,\n             destflags, cancelled);\n        virObjectLock(vm);\n    }\n\n    cancelled = (ddomain == NULL);\n\n    /* If Finish3Params set an error, and we don't have an earlier\n     * one we need to preserve it in case confirm3 overwrites\n     */\n    if (!orig_err)\n        virErrorPreserveLast(&orig_err);\n\n confirm:\n    if (notify_source) {\n        VIR_DEBUG(\"Confirm3 cancelled=%d vm=%p\", cancelled, vm);\n        ret = libxlDomainMigrationSrcConfirm(driver, vm, flags, cancelled);\n\n        if (ret < 0)\n            VIR_WARN(\"Guest %s probably left in 'paused' state on source\",\n                     vm->def->name);\n    }\n\n cleanup:\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        libxlMigrationSrcStopTunnel(tc);\n        virObjectUnref(st);\n    }\n\n    if (ddomain) {\n        virObjectUnref(ddomain);\n        ret = 0;\n    } else {\n        ret = -1;\n    }\n\n    virErrorRestore(&orig_err);\n\n    VIR_FREE(cookieout);\n    VIR_FREE(dom_xml);\n    VIR_FREE(uri_out);\n    virTypedParamsFree(params, nparams);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nlibxlDoMigrateSrcP2P(libxlDriverPrivatePtr driver,\n                     virDomainObjPtr vm,\n                     virConnectPtr sconn,\n                     const char *xmlin,\n                     virConnectPtr dconn,\n                     const char *dconnuri G_GNUC_UNUSED,\n                     const char *dname,\n                     const char *uri,\n                     unsigned int flags)\n{\n    virDomainPtr ddomain = NULL;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int maxparams = 0;\n    char *uri_out = NULL;\n    char *dom_xml = NULL;\n    unsigned long destflags;\n    char *cookieout = NULL;\n    int cookieoutlen;\n    bool cancelled = true;\n    bool notify_source = true;\n    virErrorPtr orig_err = NULL;\n    int ret = -1;\n    /* For tunnel migration */\n    virStreamPtr st = NULL;\n    struct libxlTunnelControl *tc = NULL;\n\n    if (dname &&\n        virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, dname) < 0)\n        goto cleanup;\n\n    if (uri &&\n        virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_URI, uri) < 0)\n        goto cleanup;\n\n    dom_xml = libxlDomainMigrationSrcBegin(sconn, vm, xmlin,\n                                           &cookieout, &cookieoutlen);\n    /*\n     * If dom_xml is non-NULL the begin phase has succeeded, and the\n     * confirm phase must be called to cleanup the migration operation.\n     */\n    if (!dom_xml)\n        goto cleanup;\n\n    if (virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_DEST_XML, dom_xml) < 0)\n        goto confirm;\n\n    /* We don't require the destination to have P2P support\n     * as it looks to be normal migration from the receiver perspective.\n     */\n    destflags = flags & ~(VIR_MIGRATE_PEER2PEER);\n\n    VIR_DEBUG(\"Prepare3\");\n    virObjectUnlock(vm);\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        if (!(st = virStreamNew(dconn, 0)))\n            goto confirm;\n        ret = dconn->driver->domainMigratePrepareTunnel3Params\n            (dconn, st, params, nparams, cookieout, cookieoutlen, NULL, NULL, destflags);\n    } else {\n        ret = dconn->driver->domainMigratePrepare3Params\n            (dconn, params, nparams, cookieout, cookieoutlen, NULL, NULL, &uri_out, destflags);\n    }\n    virObjectLock(vm);\n\n    if (ret == -1)\n        goto confirm;\n\n    if (!(flags & VIR_MIGRATE_TUNNELLED)) {\n        if (uri_out) {\n            if (virTypedParamsReplaceString(&params, &nparams,\n                                            VIR_MIGRATE_PARAM_URI, uri_out) < 0) {\n                virErrorPreserveLast(&orig_err);\n                goto finish;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"domainMigratePrepare3 did not set uri\"));\n            goto finish;\n        }\n    }\n\n    VIR_DEBUG(\"Perform3 uri=%s\", NULLSTR(uri_out));\n    if (flags & VIR_MIGRATE_TUNNELLED)\n        ret = libxlMigrationSrcStartTunnel(driver, vm, flags, st, &tc);\n    else\n        ret = libxlDomainMigrationSrcPerform(driver, vm, NULL, NULL,\n                                             uri_out, NULL, flags);\n    if (ret < 0) {\n        notify_source = false;\n        virErrorPreserveLast(&orig_err);\n    }\n\n    cancelled = (ret < 0);\n\n finish:\n    VIR_DEBUG(\"Finish3 ret=%d\", ret);\n    if (virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, NULL) <= 0 &&\n        virTypedParamsReplaceString(&params, &nparams,\n                                    VIR_MIGRATE_PARAM_DEST_NAME,\n                                    vm->def->name) < 0) {\n        ddomain = NULL;\n    } else {\n        virObjectUnlock(vm);\n        ddomain = dconn->driver->domainMigrateFinish3Params\n            (dconn, params, nparams, NULL, 0, NULL, NULL,\n             destflags, cancelled);\n        virObjectLock(vm);\n    }\n\n    cancelled = (ddomain == NULL);\n\n    /* If Finish3Params set an error, and we don't have an earlier\n     * one we need to preserve it in case confirm3 overwrites\n     */\n    if (!orig_err)\n        virErrorPreserveLast(&orig_err);\n\n confirm:\n    if (notify_source) {\n        VIR_DEBUG(\"Confirm3 cancelled=%d vm=%p\", cancelled, vm);\n        ret = libxlDomainMigrationSrcConfirm(driver, vm, flags, cancelled);\n\n        if (ret < 0)\n            VIR_WARN(\"Guest %s probably left in 'paused' state on source\",\n                     vm->def->name);\n    }\n\n cleanup:\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        libxlMigrationSrcStopTunnel(tc);\n        virObjectUnref(st);\n    }\n\n    if (ddomain) {\n        virObjectUnref(ddomain);\n        ret = 0;\n    } else {\n        ret = -1;\n    }\n\n    virErrorRestore(&orig_err);\n\n    VIR_FREE(cookieout);\n    VIR_FREE(dom_xml);\n    VIR_FREE(uri_out);\n    virTypedParamsFree(params, nparams);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Destination libvirt does not support migration with extensible parameters\")"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Destination libvirt does not support migration with extensible parameters\""
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DRV_SUPPORTS_FEATURE",
          "args": [
            "dconn->driver",
            "dconn",
            "VIR_DRV_FEATURE_MIGRATION_PARAMS"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConnectSetKeepAlive",
          "args": [
            "dconn",
            "cfg->keepAliveInterval",
            "cfg->keepAliveCount"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectSetKeepAlive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-host.c",
          "lines": "1350-1375",
          "snippet": "int\nvirConnectSetKeepAlive(virConnectPtr conn,\n                       int interval,\n                       unsigned int count)\n{\n    int ret = -1;\n\n    VIR_DEBUG(\"conn=%p, interval=%d, count=%u\", conn, interval, count);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n\n    if (conn->driver->connectSetKeepAlive) {\n        ret = conn->driver->connectSetKeepAlive(conn, interval, count);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirConnectSetKeepAlive(virConnectPtr conn,\n                       int interval,\n                       unsigned int count)\n{\n    int ret = -1;\n\n    VIR_DEBUG(\"conn=%p, interval=%d, count=%u\", conn, interval, count);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n\n    if (conn->driver->connectSetKeepAlive) {\n        ret = conn->driver->connectSetKeepAlive(conn, interval, count);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Failed to connect to remote libvirt URI %s: %s\")",
            "dconnuri",
            "virGetLastErrorMessage()"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectOpenAuth",
          "args": [
            "dconnuri",
            "&virConnectAuthConfig",
            "0"
          ],
          "line": 1164
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectOpenAuth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "1219-1239",
          "snippet": "virConnectPtr\nvirConnectOpenAuth(const char *name,\n                   virConnectAuthPtr auth,\n                   unsigned int flags)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s, auth=%p, flags=0x%x\", NULLSTR(name), auth, flags);\n    virResetLastError();\n    ret = virConnectOpenInternal(name, auth, flags);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirConnectPtr\nvirConnectOpenAuth(const char *name,\n                   virConnectAuthPtr auth,\n                   unsigned int flags)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s, auth=%p, flags=0x%x\", NULLSTR(name), auth, flags);\n    virResetLastError();\n    ret = virConnectOpenInternal(name, auth, flags);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virConnectAuth virConnectAuthConfig = {\n    .credtype = virConnectCredType,\n    .ncredtype = G_N_ELEMENTS(virConnectCredType),\n};\n\nint\nlibxlDomainMigrationSrcPerformP2P(libxlDriverPrivatePtr driver,\n                                  virDomainObjPtr vm,\n                                  virConnectPtr sconn,\n                                  const char *xmlin,\n                                  const char *dconnuri,\n                                  const char *uri_str G_GNUC_UNUSED,\n                                  const char *dname,\n                                  unsigned int flags)\n{\n    int ret = -1;\n    bool useParams;\n    virConnectPtr dconn = NULL;\n    virErrorPtr orig_err = NULL;\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n\n    virObjectUnlock(vm);\n    dconn = virConnectOpenAuth(dconnuri, &virConnectAuthConfig, 0);\n    virObjectLock(vm);\n\n    if (dconn == NULL) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Failed to connect to remote libvirt URI %s: %s\"),\n                       dconnuri, virGetLastErrorMessage());\n        return ret;\n    }\n\n    if (virConnectSetKeepAlive(dconn, cfg->keepAliveInterval,\n                               cfg->keepAliveCount) < 0)\n        goto cleanup;\n\n    virObjectUnlock(vm);\n    useParams = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                         VIR_DRV_FEATURE_MIGRATION_PARAMS);\n    virObjectLock(vm);\n\n    if (!useParams) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Destination libvirt does not support migration with extensible parameters\"));\n        goto cleanup;\n    }\n\n    ret = libxlDoMigrateSrcP2P(driver, vm, sconn, xmlin, dconn, dconnuri,\n                               dname, uri_str, flags);\n\n    if (ret < 0) {\n        /*\n         * Confirm phase will not be executed if perform fails. End the\n         * job started in begin phase.\n         */\n        libxlDomainObjEndJob(driver, vm);\n    }\n\n cleanup:\n    virErrorPreserveLast(&orig_err);\n    virObjectUnlock(vm);\n    virObjectUnref(dconn);\n    virObjectUnref(cfg);\n    virObjectLock(vm);\n    virErrorRestore(&orig_err);\n    return ret;\n}"
  },
  {
    "function_name": "libxlDoMigrateSrcP2P",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "977-1130",
    "snippet": "static int\nlibxlDoMigrateSrcP2P(libxlDriverPrivatePtr driver,\n                     virDomainObjPtr vm,\n                     virConnectPtr sconn,\n                     const char *xmlin,\n                     virConnectPtr dconn,\n                     const char *dconnuri G_GNUC_UNUSED,\n                     const char *dname,\n                     const char *uri,\n                     unsigned int flags)\n{\n    virDomainPtr ddomain = NULL;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int maxparams = 0;\n    char *uri_out = NULL;\n    char *dom_xml = NULL;\n    unsigned long destflags;\n    char *cookieout = NULL;\n    int cookieoutlen;\n    bool cancelled = true;\n    bool notify_source = true;\n    virErrorPtr orig_err = NULL;\n    int ret = -1;\n    /* For tunnel migration */\n    virStreamPtr st = NULL;\n    struct libxlTunnelControl *tc = NULL;\n\n    if (dname &&\n        virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, dname) < 0)\n        goto cleanup;\n\n    if (uri &&\n        virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_URI, uri) < 0)\n        goto cleanup;\n\n    dom_xml = libxlDomainMigrationSrcBegin(sconn, vm, xmlin,\n                                           &cookieout, &cookieoutlen);\n    /*\n     * If dom_xml is non-NULL the begin phase has succeeded, and the\n     * confirm phase must be called to cleanup the migration operation.\n     */\n    if (!dom_xml)\n        goto cleanup;\n\n    if (virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_DEST_XML, dom_xml) < 0)\n        goto confirm;\n\n    /* We don't require the destination to have P2P support\n     * as it looks to be normal migration from the receiver perspective.\n     */\n    destflags = flags & ~(VIR_MIGRATE_PEER2PEER);\n\n    VIR_DEBUG(\"Prepare3\");\n    virObjectUnlock(vm);\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        if (!(st = virStreamNew(dconn, 0)))\n            goto confirm;\n        ret = dconn->driver->domainMigratePrepareTunnel3Params\n            (dconn, st, params, nparams, cookieout, cookieoutlen, NULL, NULL, destflags);\n    } else {\n        ret = dconn->driver->domainMigratePrepare3Params\n            (dconn, params, nparams, cookieout, cookieoutlen, NULL, NULL, &uri_out, destflags);\n    }\n    virObjectLock(vm);\n\n    if (ret == -1)\n        goto confirm;\n\n    if (!(flags & VIR_MIGRATE_TUNNELLED)) {\n        if (uri_out) {\n            if (virTypedParamsReplaceString(&params, &nparams,\n                                            VIR_MIGRATE_PARAM_URI, uri_out) < 0) {\n                virErrorPreserveLast(&orig_err);\n                goto finish;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"domainMigratePrepare3 did not set uri\"));\n            goto finish;\n        }\n    }\n\n    VIR_DEBUG(\"Perform3 uri=%s\", NULLSTR(uri_out));\n    if (flags & VIR_MIGRATE_TUNNELLED)\n        ret = libxlMigrationSrcStartTunnel(driver, vm, flags, st, &tc);\n    else\n        ret = libxlDomainMigrationSrcPerform(driver, vm, NULL, NULL,\n                                             uri_out, NULL, flags);\n    if (ret < 0) {\n        notify_source = false;\n        virErrorPreserveLast(&orig_err);\n    }\n\n    cancelled = (ret < 0);\n\n finish:\n    VIR_DEBUG(\"Finish3 ret=%d\", ret);\n    if (virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, NULL) <= 0 &&\n        virTypedParamsReplaceString(&params, &nparams,\n                                    VIR_MIGRATE_PARAM_DEST_NAME,\n                                    vm->def->name) < 0) {\n        ddomain = NULL;\n    } else {\n        virObjectUnlock(vm);\n        ddomain = dconn->driver->domainMigrateFinish3Params\n            (dconn, params, nparams, NULL, 0, NULL, NULL,\n             destflags, cancelled);\n        virObjectLock(vm);\n    }\n\n    cancelled = (ddomain == NULL);\n\n    /* If Finish3Params set an error, and we don't have an earlier\n     * one we need to preserve it in case confirm3 overwrites\n     */\n    if (!orig_err)\n        virErrorPreserveLast(&orig_err);\n\n confirm:\n    if (notify_source) {\n        VIR_DEBUG(\"Confirm3 cancelled=%d vm=%p\", cancelled, vm);\n        ret = libxlDomainMigrationSrcConfirm(driver, vm, flags, cancelled);\n\n        if (ret < 0)\n            VIR_WARN(\"Guest %s probably left in 'paused' state on source\",\n                     vm->def->name);\n    }\n\n cleanup:\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        libxlMigrationSrcStopTunnel(tc);\n        virObjectUnref(st);\n    }\n\n    if (ddomain) {\n        virObjectUnref(ddomain);\n        ret = 0;\n    } else {\n        ret = -1;\n    }\n\n    virErrorRestore(&orig_err);\n\n    VIR_FREE(cookieout);\n    VIR_FREE(dom_xml);\n    VIR_FREE(uri_out);\n    virTypedParamsFree(params, nparams);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virTypedParamsFree",
          "args": [
            "params",
            "nparams"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam-public.c",
          "lines": "878-884",
          "snippet": "void\nvirTypedParamsFree(virTypedParameterPtr params,\n                   int nparams)\n{\n    virTypedParamsClear(params, nparams);\n    VIR_FREE(params);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtypedparam.h\"\n#include <config.h>\n\nvoid\nvirTypedParamsFree(virTypedParameterPtr params,\n                   int nparams)\n{\n    virTypedParamsClear(params, nparams);\n    VIR_FREE(params);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uri_out"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dom_xml"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cookieout"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&orig_err"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "ddomain"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMigrationSrcStopTunnel",
          "args": [
            "tc"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMigrationSrcStopTunnel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "960-971",
          "snippet": "static void libxlMigrationSrcStopTunnel(struct libxlTunnelControl *tc)\n{\n    if (!tc)\n        return;\n\n    virThreadCancel(&tc->thread);\n    virThreadJoin(&tc->thread);\n\n    VIR_FORCE_CLOSE(tc->dataFD[0]);\n    VIR_FORCE_CLOSE(tc->dataFD[1]);\n    VIR_FREE(tc);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void libxlMigrationSrcStopTunnel(struct libxlTunnelControl *tc)\n{\n    if (!tc)\n        return;\n\n    virThreadCancel(&tc->thread);\n    virThreadJoin(&tc->thread);\n\n    VIR_FORCE_CLOSE(tc->dataFD[0]);\n    VIR_FORCE_CLOSE(tc->dataFD[1]);\n    VIR_FREE(tc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Guest %s probably left in 'paused' state on source\"",
            "vm->def->name"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainMigrationSrcConfirm",
          "args": [
            "driver",
            "vm",
            "flags",
            "cancelled"
          ],
          "line": 1103
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainMigrationSrcConfirm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "1375-1429",
          "snippet": "int\nlibxlDomainMigrationSrcConfirm(libxlDriverPrivatePtr driver,\n                               virDomainObjPtr vm,\n                               unsigned int flags,\n                               int cancelled)\n{\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    virObjectEventPtr event = NULL;\n    int ret = -1;\n\n    if (cancelled) {\n        /* Resume lock process that was paused in MigrationSrcPerform */\n        virDomainLockProcessResume(driver->lockManager,\n                                   \"xen:///system\",\n                                   vm,\n                                   priv->lockState);\n        if (libxl_domain_resume(cfg->ctx, vm->def->id, 1, 0) == 0) {\n            ret = 0;\n        } else {\n            VIR_DEBUG(\"Unable to resume domain '%s' after failed migration\",\n                      vm->def->name);\n            virDomainObjSetState(vm, VIR_DOMAIN_PAUSED,\n                                 VIR_DOMAIN_PAUSED_MIGRATION);\n            event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_SUSPENDED,\n                                     VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED);\n            ignore_value(virDomainObjSave(vm, driver->xmlopt, cfg->stateDir));\n        }\n        goto cleanup;\n    }\n\n    libxlDomainDestroyInternal(driver, vm);\n    libxlDomainCleanup(driver, vm);\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF,\n                         VIR_DOMAIN_SHUTOFF_MIGRATED);\n    event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_STOPPED,\n                                              VIR_DOMAIN_EVENT_STOPPED_MIGRATED);\n\n    VIR_DEBUG(\"Domain '%s' successfully migrated\", vm->def->name);\n\n    if (flags & VIR_MIGRATE_UNDEFINE_SOURCE)\n        virDomainDeleteConfig(cfg->configDir, cfg->autostartDir, vm);\n\n    if (!vm->persistent || (flags & VIR_MIGRATE_UNDEFINE_SOURCE))\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n\n cleanup:\n    /* EndJob for corresponding BeginJob in begin phase */\n    libxlDomainObjEndJob(driver, vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectUnref(cfg);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nlibxlDomainMigrationSrcConfirm(libxlDriverPrivatePtr driver,\n                               virDomainObjPtr vm,\n                               unsigned int flags,\n                               int cancelled)\n{\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    virObjectEventPtr event = NULL;\n    int ret = -1;\n\n    if (cancelled) {\n        /* Resume lock process that was paused in MigrationSrcPerform */\n        virDomainLockProcessResume(driver->lockManager,\n                                   \"xen:///system\",\n                                   vm,\n                                   priv->lockState);\n        if (libxl_domain_resume(cfg->ctx, vm->def->id, 1, 0) == 0) {\n            ret = 0;\n        } else {\n            VIR_DEBUG(\"Unable to resume domain '%s' after failed migration\",\n                      vm->def->name);\n            virDomainObjSetState(vm, VIR_DOMAIN_PAUSED,\n                                 VIR_DOMAIN_PAUSED_MIGRATION);\n            event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_SUSPENDED,\n                                     VIR_DOMAIN_EVENT_SUSPENDED_MIGRATED);\n            ignore_value(virDomainObjSave(vm, driver->xmlopt, cfg->stateDir));\n        }\n        goto cleanup;\n    }\n\n    libxlDomainDestroyInternal(driver, vm);\n    libxlDomainCleanup(driver, vm);\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF,\n                         VIR_DOMAIN_SHUTOFF_MIGRATED);\n    event = virDomainEventLifecycleNewFromObj(vm, VIR_DOMAIN_EVENT_STOPPED,\n                                              VIR_DOMAIN_EVENT_STOPPED_MIGRATED);\n\n    VIR_DEBUG(\"Domain '%s' successfully migrated\", vm->def->name);\n\n    if (flags & VIR_MIGRATE_UNDEFINE_SOURCE)\n        virDomainDeleteConfig(cfg->configDir, cfg->autostartDir, vm);\n\n    if (!vm->persistent || (flags & VIR_MIGRATE_UNDEFINE_SOURCE))\n        virDomainObjListRemove(driver->domains, vm);\n\n    ret = 0;\n\n cleanup:\n    /* EndJob for corresponding BeginJob in begin phase */\n    libxlDomainObjEndJob(driver, vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectUnref(cfg);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Confirm3 cancelled=%d vm=%p\"",
            "cancelled",
            "vm"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&orig_err"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dconn->driver->domainMigrateFinish3Params",
          "args": [
            "dconn",
            "params",
            "nparams",
            "NULL",
            "0",
            "NULL",
            "NULL",
            "destflags",
            "cancelled"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsReplaceString",
          "args": [
            "&params",
            "&nparams",
            "VIR_MIGRATE_PARAM_DEST_NAME",
            "vm->def->name"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsReplaceString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "312-350",
          "snippet": "int\nvirTypedParamsReplaceString(virTypedParameterPtr *params,\n                            int *nparams,\n                            const char *name,\n                            const char *value)\n{\n    char *str = NULL;\n    char *old = NULL;\n    size_t n = *nparams;\n    virTypedParameterPtr param;\n\n    param = virTypedParamsGet(*params, n, name);\n    if (param) {\n        if (param->type != VIR_TYPED_PARAM_STRING) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Parameter '%s' is not a string\"),\n                           param->field);\n            return -1;\n        }\n        old = param->value.s;\n    } else {\n        if (VIR_EXPAND_N(*params, n, 1) < 0)\n            return -1;\n        param = *params + n - 1;\n    }\n\n    str = g_strdup(value);\n\n    if (virTypedParameterAssign(param, name,\n                                VIR_TYPED_PARAM_STRING, str) < 0) {\n        param->value.s = old;\n        VIR_FREE(str);\n        return -1;\n    }\n    VIR_FREE(old);\n\n    *nparams = n;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsReplaceString(virTypedParameterPtr *params,\n                            int *nparams,\n                            const char *name,\n                            const char *value)\n{\n    char *str = NULL;\n    char *old = NULL;\n    size_t n = *nparams;\n    virTypedParameterPtr param;\n\n    param = virTypedParamsGet(*params, n, name);\n    if (param) {\n        if (param->type != VIR_TYPED_PARAM_STRING) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Parameter '%s' is not a string\"),\n                           param->field);\n            return -1;\n        }\n        old = param->value.s;\n    } else {\n        if (VIR_EXPAND_N(*params, n, 1) < 0)\n            return -1;\n        param = *params + n - 1;\n    }\n\n    str = g_strdup(value);\n\n    if (virTypedParameterAssign(param, name,\n                                VIR_TYPED_PARAM_STRING, str) < 0) {\n        param->value.s = old;\n        VIR_FREE(str);\n        return -1;\n    }\n    VIR_FREE(old);\n\n    *nparams = n;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsGetString",
          "args": [
            "params",
            "nparams",
            "VIR_MIGRATE_PARAM_DEST_NAME",
            "NULL"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsGetStringList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "432-467",
          "snippet": "int\nvirTypedParamsGetStringList(virTypedParameterPtr params,\n                            int nparams,\n                            const char *name,\n                            const char ***values)\n{\n    size_t i, n;\n    int nfiltered;\n    virTypedParameterPtr *filtered = NULL;\n\n    virCheckNonNullArgGoto(values, error);\n    *values = NULL;\n\n    nfiltered = virTypedParamsFilter(params, nparams, name, &filtered);\n\n    if (nfiltered < 0)\n        goto error;\n\n    if (nfiltered &&\n        VIR_ALLOC_N(*values, nfiltered) < 0)\n        goto error;\n\n    for (n = 0, i = 0; i < nfiltered; i++) {\n        if (filtered[i]->type == VIR_TYPED_PARAM_STRING)\n            (*values)[n++] = filtered[i]->value.s;\n    }\n\n    VIR_FREE(filtered);\n    return n;\n\n error:\n    if (values)\n        VIR_FREE(*values);\n    VIR_FREE(filtered);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsGetStringList(virTypedParameterPtr params,\n                            int nparams,\n                            const char *name,\n                            const char ***values)\n{\n    size_t i, n;\n    int nfiltered;\n    virTypedParameterPtr *filtered = NULL;\n\n    virCheckNonNullArgGoto(values, error);\n    *values = NULL;\n\n    nfiltered = virTypedParamsFilter(params, nparams, name, &filtered);\n\n    if (nfiltered < 0)\n        goto error;\n\n    if (nfiltered &&\n        VIR_ALLOC_N(*values, nfiltered) < 0)\n        goto error;\n\n    for (n = 0, i = 0; i < nfiltered; i++) {\n        if (filtered[i]->type == VIR_TYPED_PARAM_STRING)\n            (*values)[n++] = filtered[i]->value.s;\n    }\n\n    VIR_FREE(filtered);\n    return n;\n\n error:\n    if (values)\n        VIR_FREE(*values);\n    VIR_FREE(filtered);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Finish3 ret=%d\"",
            "ret"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDomainMigrationSrcPerform",
          "args": [
            "driver",
            "vm",
            "NULL",
            "NULL",
            "uri_out",
            "NULL",
            "flags"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainMigrationSrcPerform",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "1210-1272",
          "snippet": "int\nlibxlDomainMigrationSrcPerform(libxlDriverPrivatePtr driver,\n                               virDomainObjPtr vm,\n                               const char *dom_xml G_GNUC_UNUSED,\n                               const char *dconnuri G_GNUC_UNUSED,\n                               const char *uri_str,\n                               const char *dname G_GNUC_UNUSED,\n                               unsigned int flags)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    char *hostname = NULL;\n    unsigned short port = 0;\n    char portstr[100];\n    virURIPtr uri = NULL;\n    virNetSocketPtr sock;\n    int sockfd = -1;\n    int ret = -1;\n\n    /* parse dst host:port from uri */\n    uri = virURIParse(uri_str);\n    if (uri == NULL || uri->server == NULL || uri->port == 0)\n        goto cleanup;\n\n    hostname = uri->server;\n    port = uri->port;\n    g_snprintf(portstr, sizeof(portstr), \"%d\", port);\n\n    /* socket connect to dst host:port */\n    if (virNetSocketNewConnectTCP(hostname, portstr,\n                                  AF_UNSPEC,\n                                  &sock) < 0)\n        goto cleanup;\n\n    if (virNetSocketSetBlocking(sock, true) < 0) {\n        virObjectUnref(sock);\n        goto cleanup;\n    }\n\n    sockfd = virNetSocketDupFD(sock, true);\n    virObjectUnref(sock);\n\n    /* suspend vm and send saved data to dst through socket fd */\n    virObjectUnlock(vm);\n    ret = libxlDoMigrateSrcSend(driver, vm, flags, sockfd);\n    virObjectLock(vm);\n\n    if (ret == 0) {\n        if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n            VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n        VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n    } else {\n        /*\n         * Confirm phase will not be executed if perform fails. End the\n         * job started in begin phase.\n         */\n        libxlDomainObjEndJob(driver, vm);\n    }\n\n cleanup:\n    VIR_FORCE_CLOSE(sockfd);\n    virURIFree(uri);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nlibxlDomainMigrationSrcPerform(libxlDriverPrivatePtr driver,\n                               virDomainObjPtr vm,\n                               const char *dom_xml G_GNUC_UNUSED,\n                               const char *dconnuri G_GNUC_UNUSED,\n                               const char *uri_str,\n                               const char *dname G_GNUC_UNUSED,\n                               unsigned int flags)\n{\n    libxlDomainObjPrivatePtr priv = vm->privateData;\n    char *hostname = NULL;\n    unsigned short port = 0;\n    char portstr[100];\n    virURIPtr uri = NULL;\n    virNetSocketPtr sock;\n    int sockfd = -1;\n    int ret = -1;\n\n    /* parse dst host:port from uri */\n    uri = virURIParse(uri_str);\n    if (uri == NULL || uri->server == NULL || uri->port == 0)\n        goto cleanup;\n\n    hostname = uri->server;\n    port = uri->port;\n    g_snprintf(portstr, sizeof(portstr), \"%d\", port);\n\n    /* socket connect to dst host:port */\n    if (virNetSocketNewConnectTCP(hostname, portstr,\n                                  AF_UNSPEC,\n                                  &sock) < 0)\n        goto cleanup;\n\n    if (virNetSocketSetBlocking(sock, true) < 0) {\n        virObjectUnref(sock);\n        goto cleanup;\n    }\n\n    sockfd = virNetSocketDupFD(sock, true);\n    virObjectUnref(sock);\n\n    /* suspend vm and send saved data to dst through socket fd */\n    virObjectUnlock(vm);\n    ret = libxlDoMigrateSrcSend(driver, vm, flags, sockfd);\n    virObjectLock(vm);\n\n    if (ret == 0) {\n        if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n            VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n        VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n    } else {\n        /*\n         * Confirm phase will not be executed if perform fails. End the\n         * job started in begin phase.\n         */\n        libxlDomainObjEndJob(driver, vm);\n    }\n\n cleanup:\n    VIR_FORCE_CLOSE(sockfd);\n    virURIFree(uri);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMigrationSrcStartTunnel",
          "args": [
            "driver",
            "vm",
            "flags",
            "st",
            "&tc"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMigrationSrcStartTunnel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "913-958",
          "snippet": "static int\nlibxlMigrationSrcStartTunnel(libxlDriverPrivatePtr driver,\n                             virDomainObjPtr vm,\n                             unsigned long flags,\n                             virStreamPtr st,\n                             struct libxlTunnelControl **tnl)\n{\n    struct libxlTunnelControl *tc = NULL;\n    libxlTunnelMigrationThread *arg = NULL;\n    int ret = -1;\n    g_autofree char *name = NULL;\n\n    if (VIR_ALLOC(tc) < 0)\n        goto out;\n    *tnl = tc;\n\n    tc->dataFD[0] = -1;\n    tc->dataFD[1] = -1;\n    if (virPipe(tc->dataFD) < 0)\n        goto out;\n\n    arg = &tc->tmThread;\n    /* Read from pipe */\n    arg->srcFD = tc->dataFD[0];\n    /* Write to dest stream */\n    arg->st = st;\n    name = g_strdup_printf(\"mig-%s\", vm->def->name);\n    if (virThreadCreateFull(&tc->thread, true,\n                            libxlTunnel3MigrationSrcFunc,\n                            name, false, arg) < 0) {\n        virReportError(errno, \"%s\",\n                       _(\"Unable to create tunnel migration thread\"));\n        goto out;\n    }\n\n    virObjectUnlock(vm);\n    /* Send data to pipe */\n    ret = libxlDoMigrateSrcSend(driver, vm, flags, tc->dataFD[1]);\n    virObjectLock(vm);\n\n out:\n    /* libxlMigrationSrcStopTunnel will be called in libxlDoMigrateSrcP2P\n     * to free all resources for us.\n     */\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nlibxlMigrationSrcStartTunnel(libxlDriverPrivatePtr driver,\n                             virDomainObjPtr vm,\n                             unsigned long flags,\n                             virStreamPtr st,\n                             struct libxlTunnelControl **tnl)\n{\n    struct libxlTunnelControl *tc = NULL;\n    libxlTunnelMigrationThread *arg = NULL;\n    int ret = -1;\n    g_autofree char *name = NULL;\n\n    if (VIR_ALLOC(tc) < 0)\n        goto out;\n    *tnl = tc;\n\n    tc->dataFD[0] = -1;\n    tc->dataFD[1] = -1;\n    if (virPipe(tc->dataFD) < 0)\n        goto out;\n\n    arg = &tc->tmThread;\n    /* Read from pipe */\n    arg->srcFD = tc->dataFD[0];\n    /* Write to dest stream */\n    arg->st = st;\n    name = g_strdup_printf(\"mig-%s\", vm->def->name);\n    if (virThreadCreateFull(&tc->thread, true,\n                            libxlTunnel3MigrationSrcFunc,\n                            name, false, arg) < 0) {\n        virReportError(errno, \"%s\",\n                       _(\"Unable to create tunnel migration thread\"));\n        goto out;\n    }\n\n    virObjectUnlock(vm);\n    /* Send data to pipe */\n    ret = libxlDoMigrateSrcSend(driver, vm, flags, tc->dataFD[1]);\n    virObjectLock(vm);\n\n out:\n    /* libxlMigrationSrcStopTunnel will be called in libxlDoMigrateSrcP2P\n     * to free all resources for us.\n     */\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Perform3 uri=%s\"",
            "NULLSTR(uri_out)"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "uri_out"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"domainMigratePrepare3 did not set uri\")"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"domainMigratePrepare3 did not set uri\""
          ],
          "line": 1058
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dconn->driver->domainMigratePrepare3Params",
          "args": [
            "dconn",
            "params",
            "nparams",
            "cookieout",
            "cookieoutlen",
            "NULL",
            "NULL",
            "&uri_out",
            "destflags"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dconn->driver->domainMigratePrepareTunnel3Params",
          "args": [
            "dconn",
            "st",
            "params",
            "nparams",
            "cookieout",
            "cookieoutlen",
            "NULL",
            "NULL",
            "destflags"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStreamNew",
          "args": [
            "dconn",
            "0"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "52-71",
          "snippet": "virStreamPtr\nvirStreamNew(virConnectPtr conn,\n             unsigned int flags)\n{\n    virStreamPtr st;\n\n    VIR_DEBUG(\"conn=%p, flags=0x%x\", conn, flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n\n    st = virGetStream(conn);\n    if (st)\n        st->flags = flags;\n    else\n        virDispatchError(conn);\n\n    return st;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirStreamPtr\nvirStreamNew(virConnectPtr conn,\n             unsigned int flags)\n{\n    virStreamPtr st;\n\n    VIR_DEBUG(\"conn=%p, flags=0x%x\", conn, flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n\n    st = virGetStream(conn);\n    if (st)\n        st->flags = flags;\n    else\n        virDispatchError(conn);\n\n    return st;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Prepare3\""
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTypedParamsAddString",
          "args": [
            "&params",
            "&nparams",
            "&maxparams",
            "VIR_MIGRATE_PARAM_DEST_XML",
            "dom_xml"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsAddStringList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam-public.c",
          "lines": "768-788",
          "snippet": "int\nvirTypedParamsAddStringList(virTypedParameterPtr *params,\n                            int *nparams,\n                            int *maxparams,\n                            const char *name,\n                            const char **values)\n{\n    size_t i;\n    int rv = -1;\n\n    if (!values)\n        return 0;\n\n    for (i = 0; values[i]; i++) {\n        if ((rv = virTypedParamsAddString(params, nparams, maxparams,\n                                          name, values[i])) < 0)\n            break;\n    }\n\n    return rv;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsAddStringList(virTypedParameterPtr *params,\n                            int *nparams,\n                            int *maxparams,\n                            const char *name,\n                            const char **values)\n{\n    size_t i;\n    int rv = -1;\n\n    if (!values)\n        return 0;\n\n    for (i = 0; values[i]; i++) {\n        if ((rv = virTypedParamsAddString(params, nparams, maxparams,\n                                          name, values[i])) < 0)\n            break;\n    }\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainMigrationSrcBegin",
          "args": [
            "sconn",
            "vm",
            "xmlin",
            "&cookieout",
            "&cookieoutlen"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainMigrationSrcBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "383-443",
          "snippet": "char *\nlibxlDomainMigrationSrcBegin(virConnectPtr conn,\n                             virDomainObjPtr vm,\n                             const char *xmlin,\n                             char **cookieout,\n                             int *cookieoutlen)\n{\n    libxlDriverPrivatePtr driver = conn->privateData;\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    libxlMigrationCookiePtr mig = NULL;\n    virDomainDefPtr tmpdef = NULL;\n    virDomainDefPtr def;\n    char *xml = NULL;\n\n    /*\n     * In the case of successful migration, a job is started here and\n     * terminated in the confirm phase. Errors in the begin or perform\n     * phase will also terminate the job.\n     */\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        goto cleanup;\n\n    if (!(mig = libxlMigrationCookieNew(vm)))\n        goto endjob;\n\n    if (libxlMigrationBakeCookie(mig, cookieout, cookieoutlen) < 0)\n        goto endjob;\n\n    if (xmlin) {\n        if (!(tmpdef = virDomainDefParseString(xmlin,\n                                               driver->xmlopt,\n                                               NULL,\n                                               VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                               VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n            goto endjob;\n\n        if (!libxlDomainDefCheckABIStability(driver, vm->def, tmpdef))\n            goto endjob;\n\n        def = tmpdef;\n    } else {\n        def = vm->def;\n    }\n\n    if (!libxlDomainMigrationIsAllowed(def))\n        goto endjob;\n\n    xml = virDomainDefFormat(def, driver->xmlopt, VIR_DOMAIN_DEF_FORMAT_SECURE);\n    /* Valid xml means success! EndJob in the confirm phase */\n    if (xml)\n        goto cleanup;\n\n endjob:\n    libxlDomainObjEndJob(driver, vm);\n\n cleanup:\n    libxlMigrationCookieFree(mig);\n    virDomainDefFree(tmpdef);\n    virObjectUnref(cfg);\n    return xml;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nlibxlDomainMigrationSrcBegin(virConnectPtr conn,\n                             virDomainObjPtr vm,\n                             const char *xmlin,\n                             char **cookieout,\n                             int *cookieoutlen)\n{\n    libxlDriverPrivatePtr driver = conn->privateData;\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    libxlMigrationCookiePtr mig = NULL;\n    virDomainDefPtr tmpdef = NULL;\n    virDomainDefPtr def;\n    char *xml = NULL;\n\n    /*\n     * In the case of successful migration, a job is started here and\n     * terminated in the confirm phase. Errors in the begin or perform\n     * phase will also terminate the job.\n     */\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        goto cleanup;\n\n    if (!(mig = libxlMigrationCookieNew(vm)))\n        goto endjob;\n\n    if (libxlMigrationBakeCookie(mig, cookieout, cookieoutlen) < 0)\n        goto endjob;\n\n    if (xmlin) {\n        if (!(tmpdef = virDomainDefParseString(xmlin,\n                                               driver->xmlopt,\n                                               NULL,\n                                               VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                               VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n            goto endjob;\n\n        if (!libxlDomainDefCheckABIStability(driver, vm->def, tmpdef))\n            goto endjob;\n\n        def = tmpdef;\n    } else {\n        def = vm->def;\n    }\n\n    if (!libxlDomainMigrationIsAllowed(def))\n        goto endjob;\n\n    xml = virDomainDefFormat(def, driver->xmlopt, VIR_DOMAIN_DEF_FORMAT_SECURE);\n    /* Valid xml means success! EndJob in the confirm phase */\n    if (xml)\n        goto cleanup;\n\n endjob:\n    libxlDomainObjEndJob(driver, vm);\n\n cleanup:\n    libxlMigrationCookieFree(mig);\n    virDomainDefFree(tmpdef);\n    virObjectUnref(cfg);\n    return xml;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nlibxlDoMigrateSrcP2P(libxlDriverPrivatePtr driver,\n                     virDomainObjPtr vm,\n                     virConnectPtr sconn,\n                     const char *xmlin,\n                     virConnectPtr dconn,\n                     const char *dconnuri G_GNUC_UNUSED,\n                     const char *dname,\n                     const char *uri,\n                     unsigned int flags)\n{\n    virDomainPtr ddomain = NULL;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int maxparams = 0;\n    char *uri_out = NULL;\n    char *dom_xml = NULL;\n    unsigned long destflags;\n    char *cookieout = NULL;\n    int cookieoutlen;\n    bool cancelled = true;\n    bool notify_source = true;\n    virErrorPtr orig_err = NULL;\n    int ret = -1;\n    /* For tunnel migration */\n    virStreamPtr st = NULL;\n    struct libxlTunnelControl *tc = NULL;\n\n    if (dname &&\n        virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, dname) < 0)\n        goto cleanup;\n\n    if (uri &&\n        virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_URI, uri) < 0)\n        goto cleanup;\n\n    dom_xml = libxlDomainMigrationSrcBegin(sconn, vm, xmlin,\n                                           &cookieout, &cookieoutlen);\n    /*\n     * If dom_xml is non-NULL the begin phase has succeeded, and the\n     * confirm phase must be called to cleanup the migration operation.\n     */\n    if (!dom_xml)\n        goto cleanup;\n\n    if (virTypedParamsAddString(&params, &nparams, &maxparams,\n                                VIR_MIGRATE_PARAM_DEST_XML, dom_xml) < 0)\n        goto confirm;\n\n    /* We don't require the destination to have P2P support\n     * as it looks to be normal migration from the receiver perspective.\n     */\n    destflags = flags & ~(VIR_MIGRATE_PEER2PEER);\n\n    VIR_DEBUG(\"Prepare3\");\n    virObjectUnlock(vm);\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        if (!(st = virStreamNew(dconn, 0)))\n            goto confirm;\n        ret = dconn->driver->domainMigratePrepareTunnel3Params\n            (dconn, st, params, nparams, cookieout, cookieoutlen, NULL, NULL, destflags);\n    } else {\n        ret = dconn->driver->domainMigratePrepare3Params\n            (dconn, params, nparams, cookieout, cookieoutlen, NULL, NULL, &uri_out, destflags);\n    }\n    virObjectLock(vm);\n\n    if (ret == -1)\n        goto confirm;\n\n    if (!(flags & VIR_MIGRATE_TUNNELLED)) {\n        if (uri_out) {\n            if (virTypedParamsReplaceString(&params, &nparams,\n                                            VIR_MIGRATE_PARAM_URI, uri_out) < 0) {\n                virErrorPreserveLast(&orig_err);\n                goto finish;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"domainMigratePrepare3 did not set uri\"));\n            goto finish;\n        }\n    }\n\n    VIR_DEBUG(\"Perform3 uri=%s\", NULLSTR(uri_out));\n    if (flags & VIR_MIGRATE_TUNNELLED)\n        ret = libxlMigrationSrcStartTunnel(driver, vm, flags, st, &tc);\n    else\n        ret = libxlDomainMigrationSrcPerform(driver, vm, NULL, NULL,\n                                             uri_out, NULL, flags);\n    if (ret < 0) {\n        notify_source = false;\n        virErrorPreserveLast(&orig_err);\n    }\n\n    cancelled = (ret < 0);\n\n finish:\n    VIR_DEBUG(\"Finish3 ret=%d\", ret);\n    if (virTypedParamsGetString(params, nparams,\n                                VIR_MIGRATE_PARAM_DEST_NAME, NULL) <= 0 &&\n        virTypedParamsReplaceString(&params, &nparams,\n                                    VIR_MIGRATE_PARAM_DEST_NAME,\n                                    vm->def->name) < 0) {\n        ddomain = NULL;\n    } else {\n        virObjectUnlock(vm);\n        ddomain = dconn->driver->domainMigrateFinish3Params\n            (dconn, params, nparams, NULL, 0, NULL, NULL,\n             destflags, cancelled);\n        virObjectLock(vm);\n    }\n\n    cancelled = (ddomain == NULL);\n\n    /* If Finish3Params set an error, and we don't have an earlier\n     * one we need to preserve it in case confirm3 overwrites\n     */\n    if (!orig_err)\n        virErrorPreserveLast(&orig_err);\n\n confirm:\n    if (notify_source) {\n        VIR_DEBUG(\"Confirm3 cancelled=%d vm=%p\", cancelled, vm);\n        ret = libxlDomainMigrationSrcConfirm(driver, vm, flags, cancelled);\n\n        if (ret < 0)\n            VIR_WARN(\"Guest %s probably left in 'paused' state on source\",\n                     vm->def->name);\n    }\n\n cleanup:\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        libxlMigrationSrcStopTunnel(tc);\n        virObjectUnref(st);\n    }\n\n    if (ddomain) {\n        virObjectUnref(ddomain);\n        ret = 0;\n    } else {\n        ret = -1;\n    }\n\n    virErrorRestore(&orig_err);\n\n    VIR_FREE(cookieout);\n    VIR_FREE(dom_xml);\n    VIR_FREE(uri_out);\n    virTypedParamsFree(params, nparams);\n    return ret;\n}"
  },
  {
    "function_name": "libxlMigrationSrcStopTunnel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "960-971",
    "snippet": "static void libxlMigrationSrcStopTunnel(struct libxlTunnelControl *tc)\n{\n    if (!tc)\n        return;\n\n    virThreadCancel(&tc->thread);\n    virThreadJoin(&tc->thread);\n\n    VIR_FORCE_CLOSE(tc->dataFD[0]);\n    VIR_FORCE_CLOSE(tc->dataFD[1]);\n    VIR_FREE(tc);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tc"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "tc->dataFD[1]"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "tc->dataFD[0]"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virThreadJoin",
          "args": [
            "&tc->thread"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadJoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "326-329",
          "snippet": "void virThreadJoin(virThreadPtr thread)\n{\n    pthread_join(thread->thread, NULL);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virThreadJoin(virThreadPtr thread)\n{\n    pthread_join(thread->thread, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadCancel",
          "args": [
            "&tc->thread"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadCancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "331-334",
          "snippet": "void virThreadCancel(virThreadPtr thread)\n{\n    pthread_cancel(thread->thread);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virThreadCancel(virThreadPtr thread)\n{\n    pthread_cancel(thread->thread);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void libxlMigrationSrcStopTunnel(struct libxlTunnelControl *tc)\n{\n    if (!tc)\n        return;\n\n    virThreadCancel(&tc->thread);\n    virThreadJoin(&tc->thread);\n\n    VIR_FORCE_CLOSE(tc->dataFD[0]);\n    VIR_FORCE_CLOSE(tc->dataFD[1]);\n    VIR_FREE(tc);\n}"
  },
  {
    "function_name": "libxlMigrationSrcStartTunnel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "913-958",
    "snippet": "static int\nlibxlMigrationSrcStartTunnel(libxlDriverPrivatePtr driver,\n                             virDomainObjPtr vm,\n                             unsigned long flags,\n                             virStreamPtr st,\n                             struct libxlTunnelControl **tnl)\n{\n    struct libxlTunnelControl *tc = NULL;\n    libxlTunnelMigrationThread *arg = NULL;\n    int ret = -1;\n    g_autofree char *name = NULL;\n\n    if (VIR_ALLOC(tc) < 0)\n        goto out;\n    *tnl = tc;\n\n    tc->dataFD[0] = -1;\n    tc->dataFD[1] = -1;\n    if (virPipe(tc->dataFD) < 0)\n        goto out;\n\n    arg = &tc->tmThread;\n    /* Read from pipe */\n    arg->srcFD = tc->dataFD[0];\n    /* Write to dest stream */\n    arg->st = st;\n    name = g_strdup_printf(\"mig-%s\", vm->def->name);\n    if (virThreadCreateFull(&tc->thread, true,\n                            libxlTunnel3MigrationSrcFunc,\n                            name, false, arg) < 0) {\n        virReportError(errno, \"%s\",\n                       _(\"Unable to create tunnel migration thread\"));\n        goto out;\n    }\n\n    virObjectUnlock(vm);\n    /* Send data to pipe */\n    ret = libxlDoMigrateSrcSend(driver, vm, flags, tc->dataFD[1]);\n    virObjectLock(vm);\n\n out:\n    /* libxlMigrationSrcStopTunnel will be called in libxlDoMigrateSrcP2P\n     * to free all resources for us.\n     */\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDoMigrateSrcSend",
          "args": [
            "driver",
            "vm",
            "flags",
            "tc->dataFD[1]"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDoMigrateSrcSend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "345-368",
          "snippet": "static int\nlibxlDoMigrateSrcSend(libxlDriverPrivatePtr driver,\n                      virDomainObjPtr vm,\n                      unsigned long flags,\n                      int sockfd)\n{\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    int xl_flags = 0;\n    int ret;\n\n    if (flags & VIR_MIGRATE_LIVE)\n        xl_flags = LIBXL_SUSPEND_LIVE;\n\n    ret = libxl_domain_suspend(cfg->ctx, vm->def->id, sockfd,\n                               xl_flags, NULL);\n    if (ret != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to send migration data to destination host\"));\n        ret = -1;\n    }\n\n    virObjectUnref(cfg);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nlibxlDoMigrateSrcSend(libxlDriverPrivatePtr driver,\n                      virDomainObjPtr vm,\n                      unsigned long flags,\n                      int sockfd)\n{\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    int xl_flags = 0;\n    int ret;\n\n    if (flags & VIR_MIGRATE_LIVE)\n        xl_flags = LIBXL_SUSPEND_LIVE;\n\n    ret = libxl_domain_suspend(cfg->ctx, vm->def->id, sockfd,\n                               xl_flags, NULL);\n    if (ret != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to send migration data to destination host\"));\n        ret = -1;\n    }\n\n    virObjectUnref(cfg);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to create tunnel migration thread\")"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to create tunnel migration thread\""
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadCreateFull",
          "args": [
            "&tc->thread",
            "true",
            "libxlTunnel3MigrationSrcFunc",
            "name",
            "false",
            "arg"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "242-283",
          "snippet": "int virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"mig-%s\"",
            "vm->def->name"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPipe",
          "args": [
            "tc->dataFD"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "virPipeNonBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1813-1817",
          "snippet": "int\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "tc"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nlibxlMigrationSrcStartTunnel(libxlDriverPrivatePtr driver,\n                             virDomainObjPtr vm,\n                             unsigned long flags,\n                             virStreamPtr st,\n                             struct libxlTunnelControl **tnl)\n{\n    struct libxlTunnelControl *tc = NULL;\n    libxlTunnelMigrationThread *arg = NULL;\n    int ret = -1;\n    g_autofree char *name = NULL;\n\n    if (VIR_ALLOC(tc) < 0)\n        goto out;\n    *tnl = tc;\n\n    tc->dataFD[0] = -1;\n    tc->dataFD[1] = -1;\n    if (virPipe(tc->dataFD) < 0)\n        goto out;\n\n    arg = &tc->tmThread;\n    /* Read from pipe */\n    arg->srcFD = tc->dataFD[0];\n    /* Write to dest stream */\n    arg->st = st;\n    name = g_strdup_printf(\"mig-%s\", vm->def->name);\n    if (virThreadCreateFull(&tc->thread, true,\n                            libxlTunnel3MigrationSrcFunc,\n                            name, false, arg) < 0) {\n        virReportError(errno, \"%s\",\n                       _(\"Unable to create tunnel migration thread\"));\n        goto out;\n    }\n\n    virObjectUnlock(vm);\n    /* Send data to pipe */\n    ret = libxlDoMigrateSrcSend(driver, vm, flags, tc->dataFD[1]);\n    virObjectLock(vm);\n\n out:\n    /* libxlMigrationSrcStopTunnel will be called in libxlDoMigrateSrcP2P\n     * to free all resources for us.\n     */\n    return ret;\n}"
  },
  {
    "function_name": "libxlTunnel3MigrationSrcFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "847-905",
    "snippet": "static void libxlTunnel3MigrationSrcFunc(void *arg)\n{\n    libxlTunnelMigrationThread *data = (libxlTunnelMigrationThread *)arg;\n    char *buffer = NULL;\n    struct pollfd fds[1];\n    int timeout = -1;\n\n    if (VIR_ALLOC_N(buffer, TUNNEL_SEND_BUF_SIZE) < 0)\n        return;\n\n    fds[0].fd = data->srcFD;\n    for (;;) {\n        int ret;\n\n        fds[0].events = POLLIN;\n        fds[0].revents = 0;\n        ret = poll(fds, G_N_ELEMENTS(fds), timeout);\n        if (ret < 0) {\n            if (errno == EAGAIN || errno == EINTR)\n                continue;\n            virReportError(errno, \"%s\",\n                           _(\"poll failed in libxlTunnel3MigrationSrcFunc\"));\n            goto cleanup;\n        }\n\n        if (ret == 0) {\n            VIR_DEBUG(\"poll returned 0\");\n            break;\n        }\n\n        if (fds[0].revents & (POLLIN | POLLERR | POLLHUP)) {\n            int nbytes;\n\n            nbytes = read(data->srcFD, buffer, TUNNEL_SEND_BUF_SIZE);\n            if (nbytes > 0) {\n                /* Write to dest stream */\n                if (virStreamSend(data->st, buffer, nbytes) < 0) {\n                    virStreamAbort(data->st);\n                    goto cleanup;\n                }\n            } else if (nbytes < 0) {\n                virReportError(errno, \"%s\",\n                               _(\"tunnelled migration failed to read from xen side\"));\n                virStreamAbort(data->st);\n                goto cleanup;\n            } else {\n                /* EOF; transferred all data */\n                break;\n            }\n        }\n    }\n\n    ignore_value(virStreamFinish(data->st));\n\n cleanup:\n    VIR_FREE(buffer);\n\n    return;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define TUNNEL_SEND_BUF_SIZE 65536"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buffer"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStreamFinish(data->st)"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStreamFinish",
          "args": [
            "data->st"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1179-1202",
          "snippet": "int\nvirStreamFinish(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamFinish) {\n        int ret;\n        ret = (stream->driver->streamFinish)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamFinish(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamFinish) {\n        int ret;\n        ret = (stream->driver->streamFinish)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamAbort",
          "args": [
            "data->st"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1221-1248",
          "snippet": "int\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"tunnelled migration failed to read from xen side\")"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"tunnelled migration failed to read from xen side\""
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamSend",
          "args": [
            "data->st",
            "buffer",
            "nbytes"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamSendAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "571-631",
          "snippet": "int\nvirStreamSendAll(virStreamPtr stream,\n                 virStreamSourceFunc handler,\n                 void *opaque)\n{\n    char *bytes = NULL;\n    size_t want = VIR_NET_MESSAGE_LEGACY_PAYLOAD_MAX;\n    int ret = -1;\n    VIR_DEBUG(\"stream=%p, handler=%p, opaque=%p\", stream, handler, opaque);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n    virCheckNonNullArgGoto(handler, cleanup);\n\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"data sources cannot be used for non-blocking streams\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(bytes, want) < 0)\n        goto cleanup;\n\n    errno = 0;\n    for (;;) {\n        int got, offset = 0;\n\n        got = (handler)(stream, bytes, want, opaque);\n        if (got < 0) {\n            if (errno == 0)\n                errno = EIO;\n            virReportSystemError(errno, \"%s\", _(\"send handler failed\"));\n            goto cleanup;\n        }\n        if (got == 0)\n            break;\n        while (offset < got) {\n            int done;\n            done = virStreamSend(stream, bytes + offset, got - offset);\n            if (done < 0)\n                goto cleanup;\n            offset += done;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(bytes);\n\n    if (ret != 0) {\n        virErrorPtr orig_err;\n\n        virErrorPreserveLast(&orig_err);\n        virStreamAbort(stream);\n        virErrorRestore(&orig_err);\n        virDispatchError(stream->conn);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamSendAll(virStreamPtr stream,\n                 virStreamSourceFunc handler,\n                 void *opaque)\n{\n    char *bytes = NULL;\n    size_t want = VIR_NET_MESSAGE_LEGACY_PAYLOAD_MAX;\n    int ret = -1;\n    VIR_DEBUG(\"stream=%p, handler=%p, opaque=%p\", stream, handler, opaque);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n    virCheckNonNullArgGoto(handler, cleanup);\n\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"data sources cannot be used for non-blocking streams\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(bytes, want) < 0)\n        goto cleanup;\n\n    errno = 0;\n    for (;;) {\n        int got, offset = 0;\n\n        got = (handler)(stream, bytes, want, opaque);\n        if (got < 0) {\n            if (errno == 0)\n                errno = EIO;\n            virReportSystemError(errno, \"%s\", _(\"send handler failed\"));\n            goto cleanup;\n        }\n        if (got == 0)\n            break;\n        while (offset < got) {\n            int done;\n            done = virStreamSend(stream, bytes + offset, got - offset);\n            if (done < 0)\n                goto cleanup;\n            offset += done;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(bytes);\n\n    if (ret != 0) {\n        virErrorPtr orig_err;\n\n        virErrorPreserveLast(&orig_err);\n        virStreamAbort(stream);\n        virErrorRestore(&orig_err);\n        virDispatchError(stream->conn);\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "data->srcFD",
            "buffer",
            "TUNNEL_SEND_BUF_SIZE"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDelIOThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-domain.c",
          "lines": "7811-7841",
          "snippet": "int\nvirDomainDelIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, flags=0x%x\", iothread_id, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonZeroArgGoto(iothread_id, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainDelIOThread) {\n        int ret;\n        ret = conn->driver->domainDelIOThread(domain, iothread_id, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirDomainDelIOThread(virDomainPtr domain,\n                     unsigned int iothread_id,\n                     unsigned int flags)\n{\n    virConnectPtr conn;\n\n    VIR_DOMAIN_DEBUG(domain, \"iothread_id=%u, flags=0x%x\", iothread_id, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(domain, -1);\n    virCheckReadOnlyGoto(domain->conn->flags, error);\n    virCheckNonZeroArgGoto(iothread_id, error);\n\n    conn = domain->conn;\n\n    if (conn->driver->domainDelIOThread) {\n        int ret;\n        ret = conn->driver->domainDelIOThread(domain, iothread_id, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(domain->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"poll returned 0\""
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"poll failed in libxlTunnel3MigrationSrcFunc\")"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "fds",
            "G_N_ELEMENTS(fds)",
            "timeout"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "fds"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "buffer",
            "TUNNEL_SEND_BUF_SIZE"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\n#define TUNNEL_SEND_BUF_SIZE 65536\n\nstatic void libxlTunnel3MigrationSrcFunc(void *arg)\n{\n    libxlTunnelMigrationThread *data = (libxlTunnelMigrationThread *)arg;\n    char *buffer = NULL;\n    struct pollfd fds[1];\n    int timeout = -1;\n\n    if (VIR_ALLOC_N(buffer, TUNNEL_SEND_BUF_SIZE) < 0)\n        return;\n\n    fds[0].fd = data->srcFD;\n    for (;;) {\n        int ret;\n\n        fds[0].events = POLLIN;\n        fds[0].revents = 0;\n        ret = poll(fds, G_N_ELEMENTS(fds), timeout);\n        if (ret < 0) {\n            if (errno == EAGAIN || errno == EINTR)\n                continue;\n            virReportError(errno, \"%s\",\n                           _(\"poll failed in libxlTunnel3MigrationSrcFunc\"));\n            goto cleanup;\n        }\n\n        if (ret == 0) {\n            VIR_DEBUG(\"poll returned 0\");\n            break;\n        }\n\n        if (fds[0].revents & (POLLIN | POLLERR | POLLHUP)) {\n            int nbytes;\n\n            nbytes = read(data->srcFD, buffer, TUNNEL_SEND_BUF_SIZE);\n            if (nbytes > 0) {\n                /* Write to dest stream */\n                if (virStreamSend(data->st, buffer, nbytes) < 0) {\n                    virStreamAbort(data->st);\n                    goto cleanup;\n                }\n            } else if (nbytes < 0) {\n                virReportError(errno, \"%s\",\n                               _(\"tunnelled migration failed to read from xen side\"));\n                virStreamAbort(data->st);\n                goto cleanup;\n            } else {\n                /* EOF; transferred all data */\n                break;\n            }\n        }\n    }\n\n    ignore_value(virStreamFinish(data->st));\n\n cleanup:\n    VIR_FREE(buffer);\n\n    return;\n}"
  },
  {
    "function_name": "libxlDomainMigrationDstPrepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "650-833",
    "snippet": "int\nlibxlDomainMigrationDstPrepare(virConnectPtr dconn,\n                               virDomainDefPtr *def,\n                               const char *uri_in,\n                               char **uri_out,\n                               const char *cookiein,\n                               int cookieinlen,\n                               unsigned int flags)\n{\n    libxlDriverPrivatePtr driver = dconn->privateData;\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    libxlMigrationCookiePtr mig = NULL;\n    virDomainObjPtr vm = NULL;\n    char *hostname = NULL;\n    char *xmlout = NULL;\n    unsigned short port;\n    char portstr[100];\n    virURIPtr uri = NULL;\n    virNetSocketPtr *socks = NULL;\n    size_t nsocks = 0;\n    int nsocks_listen = 0;\n    libxlMigrationDstArgs *args = NULL;\n    bool taint_hook = false;\n    libxlDomainObjPrivatePtr priv = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (libxlDomainMigrationPrepareAny(dconn, def, cookiein, cookieinlen,\n                                       &mig, &xmlout, &taint_hook) < 0)\n        goto error;\n\n    if (!(vm = virDomainObjListAdd(driver->domains, *def,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto error;\n    *def = NULL;\n\n    /*\n     * Unless an error is encountered in this function, the job will\n     * be terminated in the finish phase.\n     */\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        goto error;\n\n    priv = vm->privateData;\n\n    if (taint_hook) {\n        /* Domain XML has been altered by a hook script. */\n        priv->hookRun = true;\n    }\n\n    /* Create socket connection to receive migration data */\n    if (!uri_in) {\n        if ((hostname = virGetHostname()) == NULL)\n            goto endjob;\n\n        if (STRPREFIX(hostname, \"localhost\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"hostname on destination resolved to localhost,\"\n                             \" but migration requires an FQDN\"));\n            goto endjob;\n        }\n\n        if (virPortAllocatorAcquire(driver->migrationPorts, &port) < 0)\n            goto endjob;\n\n        priv->migrationPort = port;\n        *uri_out = g_strdup_printf(\"tcp://%s:%d\", hostname, port);\n    } else {\n        if (!(STRPREFIX(uri_in, \"tcp://\"))) {\n            /* not full URI, add prefix tcp:// */\n            char *tmp;\n            tmp = g_strdup_printf(\"tcp://%s\", uri_in);\n            uri = virURIParse(tmp);\n            VIR_FREE(tmp);\n        } else {\n            uri = virURIParse(uri_in);\n        }\n\n        if (uri == NULL) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"unable to parse URI: %s\"),\n                           uri_in);\n            goto endjob;\n        }\n\n        if (uri->server == NULL) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"missing host in migration URI: %s\"),\n                           uri_in);\n            goto endjob;\n        }\n        hostname = uri->server;\n\n        if (uri->port == 0) {\n            if (virPortAllocatorAcquire(driver->migrationPorts, &port) < 0)\n                goto endjob;\n\n            priv->migrationPort = port;\n        } else {\n            port = uri->port;\n        }\n\n        *uri_out = g_strdup_printf(\"tcp://%s:%d\", hostname, port);\n    }\n\n    g_snprintf(portstr, sizeof(portstr), \"%d\", port);\n\n    if (virNetSocketNewListenTCP(hostname, portstr,\n                                 AF_UNSPEC,\n                                 &socks, &nsocks) < 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Fail to create socket for incoming migration\"));\n        goto endjob;\n    }\n\n    if (libxlMigrationDstArgsInitialize() < 0)\n        goto endjob;\n\n    if (!(args = virObjectNew(libxlMigrationDstArgsClass)))\n        goto endjob;\n\n    args->conn = virObjectRef(dconn);\n    args->vm = virObjectRef(vm);\n    args->flags = flags;\n    args->socks = socks;\n    args->nsocks = nsocks;\n    args->migcookie = mig;\n    mig = NULL;\n\n    for (i = 0; i < nsocks; i++) {\n        if (virNetSocketSetBlocking(socks[i], true) < 0)\n             continue;\n\n        if (virNetSocketListen(socks[i], 1) < 0)\n            continue;\n\n        if (virNetSocketAddIOCallback(socks[i],\n                                      VIR_EVENT_HANDLE_READABLE,\n                                      libxlMigrateDstReceive,\n                                      virObjectRef(args),\n                                      NULL) < 0)\n            continue;\n\n        nsocks_listen++;\n    }\n\n    if (!nsocks_listen)\n        goto endjob;\n\n    ret = 0;\n    goto done;\n\n endjob:\n    libxlDomainObjEndJob(driver, vm);\n\n error:\n    for (i = 0; i < nsocks; i++) {\n        virNetSocketClose(socks[i]);\n        virObjectUnref(socks[i]);\n    }\n    VIR_FREE(socks);\n    if (priv) {\n        virPortAllocatorRelease(priv->migrationPort);\n        priv->migrationPort = 0;\n    }\n    /* Remove virDomainObj from domain list */\n    if (vm)\n        virDomainObjListRemove(driver->domains, vm);\n\n done:\n    VIR_FREE(xmlout);\n    libxlMigrationCookieFree(mig);\n    if (!uri_in)\n        VIR_FREE(hostname);\n    else\n        virURIFree(uri);\n    virObjectUnref(args);\n    virDomainObjEndAPI(&vm);\n    virObjectUnref(cfg);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr libxlMigrationDstArgsClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virURIFree",
          "args": [
            "uri"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "virURIFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "277-298",
          "snippet": "void virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvoid virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "hostname"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlMigrationCookieFree",
          "args": [
            "mig"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMigrationCookieFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "79-88",
          "snippet": "static void\nlibxlMigrationCookieFree(libxlMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    VIR_FREE(mig->srcHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nlibxlMigrationCookieFree(libxlMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    VIR_FREE(mig->srcHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xmlout"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjListRemove",
          "args": [
            "driver->domains",
            "vm"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "401-413",
          "snippet": "void\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPortAllocatorRelease",
          "args": [
            "priv->migrationPort"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "256-281",
          "snippet": "int\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "socks"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketClose",
          "args": [
            "socks[i]"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2254-2277",
          "snippet": "void virNetSocketClose(virNetSocketPtr sock)\n{\n    if (!sock)\n        return;\n\n    virObjectLock(sock);\n\n    if (sock->fd != -1) {\n        closesocket(sock->fd);\n        sock->fd = -1;\n    }\n\n#ifndef WIN32\n    /* If a server socket, then unlink UNIX path */\n    if (sock->unlinkUNIX &&\n        sock->localAddr.data.sa.sa_family == AF_UNIX &&\n        sock->localAddr.data.un.sun_path[0] != '\\0') {\n        if (unlink(sock->localAddr.data.un.sun_path) == 0)\n            sock->localAddr.data.un.sun_path[0] = '\\0';\n    }\n#endif\n\n    virObjectUnlock(sock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketClose(virNetSocketPtr sock)\n{\n    if (!sock)\n        return;\n\n    virObjectLock(sock);\n\n    if (sock->fd != -1) {\n        closesocket(sock->fd);\n        sock->fd = -1;\n    }\n\n#ifndef WIN32\n    /* If a server socket, then unlink UNIX path */\n    if (sock->unlinkUNIX &&\n        sock->localAddr.data.sa.sa_family == AF_UNIX &&\n        sock->localAddr.data.un.sun_path[0] != '\\0') {\n        if (unlink(sock->localAddr.data.un.sun_path) == 0)\n            sock->localAddr.data.un.sun_path[0] = '\\0';\n    }\n#endif\n\n    virObjectUnlock(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjEndJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjEndJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "167-179",
          "snippet": "void\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nlibxlDomainObjPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nvoid\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketAddIOCallback",
          "args": [
            "socks[i]",
            "VIR_EVENT_HANDLE_READABLE",
            "libxlMigrateDstReceive",
            "virObjectRef(args)",
            "NULL"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketAddIOCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2186-2220",
          "snippet": "int virNetSocketAddIOCallback(virNetSocketPtr sock,\n                              int events,\n                              virNetSocketIOFunc func,\n                              void *opaque,\n                              virFreeCallback ff)\n{\n    int ret = -1;\n\n    virObjectRef(sock);\n    virObjectLock(sock);\n    if (sock->watch >= 0) {\n        VIR_DEBUG(\"Watch already registered on socket %p\", sock);\n        goto cleanup;\n    }\n\n    if ((sock->watch = virEventAddHandle(sock->fd,\n                                         events,\n                                         virNetSocketEventHandle,\n                                         sock,\n                                         virNetSocketEventFree)) < 0) {\n        VIR_DEBUG(\"Failed to register watch on socket %p\", sock);\n        goto cleanup;\n    }\n    sock->func = func;\n    sock->opaque = opaque;\n    sock->ff = ff;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sock);\n    if (ret != 0)\n        virObjectUnref(sock);\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketAddIOCallback(virNetSocketPtr sock,\n                              int events,\n                              virNetSocketIOFunc func,\n                              void *opaque,\n                              virFreeCallback ff)\n{\n    int ret = -1;\n\n    virObjectRef(sock);\n    virObjectLock(sock);\n    if (sock->watch >= 0) {\n        VIR_DEBUG(\"Watch already registered on socket %p\", sock);\n        goto cleanup;\n    }\n\n    if ((sock->watch = virEventAddHandle(sock->fd,\n                                         events,\n                                         virNetSocketEventHandle,\n                                         sock,\n                                         virNetSocketEventFree)) < 0) {\n        VIR_DEBUG(\"Failed to register watch on socket %p\", sock);\n        goto cleanup;\n    }\n    sock->func = func;\n    sock->opaque = opaque;\n    sock->ff = ff;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(sock);\n    if (ret != 0)\n        virObjectUnref(sock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "args"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketListen",
          "args": [
            "socks[i]",
            "1"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketListen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2084-2094",
          "snippet": "int virNetSocketListen(virNetSocketPtr sock, int backlog)\n{\n    virObjectLock(sock);\n    if (listen(sock->fd, backlog > 0 ? backlog : 30) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to listen on socket\"));\n        virObjectUnlock(sock);\n        return -1;\n    }\n    virObjectUnlock(sock);\n    return 0;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketListen(virNetSocketPtr sock, int backlog)\n{\n    virObjectLock(sock);\n    if (listen(sock->fd, backlog > 0 ? backlog : 30) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to listen on socket\"));\n        virObjectUnlock(sock);\n        return -1;\n    }\n    virObjectUnlock(sock);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketSetBlocking",
          "args": [
            "socks[i]",
            "true"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketSetBlocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1632-1640",
          "snippet": "int virNetSocketSetBlocking(virNetSocketPtr sock,\n                            bool blocking)\n{\n    int ret;\n    virObjectLock(sock);\n    ret = virSetBlocking(sock->fd, blocking);\n    virObjectUnlock(sock);\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketSetBlocking(virNetSocketPtr sock,\n                            bool blocking)\n{\n    int ret;\n    virObjectLock(sock);\n    ret = virSetBlocking(sock->fd, blocking);\n    virObjectUnlock(sock);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "libxlMigrationDstArgsClass"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMigrationDstArgsInitialize",
          "args": [],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Fail to create socket for incoming migration\")"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Fail to create socket for incoming migration\""
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNewListenTCP",
          "args": [
            "hostname",
            "portstr",
            "AF_UNSPEC",
            "&socks",
            "&nsocks"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewListenTCP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "292-454",
          "snippet": "int virNetSocketNewListenTCP(const char *nodename,\n                             const char *service,\n                             int family,\n                             virNetSocketPtr **retsocks,\n                             size_t *nretsocks)\n{\n    virNetSocketPtr *socks = NULL;\n    size_t nsocks = 0;\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    size_t i;\n    int socketErrno = 0;\n    int bindErrno = 0;\n    virSocketAddr tmp_addr;\n    int port = 0;\n\n    *retsocks = NULL;\n    *nretsocks = 0;\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE;\n    hints.ai_socktype = SOCK_STREAM;\n\n    /* Don't use ADDRCONFIG for binding to the wildcard address.\n     * Just catch the error returned by socket() if the system has\n     * no IPv6 support.\n     *\n     * This allows libvirtd to be started in parallel with the network\n     * startup in most cases.\n     */\n    if (nodename &&\n        !(virSocketAddrParseAny(&tmp_addr, nodename, AF_UNSPEC, false) > 0 &&\n          virSocketAddrIsWildcard(&tmp_addr)))\n        hints.ai_flags |= AI_ADDRCONFIG;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    struct addrinfo *runp = ai;\n    while (runp) {\n        virSocketAddr addr;\n\n        memset(&addr, 0, sizeof(addr));\n\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            if (errno == EAFNOSUPPORT) {\n                socketErrno = errno;\n                runp = runp->ai_next;\n                continue;\n            }\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, true) < 0)\n            goto error;\n\n#ifdef IPV6_V6ONLY\n        if (runp->ai_family == PF_INET6) {\n            int on = 1;\n            /*\n             * Normally on Linux an INET6 socket will bind to the INET4\n             * address too. If getaddrinfo returns results with INET4\n             * first though, this will result in INET6 binding failing.\n             * We can trivially cope with multiple server sockets, so\n             * we force it to only listen on IPv6\n             */\n            if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY,\n                           (void*)&on, sizeof(on)) < 0) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Unable to force bind to IPv6 only\"));\n                goto error;\n            }\n        }\n#endif\n\n        addr.len = runp->ai_addrlen;\n        memcpy(&addr.data.sa, runp->ai_addr, runp->ai_addrlen);\n\n        /* When service is NULL, we let the kernel auto-select the\n         * port. Once we've selected a port for one IP protocol\n         * though, we want to ensure we pick the same port for the\n         * other IP protocol\n         */\n        if (port != 0 && service == NULL) {\n            if (addr.data.sa.sa_family == AF_INET) {\n                addr.data.inet4.sin_port = port;\n            } else if (addr.data.sa.sa_family == AF_INET6) {\n                addr.data.inet6.sin6_port = port;\n            }\n            VIR_DEBUG(\"Used saved port %d\", port);\n        }\n\n        if (bind(fd, &addr.data.sa, addr.len) < 0) {\n            if (errno != EADDRINUSE && errno != EADDRNOTAVAIL) {\n                virReportSystemError(errno, \"%s\", _(\"Unable to bind to port\"));\n                goto error;\n            }\n            bindErrno = errno;\n            closesocket(fd);\n            fd = -1;\n            runp = runp->ai_next;\n            continue;\n        }\n\n        addr.len = sizeof(addr.data);\n        if (getsockname(fd, &addr.data.sa, &addr.len) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n            goto error;\n        }\n\n        if (port == 0 && service == NULL) {\n            if (addr.data.sa.sa_family == AF_INET)\n                port = addr.data.inet4.sin_port;\n            else if (addr.data.sa.sa_family == AF_INET6)\n                port = addr.data.inet6.sin6_port;\n            VIR_DEBUG(\"Saved port %d\", port);\n        }\n\n        VIR_DEBUG(\"%p f=%d f=%d\", &addr, runp->ai_family, addr.data.sa.sa_family);\n\n        if (VIR_EXPAND_N(socks, nsocks, 1) < 0)\n            goto error;\n\n        if (!(socks[nsocks-1] = virNetSocketNew(&addr, NULL, false, fd, -1, 0, false)))\n            goto error;\n        runp = runp->ai_next;\n        fd = -1;\n    }\n\n    if (nsocks == 0) {\n        if (bindErrno)\n            virReportSystemError(bindErrno, \"%s\", _(\"Unable to bind to port\"));\n        else if (socketErrno)\n            virReportSystemError(socketErrno, \"%s\", _(\"Unable to create socket\"));\n        else\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"No addresses to bind to\"));\n        goto error;\n    }\n\n    freeaddrinfo(ai);\n\n    *retsocks = socks;\n    *nretsocks = nsocks;\n    return 0;\n\n error:\n    for (i = 0; i < nsocks; i++)\n        virObjectUnref(socks[i]);\n    VIR_FREE(socks);\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewListenTCP(const char *nodename,\n                             const char *service,\n                             int family,\n                             virNetSocketPtr **retsocks,\n                             size_t *nretsocks)\n{\n    virNetSocketPtr *socks = NULL;\n    size_t nsocks = 0;\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    size_t i;\n    int socketErrno = 0;\n    int bindErrno = 0;\n    virSocketAddr tmp_addr;\n    int port = 0;\n\n    *retsocks = NULL;\n    *nretsocks = 0;\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE;\n    hints.ai_socktype = SOCK_STREAM;\n\n    /* Don't use ADDRCONFIG for binding to the wildcard address.\n     * Just catch the error returned by socket() if the system has\n     * no IPv6 support.\n     *\n     * This allows libvirtd to be started in parallel with the network\n     * startup in most cases.\n     */\n    if (nodename &&\n        !(virSocketAddrParseAny(&tmp_addr, nodename, AF_UNSPEC, false) > 0 &&\n          virSocketAddrIsWildcard(&tmp_addr)))\n        hints.ai_flags |= AI_ADDRCONFIG;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    struct addrinfo *runp = ai;\n    while (runp) {\n        virSocketAddr addr;\n\n        memset(&addr, 0, sizeof(addr));\n\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            if (errno == EAFNOSUPPORT) {\n                socketErrno = errno;\n                runp = runp->ai_next;\n                continue;\n            }\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, true) < 0)\n            goto error;\n\n#ifdef IPV6_V6ONLY\n        if (runp->ai_family == PF_INET6) {\n            int on = 1;\n            /*\n             * Normally on Linux an INET6 socket will bind to the INET4\n             * address too. If getaddrinfo returns results with INET4\n             * first though, this will result in INET6 binding failing.\n             * We can trivially cope with multiple server sockets, so\n             * we force it to only listen on IPv6\n             */\n            if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY,\n                           (void*)&on, sizeof(on)) < 0) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"Unable to force bind to IPv6 only\"));\n                goto error;\n            }\n        }\n#endif\n\n        addr.len = runp->ai_addrlen;\n        memcpy(&addr.data.sa, runp->ai_addr, runp->ai_addrlen);\n\n        /* When service is NULL, we let the kernel auto-select the\n         * port. Once we've selected a port for one IP protocol\n         * though, we want to ensure we pick the same port for the\n         * other IP protocol\n         */\n        if (port != 0 && service == NULL) {\n            if (addr.data.sa.sa_family == AF_INET) {\n                addr.data.inet4.sin_port = port;\n            } else if (addr.data.sa.sa_family == AF_INET6) {\n                addr.data.inet6.sin6_port = port;\n            }\n            VIR_DEBUG(\"Used saved port %d\", port);\n        }\n\n        if (bind(fd, &addr.data.sa, addr.len) < 0) {\n            if (errno != EADDRINUSE && errno != EADDRNOTAVAIL) {\n                virReportSystemError(errno, \"%s\", _(\"Unable to bind to port\"));\n                goto error;\n            }\n            bindErrno = errno;\n            closesocket(fd);\n            fd = -1;\n            runp = runp->ai_next;\n            continue;\n        }\n\n        addr.len = sizeof(addr.data);\n        if (getsockname(fd, &addr.data.sa, &addr.len) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n            goto error;\n        }\n\n        if (port == 0 && service == NULL) {\n            if (addr.data.sa.sa_family == AF_INET)\n                port = addr.data.inet4.sin_port;\n            else if (addr.data.sa.sa_family == AF_INET6)\n                port = addr.data.inet6.sin6_port;\n            VIR_DEBUG(\"Saved port %d\", port);\n        }\n\n        VIR_DEBUG(\"%p f=%d f=%d\", &addr, runp->ai_family, addr.data.sa.sa_family);\n\n        if (VIR_EXPAND_N(socks, nsocks, 1) < 0)\n            goto error;\n\n        if (!(socks[nsocks-1] = virNetSocketNew(&addr, NULL, false, fd, -1, 0, false)))\n            goto error;\n        runp = runp->ai_next;\n        fd = -1;\n    }\n\n    if (nsocks == 0) {\n        if (bindErrno)\n            virReportSystemError(bindErrno, \"%s\", _(\"Unable to bind to port\"));\n        else if (socketErrno)\n            virReportSystemError(socketErrno, \"%s\", _(\"Unable to create socket\"));\n        else\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"No addresses to bind to\"));\n        goto error;\n    }\n\n    freeaddrinfo(ai);\n\n    *retsocks = socks;\n    *nretsocks = nsocks;\n    return 0;\n\n error:\n    for (i = 0; i < nsocks; i++)\n        virObjectUnref(socks[i]);\n    VIR_FREE(socks);\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "portstr",
            "sizeof(portstr)",
            "\"%d\"",
            "port"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"tcp://%s:%d\"",
            "hostname",
            "port"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPortAllocatorAcquire",
          "args": [
            "driver->migrationPorts",
            "&port"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorAcquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "209-254",
          "snippet": "int\nvirPortAllocatorAcquire(const virPortAllocatorRange *range,\n                        unsigned short *port)\n{\n    int ret = -1;\n    size_t i;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    *port = 0;\n\n    if (!pa)\n        return -1;\n\n    virObjectLock(pa);\n\n    for (i = range->start; i <= range->end && !*port; i++) {\n        bool used = false, v6used = false;\n\n        if (virBitmapIsBitSet(pa->bitmap, i))\n            continue;\n\n        if (virPortAllocatorBindToPort(&v6used, i, AF_INET6) < 0 ||\n            virPortAllocatorBindToPort(&used, i, AF_INET) < 0)\n            goto cleanup;\n\n        if (!used && !v6used) {\n            /* Add port to bitmap of reserved ports */\n            if (virBitmapSetBit(pa->bitmap, i) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to reserve port %zu\"), i);\n                goto cleanup;\n            }\n            *port = i;\n            ret = 0;\n        }\n    }\n\n    if (*port == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find an unused port in range '%s' (%d-%d)\"),\n                       range->name, range->start, range->end);\n    }\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorAcquire(const virPortAllocatorRange *range,\n                        unsigned short *port)\n{\n    int ret = -1;\n    size_t i;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    *port = 0;\n\n    if (!pa)\n        return -1;\n\n    virObjectLock(pa);\n\n    for (i = range->start; i <= range->end && !*port; i++) {\n        bool used = false, v6used = false;\n\n        if (virBitmapIsBitSet(pa->bitmap, i))\n            continue;\n\n        if (virPortAllocatorBindToPort(&v6used, i, AF_INET6) < 0 ||\n            virPortAllocatorBindToPort(&used, i, AF_INET) < 0)\n            goto cleanup;\n\n        if (!used && !v6used) {\n            /* Add port to bitmap of reserved ports */\n            if (virBitmapSetBit(pa->bitmap, i) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to reserve port %zu\"), i);\n                goto cleanup;\n            }\n            *port = i;\n            ret = 0;\n        }\n    }\n\n    if (*port == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find an unused port in range '%s' (%d-%d)\"),\n                       range->name, range->start, range->end);\n    }\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"missing host in migration URI: %s\")",
            "uri_in"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"unable to parse URI: %s\")",
            "uri_in"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virURIParse",
          "args": [
            "uri_in"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "virURIParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "143-194",
          "snippet": "virURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvirURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "uri_in",
            "\"tcp://\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"hostname on destination resolved to localhost,\"\n                             \" but migration requires an FQDN\")"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "hostname",
            "\"localhost\""
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetHostname",
          "args": [],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "virGetHostnameQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "560-564",
          "snippet": "char *\nvirGetHostnameQuiet(void)\n{\n    return virGetHostnameImpl(true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirGetHostnameQuiet(void)\n{\n    return virGetHostnameImpl(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjBeginJob",
          "args": [
            "driver",
            "vm",
            "LIBXL_JOB_MODIFY"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjBeginJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "109-155",
          "snippet": "int\nlibxlDomainObjBeginJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                       virDomainObjPtr obj,\n                       enum libxlDomainJob job)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    unsigned long long now;\n    unsigned long long then;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n    then = now + LIBXL_JOB_WAIT_TIME;\n\n    while (priv->job.active) {\n        VIR_DEBUG(\"Wait normal job condition for starting job: %s\",\n                  libxlDomainJobTypeToString(job));\n        if (virCondWaitUntil(&priv->job.cond, &obj->parent.lock, then) < 0)\n            goto error;\n    }\n\n    libxlDomainObjResetJob(priv);\n\n    VIR_DEBUG(\"Starting job: %s\", libxlDomainJobTypeToString(job));\n    priv->job.active = job;\n    priv->job.owner = virThreadSelfID();\n    priv->job.started = now;\n    priv->job.current->type = VIR_DOMAIN_JOB_UNBOUNDED;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Cannot start job (%s) for domain %s;\"\n             \" current job is (%s) owned by (%d)\",\n             libxlDomainJobTypeToString(job),\n             obj->def->name,\n             libxlDomainJobTypeToString(priv->job.active),\n             priv->job.owner);\n\n    if (errno == ETIMEDOUT)\n        virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                       \"%s\", _(\"cannot acquire state change lock\"));\n    else\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot acquire job mutex\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBXL_JOB_WAIT_TIME (1000ull * 30)"
          ],
          "globals_used": [
            "static void\nlibxlDomainObjPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\n#define LIBXL_JOB_WAIT_TIME (1000ull * 30)\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nint\nlibxlDomainObjBeginJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                       virDomainObjPtr obj,\n                       enum libxlDomainJob job)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    unsigned long long now;\n    unsigned long long then;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n    then = now + LIBXL_JOB_WAIT_TIME;\n\n    while (priv->job.active) {\n        VIR_DEBUG(\"Wait normal job condition for starting job: %s\",\n                  libxlDomainJobTypeToString(job));\n        if (virCondWaitUntil(&priv->job.cond, &obj->parent.lock, then) < 0)\n            goto error;\n    }\n\n    libxlDomainObjResetJob(priv);\n\n    VIR_DEBUG(\"Starting job: %s\", libxlDomainJobTypeToString(job));\n    priv->job.active = job;\n    priv->job.owner = virThreadSelfID();\n    priv->job.started = now;\n    priv->job.current->type = VIR_DOMAIN_JOB_UNBOUNDED;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Cannot start job (%s) for domain %s;\"\n             \" current job is (%s) owned by (%d)\",\n             libxlDomainJobTypeToString(job),\n             obj->def->name,\n             libxlDomainJobTypeToString(priv->job.active),\n             priv->job.owner);\n\n    if (errno == ETIMEDOUT)\n        virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                       \"%s\", _(\"cannot acquire state change lock\"));\n    else\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot acquire job mutex\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListAdd",
          "args": [
            "driver->domains",
            "*def",
            "driver->xmlopt",
            "VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE",
            "NULL"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "354-366",
          "snippet": "virDomainObjPtr virDomainObjListAdd(virDomainObjListPtr doms,\n                                    virDomainDefPtr def,\n                                    virDomainXMLOptionPtr xmlopt,\n                                    unsigned int flags,\n                                    virDomainDefPtr *oldDef)\n{\n    virDomainObjPtr ret;\n\n    virObjectRWLockWrite(doms);\n    ret = virDomainObjListAddLocked(doms, def, xmlopt, flags, oldDef);\n    virObjectRWUnlock(doms);\n    return ret;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainObjPtr virDomainObjListAdd(virDomainObjListPtr doms,\n                                    virDomainDefPtr def,\n                                    virDomainXMLOptionPtr xmlopt,\n                                    unsigned int flags,\n                                    virDomainDefPtr *oldDef)\n{\n    virDomainObjPtr ret;\n\n    virObjectRWLockWrite(doms);\n    ret = virDomainObjListAddLocked(doms, def, xmlopt, flags, oldDef);\n    virObjectRWUnlock(doms);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainMigrationPrepareAny",
          "args": [
            "dconn",
            "def",
            "cookiein",
            "cookieinlen",
            "&mig",
            "&xmlout",
            "&taint_hook"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainMigrationPrepareAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "477-544",
          "snippet": "static int\nlibxlDomainMigrationPrepareAny(virConnectPtr dconn,\n                               virDomainDefPtr *def,\n                               const char *cookiein,\n                               int cookieinlen,\n                               libxlMigrationCookiePtr *mig,\n                               char **xmlout,\n                               bool *taint_hook)\n{\n    libxlDriverPrivatePtr driver = dconn->privateData;\n\n    if (libxlMigrationEatCookie(cookiein, cookieinlen, mig) < 0)\n        return -1;\n\n    if ((*mig)->xenMigStreamVer > LIBXL_SAVE_VERSION) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Xen migration stream version '%d' is not supported on this host\"),\n                       (*mig)->xenMigStreamVer);\n        return -1;\n    }\n\n    /* Let migration hook filter domain XML */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml;\n        int hookret;\n\n        if (!(xml = virDomainDefFormat(*def, driver->xmlopt,\n                                       VIR_DOMAIN_XML_SECURE |\n                                       VIR_DOMAIN_XML_MIGRATABLE)))\n            return -1;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LIBXL, (*def)->name,\n                              VIR_HOOK_LIBXL_OP_MIGRATE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, xmlout);\n        VIR_FREE(xml);\n\n        if (hookret < 0) {\n            return -1;\n        } else if (hookret == 0) {\n            if (virStringIsEmpty(*xmlout)) {\n                VIR_DEBUG(\"Migrate hook filter returned nothing; using the\"\n                          \" original XML\");\n            } else {\n                virDomainDefPtr newdef;\n\n                VIR_DEBUG(\"Using hook-filtered domain XML: %s\", *xmlout);\n                newdef = virDomainDefParseString(*xmlout, driver->xmlopt,\n                                                 NULL,\n                                                 VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                 VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n                if (!newdef)\n                    return -1;\n\n                /* TODO At some stage we will want to have some check of what the user\n                 * did in the hook. */\n\n                virDomainDefFree(*def);\n                *def = newdef;\n                /* We should taint the domain here. However, @vm and therefore\n                 * privateData too are still NULL, so just notice the fact and\n                 * taint it later. */\n                *taint_hook = true;\n            }\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nlibxlDomainMigrationPrepareAny(virConnectPtr dconn,\n                               virDomainDefPtr *def,\n                               const char *cookiein,\n                               int cookieinlen,\n                               libxlMigrationCookiePtr *mig,\n                               char **xmlout,\n                               bool *taint_hook)\n{\n    libxlDriverPrivatePtr driver = dconn->privateData;\n\n    if (libxlMigrationEatCookie(cookiein, cookieinlen, mig) < 0)\n        return -1;\n\n    if ((*mig)->xenMigStreamVer > LIBXL_SAVE_VERSION) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Xen migration stream version '%d' is not supported on this host\"),\n                       (*mig)->xenMigStreamVer);\n        return -1;\n    }\n\n    /* Let migration hook filter domain XML */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml;\n        int hookret;\n\n        if (!(xml = virDomainDefFormat(*def, driver->xmlopt,\n                                       VIR_DOMAIN_XML_SECURE |\n                                       VIR_DOMAIN_XML_MIGRATABLE)))\n            return -1;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LIBXL, (*def)->name,\n                              VIR_HOOK_LIBXL_OP_MIGRATE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, xmlout);\n        VIR_FREE(xml);\n\n        if (hookret < 0) {\n            return -1;\n        } else if (hookret == 0) {\n            if (virStringIsEmpty(*xmlout)) {\n                VIR_DEBUG(\"Migrate hook filter returned nothing; using the\"\n                          \" original XML\");\n            } else {\n                virDomainDefPtr newdef;\n\n                VIR_DEBUG(\"Using hook-filtered domain XML: %s\", *xmlout);\n                newdef = virDomainDefParseString(*xmlout, driver->xmlopt,\n                                                 NULL,\n                                                 VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                 VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n                if (!newdef)\n                    return -1;\n\n                /* TODO At some stage we will want to have some check of what the user\n                 * did in the hook. */\n\n                virDomainDefFree(*def);\n                *def = newdef;\n                /* We should taint the domain here. However, @vm and therefore\n                 * privateData too are still NULL, so just notice the fact and\n                 * taint it later. */\n                *taint_hook = true;\n            }\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virClassPtr libxlMigrationDstArgsClass;\n\nint\nlibxlDomainMigrationDstPrepare(virConnectPtr dconn,\n                               virDomainDefPtr *def,\n                               const char *uri_in,\n                               char **uri_out,\n                               const char *cookiein,\n                               int cookieinlen,\n                               unsigned int flags)\n{\n    libxlDriverPrivatePtr driver = dconn->privateData;\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    libxlMigrationCookiePtr mig = NULL;\n    virDomainObjPtr vm = NULL;\n    char *hostname = NULL;\n    char *xmlout = NULL;\n    unsigned short port;\n    char portstr[100];\n    virURIPtr uri = NULL;\n    virNetSocketPtr *socks = NULL;\n    size_t nsocks = 0;\n    int nsocks_listen = 0;\n    libxlMigrationDstArgs *args = NULL;\n    bool taint_hook = false;\n    libxlDomainObjPrivatePtr priv = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (libxlDomainMigrationPrepareAny(dconn, def, cookiein, cookieinlen,\n                                       &mig, &xmlout, &taint_hook) < 0)\n        goto error;\n\n    if (!(vm = virDomainObjListAdd(driver->domains, *def,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto error;\n    *def = NULL;\n\n    /*\n     * Unless an error is encountered in this function, the job will\n     * be terminated in the finish phase.\n     */\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        goto error;\n\n    priv = vm->privateData;\n\n    if (taint_hook) {\n        /* Domain XML has been altered by a hook script. */\n        priv->hookRun = true;\n    }\n\n    /* Create socket connection to receive migration data */\n    if (!uri_in) {\n        if ((hostname = virGetHostname()) == NULL)\n            goto endjob;\n\n        if (STRPREFIX(hostname, \"localhost\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"hostname on destination resolved to localhost,\"\n                             \" but migration requires an FQDN\"));\n            goto endjob;\n        }\n\n        if (virPortAllocatorAcquire(driver->migrationPorts, &port) < 0)\n            goto endjob;\n\n        priv->migrationPort = port;\n        *uri_out = g_strdup_printf(\"tcp://%s:%d\", hostname, port);\n    } else {\n        if (!(STRPREFIX(uri_in, \"tcp://\"))) {\n            /* not full URI, add prefix tcp:// */\n            char *tmp;\n            tmp = g_strdup_printf(\"tcp://%s\", uri_in);\n            uri = virURIParse(tmp);\n            VIR_FREE(tmp);\n        } else {\n            uri = virURIParse(uri_in);\n        }\n\n        if (uri == NULL) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"unable to parse URI: %s\"),\n                           uri_in);\n            goto endjob;\n        }\n\n        if (uri->server == NULL) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"missing host in migration URI: %s\"),\n                           uri_in);\n            goto endjob;\n        }\n        hostname = uri->server;\n\n        if (uri->port == 0) {\n            if (virPortAllocatorAcquire(driver->migrationPorts, &port) < 0)\n                goto endjob;\n\n            priv->migrationPort = port;\n        } else {\n            port = uri->port;\n        }\n\n        *uri_out = g_strdup_printf(\"tcp://%s:%d\", hostname, port);\n    }\n\n    g_snprintf(portstr, sizeof(portstr), \"%d\", port);\n\n    if (virNetSocketNewListenTCP(hostname, portstr,\n                                 AF_UNSPEC,\n                                 &socks, &nsocks) < 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Fail to create socket for incoming migration\"));\n        goto endjob;\n    }\n\n    if (libxlMigrationDstArgsInitialize() < 0)\n        goto endjob;\n\n    if (!(args = virObjectNew(libxlMigrationDstArgsClass)))\n        goto endjob;\n\n    args->conn = virObjectRef(dconn);\n    args->vm = virObjectRef(vm);\n    args->flags = flags;\n    args->socks = socks;\n    args->nsocks = nsocks;\n    args->migcookie = mig;\n    mig = NULL;\n\n    for (i = 0; i < nsocks; i++) {\n        if (virNetSocketSetBlocking(socks[i], true) < 0)\n             continue;\n\n        if (virNetSocketListen(socks[i], 1) < 0)\n            continue;\n\n        if (virNetSocketAddIOCallback(socks[i],\n                                      VIR_EVENT_HANDLE_READABLE,\n                                      libxlMigrateDstReceive,\n                                      virObjectRef(args),\n                                      NULL) < 0)\n            continue;\n\n        nsocks_listen++;\n    }\n\n    if (!nsocks_listen)\n        goto endjob;\n\n    ret = 0;\n    goto done;\n\n endjob:\n    libxlDomainObjEndJob(driver, vm);\n\n error:\n    for (i = 0; i < nsocks; i++) {\n        virNetSocketClose(socks[i]);\n        virObjectUnref(socks[i]);\n    }\n    VIR_FREE(socks);\n    if (priv) {\n        virPortAllocatorRelease(priv->migrationPort);\n        priv->migrationPort = 0;\n    }\n    /* Remove virDomainObj from domain list */\n    if (vm)\n        virDomainObjListRemove(driver->domains, vm);\n\n done:\n    VIR_FREE(xmlout);\n    libxlMigrationCookieFree(mig);\n    if (!uri_in)\n        VIR_FREE(hostname);\n    else\n        virURIFree(uri);\n    virObjectUnref(args);\n    virDomainObjEndAPI(&vm);\n    virObjectUnref(cfg);\n    return ret;\n}"
  },
  {
    "function_name": "libxlDomainMigrationDstPrepareTunnel3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "546-648",
    "snippet": "int\nlibxlDomainMigrationDstPrepareTunnel3(virConnectPtr dconn,\n                                      virStreamPtr st,\n                                      virDomainDefPtr *def,\n                                      const char *cookiein,\n                                      int cookieinlen,\n                                      unsigned int flags)\n{\n    libxlMigrationCookiePtr mig = NULL;\n    libxlDriverPrivatePtr driver = dconn->privateData;\n    virDomainObjPtr vm = NULL;\n    libxlMigrationDstArgs *args = NULL;\n    bool taint_hook = false;\n    libxlDomainObjPrivatePtr priv = NULL;\n    char *xmlout = NULL;\n    int dataFD[2] = { -1, -1 };\n    int ret = -1;\n    g_autofree char *name = NULL;\n\n    if (libxlDomainMigrationPrepareAny(dconn, def, cookiein, cookieinlen,\n                                       &mig, &xmlout, &taint_hook) < 0)\n        goto error;\n\n    if (!(vm = virDomainObjListAdd(driver->domains, *def,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto error;\n    *def = NULL;\n\n    /*\n     * Unless an error is encountered in this function, the job will\n     * be terminated in the finish phase.\n     */\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        goto error;\n\n    priv = vm->privateData;\n\n    if (taint_hook) {\n        /* Domain XML has been altered by a hook script. */\n        priv->hookRun = true;\n    }\n\n    /*\n     * The data flow of tunnel3 migration in the dest side:\n     * stream -> pipe -> recvfd of libxlDomainStartRestore\n     */\n    if (virPipe(dataFD) < 0)\n        goto endjob;\n\n    /* Stream data will be written to pipeIn */\n    if (virFDStreamOpen(st, dataFD[1]) < 0)\n        goto endjob;\n    dataFD[1] = -1; /* 'st' owns the FD now & will close it */\n\n    if (libxlMigrationDstArgsInitialize() < 0)\n        goto endjob;\n\n    if (!(args = virObjectNew(libxlMigrationDstArgsClass)))\n        goto endjob;\n\n    args->conn = virObjectRef(dconn);\n    args->vm = virObjectRef(vm);\n    args->flags = flags;\n    args->migcookie = mig;\n    /* Receive from pipeOut */\n    args->recvfd = dataFD[0];\n    args->nsocks = 0;\n    mig = NULL;\n\n    VIR_FREE(priv->migrationDstReceiveThr);\n    if (VIR_ALLOC(priv->migrationDstReceiveThr) < 0)\n        goto error;\n    name = g_strdup_printf(\"mig-%s\", args->vm->def->name);\n    if (virThreadCreateFull(priv->migrationDstReceiveThr, true,\n                            libxlDoMigrateDstReceive,\n                            name, false, args) < 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to create thread for receiving migration data\"));\n        goto endjob;\n    }\n\n    ret = 0;\n    goto done;\n\n endjob:\n    libxlDomainObjEndJob(driver, vm);\n\n error:\n    libxlMigrationCookieFree(mig);\n    VIR_FORCE_CLOSE(dataFD[1]);\n    VIR_FORCE_CLOSE(dataFD[0]);\n    virObjectUnref(args);\n    /* Remove virDomainObj from domain list */\n    if (vm)\n        virDomainObjListRemove(driver->domains, vm);\n\n done:\n    virDomainObjEndAPI(&vm);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr libxlMigrationDstArgsClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListRemove",
          "args": [
            "driver->domains",
            "vm"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "401-413",
          "snippet": "void\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirDomainObjListRemove(virDomainObjListPtr doms,\n                       virDomainObjPtr dom)\n{\n    dom->removing = true;\n    virObjectRef(dom);\n    virObjectUnlock(dom);\n    virObjectRWLockWrite(doms);\n    virObjectLock(dom);\n    virDomainObjListRemoveLocked(doms, dom);\n    virObjectUnref(dom);\n    virObjectRWUnlock(doms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "args"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "dataFD[0]"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "dataFD[1]"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlMigrationCookieFree",
          "args": [
            "mig"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMigrationCookieFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "79-88",
          "snippet": "static void\nlibxlMigrationCookieFree(libxlMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    VIR_FREE(mig->srcHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nlibxlMigrationCookieFree(libxlMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    VIR_FREE(mig->srcHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjEndJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjEndJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "167-179",
          "snippet": "void\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nlibxlDomainObjPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nvoid\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Failed to create thread for receiving migration data\")"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to create thread for receiving migration data\""
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadCreateFull",
          "args": [
            "priv->migrationDstReceiveThr",
            "true",
            "libxlDoMigrateDstReceive",
            "name",
            "false",
            "args"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "242-283",
          "snippet": "int virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"mig-%s\"",
            "args->vm->def->name"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "priv->migrationDstReceiveThr"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->migrationDstReceiveThr"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "vm"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "libxlMigrationDstArgsClass"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMigrationDstArgsInitialize",
          "args": [],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFDStreamOpen",
          "args": [
            "st",
            "dataFD[1]"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1425-1432",
          "snippet": "int\nvirFDStreamOpen(virStreamPtr st G_GNUC_UNUSED,\n                int fd G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamOpen(virStreamPtr st G_GNUC_UNUSED,\n                int fd G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPipe",
          "args": [
            "dataFD"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "virPipeNonBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1813-1817",
          "snippet": "int\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjBeginJob",
          "args": [
            "driver",
            "vm",
            "LIBXL_JOB_MODIFY"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjBeginJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "109-155",
          "snippet": "int\nlibxlDomainObjBeginJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                       virDomainObjPtr obj,\n                       enum libxlDomainJob job)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    unsigned long long now;\n    unsigned long long then;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n    then = now + LIBXL_JOB_WAIT_TIME;\n\n    while (priv->job.active) {\n        VIR_DEBUG(\"Wait normal job condition for starting job: %s\",\n                  libxlDomainJobTypeToString(job));\n        if (virCondWaitUntil(&priv->job.cond, &obj->parent.lock, then) < 0)\n            goto error;\n    }\n\n    libxlDomainObjResetJob(priv);\n\n    VIR_DEBUG(\"Starting job: %s\", libxlDomainJobTypeToString(job));\n    priv->job.active = job;\n    priv->job.owner = virThreadSelfID();\n    priv->job.started = now;\n    priv->job.current->type = VIR_DOMAIN_JOB_UNBOUNDED;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Cannot start job (%s) for domain %s;\"\n             \" current job is (%s) owned by (%d)\",\n             libxlDomainJobTypeToString(job),\n             obj->def->name,\n             libxlDomainJobTypeToString(priv->job.active),\n             priv->job.owner);\n\n    if (errno == ETIMEDOUT)\n        virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                       \"%s\", _(\"cannot acquire state change lock\"));\n    else\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot acquire job mutex\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBXL_JOB_WAIT_TIME (1000ull * 30)"
          ],
          "globals_used": [
            "static void\nlibxlDomainObjPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\n#define LIBXL_JOB_WAIT_TIME (1000ull * 30)\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nint\nlibxlDomainObjBeginJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                       virDomainObjPtr obj,\n                       enum libxlDomainJob job)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    unsigned long long now;\n    unsigned long long then;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n    then = now + LIBXL_JOB_WAIT_TIME;\n\n    while (priv->job.active) {\n        VIR_DEBUG(\"Wait normal job condition for starting job: %s\",\n                  libxlDomainJobTypeToString(job));\n        if (virCondWaitUntil(&priv->job.cond, &obj->parent.lock, then) < 0)\n            goto error;\n    }\n\n    libxlDomainObjResetJob(priv);\n\n    VIR_DEBUG(\"Starting job: %s\", libxlDomainJobTypeToString(job));\n    priv->job.active = job;\n    priv->job.owner = virThreadSelfID();\n    priv->job.started = now;\n    priv->job.current->type = VIR_DOMAIN_JOB_UNBOUNDED;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Cannot start job (%s) for domain %s;\"\n             \" current job is (%s) owned by (%d)\",\n             libxlDomainJobTypeToString(job),\n             obj->def->name,\n             libxlDomainJobTypeToString(priv->job.active),\n             priv->job.owner);\n\n    if (errno == ETIMEDOUT)\n        virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                       \"%s\", _(\"cannot acquire state change lock\"));\n    else\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot acquire job mutex\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListAdd",
          "args": [
            "driver->domains",
            "*def",
            "driver->xmlopt",
            "VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE",
            "NULL"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "354-366",
          "snippet": "virDomainObjPtr virDomainObjListAdd(virDomainObjListPtr doms,\n                                    virDomainDefPtr def,\n                                    virDomainXMLOptionPtr xmlopt,\n                                    unsigned int flags,\n                                    virDomainDefPtr *oldDef)\n{\n    virDomainObjPtr ret;\n\n    virObjectRWLockWrite(doms);\n    ret = virDomainObjListAddLocked(doms, def, xmlopt, flags, oldDef);\n    virObjectRWUnlock(doms);\n    return ret;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainObjPtr virDomainObjListAdd(virDomainObjListPtr doms,\n                                    virDomainDefPtr def,\n                                    virDomainXMLOptionPtr xmlopt,\n                                    unsigned int flags,\n                                    virDomainDefPtr *oldDef)\n{\n    virDomainObjPtr ret;\n\n    virObjectRWLockWrite(doms);\n    ret = virDomainObjListAddLocked(doms, def, xmlopt, flags, oldDef);\n    virObjectRWUnlock(doms);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainMigrationPrepareAny",
          "args": [
            "dconn",
            "def",
            "cookiein",
            "cookieinlen",
            "&mig",
            "&xmlout",
            "&taint_hook"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainMigrationPrepareAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "477-544",
          "snippet": "static int\nlibxlDomainMigrationPrepareAny(virConnectPtr dconn,\n                               virDomainDefPtr *def,\n                               const char *cookiein,\n                               int cookieinlen,\n                               libxlMigrationCookiePtr *mig,\n                               char **xmlout,\n                               bool *taint_hook)\n{\n    libxlDriverPrivatePtr driver = dconn->privateData;\n\n    if (libxlMigrationEatCookie(cookiein, cookieinlen, mig) < 0)\n        return -1;\n\n    if ((*mig)->xenMigStreamVer > LIBXL_SAVE_VERSION) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Xen migration stream version '%d' is not supported on this host\"),\n                       (*mig)->xenMigStreamVer);\n        return -1;\n    }\n\n    /* Let migration hook filter domain XML */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml;\n        int hookret;\n\n        if (!(xml = virDomainDefFormat(*def, driver->xmlopt,\n                                       VIR_DOMAIN_XML_SECURE |\n                                       VIR_DOMAIN_XML_MIGRATABLE)))\n            return -1;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LIBXL, (*def)->name,\n                              VIR_HOOK_LIBXL_OP_MIGRATE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, xmlout);\n        VIR_FREE(xml);\n\n        if (hookret < 0) {\n            return -1;\n        } else if (hookret == 0) {\n            if (virStringIsEmpty(*xmlout)) {\n                VIR_DEBUG(\"Migrate hook filter returned nothing; using the\"\n                          \" original XML\");\n            } else {\n                virDomainDefPtr newdef;\n\n                VIR_DEBUG(\"Using hook-filtered domain XML: %s\", *xmlout);\n                newdef = virDomainDefParseString(*xmlout, driver->xmlopt,\n                                                 NULL,\n                                                 VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                 VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n                if (!newdef)\n                    return -1;\n\n                /* TODO At some stage we will want to have some check of what the user\n                 * did in the hook. */\n\n                virDomainDefFree(*def);\n                *def = newdef;\n                /* We should taint the domain here. However, @vm and therefore\n                 * privateData too are still NULL, so just notice the fact and\n                 * taint it later. */\n                *taint_hook = true;\n            }\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nlibxlDomainMigrationPrepareAny(virConnectPtr dconn,\n                               virDomainDefPtr *def,\n                               const char *cookiein,\n                               int cookieinlen,\n                               libxlMigrationCookiePtr *mig,\n                               char **xmlout,\n                               bool *taint_hook)\n{\n    libxlDriverPrivatePtr driver = dconn->privateData;\n\n    if (libxlMigrationEatCookie(cookiein, cookieinlen, mig) < 0)\n        return -1;\n\n    if ((*mig)->xenMigStreamVer > LIBXL_SAVE_VERSION) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Xen migration stream version '%d' is not supported on this host\"),\n                       (*mig)->xenMigStreamVer);\n        return -1;\n    }\n\n    /* Let migration hook filter domain XML */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml;\n        int hookret;\n\n        if (!(xml = virDomainDefFormat(*def, driver->xmlopt,\n                                       VIR_DOMAIN_XML_SECURE |\n                                       VIR_DOMAIN_XML_MIGRATABLE)))\n            return -1;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LIBXL, (*def)->name,\n                              VIR_HOOK_LIBXL_OP_MIGRATE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, xmlout);\n        VIR_FREE(xml);\n\n        if (hookret < 0) {\n            return -1;\n        } else if (hookret == 0) {\n            if (virStringIsEmpty(*xmlout)) {\n                VIR_DEBUG(\"Migrate hook filter returned nothing; using the\"\n                          \" original XML\");\n            } else {\n                virDomainDefPtr newdef;\n\n                VIR_DEBUG(\"Using hook-filtered domain XML: %s\", *xmlout);\n                newdef = virDomainDefParseString(*xmlout, driver->xmlopt,\n                                                 NULL,\n                                                 VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                 VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n                if (!newdef)\n                    return -1;\n\n                /* TODO At some stage we will want to have some check of what the user\n                 * did in the hook. */\n\n                virDomainDefFree(*def);\n                *def = newdef;\n                /* We should taint the domain here. However, @vm and therefore\n                 * privateData too are still NULL, so just notice the fact and\n                 * taint it later. */\n                *taint_hook = true;\n            }\n        }\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virClassPtr libxlMigrationDstArgsClass;\n\nint\nlibxlDomainMigrationDstPrepareTunnel3(virConnectPtr dconn,\n                                      virStreamPtr st,\n                                      virDomainDefPtr *def,\n                                      const char *cookiein,\n                                      int cookieinlen,\n                                      unsigned int flags)\n{\n    libxlMigrationCookiePtr mig = NULL;\n    libxlDriverPrivatePtr driver = dconn->privateData;\n    virDomainObjPtr vm = NULL;\n    libxlMigrationDstArgs *args = NULL;\n    bool taint_hook = false;\n    libxlDomainObjPrivatePtr priv = NULL;\n    char *xmlout = NULL;\n    int dataFD[2] = { -1, -1 };\n    int ret = -1;\n    g_autofree char *name = NULL;\n\n    if (libxlDomainMigrationPrepareAny(dconn, def, cookiein, cookieinlen,\n                                       &mig, &xmlout, &taint_hook) < 0)\n        goto error;\n\n    if (!(vm = virDomainObjListAdd(driver->domains, *def,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto error;\n    *def = NULL;\n\n    /*\n     * Unless an error is encountered in this function, the job will\n     * be terminated in the finish phase.\n     */\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        goto error;\n\n    priv = vm->privateData;\n\n    if (taint_hook) {\n        /* Domain XML has been altered by a hook script. */\n        priv->hookRun = true;\n    }\n\n    /*\n     * The data flow of tunnel3 migration in the dest side:\n     * stream -> pipe -> recvfd of libxlDomainStartRestore\n     */\n    if (virPipe(dataFD) < 0)\n        goto endjob;\n\n    /* Stream data will be written to pipeIn */\n    if (virFDStreamOpen(st, dataFD[1]) < 0)\n        goto endjob;\n    dataFD[1] = -1; /* 'st' owns the FD now & will close it */\n\n    if (libxlMigrationDstArgsInitialize() < 0)\n        goto endjob;\n\n    if (!(args = virObjectNew(libxlMigrationDstArgsClass)))\n        goto endjob;\n\n    args->conn = virObjectRef(dconn);\n    args->vm = virObjectRef(vm);\n    args->flags = flags;\n    args->migcookie = mig;\n    /* Receive from pipeOut */\n    args->recvfd = dataFD[0];\n    args->nsocks = 0;\n    mig = NULL;\n\n    VIR_FREE(priv->migrationDstReceiveThr);\n    if (VIR_ALLOC(priv->migrationDstReceiveThr) < 0)\n        goto error;\n    name = g_strdup_printf(\"mig-%s\", args->vm->def->name);\n    if (virThreadCreateFull(priv->migrationDstReceiveThr, true,\n                            libxlDoMigrateDstReceive,\n                            name, false, args) < 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to create thread for receiving migration data\"));\n        goto endjob;\n    }\n\n    ret = 0;\n    goto done;\n\n endjob:\n    libxlDomainObjEndJob(driver, vm);\n\n error:\n    libxlMigrationCookieFree(mig);\n    VIR_FORCE_CLOSE(dataFD[1]);\n    VIR_FORCE_CLOSE(dataFD[0]);\n    virObjectUnref(args);\n    /* Remove virDomainObj from domain list */\n    if (vm)\n        virDomainObjListRemove(driver->domains, vm);\n\n done:\n    virDomainObjEndAPI(&vm);\n    return ret;\n}"
  },
  {
    "function_name": "libxlDomainMigrationPrepareAny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "477-544",
    "snippet": "static int\nlibxlDomainMigrationPrepareAny(virConnectPtr dconn,\n                               virDomainDefPtr *def,\n                               const char *cookiein,\n                               int cookieinlen,\n                               libxlMigrationCookiePtr *mig,\n                               char **xmlout,\n                               bool *taint_hook)\n{\n    libxlDriverPrivatePtr driver = dconn->privateData;\n\n    if (libxlMigrationEatCookie(cookiein, cookieinlen, mig) < 0)\n        return -1;\n\n    if ((*mig)->xenMigStreamVer > LIBXL_SAVE_VERSION) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Xen migration stream version '%d' is not supported on this host\"),\n                       (*mig)->xenMigStreamVer);\n        return -1;\n    }\n\n    /* Let migration hook filter domain XML */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml;\n        int hookret;\n\n        if (!(xml = virDomainDefFormat(*def, driver->xmlopt,\n                                       VIR_DOMAIN_XML_SECURE |\n                                       VIR_DOMAIN_XML_MIGRATABLE)))\n            return -1;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LIBXL, (*def)->name,\n                              VIR_HOOK_LIBXL_OP_MIGRATE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, xmlout);\n        VIR_FREE(xml);\n\n        if (hookret < 0) {\n            return -1;\n        } else if (hookret == 0) {\n            if (virStringIsEmpty(*xmlout)) {\n                VIR_DEBUG(\"Migrate hook filter returned nothing; using the\"\n                          \" original XML\");\n            } else {\n                virDomainDefPtr newdef;\n\n                VIR_DEBUG(\"Using hook-filtered domain XML: %s\", *xmlout);\n                newdef = virDomainDefParseString(*xmlout, driver->xmlopt,\n                                                 NULL,\n                                                 VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                 VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n                if (!newdef)\n                    return -1;\n\n                /* TODO At some stage we will want to have some check of what the user\n                 * did in the hook. */\n\n                virDomainDefFree(*def);\n                *def = newdef;\n                /* We should taint the domain here. However, @vm and therefore\n                 * privateData too are still NULL, so just notice the fact and\n                 * taint it later. */\n                *taint_hook = true;\n            }\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "*def"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefParseString",
          "args": [
            "*xmlout",
            "driver->xmlopt",
            "NULL",
            "VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                 VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "22134-22141",
          "snippet": "virDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Using hook-filtered domain XML: %s\"",
            "*xmlout"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Migrate hook filter returned nothing; using the\"\n                          \" original XML\""
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringIsEmpty",
          "args": [
            "*xmlout"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "virStringIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "882-890",
          "snippet": "bool\nvirStringIsEmpty(const char *str)\n{\n    if (!str)\n        return true;\n\n    virSkipSpaces(&str);\n    return str[0] == '\\0';\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nbool\nvirStringIsEmpty(const char *str)\n{\n    if (!str)\n        return true;\n\n    virSkipSpaces(&str);\n    return str[0] == '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHookCall",
          "args": [
            "VIR_HOOK_DRIVER_LIBXL",
            "(*def)->name",
            "VIR_HOOK_LIBXL_OP_MIGRATE",
            "VIR_HOOK_SUBOP_BEGIN",
            "NULL",
            "xml",
            "xmlout"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "virHookCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "243-341",
          "snippet": "int\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\""
          ],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\"\n\nstatic int virHooksFound = -1;\n\nint\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormat",
          "args": [
            "*def",
            "driver->xmlopt",
            "VIR_DOMAIN_XML_SECURE |\n                                       VIR_DOMAIN_XML_MIGRATABLE"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29496-29508",
          "snippet": "char *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)\n\nchar *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHookPresent",
          "args": [
            "VIR_HOOK_DRIVER_LIBXL"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "virHookPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "210-222",
          "snippet": "int\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virHooksFound = -1;\n\nint\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "_(\"Xen migration stream version '%d' is not supported on this host\")",
            "(*mig)->xenMigStreamVer"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Xen migration stream version '%d' is not supported on this host\""
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMigrationEatCookie",
          "args": [
            "cookiein",
            "cookieinlen",
            "mig"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMigrationEatCookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "146-226",
          "snippet": "static int\nlibxlMigrationEatCookie(const char *cookiein,\n                        int cookieinlen,\n                        libxlMigrationCookiePtr *migout)\n{\n    libxlMigrationCookiePtr mig = NULL;\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    char *uuidstr = NULL;\n    int ret = -1;\n\n    /*\n     * Assume a legacy (V1) migration stream if request came from a\n     * source host without cookie support, and hence no way to\n     * specify a stream version.\n     */\n    if (!cookiein || !cookieinlen) {\n        if (VIR_ALLOC(mig) < 0)\n            return -1;\n\n        mig->xenMigStreamVer = 1;\n        *migout = mig;\n        return 0;\n    }\n\n    if (cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (VIR_ALLOC(mig) < 0)\n        return -1;\n\n    if (!(doc = virXMLParseStringCtxt(cookiein,\n                                      _(\"(libxl_migration_cookie)\"),\n                                      &ctxt)))\n        goto error;\n\n    /* Extract domain name */\n    if (!(mig->name = virXPathString(\"string(./name[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing name element in migration data\"));\n        goto error;\n    }\n\n    /* Extract domain uuid */\n    uuidstr = virXPathString(\"string(./uuid[1])\", ctxt);\n    if (!uuidstr) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing uuid element in migration data\"));\n        goto error;\n    }\n    if (virUUIDParse(uuidstr, mig->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed uuid element\"));\n        goto error;\n    }\n\n    if (virXPathUInt(\"string(./migration-stream-version[1])\",\n                     ctxt, &mig->xenMigStreamVer) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing Xen migration stream version\"));\n        goto error;\n    }\n\n    *migout = mig;\n    ret = 0;\n    goto cleanup;\n\n error:\n    libxlMigrationCookieFree(mig);\n\n cleanup:\n    VIR_FREE(uuidstr);\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nlibxlMigrationEatCookie(const char *cookiein,\n                        int cookieinlen,\n                        libxlMigrationCookiePtr *migout)\n{\n    libxlMigrationCookiePtr mig = NULL;\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    char *uuidstr = NULL;\n    int ret = -1;\n\n    /*\n     * Assume a legacy (V1) migration stream if request came from a\n     * source host without cookie support, and hence no way to\n     * specify a stream version.\n     */\n    if (!cookiein || !cookieinlen) {\n        if (VIR_ALLOC(mig) < 0)\n            return -1;\n\n        mig->xenMigStreamVer = 1;\n        *migout = mig;\n        return 0;\n    }\n\n    if (cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (VIR_ALLOC(mig) < 0)\n        return -1;\n\n    if (!(doc = virXMLParseStringCtxt(cookiein,\n                                      _(\"(libxl_migration_cookie)\"),\n                                      &ctxt)))\n        goto error;\n\n    /* Extract domain name */\n    if (!(mig->name = virXPathString(\"string(./name[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing name element in migration data\"));\n        goto error;\n    }\n\n    /* Extract domain uuid */\n    uuidstr = virXPathString(\"string(./uuid[1])\", ctxt);\n    if (!uuidstr) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing uuid element in migration data\"));\n        goto error;\n    }\n    if (virUUIDParse(uuidstr, mig->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed uuid element\"));\n        goto error;\n    }\n\n    if (virXPathUInt(\"string(./migration-stream-version[1])\",\n                     ctxt, &mig->xenMigStreamVer) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing Xen migration stream version\"));\n        goto error;\n    }\n\n    *migout = mig;\n    ret = 0;\n    goto cleanup;\n\n error:\n    libxlMigrationCookieFree(mig);\n\n cleanup:\n    VIR_FREE(uuidstr);\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nlibxlDomainMigrationPrepareAny(virConnectPtr dconn,\n                               virDomainDefPtr *def,\n                               const char *cookiein,\n                               int cookieinlen,\n                               libxlMigrationCookiePtr *mig,\n                               char **xmlout,\n                               bool *taint_hook)\n{\n    libxlDriverPrivatePtr driver = dconn->privateData;\n\n    if (libxlMigrationEatCookie(cookiein, cookieinlen, mig) < 0)\n        return -1;\n\n    if ((*mig)->xenMigStreamVer > LIBXL_SAVE_VERSION) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                       _(\"Xen migration stream version '%d' is not supported on this host\"),\n                       (*mig)->xenMigStreamVer);\n        return -1;\n    }\n\n    /* Let migration hook filter domain XML */\n    if (virHookPresent(VIR_HOOK_DRIVER_LIBXL)) {\n        char *xml;\n        int hookret;\n\n        if (!(xml = virDomainDefFormat(*def, driver->xmlopt,\n                                       VIR_DOMAIN_XML_SECURE |\n                                       VIR_DOMAIN_XML_MIGRATABLE)))\n            return -1;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_LIBXL, (*def)->name,\n                              VIR_HOOK_LIBXL_OP_MIGRATE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, xmlout);\n        VIR_FREE(xml);\n\n        if (hookret < 0) {\n            return -1;\n        } else if (hookret == 0) {\n            if (virStringIsEmpty(*xmlout)) {\n                VIR_DEBUG(\"Migrate hook filter returned nothing; using the\"\n                          \" original XML\");\n            } else {\n                virDomainDefPtr newdef;\n\n                VIR_DEBUG(\"Using hook-filtered domain XML: %s\", *xmlout);\n                newdef = virDomainDefParseString(*xmlout, driver->xmlopt,\n                                                 NULL,\n                                                 VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                 VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n                if (!newdef)\n                    return -1;\n\n                /* TODO At some stage we will want to have some check of what the user\n                 * did in the hook. */\n\n                virDomainDefFree(*def);\n                *def = newdef;\n                /* We should taint the domain here. However, @vm and therefore\n                 * privateData too are still NULL, so just notice the fact and\n                 * taint it later. */\n                *taint_hook = true;\n            }\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlDomainMigrationDstPrepareDef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "445-475",
    "snippet": "virDomainDefPtr\nlibxlDomainMigrationDstPrepareDef(libxlDriverPrivatePtr driver,\n                                  const char *dom_xml,\n                                  const char *dname)\n{\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    virDomainDefPtr def;\n    char *name = NULL;\n\n    if (!dom_xml) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no domain XML passed\"));\n        return NULL;\n    }\n\n    if (!(def = virDomainDefParseString(dom_xml, driver->xmlopt,\n                                        NULL,\n                                        VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                        VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n        goto cleanup;\n\n    if (dname) {\n        name = def->name;\n        def->name = g_strdup(dname);\n    }\n\n cleanup:\n    virObjectUnref(cfg);\n    VIR_FREE(name);\n    return def;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "dname"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefParseString",
          "args": [
            "dom_xml",
            "driver->xmlopt",
            "NULL",
            "VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                        VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "22134-22141",
          "snippet": "virDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no domain XML passed\")"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no domain XML passed\""
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainDefPtr\nlibxlDomainMigrationDstPrepareDef(libxlDriverPrivatePtr driver,\n                                  const char *dom_xml,\n                                  const char *dname)\n{\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    virDomainDefPtr def;\n    char *name = NULL;\n\n    if (!dom_xml) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no domain XML passed\"));\n        return NULL;\n    }\n\n    if (!(def = virDomainDefParseString(dom_xml, driver->xmlopt,\n                                        NULL,\n                                        VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                        VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n        goto cleanup;\n\n    if (dname) {\n        name = def->name;\n        def->name = g_strdup(dname);\n    }\n\n cleanup:\n    virObjectUnref(cfg);\n    VIR_FREE(name);\n    return def;\n}"
  },
  {
    "function_name": "libxlDomainMigrationSrcBegin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "383-443",
    "snippet": "char *\nlibxlDomainMigrationSrcBegin(virConnectPtr conn,\n                             virDomainObjPtr vm,\n                             const char *xmlin,\n                             char **cookieout,\n                             int *cookieoutlen)\n{\n    libxlDriverPrivatePtr driver = conn->privateData;\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    libxlMigrationCookiePtr mig = NULL;\n    virDomainDefPtr tmpdef = NULL;\n    virDomainDefPtr def;\n    char *xml = NULL;\n\n    /*\n     * In the case of successful migration, a job is started here and\n     * terminated in the confirm phase. Errors in the begin or perform\n     * phase will also terminate the job.\n     */\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        goto cleanup;\n\n    if (!(mig = libxlMigrationCookieNew(vm)))\n        goto endjob;\n\n    if (libxlMigrationBakeCookie(mig, cookieout, cookieoutlen) < 0)\n        goto endjob;\n\n    if (xmlin) {\n        if (!(tmpdef = virDomainDefParseString(xmlin,\n                                               driver->xmlopt,\n                                               NULL,\n                                               VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                               VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n            goto endjob;\n\n        if (!libxlDomainDefCheckABIStability(driver, vm->def, tmpdef))\n            goto endjob;\n\n        def = tmpdef;\n    } else {\n        def = vm->def;\n    }\n\n    if (!libxlDomainMigrationIsAllowed(def))\n        goto endjob;\n\n    xml = virDomainDefFormat(def, driver->xmlopt, VIR_DOMAIN_DEF_FORMAT_SECURE);\n    /* Valid xml means success! EndJob in the confirm phase */\n    if (xml)\n        goto cleanup;\n\n endjob:\n    libxlDomainObjEndJob(driver, vm);\n\n cleanup:\n    libxlMigrationCookieFree(mig);\n    virDomainDefFree(tmpdef);\n    virObjectUnref(cfg);\n    return xml;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "tmpdef"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMigrationCookieFree",
          "args": [
            "mig"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMigrationCookieFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "79-88",
          "snippet": "static void\nlibxlMigrationCookieFree(libxlMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    VIR_FREE(mig->srcHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nlibxlMigrationCookieFree(libxlMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    VIR_FREE(mig->srcHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjEndJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjEndJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "167-179",
          "snippet": "void\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void\nlibxlDomainObjPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nvoid\nlibxlDomainObjEndJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                     virDomainObjPtr obj)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    enum libxlDomainJob job = priv->job.active;\n\n    VIR_DEBUG(\"Stopping job: %s\",\n              libxlDomainJobTypeToString(job));\n\n    libxlDomainObjResetJob(priv);\n    virCondSignal(&priv->job.cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormat",
          "args": [
            "def",
            "driver->xmlopt",
            "VIR_DOMAIN_DEF_FORMAT_SECURE"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29496-29508",
          "snippet": "char *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)\n\nchar *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainMigrationIsAllowed",
          "args": [
            "def"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainMigrationIsAllowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "370-381",
          "snippet": "static bool\nlibxlDomainMigrationIsAllowed(virDomainDefPtr def)\n{\n    /* Migration is not allowed if definition contains any hostdevs */\n    if (def->nhostdevs > 0) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"domain has assigned host devices\"));\n        return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic bool\nlibxlDomainMigrationIsAllowed(virDomainDefPtr def)\n{\n    /* Migration is not allowed if definition contains any hostdevs */\n    if (def->nhostdevs > 0) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"domain has assigned host devices\"));\n        return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainDefCheckABIStability",
          "args": [
            "driver",
            "vm->def",
            "tmpdef"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainDefCheckABIStability",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "1542-1563",
          "snippet": "bool\nlibxlDomainDefCheckABIStability(libxlDriverPrivatePtr driver,\n                                virDomainDefPtr src,\n                                virDomainDefPtr dst)\n{\n    virDomainDefPtr migratableDefSrc = NULL;\n    virDomainDefPtr migratableDefDst = NULL;\n    bool ret = false;\n\n    if (!(migratableDefSrc = virDomainDefCopy(src, driver->xmlopt, NULL, true)) ||\n        !(migratableDefDst = virDomainDefCopy(dst, driver->xmlopt, NULL, true)))\n        goto cleanup;\n\n    ret = virDomainDefCheckABIStability(migratableDefSrc,\n                                        migratableDefDst,\n                                        driver->xmlopt);\n\n cleanup:\n    virDomainDefFree(migratableDefSrc);\n    virDomainDefFree(migratableDefDst);\n    return ret;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nbool\nlibxlDomainDefCheckABIStability(libxlDriverPrivatePtr driver,\n                                virDomainDefPtr src,\n                                virDomainDefPtr dst)\n{\n    virDomainDefPtr migratableDefSrc = NULL;\n    virDomainDefPtr migratableDefDst = NULL;\n    bool ret = false;\n\n    if (!(migratableDefSrc = virDomainDefCopy(src, driver->xmlopt, NULL, true)) ||\n        !(migratableDefDst = virDomainDefCopy(dst, driver->xmlopt, NULL, true)))\n        goto cleanup;\n\n    ret = virDomainDefCheckABIStability(migratableDefSrc,\n                                        migratableDefDst,\n                                        driver->xmlopt);\n\n cleanup:\n    virDomainDefFree(migratableDefSrc);\n    virDomainDefFree(migratableDefDst);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefParseString",
          "args": [
            "xmlin",
            "driver->xmlopt",
            "NULL",
            "VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                               VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "22134-22141",
          "snippet": "virDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMigrationBakeCookie",
          "args": [
            "mig",
            "cookieout",
            "cookieoutlen"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMigrationBakeCookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "115-144",
          "snippet": "static int\nlibxlMigrationBakeCookie(libxlMigrationCookiePtr mig,\n                         char **cookieout,\n                         int *cookieoutlen)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (!cookieout || !cookieoutlen)\n        return 0;\n\n    *cookieoutlen = 0;\n    virUUIDFormat(mig->uuid, uuidstr);\n\n    virBufferAddLit(&buf, \"<libxl-migration>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", mig->name);\n    virBufferAsprintf(&buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n    virBufferEscapeString(&buf, \"<hostname>%s</hostname>\\n\", mig->srcHostname);\n    virBufferAsprintf(&buf, \"<migration-stream-version>%u</migration-stream-version>\\n\", mig->xenMigStreamVer);\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</libxl-migration>\\n\");\n\n    *cookieout = virBufferContentAndReset(&buf);\n    *cookieoutlen = strlen(*cookieout) + 1;\n\n    VIR_DEBUG(\"cookielen=%d cookie=%s\", *cookieoutlen, *cookieout);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nlibxlMigrationBakeCookie(libxlMigrationCookiePtr mig,\n                         char **cookieout,\n                         int *cookieoutlen)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (!cookieout || !cookieoutlen)\n        return 0;\n\n    *cookieoutlen = 0;\n    virUUIDFormat(mig->uuid, uuidstr);\n\n    virBufferAddLit(&buf, \"<libxl-migration>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", mig->name);\n    virBufferAsprintf(&buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n    virBufferEscapeString(&buf, \"<hostname>%s</hostname>\\n\", mig->srcHostname);\n    virBufferAsprintf(&buf, \"<migration-stream-version>%u</migration-stream-version>\\n\", mig->xenMigStreamVer);\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</libxl-migration>\\n\");\n\n    *cookieout = virBufferContentAndReset(&buf);\n    *cookieoutlen = strlen(*cookieout) + 1;\n\n    VIR_DEBUG(\"cookielen=%d cookie=%s\", *cookieoutlen, *cookieout);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMigrationCookieNew",
          "args": [
            "vm"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMigrationCookieNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "90-112",
          "snippet": "static libxlMigrationCookiePtr\nlibxlMigrationCookieNew(virDomainObjPtr dom)\n{\n    libxlMigrationCookiePtr mig = NULL;\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    mig->name = g_strdup(dom->def->name);\n\n    memcpy(mig->uuid, dom->def->uuid, VIR_UUID_BUFLEN);\n\n    if (!(mig->srcHostname = virGetHostname()))\n        goto error;\n\n    mig->xenMigStreamVer = LIBXL_SAVE_VERSION;\n\n    return mig;\n\n error:\n    libxlMigrationCookieFree(mig);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic libxlMigrationCookiePtr\nlibxlMigrationCookieNew(virDomainObjPtr dom)\n{\n    libxlMigrationCookiePtr mig = NULL;\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    mig->name = g_strdup(dom->def->name);\n\n    memcpy(mig->uuid, dom->def->uuid, VIR_UUID_BUFLEN);\n\n    if (!(mig->srcHostname = virGetHostname()))\n        goto error;\n\n    mig->xenMigStreamVer = LIBXL_SAVE_VERSION;\n\n    return mig;\n\n error:\n    libxlMigrationCookieFree(mig);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainObjBeginJob",
          "args": [
            "driver",
            "vm",
            "LIBXL_JOB_MODIFY"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainObjBeginJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "109-155",
          "snippet": "int\nlibxlDomainObjBeginJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                       virDomainObjPtr obj,\n                       enum libxlDomainJob job)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    unsigned long long now;\n    unsigned long long then;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n    then = now + LIBXL_JOB_WAIT_TIME;\n\n    while (priv->job.active) {\n        VIR_DEBUG(\"Wait normal job condition for starting job: %s\",\n                  libxlDomainJobTypeToString(job));\n        if (virCondWaitUntil(&priv->job.cond, &obj->parent.lock, then) < 0)\n            goto error;\n    }\n\n    libxlDomainObjResetJob(priv);\n\n    VIR_DEBUG(\"Starting job: %s\", libxlDomainJobTypeToString(job));\n    priv->job.active = job;\n    priv->job.owner = virThreadSelfID();\n    priv->job.started = now;\n    priv->job.current->type = VIR_DOMAIN_JOB_UNBOUNDED;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Cannot start job (%s) for domain %s;\"\n             \" current job is (%s) owned by (%d)\",\n             libxlDomainJobTypeToString(job),\n             obj->def->name,\n             libxlDomainJobTypeToString(priv->job.active),\n             priv->job.owner);\n\n    if (errno == ETIMEDOUT)\n        virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                       \"%s\", _(\"cannot acquire state change lock\"));\n    else\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot acquire job mutex\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBXL_JOB_WAIT_TIME (1000ull * 30)"
          ],
          "globals_used": [
            "static void\nlibxlDomainObjPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\n#define LIBXL_JOB_WAIT_TIME (1000ull * 30)\n\nstatic void\nlibxlDomainObjPrivateDispose(void *obj);\n\nint\nlibxlDomainObjBeginJob(libxlDriverPrivatePtr driver G_GNUC_UNUSED,\n                       virDomainObjPtr obj,\n                       enum libxlDomainJob job)\n{\n    libxlDomainObjPrivatePtr priv = obj->privateData;\n    unsigned long long now;\n    unsigned long long then;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n    then = now + LIBXL_JOB_WAIT_TIME;\n\n    while (priv->job.active) {\n        VIR_DEBUG(\"Wait normal job condition for starting job: %s\",\n                  libxlDomainJobTypeToString(job));\n        if (virCondWaitUntil(&priv->job.cond, &obj->parent.lock, then) < 0)\n            goto error;\n    }\n\n    libxlDomainObjResetJob(priv);\n\n    VIR_DEBUG(\"Starting job: %s\", libxlDomainJobTypeToString(job));\n    priv->job.active = job;\n    priv->job.owner = virThreadSelfID();\n    priv->job.started = now;\n    priv->job.current->type = VIR_DOMAIN_JOB_UNBOUNDED;\n\n    return 0;\n\n error:\n    VIR_WARN(\"Cannot start job (%s) for domain %s;\"\n             \" current job is (%s) owned by (%d)\",\n             libxlDomainJobTypeToString(job),\n             obj->def->name,\n             libxlDomainJobTypeToString(priv->job.active),\n             priv->job.owner);\n\n    if (errno == ETIMEDOUT)\n        virReportError(VIR_ERR_OPERATION_TIMEOUT,\n                       \"%s\", _(\"cannot acquire state change lock\"));\n    else\n        virReportSystemError(errno,\n                             \"%s\", _(\"cannot acquire job mutex\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nlibxlDomainMigrationSrcBegin(virConnectPtr conn,\n                             virDomainObjPtr vm,\n                             const char *xmlin,\n                             char **cookieout,\n                             int *cookieoutlen)\n{\n    libxlDriverPrivatePtr driver = conn->privateData;\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    libxlMigrationCookiePtr mig = NULL;\n    virDomainDefPtr tmpdef = NULL;\n    virDomainDefPtr def;\n    char *xml = NULL;\n\n    /*\n     * In the case of successful migration, a job is started here and\n     * terminated in the confirm phase. Errors in the begin or perform\n     * phase will also terminate the job.\n     */\n    if (libxlDomainObjBeginJob(driver, vm, LIBXL_JOB_MODIFY) < 0)\n        goto cleanup;\n\n    if (!(mig = libxlMigrationCookieNew(vm)))\n        goto endjob;\n\n    if (libxlMigrationBakeCookie(mig, cookieout, cookieoutlen) < 0)\n        goto endjob;\n\n    if (xmlin) {\n        if (!(tmpdef = virDomainDefParseString(xmlin,\n                                               driver->xmlopt,\n                                               NULL,\n                                               VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                               VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n            goto endjob;\n\n        if (!libxlDomainDefCheckABIStability(driver, vm->def, tmpdef))\n            goto endjob;\n\n        def = tmpdef;\n    } else {\n        def = vm->def;\n    }\n\n    if (!libxlDomainMigrationIsAllowed(def))\n        goto endjob;\n\n    xml = virDomainDefFormat(def, driver->xmlopt, VIR_DOMAIN_DEF_FORMAT_SECURE);\n    /* Valid xml means success! EndJob in the confirm phase */\n    if (xml)\n        goto cleanup;\n\n endjob:\n    libxlDomainObjEndJob(driver, vm);\n\n cleanup:\n    libxlMigrationCookieFree(mig);\n    virDomainDefFree(tmpdef);\n    virObjectUnref(cfg);\n    return xml;\n}"
  },
  {
    "function_name": "libxlDomainMigrationIsAllowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "370-381",
    "snippet": "static bool\nlibxlDomainMigrationIsAllowed(virDomainDefPtr def)\n{\n    /* Migration is not allowed if definition contains any hostdevs */\n    if (def->nhostdevs > 0) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"domain has assigned host devices\"));\n        return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"domain has assigned host devices\")"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"domain has assigned host devices\""
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic bool\nlibxlDomainMigrationIsAllowed(virDomainDefPtr def)\n{\n    /* Migration is not allowed if definition contains any hostdevs */\n    if (def->nhostdevs > 0) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"domain has assigned host devices\"));\n        return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "libxlDoMigrateSrcSend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "345-368",
    "snippet": "static int\nlibxlDoMigrateSrcSend(libxlDriverPrivatePtr driver,\n                      virDomainObjPtr vm,\n                      unsigned long flags,\n                      int sockfd)\n{\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    int xl_flags = 0;\n    int ret;\n\n    if (flags & VIR_MIGRATE_LIVE)\n        xl_flags = LIBXL_SUSPEND_LIVE;\n\n    ret = libxl_domain_suspend(cfg->ctx, vm->def->id, sockfd,\n                               xl_flags, NULL);\n    if (ret != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to send migration data to destination host\"));\n        ret = -1;\n    }\n\n    virObjectUnref(cfg);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to send migration data to destination host\")"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to send migration data to destination host\""
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_domain_suspend",
          "args": [
            "cfg->ctx",
            "vm->def->id",
            "sockfd",
            "xl_flags",
            "NULL"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlDriverConfigGet",
          "args": [
            "driver"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDriverConfigGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_conf.c",
          "lines": "1783-1792",
          "snippet": "libxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"xen_xl.h\"",
            "#include \"xen_common.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"libxl_utils.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virconf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <sys/types.h>",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"xen_xl.h\"\n#include \"xen_common.h\"\n#include \"cpu/cpu.h\"\n#include \"virsecret.h\"\n#include \"virstoragefile.h\"\n#include \"libxl_utils.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_domain.h\"\n#include \"virsocketaddr.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virconf.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <sys/types.h>\n#include <libxl.h>\n#include <config.h>\n\nlibxlDriverConfigPtr\nlibxlDriverConfigGet(libxlDriverPrivatePtr driver)\n{\n    libxlDriverConfigPtr cfg;\n\n    libxlDriverLock(driver);\n    cfg = virObjectRef(driver->config);\n    libxlDriverUnlock(driver);\n    return cfg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nlibxlDoMigrateSrcSend(libxlDriverPrivatePtr driver,\n                      virDomainObjPtr vm,\n                      unsigned long flags,\n                      int sockfd)\n{\n    libxlDriverConfigPtr cfg = libxlDriverConfigGet(driver);\n    int xl_flags = 0;\n    int ret;\n\n    if (flags & VIR_MIGRATE_LIVE)\n        xl_flags = LIBXL_SUSPEND_LIVE;\n\n    ret = libxl_domain_suspend(cfg->ctx, vm->def->id, sockfd,\n                               xl_flags, NULL);\n    if (ret != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to send migration data to destination host\"));\n        ret = -1;\n    }\n\n    virObjectUnref(cfg);\n    return ret;\n}"
  },
  {
    "function_name": "libxlMigrateDstReceive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "285-343",
    "snippet": "static void\nlibxlMigrateDstReceive(virNetSocketPtr sock,\n                       int events G_GNUC_UNUSED,\n                       void *opaque)\n{\n    libxlMigrationDstArgs *args = opaque;\n    virNetSocketPtr *socks = args->socks;\n    size_t nsocks = args->nsocks;\n    libxlDomainObjPrivatePtr priv = args->vm->privateData;\n    virNetSocketPtr client_sock;\n    int recvfd = -1;\n    size_t i;\n    g_autofree char *name = NULL;\n\n    /* Accept migration connection */\n    if (virNetSocketAccept(sock, &client_sock) < 0 || !client_sock) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to accept migration connection\"));\n        goto fail;\n    }\n    VIR_DEBUG(\"Accepted migration connection.\"\n              \"  Spawning thread to process migration data\");\n    recvfd = virNetSocketDupFD(client_sock, true);\n    virObjectUnref(client_sock);\n\n    /*\n     * Avoid blocking the event loop.  Start a thread to receive\n     * the migration data\n     */\n    args->recvfd = recvfd;\n    VIR_FREE(priv->migrationDstReceiveThr);\n    if (VIR_ALLOC(priv->migrationDstReceiveThr) < 0)\n        goto fail;\n\n    name = g_strdup_printf(\"mig-%s\", args->vm->def->name);\n    if (virThreadCreateFull(priv->migrationDstReceiveThr, true,\n                            libxlDoMigrateDstReceive,\n                            name,\n                            false,\n                            args) < 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to create thread for receiving migration data\"));\n        goto fail;\n    }\n\n    return;\n\n fail:\n    /* Remove all listen socks from event handler, and close them. */\n    for (i = 0; i < nsocks; i++) {\n        virNetSocketUpdateIOCallback(socks[i], 0);\n        virNetSocketRemoveIOCallback(socks[i]);\n        virNetSocketClose(socks[i]);\n        socks[i] = NULL;\n    }\n    args->nsocks = 0;\n    VIR_FORCE_CLOSE(recvfd);\n    virObjectUnref(args);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "args"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "recvfd"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketClose",
          "args": [
            "socks[i]"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2254-2277",
          "snippet": "void virNetSocketClose(virNetSocketPtr sock)\n{\n    if (!sock)\n        return;\n\n    virObjectLock(sock);\n\n    if (sock->fd != -1) {\n        closesocket(sock->fd);\n        sock->fd = -1;\n    }\n\n#ifndef WIN32\n    /* If a server socket, then unlink UNIX path */\n    if (sock->unlinkUNIX &&\n        sock->localAddr.data.sa.sa_family == AF_UNIX &&\n        sock->localAddr.data.un.sun_path[0] != '\\0') {\n        if (unlink(sock->localAddr.data.un.sun_path) == 0)\n            sock->localAddr.data.un.sun_path[0] = '\\0';\n    }\n#endif\n\n    virObjectUnlock(sock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketClose(virNetSocketPtr sock)\n{\n    if (!sock)\n        return;\n\n    virObjectLock(sock);\n\n    if (sock->fd != -1) {\n        closesocket(sock->fd);\n        sock->fd = -1;\n    }\n\n#ifndef WIN32\n    /* If a server socket, then unlink UNIX path */\n    if (sock->unlinkUNIX &&\n        sock->localAddr.data.sa.sa_family == AF_UNIX &&\n        sock->localAddr.data.un.sun_path[0] != '\\0') {\n        if (unlink(sock->localAddr.data.un.sun_path) == 0)\n            sock->localAddr.data.un.sun_path[0] = '\\0';\n    }\n#endif\n\n    virObjectUnlock(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketRemoveIOCallback",
          "args": [
            "socks[i]"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketRemoveIOCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2237-2252",
          "snippet": "void virNetSocketRemoveIOCallback(virNetSocketPtr sock)\n{\n    virObjectLock(sock);\n\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventRemoveHandle(sock->watch);\n    /* Don't unref @sock, it's done via eventloop callback. */\n    sock->watch = -1;\n\n    virObjectUnlock(sock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketRemoveIOCallback(virNetSocketPtr sock)\n{\n    virObjectLock(sock);\n\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventRemoveHandle(sock->watch);\n    /* Don't unref @sock, it's done via eventloop callback. */\n    sock->watch = -1;\n\n    virObjectUnlock(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketUpdateIOCallback",
          "args": [
            "socks[i]",
            "0"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketUpdateIOCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2222-2235",
          "snippet": "void virNetSocketUpdateIOCallback(virNetSocketPtr sock,\n                                  int events)\n{\n    virObjectLock(sock);\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventUpdateHandle(sock->watch, events);\n\n    virObjectUnlock(sock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketUpdateIOCallback(virNetSocketPtr sock,\n                                  int events)\n{\n    virObjectLock(sock);\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventUpdateHandle(sock->watch, events);\n\n    virObjectUnlock(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Failed to create thread for receiving migration data\")"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to create thread for receiving migration data\""
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadCreateFull",
          "args": [
            "priv->migrationDstReceiveThr",
            "true",
            "libxlDoMigrateDstReceive",
            "name",
            "false",
            "args"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "242-283",
          "snippet": "int virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"mig-%s\"",
            "args->vm->def->name"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "priv->migrationDstReceiveThr"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->migrationDstReceiveThr"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketDupFD",
          "args": [
            "client_sock",
            "true"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketDupFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1386-1412",
          "snippet": "int virNetSocketDupFD(virNetSocketPtr sock, bool cloexec)\n{\n    int fd;\n\n#ifdef F_DUPFD_CLOEXEC\n    if (cloexec)\n        fd = fcntl(sock->fd, F_DUPFD_CLOEXEC, 0);\n    else\n#endif /* F_DUPFD_CLOEXEC */\n        fd = dup(sock->fd);\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to copy socket file handle\"));\n        return -1;\n    }\n#ifndef F_DUPFD_CLOEXEC\n    if (cloexec &&\n        virSetCloseExec(fd < 0)) {\n        int saveerr = errno;\n        closesocket(fd);\n        errno = saveerr;\n        return -1;\n    }\n#endif /* F_DUPFD_CLOEXEC */\n\n    return fd;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketDupFD(virNetSocketPtr sock, bool cloexec)\n{\n    int fd;\n\n#ifdef F_DUPFD_CLOEXEC\n    if (cloexec)\n        fd = fcntl(sock->fd, F_DUPFD_CLOEXEC, 0);\n    else\n#endif /* F_DUPFD_CLOEXEC */\n        fd = dup(sock->fd);\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to copy socket file handle\"));\n        return -1;\n    }\n#ifndef F_DUPFD_CLOEXEC\n    if (cloexec &&\n        virSetCloseExec(fd < 0)) {\n        int saveerr = errno;\n        closesocket(fd);\n        errno = saveerr;\n        return -1;\n    }\n#endif /* F_DUPFD_CLOEXEC */\n\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Accepted migration connection.\"\n              \"  Spawning thread to process migration data\""
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Failed to accept migration connection\")"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketAccept",
          "args": [
            "sock",
            "&client_sock"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketAccept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2096-2144",
          "snippet": "int virNetSocketAccept(virNetSocketPtr sock, virNetSocketPtr *clientsock)\n{\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    int ret = -1;\n\n    virObjectLock(sock);\n\n    *clientsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    remoteAddr.len = sizeof(remoteAddr.data.stor);\n    if ((fd = accept(sock->fd, &remoteAddr.data.sa, &remoteAddr.len)) < 0) {\n        if (errno == ECONNABORTED ||\n            errno == EAGAIN) {\n            ret = 0;\n            goto cleanup;\n        }\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to accept client\"));\n        goto cleanup;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto cleanup;\n    }\n\n    if (!(*clientsock = virNetSocketNew(&localAddr,\n                                        &remoteAddr,\n                                        true,\n                                        fd, -1, 0,\n                                        false)))\n        goto cleanup;\n\n    fd = -1;\n    ret = 0;\n\n cleanup:\n    if (fd != -1)\n        closesocket(fd);\n    virObjectUnlock(sock);\n    return ret;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketAccept(virNetSocketPtr sock, virNetSocketPtr *clientsock)\n{\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    int ret = -1;\n\n    virObjectLock(sock);\n\n    *clientsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    remoteAddr.len = sizeof(remoteAddr.data.stor);\n    if ((fd = accept(sock->fd, &remoteAddr.data.sa, &remoteAddr.len)) < 0) {\n        if (errno == ECONNABORTED ||\n            errno == EAGAIN) {\n            ret = 0;\n            goto cleanup;\n        }\n\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to accept client\"));\n        goto cleanup;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto cleanup;\n    }\n\n    if (!(*clientsock = virNetSocketNew(&localAddr,\n                                        &remoteAddr,\n                                        true,\n                                        fd, -1, 0,\n                                        false)))\n        goto cleanup;\n\n    fd = -1;\n    ret = 0;\n\n cleanup:\n    if (fd != -1)\n        closesocket(fd);\n    virObjectUnlock(sock);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nlibxlMigrateDstReceive(virNetSocketPtr sock,\n                       int events G_GNUC_UNUSED,\n                       void *opaque)\n{\n    libxlMigrationDstArgs *args = opaque;\n    virNetSocketPtr *socks = args->socks;\n    size_t nsocks = args->nsocks;\n    libxlDomainObjPrivatePtr priv = args->vm->privateData;\n    virNetSocketPtr client_sock;\n    int recvfd = -1;\n    size_t i;\n    g_autofree char *name = NULL;\n\n    /* Accept migration connection */\n    if (virNetSocketAccept(sock, &client_sock) < 0 || !client_sock) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to accept migration connection\"));\n        goto fail;\n    }\n    VIR_DEBUG(\"Accepted migration connection.\"\n              \"  Spawning thread to process migration data\");\n    recvfd = virNetSocketDupFD(client_sock, true);\n    virObjectUnref(client_sock);\n\n    /*\n     * Avoid blocking the event loop.  Start a thread to receive\n     * the migration data\n     */\n    args->recvfd = recvfd;\n    VIR_FREE(priv->migrationDstReceiveThr);\n    if (VIR_ALLOC(priv->migrationDstReceiveThr) < 0)\n        goto fail;\n\n    name = g_strdup_printf(\"mig-%s\", args->vm->def->name);\n    if (virThreadCreateFull(priv->migrationDstReceiveThr, true,\n                            libxlDoMigrateDstReceive,\n                            name,\n                            false,\n                            args) < 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Failed to create thread for receiving migration data\"));\n        goto fail;\n    }\n\n    return;\n\n fail:\n    /* Remove all listen socks from event handler, and close them. */\n    for (i = 0; i < nsocks; i++) {\n        virNetSocketUpdateIOCallback(socks[i], 0);\n        virNetSocketRemoveIOCallback(socks[i]);\n        virNetSocketClose(socks[i]);\n        socks[i] = NULL;\n    }\n    args->nsocks = 0;\n    VIR_FORCE_CLOSE(recvfd);\n    virObjectUnref(args);\n}"
  },
  {
    "function_name": "libxlDoMigrateDstReceive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "250-282",
    "snippet": "static void\nlibxlDoMigrateDstReceive(void *opaque)\n{\n    libxlMigrationDstArgs *args = opaque;\n    virDomainObjPtr vm = args->vm;\n    virNetSocketPtr *socks = args->socks;\n    size_t nsocks = args->nsocks;\n    libxlDriverPrivatePtr driver = args->conn->privateData;\n    int recvfd = args->recvfd;\n    size_t i;\n\n    virObjectRef(vm);\n\n    /*\n     * Always start the domain paused.  If needed, unpause in the\n     * finish phase, after transfer of the domain is complete.\n     * Errors and cleanup are also handled in the finish phase.\n     */\n    libxlDomainStartRestore(driver, vm, true, recvfd,\n                            args->migcookie->xenMigStreamVer);\n\n    /* Remove all listen socks from event handler, and close them. */\n    for (i = 0; i < nsocks; i++) {\n        virNetSocketRemoveIOCallback(socks[i]);\n        virNetSocketClose(socks[i]);\n        virObjectUnref(socks[i]);\n        socks[i] = NULL;\n    }\n    args->nsocks = 0;\n    VIR_FORCE_CLOSE(recvfd);\n    virObjectUnref(args);\n    virDomainObjEndAPI(&vm);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "args"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "recvfd"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetSocketClose",
          "args": [
            "socks[i]"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2254-2277",
          "snippet": "void virNetSocketClose(virNetSocketPtr sock)\n{\n    if (!sock)\n        return;\n\n    virObjectLock(sock);\n\n    if (sock->fd != -1) {\n        closesocket(sock->fd);\n        sock->fd = -1;\n    }\n\n#ifndef WIN32\n    /* If a server socket, then unlink UNIX path */\n    if (sock->unlinkUNIX &&\n        sock->localAddr.data.sa.sa_family == AF_UNIX &&\n        sock->localAddr.data.un.sun_path[0] != '\\0') {\n        if (unlink(sock->localAddr.data.un.sun_path) == 0)\n            sock->localAddr.data.un.sun_path[0] = '\\0';\n    }\n#endif\n\n    virObjectUnlock(sock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketClose(virNetSocketPtr sock)\n{\n    if (!sock)\n        return;\n\n    virObjectLock(sock);\n\n    if (sock->fd != -1) {\n        closesocket(sock->fd);\n        sock->fd = -1;\n    }\n\n#ifndef WIN32\n    /* If a server socket, then unlink UNIX path */\n    if (sock->unlinkUNIX &&\n        sock->localAddr.data.sa.sa_family == AF_UNIX &&\n        sock->localAddr.data.un.sun_path[0] != '\\0') {\n        if (unlink(sock->localAddr.data.un.sun_path) == 0)\n            sock->localAddr.data.un.sun_path[0] = '\\0';\n    }\n#endif\n\n    virObjectUnlock(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketRemoveIOCallback",
          "args": [
            "socks[i]"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketRemoveIOCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "2237-2252",
          "snippet": "void virNetSocketRemoveIOCallback(virNetSocketPtr sock)\n{\n    virObjectLock(sock);\n\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventRemoveHandle(sock->watch);\n    /* Don't unref @sock, it's done via eventloop callback. */\n    sock->watch = -1;\n\n    virObjectUnlock(sock);\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid virNetSocketRemoveIOCallback(virNetSocketPtr sock)\n{\n    virObjectLock(sock);\n\n    if (sock->watch < 0) {\n        VIR_DEBUG(\"Watch not registered on socket %p\", sock);\n        virObjectUnlock(sock);\n        return;\n    }\n\n    virEventRemoveHandle(sock->watch);\n    /* Don't unref @sock, it's done via eventloop callback. */\n    sock->watch = -1;\n\n    virObjectUnlock(sock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlDomainStartRestore",
          "args": [
            "driver",
            "vm",
            "true",
            "recvfd",
            "args->migcookie->xenMigStreamVer"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "libxlDomainStartRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_domain.c",
          "lines": "1531-1540",
          "snippet": "int\nlibxlDomainStartRestore(libxlDriverPrivatePtr driver,\n                        virDomainObjPtr vm,\n                        bool start_paused,\n                        int restore_fd,\n                        uint32_t restore_ver)\n{\n    return libxlDomainStart(driver, vm, start_paused,\n                            restore_fd, restore_ver);\n}",
          "includes": [
            "#include \"driver.h\"",
            "#include \"xen_common.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"libxl_domain.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"driver.h\"\n#include \"xen_common.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"libxl_capabilities.h\"\n#include \"libxl_domain.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nlibxlDomainStartRestore(libxlDriverPrivatePtr driver,\n                        virDomainObjPtr vm,\n                        bool start_paused,\n                        int restore_fd,\n                        uint32_t restore_ver)\n{\n    return libxlDomainStart(driver, vm, start_paused,\n                            restore_fd, restore_ver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "vm"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nlibxlDoMigrateDstReceive(void *opaque)\n{\n    libxlMigrationDstArgs *args = opaque;\n    virDomainObjPtr vm = args->vm;\n    virNetSocketPtr *socks = args->socks;\n    size_t nsocks = args->nsocks;\n    libxlDriverPrivatePtr driver = args->conn->privateData;\n    int recvfd = args->recvfd;\n    size_t i;\n\n    virObjectRef(vm);\n\n    /*\n     * Always start the domain paused.  If needed, unpause in the\n     * finish phase, after transfer of the domain is complete.\n     * Errors and cleanup are also handled in the finish phase.\n     */\n    libxlDomainStartRestore(driver, vm, true, recvfd,\n                            args->migcookie->xenMigStreamVer);\n\n    /* Remove all listen socks from event handler, and close them. */\n    for (i = 0; i < nsocks; i++) {\n        virNetSocketRemoveIOCallback(socks[i]);\n        virNetSocketClose(socks[i]);\n        virObjectUnref(socks[i]);\n        socks[i] = NULL;\n    }\n    args->nsocks = 0;\n    VIR_FORCE_CLOSE(recvfd);\n    virObjectUnref(args);\n    virDomainObjEndAPI(&vm);\n}"
  },
  {
    "function_name": "libxlMigrationDstArgsOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "239-246",
    "snippet": "static int\nlibxlMigrationDstArgsOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(libxlMigrationDstArgs, virClassForObject()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "libxlMigrationDstArgs",
            "virClassForObject()"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObject",
          "args": [],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectRWLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "131-138",
          "snippet": "virClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectRWLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectRWLockableClass;\n\nvirClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nlibxlMigrationDstArgsOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(libxlMigrationDstArgs, virClassForObject()))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlMigrationDstArgsDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "228-237",
    "snippet": "static void\nlibxlMigrationDstArgsDispose(void *obj)\n{\n    libxlMigrationDstArgs *args = obj;\n\n    libxlMigrationCookieFree(args->migcookie);\n    VIR_FREE(args->socks);\n    virObjectUnref(args->conn);\n    virObjectUnref(args->vm);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "args->vm"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "args->socks"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlMigrationCookieFree",
          "args": [
            "args->migcookie"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMigrationCookieFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "79-88",
          "snippet": "static void\nlibxlMigrationCookieFree(libxlMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    VIR_FREE(mig->srcHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nlibxlMigrationCookieFree(libxlMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    VIR_FREE(mig->srcHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nlibxlMigrationDstArgsDispose(void *obj)\n{\n    libxlMigrationDstArgs *args = obj;\n\n    libxlMigrationCookieFree(args->migcookie);\n    VIR_FREE(args->socks);\n    virObjectUnref(args->conn);\n    virObjectUnref(args->vm);\n}"
  },
  {
    "function_name": "libxlMigrationEatCookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "146-226",
    "snippet": "static int\nlibxlMigrationEatCookie(const char *cookiein,\n                        int cookieinlen,\n                        libxlMigrationCookiePtr *migout)\n{\n    libxlMigrationCookiePtr mig = NULL;\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    char *uuidstr = NULL;\n    int ret = -1;\n\n    /*\n     * Assume a legacy (V1) migration stream if request came from a\n     * source host without cookie support, and hence no way to\n     * specify a stream version.\n     */\n    if (!cookiein || !cookieinlen) {\n        if (VIR_ALLOC(mig) < 0)\n            return -1;\n\n        mig->xenMigStreamVer = 1;\n        *migout = mig;\n        return 0;\n    }\n\n    if (cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (VIR_ALLOC(mig) < 0)\n        return -1;\n\n    if (!(doc = virXMLParseStringCtxt(cookiein,\n                                      _(\"(libxl_migration_cookie)\"),\n                                      &ctxt)))\n        goto error;\n\n    /* Extract domain name */\n    if (!(mig->name = virXPathString(\"string(./name[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing name element in migration data\"));\n        goto error;\n    }\n\n    /* Extract domain uuid */\n    uuidstr = virXPathString(\"string(./uuid[1])\", ctxt);\n    if (!uuidstr) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing uuid element in migration data\"));\n        goto error;\n    }\n    if (virUUIDParse(uuidstr, mig->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed uuid element\"));\n        goto error;\n    }\n\n    if (virXPathUInt(\"string(./migration-stream-version[1])\",\n                     ctxt, &mig->xenMigStreamVer) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing Xen migration stream version\"));\n        goto error;\n    }\n\n    *migout = mig;\n    ret = 0;\n    goto cleanup;\n\n error:\n    libxlMigrationCookieFree(mig);\n\n cleanup:\n    VIR_FREE(uuidstr);\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlFreeDoc",
          "args": [
            "doc"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlXPathFreeContext",
          "args": [
            "ctxt"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuidstr"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlMigrationCookieFree",
          "args": [
            "mig"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMigrationCookieFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "79-88",
          "snippet": "static void\nlibxlMigrationCookieFree(libxlMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    VIR_FREE(mig->srcHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nlibxlMigrationCookieFree(libxlMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    VIR_FREE(mig->srcHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing Xen migration stream version\")"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing Xen migration stream version\""
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathUInt",
          "args": [
            "\"string(./migration-stream-version[1])\"",
            "ctxt",
            "&mig->xenMigStreamVer"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathUInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "328-343",
          "snippet": "int\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathUInt(const char *xpath,\n             xmlXPathContextPtr ctxt,\n             unsigned int *value)\n{\n    unsigned long tmp;\n    int ret;\n\n    ret = virXPathULongBase(xpath, ctxt, 10, &tmp);\n    if (ret < 0)\n        return ret;\n    if ((unsigned int) tmp != tmp)\n        return -2;\n    *value = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed uuid element\")"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "uuidstr",
            "mig->uuid"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing uuid element in migration data\")"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./uuid[1])\"",
            "ctxt"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"missing name element in migration data\")"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLParseStringCtxt",
          "args": [
            "cookiein",
            "_(\"(libxl_migration_cookie)\")",
            "&ctxt"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "mig"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cookielen=%d cookie='%s'\"",
            "cookieinlen",
            "NULLSTR(cookiein)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cookiein"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Migration cookie was not NULL terminated\")"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "mig"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nlibxlMigrationEatCookie(const char *cookiein,\n                        int cookieinlen,\n                        libxlMigrationCookiePtr *migout)\n{\n    libxlMigrationCookiePtr mig = NULL;\n    xmlDocPtr doc = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    char *uuidstr = NULL;\n    int ret = -1;\n\n    /*\n     * Assume a legacy (V1) migration stream if request came from a\n     * source host without cookie support, and hence no way to\n     * specify a stream version.\n     */\n    if (!cookiein || !cookieinlen) {\n        if (VIR_ALLOC(mig) < 0)\n            return -1;\n\n        mig->xenMigStreamVer = 1;\n        *migout = mig;\n        return 0;\n    }\n\n    if (cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        return -1;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (VIR_ALLOC(mig) < 0)\n        return -1;\n\n    if (!(doc = virXMLParseStringCtxt(cookiein,\n                                      _(\"(libxl_migration_cookie)\"),\n                                      &ctxt)))\n        goto error;\n\n    /* Extract domain name */\n    if (!(mig->name = virXPathString(\"string(./name[1])\", ctxt))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing name element in migration data\"));\n        goto error;\n    }\n\n    /* Extract domain uuid */\n    uuidstr = virXPathString(\"string(./uuid[1])\", ctxt);\n    if (!uuidstr) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"missing uuid element in migration data\"));\n        goto error;\n    }\n    if (virUUIDParse(uuidstr, mig->uuid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"malformed uuid element\"));\n        goto error;\n    }\n\n    if (virXPathUInt(\"string(./migration-stream-version[1])\",\n                     ctxt, &mig->xenMigStreamVer) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"missing Xen migration stream version\"));\n        goto error;\n    }\n\n    *migout = mig;\n    ret = 0;\n    goto cleanup;\n\n error:\n    libxlMigrationCookieFree(mig);\n\n cleanup:\n    VIR_FREE(uuidstr);\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(doc);\n    return ret;\n}"
  },
  {
    "function_name": "libxlMigrationBakeCookie",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "115-144",
    "snippet": "static int\nlibxlMigrationBakeCookie(libxlMigrationCookiePtr mig,\n                         char **cookieout,\n                         int *cookieoutlen)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (!cookieout || !cookieoutlen)\n        return 0;\n\n    *cookieoutlen = 0;\n    virUUIDFormat(mig->uuid, uuidstr);\n\n    virBufferAddLit(&buf, \"<libxl-migration>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", mig->name);\n    virBufferAsprintf(&buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n    virBufferEscapeString(&buf, \"<hostname>%s</hostname>\\n\", mig->srcHostname);\n    virBufferAsprintf(&buf, \"<migration-stream-version>%u</migration-stream-version>\\n\", mig->xenMigStreamVer);\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</libxl-migration>\\n\");\n\n    *cookieout = virBufferContentAndReset(&buf);\n    *cookieoutlen = strlen(*cookieout) + 1;\n\n    VIR_DEBUG(\"cookielen=%d cookie=%s\", *cookieoutlen, *cookieout);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"cookielen=%d cookie=%s\"",
            "*cookieoutlen",
            "*cookieout"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*cookieout"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"</libxl-migration>\\n\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "&buf",
            "-2"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"<migration-stream-version>%u</migration-stream-version>\\n\"",
            "mig->xenMigStreamVer"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "&buf",
            "\"<hostname>%s</hostname>\\n\"",
            "mig->srcHostname"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"<libxl-migration>\\n\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "mig->uuid",
            "uuidstr"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nlibxlMigrationBakeCookie(libxlMigrationCookiePtr mig,\n                         char **cookieout,\n                         int *cookieoutlen)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n    if (!cookieout || !cookieoutlen)\n        return 0;\n\n    *cookieoutlen = 0;\n    virUUIDFormat(mig->uuid, uuidstr);\n\n    virBufferAddLit(&buf, \"<libxl-migration>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", mig->name);\n    virBufferAsprintf(&buf, \"<uuid>%s</uuid>\\n\", uuidstr);\n    virBufferEscapeString(&buf, \"<hostname>%s</hostname>\\n\", mig->srcHostname);\n    virBufferAsprintf(&buf, \"<migration-stream-version>%u</migration-stream-version>\\n\", mig->xenMigStreamVer);\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</libxl-migration>\\n\");\n\n    *cookieout = virBufferContentAndReset(&buf);\n    *cookieoutlen = strlen(*cookieout) + 1;\n\n    VIR_DEBUG(\"cookielen=%d cookie=%s\", *cookieoutlen, *cookieout);\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlMigrationCookieNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "90-112",
    "snippet": "static libxlMigrationCookiePtr\nlibxlMigrationCookieNew(virDomainObjPtr dom)\n{\n    libxlMigrationCookiePtr mig = NULL;\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    mig->name = g_strdup(dom->def->name);\n\n    memcpy(mig->uuid, dom->def->uuid, VIR_UUID_BUFLEN);\n\n    if (!(mig->srcHostname = virGetHostname()))\n        goto error;\n\n    mig->xenMigStreamVer = LIBXL_SAVE_VERSION;\n\n    return mig;\n\n error:\n    libxlMigrationCookieFree(mig);\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxlMigrationCookieFree",
          "args": [
            "mig"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMigrationCookieFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
          "lines": "79-88",
          "snippet": "static void\nlibxlMigrationCookieFree(libxlMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    VIR_FREE(mig->srcHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"libxl_migration.h\"",
            "#include \"libxl_conf.h\"",
            "#include \"libxl_driver.h\"",
            "#include \"libxl_domain.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"virhook.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"datatypes.h\"",
            "#include \"virconf.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nlibxlMigrationCookieFree(libxlMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    VIR_FREE(mig->srcHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetHostname",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "virGetHostnameQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "560-564",
          "snippet": "char *\nvirGetHostnameQuiet(void)\n{\n    return virGetHostnameImpl(true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirGetHostnameQuiet(void)\n{\n    return virGetHostnameImpl(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "mig->uuid",
            "dom->def->uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "dom->def->name"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "mig"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic libxlMigrationCookiePtr\nlibxlMigrationCookieNew(virDomainObjPtr dom)\n{\n    libxlMigrationCookiePtr mig = NULL;\n\n    if (VIR_ALLOC(mig) < 0)\n        goto error;\n\n    mig->name = g_strdup(dom->def->name);\n\n    memcpy(mig->uuid, dom->def->uuid, VIR_UUID_BUFLEN);\n\n    if (!(mig->srcHostname = virGetHostname()))\n        goto error;\n\n    mig->xenMigStreamVer = LIBXL_SAVE_VERSION;\n\n    return mig;\n\n error:\n    libxlMigrationCookieFree(mig);\n    return NULL;\n}"
  },
  {
    "function_name": "libxlMigrationCookieFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_migration.c",
    "lines": "79-88",
    "snippet": "static void\nlibxlMigrationCookieFree(libxlMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    VIR_FREE(mig->srcHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"libxl_migration.h\"",
      "#include \"libxl_conf.h\"",
      "#include \"libxl_driver.h\"",
      "#include \"libxl_domain.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"virhook.h\"",
      "#include \"virthread.h\"",
      "#include \"virobject.h\"",
      "#include \"virstring.h\"",
      "#include \"vircommand.h\"",
      "#include \"viruuid.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"datatypes.h\"",
      "#include \"virconf.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mig"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mig->name"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mig->srcHostname"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"virtypedparam.h\"\n#include \"locking/domain_lock.h\"\n#include \"libxl_migration.h\"\n#include \"libxl_conf.h\"\n#include \"libxl_driver.h\"\n#include \"libxl_domain.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"virhook.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"datatypes.h\"\n#include \"virconf.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nlibxlMigrationCookieFree(libxlMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    VIR_FREE(mig->srcHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig);\n}"
  }
]