[
  {
    "function_name": "vboxGetHypervisorDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "7941-7953",
    "snippet": "virHypervisorDriverPtr vboxGetHypervisorDriver(uint32_t uVersion)\n{\n    /* Install gVBoxAPI according to the vbox API version. */\n    int result = 0;\n    installUniformedAPI(gVBoxAPI, result);\n    if (result < 0) {\n        VIR_WARN(\"Libvirt doesn't support VirtualBox API version %u\",\n                 uVersion);\n        return NULL;\n    }\n\n    return &vboxCommonDriver;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;",
      "static virHypervisorDriver vboxCommonDriver = {\n    .name = \"VBOX\",\n    .connectURIProbe = vboxConnectURIProbe,\n    .connectOpen = vboxConnectOpen, /* 0.6.3 */\n    .connectClose = vboxConnectClose, /* 0.6.3 */\n    .connectGetVersion = vboxConnectGetVersion, /* 0.6.3 */\n    .connectGetHostname = vboxConnectGetHostname, /* 0.6.3 */\n    .connectGetMaxVcpus = vboxConnectGetMaxVcpus, /* 0.6.3 */\n    .nodeGetInfo = vboxNodeGetInfo, /* 0.6.3 */\n    .connectGetCapabilities = vboxConnectGetCapabilities, /* 0.6.3 */\n    .connectListDomains = vboxConnectListDomains, /* 0.6.3 */\n    .connectNumOfDomains = vboxConnectNumOfDomains, /* 0.6.3 */\n    .connectListAllDomains = vboxConnectListAllDomains, /* 0.9.13 */\n    .domainCreateXML = vboxDomainCreateXML, /* 0.6.3 */\n    .domainLookupByID = vboxDomainLookupByID, /* 0.6.3 */\n    .domainLookupByUUID = vboxDomainLookupByUUID, /* 0.6.3 */\n    .domainLookupByName = vboxDomainLookupByName, /* 0.6.3 */\n    .domainSuspend = vboxDomainSuspend, /* 0.6.3 */\n    .domainResume = vboxDomainResume, /* 0.6.3 */\n    .domainShutdown = vboxDomainShutdown, /* 0.6.3 */\n    .domainShutdownFlags = vboxDomainShutdownFlags, /* 0.9.10 */\n    .domainReboot = vboxDomainReboot, /* 0.6.3 */\n    .domainDestroy = vboxDomainDestroy, /* 0.6.3 */\n    .domainDestroyFlags = vboxDomainDestroyFlags, /* 0.9.4 */\n    .domainGetOSType = vboxDomainGetOSType, /* 0.6.3 */\n    .domainSetMemory = vboxDomainSetMemory, /* 0.6.3 */\n    .domainGetInfo = vboxDomainGetInfo, /* 0.6.3 */\n    .domainGetState = vboxDomainGetState, /* 0.9.2 */\n    .domainSave = vboxDomainSave, /* 0.6.3 */\n    .domainSetVcpus = vboxDomainSetVcpus, /* 0.7.1 */\n    .domainSetVcpusFlags = vboxDomainSetVcpusFlags, /* 0.8.5 */\n    .domainGetVcpusFlags = vboxDomainGetVcpusFlags, /* 0.8.5 */\n    .domainGetMaxVcpus = vboxDomainGetMaxVcpus, /* 0.7.1 */\n    .domainGetXMLDesc = vboxDomainGetXMLDesc, /* 0.6.3 */\n    .connectListDefinedDomains = vboxConnectListDefinedDomains, /* 0.6.3 */\n    .connectNumOfDefinedDomains = vboxConnectNumOfDefinedDomains, /* 0.6.3 */\n    .domainCreate = vboxDomainCreate, /* 0.6.3 */\n    .domainCreateWithFlags = vboxDomainCreateWithFlags, /* 0.8.2 */\n    .domainDefineXML = vboxDomainDefineXML, /* 0.6.3 */\n    .domainDefineXMLFlags = vboxDomainDefineXMLFlags, /* 1.2.12 */\n    .domainUndefine = vboxDomainUndefine, /* 0.6.3 */\n    .domainUndefineFlags = vboxDomainUndefineFlags, /* 0.9.5 */\n    .domainAttachDevice = vboxDomainAttachDevice, /* 0.6.3 */\n    .domainAttachDeviceFlags = vboxDomainAttachDeviceFlags, /* 0.7.7 */\n    .domainDetachDevice = vboxDomainDetachDevice, /* 0.6.3 */\n    .domainDetachDeviceFlags = vboxDomainDetachDeviceFlags, /* 0.7.7 */\n    .domainUpdateDeviceFlags = vboxDomainUpdateDeviceFlags, /* 0.8.0 */\n    .nodeGetCellsFreeMemory = vboxNodeGetCellsFreeMemory, /* 0.6.5 */\n    .nodeGetFreeMemory = vboxNodeGetFreeMemory, /* 0.6.5 */\n    .connectIsEncrypted = vboxConnectIsEncrypted, /* 0.7.3 */\n    .connectIsSecure = vboxConnectIsSecure, /* 0.7.3 */\n    .domainIsActive = vboxDomainIsActive, /* 0.7.3 */\n    .domainIsPersistent = vboxDomainIsPersistent, /* 0.7.3 */\n    .domainIsUpdated = vboxDomainIsUpdated, /* 0.8.6 */\n    .domainSnapshotCreateXML = vboxDomainSnapshotCreateXML, /* 0.8.0 */\n    .domainSnapshotGetXMLDesc = vboxDomainSnapshotGetXMLDesc, /* 0.8.0 */\n    .domainSnapshotNum = vboxDomainSnapshotNum, /* 0.8.0 */\n    .domainSnapshotListNames = vboxDomainSnapshotListNames, /* 0.8.0 */\n    .domainSnapshotLookupByName = vboxDomainSnapshotLookupByName, /* 0.8.0 */\n    .domainHasCurrentSnapshot = vboxDomainHasCurrentSnapshot, /* 0.8.0 */\n    .domainSnapshotGetParent = vboxDomainSnapshotGetParent, /* 0.9.7 */\n    .domainSnapshotCurrent = vboxDomainSnapshotCurrent, /* 0.8.0 */\n    .domainSnapshotIsCurrent = vboxDomainSnapshotIsCurrent, /* 0.9.13 */\n    .domainSnapshotHasMetadata = vboxDomainSnapshotHasMetadata, /* 0.9.13 */\n    .domainRevertToSnapshot = vboxDomainRevertToSnapshot, /* 0.8.0 */\n    .domainSnapshotDelete = vboxDomainSnapshotDelete, /* 0.8.0 */\n    .connectIsAlive = vboxConnectIsAlive, /* 0.9.8 */\n    .nodeGetFreePages = vboxNodeGetFreePages, /* 1.2.6 */\n    .nodeAllocPages = vboxNodeAllocPages, /* 1.2.9 */\n    .domainHasManagedSaveImage = vboxDomainHasManagedSaveImage, /* 1.2.13 */\n    .domainSendKey = vboxDomainSendKey, /* 1.2.15 */\n    .domainScreenshot = vboxDomainScreenshot, /* 0.9.2 */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Libvirt doesn't support VirtualBox API version %u\"",
            "uVersion"
          ],
          "line": 7947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "installUniformedAPI",
          "args": [
            "gVBoxAPI",
            "result"
          ],
          "line": 7945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\nstatic virHypervisorDriver vboxCommonDriver = {\n    .name = \"VBOX\",\n    .connectURIProbe = vboxConnectURIProbe,\n    .connectOpen = vboxConnectOpen, /* 0.6.3 */\n    .connectClose = vboxConnectClose, /* 0.6.3 */\n    .connectGetVersion = vboxConnectGetVersion, /* 0.6.3 */\n    .connectGetHostname = vboxConnectGetHostname, /* 0.6.3 */\n    .connectGetMaxVcpus = vboxConnectGetMaxVcpus, /* 0.6.3 */\n    .nodeGetInfo = vboxNodeGetInfo, /* 0.6.3 */\n    .connectGetCapabilities = vboxConnectGetCapabilities, /* 0.6.3 */\n    .connectListDomains = vboxConnectListDomains, /* 0.6.3 */\n    .connectNumOfDomains = vboxConnectNumOfDomains, /* 0.6.3 */\n    .connectListAllDomains = vboxConnectListAllDomains, /* 0.9.13 */\n    .domainCreateXML = vboxDomainCreateXML, /* 0.6.3 */\n    .domainLookupByID = vboxDomainLookupByID, /* 0.6.3 */\n    .domainLookupByUUID = vboxDomainLookupByUUID, /* 0.6.3 */\n    .domainLookupByName = vboxDomainLookupByName, /* 0.6.3 */\n    .domainSuspend = vboxDomainSuspend, /* 0.6.3 */\n    .domainResume = vboxDomainResume, /* 0.6.3 */\n    .domainShutdown = vboxDomainShutdown, /* 0.6.3 */\n    .domainShutdownFlags = vboxDomainShutdownFlags, /* 0.9.10 */\n    .domainReboot = vboxDomainReboot, /* 0.6.3 */\n    .domainDestroy = vboxDomainDestroy, /* 0.6.3 */\n    .domainDestroyFlags = vboxDomainDestroyFlags, /* 0.9.4 */\n    .domainGetOSType = vboxDomainGetOSType, /* 0.6.3 */\n    .domainSetMemory = vboxDomainSetMemory, /* 0.6.3 */\n    .domainGetInfo = vboxDomainGetInfo, /* 0.6.3 */\n    .domainGetState = vboxDomainGetState, /* 0.9.2 */\n    .domainSave = vboxDomainSave, /* 0.6.3 */\n    .domainSetVcpus = vboxDomainSetVcpus, /* 0.7.1 */\n    .domainSetVcpusFlags = vboxDomainSetVcpusFlags, /* 0.8.5 */\n    .domainGetVcpusFlags = vboxDomainGetVcpusFlags, /* 0.8.5 */\n    .domainGetMaxVcpus = vboxDomainGetMaxVcpus, /* 0.7.1 */\n    .domainGetXMLDesc = vboxDomainGetXMLDesc, /* 0.6.3 */\n    .connectListDefinedDomains = vboxConnectListDefinedDomains, /* 0.6.3 */\n    .connectNumOfDefinedDomains = vboxConnectNumOfDefinedDomains, /* 0.6.3 */\n    .domainCreate = vboxDomainCreate, /* 0.6.3 */\n    .domainCreateWithFlags = vboxDomainCreateWithFlags, /* 0.8.2 */\n    .domainDefineXML = vboxDomainDefineXML, /* 0.6.3 */\n    .domainDefineXMLFlags = vboxDomainDefineXMLFlags, /* 1.2.12 */\n    .domainUndefine = vboxDomainUndefine, /* 0.6.3 */\n    .domainUndefineFlags = vboxDomainUndefineFlags, /* 0.9.5 */\n    .domainAttachDevice = vboxDomainAttachDevice, /* 0.6.3 */\n    .domainAttachDeviceFlags = vboxDomainAttachDeviceFlags, /* 0.7.7 */\n    .domainDetachDevice = vboxDomainDetachDevice, /* 0.6.3 */\n    .domainDetachDeviceFlags = vboxDomainDetachDeviceFlags, /* 0.7.7 */\n    .domainUpdateDeviceFlags = vboxDomainUpdateDeviceFlags, /* 0.8.0 */\n    .nodeGetCellsFreeMemory = vboxNodeGetCellsFreeMemory, /* 0.6.5 */\n    .nodeGetFreeMemory = vboxNodeGetFreeMemory, /* 0.6.5 */\n    .connectIsEncrypted = vboxConnectIsEncrypted, /* 0.7.3 */\n    .connectIsSecure = vboxConnectIsSecure, /* 0.7.3 */\n    .domainIsActive = vboxDomainIsActive, /* 0.7.3 */\n    .domainIsPersistent = vboxDomainIsPersistent, /* 0.7.3 */\n    .domainIsUpdated = vboxDomainIsUpdated, /* 0.8.6 */\n    .domainSnapshotCreateXML = vboxDomainSnapshotCreateXML, /* 0.8.0 */\n    .domainSnapshotGetXMLDesc = vboxDomainSnapshotGetXMLDesc, /* 0.8.0 */\n    .domainSnapshotNum = vboxDomainSnapshotNum, /* 0.8.0 */\n    .domainSnapshotListNames = vboxDomainSnapshotListNames, /* 0.8.0 */\n    .domainSnapshotLookupByName = vboxDomainSnapshotLookupByName, /* 0.8.0 */\n    .domainHasCurrentSnapshot = vboxDomainHasCurrentSnapshot, /* 0.8.0 */\n    .domainSnapshotGetParent = vboxDomainSnapshotGetParent, /* 0.9.7 */\n    .domainSnapshotCurrent = vboxDomainSnapshotCurrent, /* 0.8.0 */\n    .domainSnapshotIsCurrent = vboxDomainSnapshotIsCurrent, /* 0.9.13 */\n    .domainSnapshotHasMetadata = vboxDomainSnapshotHasMetadata, /* 0.9.13 */\n    .domainRevertToSnapshot = vboxDomainRevertToSnapshot, /* 0.8.0 */\n    .domainSnapshotDelete = vboxDomainSnapshotDelete, /* 0.8.0 */\n    .connectIsAlive = vboxConnectIsAlive, /* 0.9.8 */\n    .nodeGetFreePages = vboxNodeGetFreePages, /* 1.2.6 */\n    .nodeAllocPages = vboxNodeAllocPages, /* 1.2.9 */\n    .domainHasManagedSaveImage = vboxDomainHasManagedSaveImage, /* 1.2.13 */\n    .domainSendKey = vboxDomainSendKey, /* 1.2.15 */\n    .domainScreenshot = vboxDomainScreenshot, /* 0.9.2 */\n};\n\nvirHypervisorDriverPtr vboxGetHypervisorDriver(uint32_t uVersion)\n{\n    /* Install gVBoxAPI according to the vbox API version. */\n    int result = 0;\n    installUniformedAPI(gVBoxAPI, result);\n    if (result < 0) {\n        VIR_WARN(\"Libvirt doesn't support VirtualBox API version %u\",\n                 uVersion);\n        return NULL;\n    }\n\n    return &vboxCommonDriver;\n}"
  },
  {
    "function_name": "vboxDomainSendKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "7744-7860",
    "snippet": "static int\nvboxDomainSendKey(virDomainPtr dom,\n                  unsigned int codeset,\n                  unsigned int holdtime,\n                  unsigned int *keycodes,\n                  int nkeycodes,\n                  unsigned int flags)\n{\n    int ret = -1;\n    vboxDriverPtr data = dom->conn->privateData;\n    IConsole *console = NULL;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    IKeyboard *keyboard = NULL;\n    PRInt32 *keyDownCodes = NULL;\n    PRInt32 *keyUpCodes = NULL;\n    PRUint32 codesStored = 0;\n    nsresult rc;\n    size_t i;\n    int keycode;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    keyDownCodes = (PRInt32 *) keycodes;\n\n    if (VIR_ALLOC_N(keyUpCodes, nkeycodes) < 0)\n        return ret;\n\n    /* translate keycodes to xt and generate keyup scancodes */\n    for (i = 0; i < nkeycodes; i++) {\n        if (codeset != VIR_KEYCODE_SET_XT) {\n            keycode = virKeycodeValueTranslate(codeset, VIR_KEYCODE_SET_XT,\n                                               keyDownCodes[i]);\n            if (keycode < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"cannot translate keycode %u of %s codeset to\"\n                                 \" xt keycode\"),\n                                 keyDownCodes[i],\n                                 virKeycodeSetTypeToString(codeset));\n                goto cleanup;\n            }\n            keyDownCodes[i] = keycode;\n        }\n\n        keyUpCodes[i] = keyDownCodes[i] + 0x80;\n    }\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Unable to open VirtualBox session with domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n\n    if (NS_FAILED(rc) || !console) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Unable to get Console object for domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIConsole.GetKeyboard(console, &keyboard);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Unable to get Keyboard object for domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIKeyboard.PutScancodes(keyboard, nkeycodes, keyDownCodes,\n                                          &codesStored);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Unable to send keyboard scancodes for domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    /* since VBOX does not support holdtime, simulate it by sleeping and\n       then sending the release key scancodes */\n    if (holdtime > 0)\n        g_usleep(holdtime * 1000);\n\n    rc = gVBoxAPI.UIKeyboard.PutScancodes(keyboard, nkeycodes, keyUpCodes,\n                                          &codesStored);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Unable to send keyboard scan codes to domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(keyUpCodes);\n    VBOX_RELEASE(keyboard);\n    VBOX_RELEASE(console);\n    gVBoxAPI.UISession.Close(data->vboxSession);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 7857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 7856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 7855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "console"
          ],
          "line": 7854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "keyboard"
          ],
          "line": 7853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "keyUpCodes"
          ],
          "line": 7852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Unable to send keyboard scan codes to domain %s\")",
            "dom->name"
          ],
          "line": 7843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to send keyboard scan codes to domain %s\""
          ],
          "line": 7844
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIKeyboard.PutScancodes",
          "args": [
            "keyboard",
            "nkeycodes",
            "keyUpCodes",
            "&codesStored"
          ],
          "line": 7839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "holdtime * 1000"
          ],
          "line": 7837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Unable to send keyboard scancodes for domain %s\")",
            "dom->name"
          ],
          "line": 7828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIKeyboard.PutScancodes",
          "args": [
            "keyboard",
            "nkeycodes",
            "keyDownCodes",
            "&codesStored"
          ],
          "line": 7824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Unable to get Keyboard object for domain %s\")",
            "dom->name"
          ],
          "line": 7818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIConsole.GetKeyboard",
          "args": [
            "console",
            "&keyboard"
          ],
          "line": 7815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Unable to get Console object for domain %s\")",
            "dom->name"
          ],
          "line": 7809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetConsole",
          "args": [
            "data->vboxSession",
            "&console"
          ],
          "line": 7806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Unable to open VirtualBox session with domain %s\")",
            "dom->name"
          ],
          "line": 7800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.OpenExisting",
          "args": [
            "data",
            "&iid",
            "machine"
          ],
          "line": 7797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 7794
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"cannot translate keycode %u of %s codeset to\"\n                                 \" xt keycode\")",
            "keyDownCodes[i]",
            "virKeycodeSetTypeToString(codeset)"
          ],
          "line": 7781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virKeycodeSetTypeToString",
          "args": [
            "codeset"
          ],
          "line": 7785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virKeycodeValueTranslate",
          "args": [
            "codeset",
            "VIR_KEYCODE_SET_XT",
            "keyDownCodes[i]"
          ],
          "line": 7778
        },
        "resolved": true,
        "details": {
          "function_name": "virKeycodeValueTranslate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virkeycode.c",
          "lines": "105-121",
          "snippet": "int virKeycodeValueTranslate(virKeycodeSet from_codeset,\n                             virKeycodeSet to_codeset,\n                             int key_value)\n{\n    size_t i;\n\n    if (key_value < 0)\n        return -1;\n\n\n    for (i = 0; i < VIR_KEYMAP_ENTRY_MAX; i++) {\n        if (virKeymapValues[from_codeset][i] == key_value)\n            return virKeymapValues[to_codeset][i];\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virkeynametable_win32.h\"",
            "#include \"virkeynametable_osx.h\"",
            "#include \"virkeynametable_linux.h\"",
            "#include \"virkeycodetable_xtkbd.h\"",
            "#include \"virkeycodetable_win32.h\"",
            "#include \"virkeycodetable_usb.h\"",
            "#include \"virkeycodetable_qnum.h\"",
            "#include \"virkeycodetable_osx.h\"",
            "#include \"virkeycodetable_linux.h\"",
            "#include \"virkeycodetable_atset3.h\"",
            "#include \"virkeycodetable_atset2.h\"",
            "#include \"virkeycodetable_atset1.h\"",
            "#include <stddef.h>",
            "#include \"virkeycode.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_KEYMAP_ENTRY_MAX G_N_ELEMENTS(virKeyCodeTable_linux)"
          ],
          "globals_used": [
            "static const unsigned short *virKeymapValues[VIR_KEYCODE_SET_LAST] = {\n    [VIR_KEYCODE_SET_LINUX] = virKeyCodeTable_linux,\n    /* XT is same as AT Set1 - it was included by mistake */\n    [VIR_KEYCODE_SET_XT] = virKeyCodeTable_atset1,\n    [VIR_KEYCODE_SET_ATSET1] = virKeyCodeTable_atset1,\n    [VIR_KEYCODE_SET_ATSET2] = virKeyCodeTable_atset2,\n    [VIR_KEYCODE_SET_ATSET3] = virKeyCodeTable_atset3,\n    [VIR_KEYCODE_SET_OSX] = virKeyCodeTable_osx,\n    [VIR_KEYCODE_SET_XT_KBD] = virKeyCodeTable_xtkbd,\n    [VIR_KEYCODE_SET_USB] = virKeyCodeTable_usb,\n    [VIR_KEYCODE_SET_WIN32] = virKeyCodeTable_win32,\n    [VIR_KEYCODE_SET_QNUM] = virKeyCodeTable_qnum,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virkeynametable_win32.h\"\n#include \"virkeynametable_osx.h\"\n#include \"virkeynametable_linux.h\"\n#include \"virkeycodetable_xtkbd.h\"\n#include \"virkeycodetable_win32.h\"\n#include \"virkeycodetable_usb.h\"\n#include \"virkeycodetable_qnum.h\"\n#include \"virkeycodetable_osx.h\"\n#include \"virkeycodetable_linux.h\"\n#include \"virkeycodetable_atset3.h\"\n#include \"virkeycodetable_atset2.h\"\n#include \"virkeycodetable_atset1.h\"\n#include <stddef.h>\n#include \"virkeycode.h\"\n#include <config.h>\n\n#define VIR_KEYMAP_ENTRY_MAX G_N_ELEMENTS(virKeyCodeTable_linux)\n\nstatic const unsigned short *virKeymapValues[VIR_KEYCODE_SET_LAST] = {\n    [VIR_KEYCODE_SET_LINUX] = virKeyCodeTable_linux,\n    /* XT is same as AT Set1 - it was included by mistake */\n    [VIR_KEYCODE_SET_XT] = virKeyCodeTable_atset1,\n    [VIR_KEYCODE_SET_ATSET1] = virKeyCodeTable_atset1,\n    [VIR_KEYCODE_SET_ATSET2] = virKeyCodeTable_atset2,\n    [VIR_KEYCODE_SET_ATSET3] = virKeyCodeTable_atset3,\n    [VIR_KEYCODE_SET_OSX] = virKeyCodeTable_osx,\n    [VIR_KEYCODE_SET_XT_KBD] = virKeyCodeTable_xtkbd,\n    [VIR_KEYCODE_SET_USB] = virKeyCodeTable_usb,\n    [VIR_KEYCODE_SET_WIN32] = virKeyCodeTable_win32,\n    [VIR_KEYCODE_SET_QNUM] = virKeyCodeTable_qnum,\n};\n\nint virKeycodeValueTranslate(virKeycodeSet from_codeset,\n                             virKeycodeSet to_codeset,\n                             int key_value)\n{\n    size_t i;\n\n    if (key_value < 0)\n        return -1;\n\n\n    for (i = 0; i < VIR_KEYMAP_ENTRY_MAX; i++) {\n        if (virKeymapValues[from_codeset][i] == key_value)\n            return virKeymapValues[to_codeset][i];\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "keyUpCodes",
            "nkeycodes"
          ],
          "line": 7772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 7768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDomainSendKey(virDomainPtr dom,\n                  unsigned int codeset,\n                  unsigned int holdtime,\n                  unsigned int *keycodes,\n                  int nkeycodes,\n                  unsigned int flags)\n{\n    int ret = -1;\n    vboxDriverPtr data = dom->conn->privateData;\n    IConsole *console = NULL;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    IKeyboard *keyboard = NULL;\n    PRInt32 *keyDownCodes = NULL;\n    PRInt32 *keyUpCodes = NULL;\n    PRUint32 codesStored = 0;\n    nsresult rc;\n    size_t i;\n    int keycode;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    keyDownCodes = (PRInt32 *) keycodes;\n\n    if (VIR_ALLOC_N(keyUpCodes, nkeycodes) < 0)\n        return ret;\n\n    /* translate keycodes to xt and generate keyup scancodes */\n    for (i = 0; i < nkeycodes; i++) {\n        if (codeset != VIR_KEYCODE_SET_XT) {\n            keycode = virKeycodeValueTranslate(codeset, VIR_KEYCODE_SET_XT,\n                                               keyDownCodes[i]);\n            if (keycode < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"cannot translate keycode %u of %s codeset to\"\n                                 \" xt keycode\"),\n                                 keyDownCodes[i],\n                                 virKeycodeSetTypeToString(codeset));\n                goto cleanup;\n            }\n            keyDownCodes[i] = keycode;\n        }\n\n        keyUpCodes[i] = keyDownCodes[i] + 0x80;\n    }\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Unable to open VirtualBox session with domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n\n    if (NS_FAILED(rc) || !console) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Unable to get Console object for domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIConsole.GetKeyboard(console, &keyboard);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Unable to get Keyboard object for domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIKeyboard.PutScancodes(keyboard, nkeycodes, keyDownCodes,\n                                          &codesStored);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Unable to send keyboard scancodes for domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    /* since VBOX does not support holdtime, simulate it by sleeping and\n       then sending the release key scancodes */\n    if (holdtime > 0)\n        g_usleep(holdtime * 1000);\n\n    rc = gVBoxAPI.UIKeyboard.PutScancodes(keyboard, nkeycodes, keyUpCodes,\n                                          &codesStored);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Unable to send keyboard scan codes to domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(keyUpCodes);\n    VBOX_RELEASE(keyboard);\n    VBOX_RELEASE(console);\n    gVBoxAPI.UISession.Close(data->vboxSession);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainHasManagedSaveImage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "7674-7742",
    "snippet": "static int\nvboxDomainHasManagedSaveImage(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    vboxIID iid;\n    char *machineNameUtf8 = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    size_t i;\n    bool matched = false;\n    nsresult rc;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return ret;\n    }\n\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n        PRBool isAccessible = PR_FALSE;\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (!isAccessible)\n            continue;\n\n        gVBoxAPI.UIMachine.GetId(machine, &iid);\n        if (NS_FAILED(rc))\n            continue;\n        vboxIIDToUUID(&iid, uuid);\n        vboxIIDUnalloc(&iid);\n\n        if (memcmp(dom->uuid, uuid, VIR_UUID_BUFLEN) == 0) {\n\n            PRUint32 state;\n\n            matched = true;\n\n            gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n            VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineNameUtf8);\n\n            gVBoxAPI.UIMachine.GetState(machine, &state);\n\n            ret = 0;\n        }\n\n        if (matched)\n            break;\n    }\n\n    /* Do the cleanup and take care you dont leak any memory */\n    VBOX_UTF8_FREE(machineNameUtf8);\n    VBOX_COM_UNALLOC_MEM(machineNameUtf16);\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&machines"
          ],
          "line": 7739
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_COM_UNALLOC_MEM",
          "args": [
            "machineNameUtf16"
          ],
          "line": 7738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "machineNameUtf8"
          ],
          "line": 7737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 7727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "machineNameUtf16",
            "&machineNameUtf8"
          ],
          "line": 7725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetName",
          "args": [
            "machine",
            "&machineNameUtf16"
          ],
          "line": 7724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dom->uuid",
            "uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 7718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 7716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDToUUID",
          "args": [
            "&iid",
            "uuid"
          ],
          "line": 7715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetId",
          "args": [
            "machine",
            "&iid"
          ],
          "line": 7712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 7708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get list of machines, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 7696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not get list of machines, rc=%08x\""
          ],
          "line": 7697
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&machines",
            "data->vboxObj",
            "ARRAY_GET_MACHINES"
          ],
          "line": 7694
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 7693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 7688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDomainHasManagedSaveImage(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    vboxIID iid;\n    char *machineNameUtf8 = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    size_t i;\n    bool matched = false;\n    nsresult rc;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return ret;\n    }\n\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n        PRBool isAccessible = PR_FALSE;\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (!isAccessible)\n            continue;\n\n        gVBoxAPI.UIMachine.GetId(machine, &iid);\n        if (NS_FAILED(rc))\n            continue;\n        vboxIIDToUUID(&iid, uuid);\n        vboxIIDUnalloc(&iid);\n\n        if (memcmp(dom->uuid, uuid, VIR_UUID_BUFLEN) == 0) {\n\n            PRUint32 state;\n\n            matched = true;\n\n            gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n            VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineNameUtf8);\n\n            gVBoxAPI.UIMachine.GetState(machine, &state);\n\n            ret = 0;\n        }\n\n        if (matched)\n            break;\n    }\n\n    /* Do the cleanup and take care you dont leak any memory */\n    VBOX_UTF8_FREE(machineNameUtf8);\n    VBOX_COM_UNALLOC_MEM(machineNameUtf16);\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxNodeAllocPages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "7657-7672",
    "snippet": "static int\nvboxNodeAllocPages(virConnectPtr conn G_GNUC_UNUSED,\n                   unsigned int npages,\n                   unsigned int *pageSizes,\n                   unsigned long long *pageCounts,\n                   int startCell,\n                   unsigned int cellCount,\n                   unsigned int flags)\n{\n    bool add = !(flags & VIR_NODE_ALLOC_PAGES_SET);\n\n    virCheckFlags(VIR_NODE_ALLOC_PAGES_SET, -1);\n\n    return virHostMemAllocPages(npages, pageSizes, pageCounts,\n                                startCell, cellCount, add);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostMemAllocPages",
          "args": [
            "npages",
            "pageSizes",
            "pageCounts",
            "startCell",
            "cellCount",
            "add"
          ],
          "line": 7670
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemAllocPages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "871-907",
          "snippet": "int\nvirHostMemAllocPages(unsigned int npages,\n                     unsigned int *pageSizes,\n                     unsigned long long *pageCounts,\n                     int startCell,\n                     unsigned int cellCount,\n                     bool add)\n{\n    int cell, lastCell;\n    size_t i, ncounts = 0;\n\n    if ((lastCell = virNumaGetMaxNode()) < 0)\n        return 0;\n\n    if (startCell > lastCell) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, lastCell);\n        return -1;\n    }\n\n    lastCell = MIN(lastCell, startCell + (int) cellCount - 1);\n\n    for (cell = startCell; cell <= lastCell; cell++) {\n        for (i = 0; i < npages; i++) {\n            unsigned int page_size = pageSizes[i];\n            unsigned long long page_count = pageCounts[i];\n\n            if (virNumaSetPagePoolSize(cell, page_size, page_count, add) < 0)\n                return -1;\n\n            ncounts++;\n        }\n    }\n\n    return ncounts;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostMemAllocPages(unsigned int npages,\n                     unsigned int *pageSizes,\n                     unsigned long long *pageCounts,\n                     int startCell,\n                     unsigned int cellCount,\n                     bool add)\n{\n    int cell, lastCell;\n    size_t i, ncounts = 0;\n\n    if ((lastCell = virNumaGetMaxNode()) < 0)\n        return 0;\n\n    if (startCell > lastCell) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, lastCell);\n        return -1;\n    }\n\n    lastCell = MIN(lastCell, startCell + (int) cellCount - 1);\n\n    for (cell = startCell; cell <= lastCell; cell++) {\n        for (i = 0; i < npages; i++) {\n            unsigned int page_size = pageSizes[i];\n            unsigned long long page_count = pageCounts[i];\n\n            if (virNumaSetPagePoolSize(cell, page_size, page_count, add) < 0)\n                return -1;\n\n            ncounts++;\n        }\n    }\n\n    return ncounts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_NODE_ALLOC_PAGES_SET",
            "-1"
          ],
          "line": 7668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvboxNodeAllocPages(virConnectPtr conn G_GNUC_UNUSED,\n                   unsigned int npages,\n                   unsigned int *pageSizes,\n                   unsigned long long *pageCounts,\n                   int startCell,\n                   unsigned int cellCount,\n                   unsigned int flags)\n{\n    bool add = !(flags & VIR_NODE_ALLOC_PAGES_SET);\n\n    virCheckFlags(VIR_NODE_ALLOC_PAGES_SET, -1);\n\n    return virHostMemAllocPages(npages, pageSizes, pageCounts,\n                                startCell, cellCount, add);\n}"
  },
  {
    "function_name": "vboxNodeGetFreePages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "7643-7655",
    "snippet": "static int\nvboxNodeGetFreePages(virConnectPtr conn G_GNUC_UNUSED,\n                     unsigned int npages,\n                     unsigned int *pages,\n                     int startCell,\n                     unsigned int cellCount,\n                     unsigned long long *counts,\n                     unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n    return virHostMemGetFreePages(npages, pages, startCell, cellCount, counts);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostMemGetFreePages",
          "args": [
            "npages",
            "pages",
            "startCell",
            "cellCount",
            "counts"
          ],
          "line": 7654
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemGetFreePages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "828-869",
          "snippet": "int\nvirHostMemGetFreePages(unsigned int npages,\n                       unsigned int *pages,\n                       int startCell,\n                       unsigned int cellCount,\n                       unsigned long long *counts)\n{\n    int cell, lastCell;\n    size_t i, ncounts = 0;\n\n    if ((lastCell = virNumaGetMaxNode()) < 0)\n        return 0;\n\n    if (startCell > lastCell) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, lastCell);\n        return -1;\n    }\n\n    lastCell = MIN(lastCell, startCell + (int) cellCount - 1);\n\n    for (cell = startCell; cell <= lastCell; cell++) {\n        for (i = 0; i < npages; i++) {\n            unsigned int page_size = pages[i];\n            unsigned long long page_free;\n\n            if (virNumaGetPageInfo(cell, page_size, 0, NULL, &page_free) < 0)\n                return -1;\n\n            counts[ncounts++] = page_free;\n        }\n    }\n\n    if (!ncounts) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no suitable info found\"));\n        return -1;\n    }\n\n    return ncounts;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostMemGetFreePages(unsigned int npages,\n                       unsigned int *pages,\n                       int startCell,\n                       unsigned int cellCount,\n                       unsigned long long *counts)\n{\n    int cell, lastCell;\n    size_t i, ncounts = 0;\n\n    if ((lastCell = virNumaGetMaxNode()) < 0)\n        return 0;\n\n    if (startCell > lastCell) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, lastCell);\n        return -1;\n    }\n\n    lastCell = MIN(lastCell, startCell + (int) cellCount - 1);\n\n    for (cell = startCell; cell <= lastCell; cell++) {\n        for (i = 0; i < npages; i++) {\n            unsigned int page_size = pages[i];\n            unsigned long long page_free;\n\n            if (virNumaGetPageInfo(cell, page_size, 0, NULL, &page_free) < 0)\n                return -1;\n\n            counts[ncounts++] = page_free;\n        }\n    }\n\n    if (!ncounts) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no suitable info found\"));\n        return -1;\n    }\n\n    return ncounts;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 7652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvboxNodeGetFreePages(virConnectPtr conn G_GNUC_UNUSED,\n                     unsigned int npages,\n                     unsigned int *pages,\n                     int startCell,\n                     unsigned int cellCount,\n                     unsigned long long *counts,\n                     unsigned int flags)\n{\n    virCheckFlags(0, -1);\n\n    return virHostMemGetFreePages(npages, pages, startCell, cellCount, counts);\n}"
  },
  {
    "function_name": "vboxNodeGetFreeMemory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "7634-7641",
    "snippet": "static unsigned long long\nvboxNodeGetFreeMemory(virConnectPtr conn G_GNUC_UNUSED)\n{\n    unsigned long long freeMem;\n    if (virHostMemGetInfo(NULL, &freeMem) < 0)\n        return 0;\n    return freeMem;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostMemGetInfo",
          "args": [
            "NULL",
            "&freeMem"
          ],
          "line": 7638
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemGetInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "790-826",
          "snippet": "int\nvirHostMemGetInfo(unsigned long long *mem,\n                  unsigned long long *freeMem)\n{\n    int max_node;\n    int n;\n\n    if (mem)\n        *mem = 0;\n\n    if (freeMem)\n        *freeMem = 0;\n\n    if (!virNumaIsAvailable())\n        return virHostMemGetInfoFake(mem, freeMem);\n\n    if ((max_node = virNumaGetMaxNode()) < 0)\n        return -1;\n\n    for (n = 0; n <= max_node; n++) {\n        unsigned long long tmp_mem = 0, tmp_freeMem = 0;\n\n        if (!virNumaNodeIsAvailable(n))\n            continue;\n\n        if (virNumaGetNodeMemory(n, &tmp_mem, &tmp_freeMem) < 0)\n            return -1;\n\n        if (mem)\n            *mem += tmp_mem;\n\n        if (freeMem)\n            *freeMem += tmp_freeMem;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostMemGetInfo(unsigned long long *mem,\n                  unsigned long long *freeMem)\n{\n    int max_node;\n    int n;\n\n    if (mem)\n        *mem = 0;\n\n    if (freeMem)\n        *freeMem = 0;\n\n    if (!virNumaIsAvailable())\n        return virHostMemGetInfoFake(mem, freeMem);\n\n    if ((max_node = virNumaGetMaxNode()) < 0)\n        return -1;\n\n    for (n = 0; n <= max_node; n++) {\n        unsigned long long tmp_mem = 0, tmp_freeMem = 0;\n\n        if (!virNumaNodeIsAvailable(n))\n            continue;\n\n        if (virNumaGetNodeMemory(n, &tmp_mem, &tmp_freeMem) < 0)\n            return -1;\n\n        if (mem)\n            *mem += tmp_mem;\n\n        if (freeMem)\n            *freeMem += tmp_freeMem;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic unsigned long long\nvboxNodeGetFreeMemory(virConnectPtr conn G_GNUC_UNUSED)\n{\n    unsigned long long freeMem;\n    if (virHostMemGetInfo(NULL, &freeMem) < 0)\n        return 0;\n    return freeMem;\n}"
  },
  {
    "function_name": "vboxNodeGetCellsFreeMemory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "7625-7632",
    "snippet": "static int\nvboxNodeGetCellsFreeMemory(virConnectPtr conn G_GNUC_UNUSED,\n                           unsigned long long *freeMems,\n                           int startCell,\n                           int maxCells)\n{\n    return virHostMemGetCellsFree(freeMems, startCell, maxCells);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostMemGetCellsFree",
          "args": [
            "freeMems",
            "startCell",
            "maxCells"
          ],
          "line": 7631
        },
        "resolved": true,
        "details": {
          "function_name": "virHostMemGetCellsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhostmem.c",
          "lines": "756-788",
          "snippet": "int\nvirHostMemGetCellsFree(unsigned long long *freeMems,\n                       int startCell,\n                       int maxCells)\n{\n    unsigned long long mem;\n    int n, lastCell, numCells;\n    int maxCell;\n\n    if (!virNumaIsAvailable())\n        return virHostMemGetCellsFreeFake(freeMems,\n                                          startCell, maxCells);\n\n    if ((maxCell = virNumaGetMaxNode()) < 0)\n        return 0;\n\n    if (startCell > maxCell) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, maxCell);\n        return -1;\n    }\n    lastCell = startCell + maxCells - 1;\n    if (lastCell > maxCell)\n        lastCell = maxCell;\n\n    for (numCells = 0, n = startCell; n <= lastCell; n++) {\n        virNumaGetNodeMemory(n, NULL, &mem);\n\n        freeMems[numCells++] = mem;\n    }\n    return numCells;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virnuma.h\"",
            "#include \"virstring.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virfile.h\"",
            "#include \"virarch.h\"",
            "#include \"virerror.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "# include <windows.h>",
            "# include <sys/resource.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/types.h>",
            "# include <sys/time.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virtypedparam.h\"\n#include \"virfile.h\"\n#include \"virarch.h\"\n#include \"virerror.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n# include <windows.h>\n# include <sys/resource.h>\n# include <sys/sysctl.h>\n# include <sys/types.h>\n# include <sys/time.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostMemGetCellsFree(unsigned long long *freeMems,\n                       int startCell,\n                       int maxCells)\n{\n    unsigned long long mem;\n    int n, lastCell, numCells;\n    int maxCell;\n\n    if (!virNumaIsAvailable())\n        return virHostMemGetCellsFreeFake(freeMems,\n                                          startCell, maxCells);\n\n    if ((maxCell = virNumaGetMaxNode()) < 0)\n        return 0;\n\n    if (startCell > maxCell) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"start cell %d out of range (0-%d)\"),\n                       startCell, maxCell);\n        return -1;\n    }\n    lastCell = startCell + maxCells - 1;\n    if (lastCell > maxCell)\n        lastCell = maxCell;\n\n    for (numCells = 0, n = startCell; n <= lastCell; n++) {\n        virNumaGetNodeMemory(n, NULL, &mem);\n\n        freeMems[numCells++] = mem;\n    }\n    return numCells;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvboxNodeGetCellsFreeMemory(virConnectPtr conn G_GNUC_UNUSED,\n                           unsigned long long *freeMems,\n                           int startCell,\n                           int maxCells)\n{\n    return virHostMemGetCellsFree(freeMems, startCell, maxCells);\n}"
  },
  {
    "function_name": "vboxNodeGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "7618-7623",
    "snippet": "static int\nvboxNodeGetInfo(virConnectPtr conn G_GNUC_UNUSED,\n                virNodeInfoPtr nodeinfo)\n{\n    return virCapabilitiesGetNodeInfo(nodeinfo);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapabilitiesGetNodeInfo",
          "args": [
            "nodeinfo"
          ],
          "line": 7622
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesGetNodeInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1434-1456",
          "snippet": "int\nvirCapabilitiesGetNodeInfo(virNodeInfoPtr nodeinfo)\n{\n    virArch hostarch = virArchFromHost();\n    unsigned long long memorybytes;\n\n    memset(nodeinfo, 0, sizeof(*nodeinfo));\n\n    if (virStrcpyStatic(nodeinfo->model, virArchToString(hostarch)) < 0)\n        return -1;\n\n    if (virHostMemGetInfo(&memorybytes, NULL) < 0)\n        return -1;\n    nodeinfo->memory = memorybytes / 1024;\n\n    if (virHostCPUGetInfo(hostarch,\n                          &nodeinfo->cpus, &nodeinfo->mhz,\n                          &nodeinfo->nodes, &nodeinfo->sockets,\n                          &nodeinfo->cores, &nodeinfo->threads) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirCapabilitiesGetNodeInfo(virNodeInfoPtr nodeinfo)\n{\n    virArch hostarch = virArchFromHost();\n    unsigned long long memorybytes;\n\n    memset(nodeinfo, 0, sizeof(*nodeinfo));\n\n    if (virStrcpyStatic(nodeinfo->model, virArchToString(hostarch)) < 0)\n        return -1;\n\n    if (virHostMemGetInfo(&memorybytes, NULL) < 0)\n        return -1;\n    nodeinfo->memory = memorybytes / 1024;\n\n    if (virHostCPUGetInfo(hostarch,\n                          &nodeinfo->cpus, &nodeinfo->mhz,\n                          &nodeinfo->nodes, &nodeinfo->sockets,\n                          &nodeinfo->cores, &nodeinfo->threads) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvboxNodeGetInfo(virConnectPtr conn G_GNUC_UNUSED,\n                virNodeInfoPtr nodeinfo)\n{\n    return virCapabilitiesGetNodeInfo(nodeinfo);\n}"
  },
  {
    "function_name": "vboxConnectListAllDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "7459-7615",
    "snippet": "static int\nvboxConnectListAllDomains(virConnectPtr conn,\n                          virDomainPtr **domains,\n                          unsigned int flags)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    char *machineNameUtf8 = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    vboxIID iid;\n    PRUint32 state;\n    nsresult rc;\n    size_t i;\n    virDomainPtr dom;\n    virDomainPtr *doms = NULL;\n    int count = 0;\n    bool active;\n    PRUint32 snapshotCount;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(VIR_CONNECT_LIST_DOMAINS_FILTERS_ALL, -1);\n\n    /* filter out flag options that will produce 0 results in vbox driver:\n     * - managed save: vbox guests don't have managed save images\n     * - autostart: vbox doesn't support autostarting guests\n     * - persistence: vbox doesn't support transient guests\n     */\n    if ((MATCH(VIR_CONNECT_LIST_DOMAINS_TRANSIENT) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_PERSISTENT)) ||\n        (MATCH(VIR_CONNECT_LIST_DOMAINS_AUTOSTART) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART)) ||\n        (MATCH(VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE))) {\n        if (domains &&\n            VIR_ALLOC_N(*domains, 1) < 0)\n            goto cleanup;\n\n        ret = 0;\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of domains, rc=%08x\"), (unsigned)rc);\n        goto cleanup;\n    }\n\n    if (domains &&\n        VIR_ALLOC_N(doms, machines.count + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < machines.count; i++) {\n        IMachine *machine = machines.items[i];\n        int id = -1;\n\n        if (!machine)\n            continue;\n\n        PRBool isAccessible = PR_FALSE;\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n\n        if (!isAccessible)\n            continue;\n\n      gVBoxAPI.UIMachine.GetState(machine, &state);\n\n      if (gVBoxAPI.machineStateChecker.Online(state))\n          active = true;\n      else\n          active = false;\n\n      /* filter by active state */\n      if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_ACTIVE) &&\n          !((MATCH(VIR_CONNECT_LIST_DOMAINS_ACTIVE) && active) ||\n            (MATCH(VIR_CONNECT_LIST_DOMAINS_INACTIVE) && !active)))\n          continue;\n\n      /* filter by snapshot existence */\n      if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_SNAPSHOT)) {\n          rc = gVBoxAPI.UIMachine.GetSnapshotCount(machine, &snapshotCount);\n          if (NS_FAILED(rc)) {\n              virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                             _(\"could not get snapshot count for listed domains\"));\n              goto cleanup;\n          }\n          if (!((MATCH(VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT) &&\n                 snapshotCount > 0) ||\n                (MATCH(VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT) &&\n                 snapshotCount == 0)))\n              continue;\n      }\n\n      /* filter by machine state */\n      if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_STATE) &&\n          !((MATCH(VIR_CONNECT_LIST_DOMAINS_RUNNING) &&\n             gVBoxAPI.machineStateChecker.Running(state)) ||\n            (MATCH(VIR_CONNECT_LIST_DOMAINS_PAUSED) &&\n             gVBoxAPI.machineStateChecker.Paused(state)) ||\n            (MATCH(VIR_CONNECT_LIST_DOMAINS_SHUTOFF) &&\n             gVBoxAPI.machineStateChecker.PoweredOff(state)) ||\n            (MATCH(VIR_CONNECT_LIST_DOMAINS_OTHER) &&\n             (!gVBoxAPI.machineStateChecker.Running(state) &&\n              !gVBoxAPI.machineStateChecker.Paused(state) &&\n              !gVBoxAPI.machineStateChecker.PoweredOff(state)))))\n          continue;\n\n      /* just count the machines */\n      if (!doms) {\n          count++;\n          continue;\n      }\n\n      gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n      VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineNameUtf8);\n      gVBoxAPI.UIMachine.GetId(machine, &iid);\n      vboxIIDToUUID(&iid, uuid);\n      vboxIIDUnalloc(&iid);\n\n      if (active)\n          id = i + 1;\n\n      dom = virGetDomain(conn, machineNameUtf8, uuid, id);\n\n      VBOX_UTF8_FREE(machineNameUtf8);\n      VBOX_UTF16_FREE(machineNameUtf16);\n\n      if (!dom)\n          goto cleanup;\n\n      doms[count++] = dom;\n    }\n\n    if (doms) {\n        /* safe to ignore, new size will be equal or less than\n         * previous allocation */\n        ignore_value(VIR_REALLOC_N(doms, count + 1));\n        *domains = doms;\n        doms = NULL;\n    }\n\n    ret = count;\n\n cleanup:\n    if (doms) {\n        for (i = 0; i < count; i++)\n            virObjectUnref(doms[i]);\n    }\n    VIR_FREE(doms);\n\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&machines"
          ],
          "line": 7613
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "doms"
          ],
          "line": 7611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "doms[i]"
          ],
          "line": 7609
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "VIR_REALLOC_N(doms, count + 1)"
          ],
          "line": 7599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "doms",
            "count + 1"
          ],
          "line": 7599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "machineNameUtf16"
          ],
          "line": 7588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "machineNameUtf8"
          ],
          "line": 7587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "machineNameUtf8",
            "uuid",
            "id"
          ],
          "line": 7585
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 7580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDToUUID",
          "args": [
            "&iid",
            "uuid"
          ],
          "line": 7579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetId",
          "args": [
            "machine",
            "&iid"
          ],
          "line": 7578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "machineNameUtf16",
            "&machineNameUtf8"
          ],
          "line": 7577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetName",
          "args": [
            "machine",
            "&machineNameUtf16"
          ],
          "line": 7576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.PoweredOff",
          "args": [
            "state"
          ],
          "line": 7567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Paused",
          "args": [
            "state"
          ],
          "line": 7566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Running",
          "args": [
            "state"
          ],
          "line": 7565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_OTHER"
          ],
          "line": 7564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.PoweredOff",
          "args": [
            "state"
          ],
          "line": 7563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_SHUTOFF"
          ],
          "line": 7562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Paused",
          "args": [
            "state"
          ],
          "line": 7561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_PAUSED"
          ],
          "line": 7560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Running",
          "args": [
            "state"
          ],
          "line": 7559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_RUNNING"
          ],
          "line": 7558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_STATE"
          ],
          "line": 7557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT"
          ],
          "line": 7551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT"
          ],
          "line": 7549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get snapshot count for listed domains\")"
          ],
          "line": 7545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not get snapshot count for listed domains\""
          ],
          "line": 7546
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetSnapshotCount",
          "args": [
            "machine",
            "&snapshotCount"
          ],
          "line": 7543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_SNAPSHOT"
          ],
          "line": 7542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_INACTIVE"
          ],
          "line": 7538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_ACTIVE"
          ],
          "line": 7537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_ACTIVE"
          ],
          "line": 7536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Online",
          "args": [
            "state"
          ],
          "line": 7530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 7528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 7523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "doms",
            "machines.count + 1"
          ],
          "line": 7512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get list of domains, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 7506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&machines",
            "data->vboxObj",
            "ARRAY_GET_MACHINES"
          ],
          "line": 7504
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*domains",
            "1"
          ],
          "line": 7497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE"
          ],
          "line": 7495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE"
          ],
          "line": 7494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART"
          ],
          "line": 7493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_AUTOSTART"
          ],
          "line": 7492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_PERSISTENT"
          ],
          "line": 7491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_TRANSIENT"
          ],
          "line": 7490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_ALL",
            "-1"
          ],
          "line": 7483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxConnectListAllDomains(virConnectPtr conn,\n                          virDomainPtr **domains,\n                          unsigned int flags)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    char *machineNameUtf8 = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    vboxIID iid;\n    PRUint32 state;\n    nsresult rc;\n    size_t i;\n    virDomainPtr dom;\n    virDomainPtr *doms = NULL;\n    int count = 0;\n    bool active;\n    PRUint32 snapshotCount;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(VIR_CONNECT_LIST_DOMAINS_FILTERS_ALL, -1);\n\n    /* filter out flag options that will produce 0 results in vbox driver:\n     * - managed save: vbox guests don't have managed save images\n     * - autostart: vbox doesn't support autostarting guests\n     * - persistence: vbox doesn't support transient guests\n     */\n    if ((MATCH(VIR_CONNECT_LIST_DOMAINS_TRANSIENT) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_PERSISTENT)) ||\n        (MATCH(VIR_CONNECT_LIST_DOMAINS_AUTOSTART) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART)) ||\n        (MATCH(VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE))) {\n        if (domains &&\n            VIR_ALLOC_N(*domains, 1) < 0)\n            goto cleanup;\n\n        ret = 0;\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of domains, rc=%08x\"), (unsigned)rc);\n        goto cleanup;\n    }\n\n    if (domains &&\n        VIR_ALLOC_N(doms, machines.count + 1) < 0)\n        goto cleanup;\n\n    for (i = 0; i < machines.count; i++) {\n        IMachine *machine = machines.items[i];\n        int id = -1;\n\n        if (!machine)\n            continue;\n\n        PRBool isAccessible = PR_FALSE;\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n\n        if (!isAccessible)\n            continue;\n\n      gVBoxAPI.UIMachine.GetState(machine, &state);\n\n      if (gVBoxAPI.machineStateChecker.Online(state))\n          active = true;\n      else\n          active = false;\n\n      /* filter by active state */\n      if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_ACTIVE) &&\n          !((MATCH(VIR_CONNECT_LIST_DOMAINS_ACTIVE) && active) ||\n            (MATCH(VIR_CONNECT_LIST_DOMAINS_INACTIVE) && !active)))\n          continue;\n\n      /* filter by snapshot existence */\n      if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_SNAPSHOT)) {\n          rc = gVBoxAPI.UIMachine.GetSnapshotCount(machine, &snapshotCount);\n          if (NS_FAILED(rc)) {\n              virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                             _(\"could not get snapshot count for listed domains\"));\n              goto cleanup;\n          }\n          if (!((MATCH(VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT) &&\n                 snapshotCount > 0) ||\n                (MATCH(VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT) &&\n                 snapshotCount == 0)))\n              continue;\n      }\n\n      /* filter by machine state */\n      if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_STATE) &&\n          !((MATCH(VIR_CONNECT_LIST_DOMAINS_RUNNING) &&\n             gVBoxAPI.machineStateChecker.Running(state)) ||\n            (MATCH(VIR_CONNECT_LIST_DOMAINS_PAUSED) &&\n             gVBoxAPI.machineStateChecker.Paused(state)) ||\n            (MATCH(VIR_CONNECT_LIST_DOMAINS_SHUTOFF) &&\n             gVBoxAPI.machineStateChecker.PoweredOff(state)) ||\n            (MATCH(VIR_CONNECT_LIST_DOMAINS_OTHER) &&\n             (!gVBoxAPI.machineStateChecker.Running(state) &&\n              !gVBoxAPI.machineStateChecker.Paused(state) &&\n              !gVBoxAPI.machineStateChecker.PoweredOff(state)))))\n          continue;\n\n      /* just count the machines */\n      if (!doms) {\n          count++;\n          continue;\n      }\n\n      gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n      VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineNameUtf8);\n      gVBoxAPI.UIMachine.GetId(machine, &iid);\n      vboxIIDToUUID(&iid, uuid);\n      vboxIIDUnalloc(&iid);\n\n      if (active)\n          id = i + 1;\n\n      dom = virGetDomain(conn, machineNameUtf8, uuid, id);\n\n      VBOX_UTF8_FREE(machineNameUtf8);\n      VBOX_UTF16_FREE(machineNameUtf16);\n\n      if (!dom)\n          goto cleanup;\n\n      doms[count++] = dom;\n    }\n\n    if (doms) {\n        /* safe to ignore, new size will be equal or less than\n         * previous allocation */\n        ignore_value(VIR_REALLOC_N(doms, count + 1));\n        *domains = doms;\n        doms = NULL;\n    }\n\n    ret = count;\n\n cleanup:\n    if (doms) {\n        for (i = 0; i < count; i++)\n            virObjectUnref(doms[i]);\n    }\n    VIR_FREE(doms);\n\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainScreenshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "7331-7456",
    "snippet": "static char *\nvboxDomainScreenshot(virDomainPtr dom,\n                     virStreamPtr st,\n                     unsigned int screen,\n                     unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IConsole *console = NULL;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    nsresult rc;\n    g_autofree char *tmp = NULL;\n    g_autofree char *cacheDir = NULL;\n    int tmp_fd = -1;\n    unsigned int max_screen;\n    bool privileged = geteuid() == 0;\n    char *ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        return NULL;\n\n    rc = gVBoxAPI.UIMachine.GetMonitorCount(machine, &max_screen);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"unable to get monitor count\"));\n        VBOX_RELEASE(machine);\n        return NULL;\n    }\n\n    if (screen >= max_screen) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"screen ID higher than monitor \"\n                         \"count (%d)\"), max_screen);\n        VBOX_RELEASE(machine);\n        return NULL;\n    }\n\n    if (privileged) {\n        cacheDir = g_strdup_printf(\"%s/cache/libvirt\", LOCALSTATEDIR);\n    } else {\n        cacheDir = virGetUserCacheDirectory();\n    }\n\n    tmp = g_strdup_printf(\"%s/vbox.screendump.XXXXXX\", cacheDir);\n\n    if ((tmp_fd = g_mkstemp_full(tmp, O_RDWR | O_CLOEXEC, S_IRUSR | S_IWUSR)) == -1) {\n        virReportSystemError(errno, _(\"g_mkstemp(\\\"%s\\\") failed\"), tmp);\n        VBOX_RELEASE(machine);\n        return NULL;\n    }\n\n\n    rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    if (NS_SUCCEEDED(rc)) {\n        rc = gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n        if (NS_SUCCEEDED(rc) && console) {\n            IDisplay *display = NULL;\n\n            gVBoxAPI.UIConsole.GetDisplay(console, &display);\n\n            if (display) {\n                PRUint32 width, height, bitsPerPixel;\n                PRUint32 screenDataSize;\n                PRUint8 *screenData;\n                PRInt32 xOrigin, yOrigin;\n\n                rc = gVBoxAPI.UIDisplay.GetScreenResolution(display, screen,\n                                                            &width, &height,\n                                                            &bitsPerPixel,\n                                                            &xOrigin, &yOrigin);\n\n                if (NS_FAILED(rc) || !width || !height) {\n                    virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                                   _(\"unable to get screen resolution\"));\n                    goto endjob;\n                }\n\n                rc = gVBoxAPI.UIDisplay.TakeScreenShotPNGToArray(display, screen,\n                                                                 width, height,\n                                                                 &screenDataSize,\n                                                                 &screenData);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                                   _(\"failed to take screenshot\"));\n                    goto endjob;\n                }\n\n                if (safewrite(tmp_fd, (char *) screenData,\n                              screenDataSize) < 0) {\n                    virReportSystemError(errno, _(\"unable to write data \"\n                                                  \"to '%s'\"), tmp);\n                    goto endjob;\n                }\n\n                if (VIR_CLOSE(tmp_fd) < 0) {\n                    virReportSystemError(errno, _(\"unable to close %s\"), tmp);\n                    goto endjob;\n                }\n\n                ret = g_strdup(\"image/png\");\n\n                if (virFDStreamOpenFile(st, tmp, 0, 0, O_RDONLY) < 0) {\n                    virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                                   _(\"unable to open stream\"));\n                    VIR_FREE(ret);\n                }\n endjob:\n                VIR_FREE(screenData);\n                VBOX_RELEASE(display);\n            }\n            VBOX_RELEASE(console);\n        }\n        gVBoxAPI.UISession.Close(data->vboxSession);\n    }\n\n    VIR_FORCE_CLOSE(tmp_fd);\n    unlink(tmp);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 7454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 7453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "tmp"
          ],
          "line": 7452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "tmp_fd"
          ],
          "line": 7451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 7448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "console"
          ],
          "line": 7446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "display"
          ],
          "line": 7444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "screenData"
          ],
          "line": 7443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ret"
          ],
          "line": 7440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"unable to open stream\")"
          ],
          "line": 7438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to open stream\""
          ],
          "line": 7439
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFDStreamOpenFile",
          "args": [
            "st",
            "tmp",
            "0",
            "0",
            "O_RDONLY"
          ],
          "line": 7437
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamOpenFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1446-1456",
          "snippet": "int\nvirFDStreamOpenFile(virStreamPtr st G_GNUC_UNUSED,\n                    const char *path G_GNUC_UNUSED,\n                    unsigned long long offset G_GNUC_UNUSED,\n                    unsigned long long length G_GNUC_UNUSED,\n                    int oflags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamOpenFile(virStreamPtr st G_GNUC_UNUSED,\n                    const char *path G_GNUC_UNUSED,\n                    unsigned long long offset G_GNUC_UNUSED,\n                    unsigned long long length G_GNUC_UNUSED,\n                    int oflags G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"image/png\""
          ],
          "line": 7435
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to close %s\")",
            "tmp"
          ],
          "line": 7431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "tmp_fd"
          ],
          "line": 7430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to write data \"\n                                                  \"to '%s'\")",
            "tmp"
          ],
          "line": 7425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "tmp_fd",
            "(char *) screenData",
            "screenDataSize"
          ],
          "line": 7423
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"failed to take screenshot\")"
          ],
          "line": 7418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIDisplay.TakeScreenShotPNGToArray",
          "args": [
            "display",
            "screen",
            "width",
            "height",
            "&screenDataSize",
            "&screenData"
          ],
          "line": 7413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"unable to get screen resolution\")"
          ],
          "line": 7408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIDisplay.GetScreenResolution",
          "args": [
            "display",
            "screen",
            "&width",
            "&height",
            "&bitsPerPixel",
            "&xOrigin",
            "&yOrigin"
          ],
          "line": 7402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIConsole.GetDisplay",
          "args": [
            "console",
            "&display"
          ],
          "line": 7394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_SUCCEEDED",
          "args": [
            "rc"
          ],
          "line": 7391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetConsole",
          "args": [
            "data->vboxSession",
            "&console"
          ],
          "line": 7390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_SUCCEEDED",
          "args": [
            "rc"
          ],
          "line": 7389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.OpenExisting",
          "args": [
            "data",
            "&iid",
            "machine"
          ],
          "line": 7388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 7383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"g_mkstemp(\\\"%s\\\") failed\")",
            "tmp"
          ],
          "line": 7382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_mkstemp_full",
          "args": [
            "tmp",
            "O_RDWR | O_CLOEXEC",
            "S_IRUSR | S_IWUSR"
          ],
          "line": 7381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetUserCacheDirectory",
          "args": [],
          "line": 7376
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserCacheDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "584-591",
          "snippet": "char *virGetUserCacheDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_cache_dir());\n#else\n    return g_build_filename(g_get_user_cache_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserCacheDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_cache_dir());\n#else\n    return g_build_filename(g_get_user_cache_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 7369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"screen ID higher than monitor \"\n                         \"count (%d)\")",
            "max_screen"
          ],
          "line": 7366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 7361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"unable to get monitor count\")"
          ],
          "line": 7359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetMonitorCount",
          "args": [
            "machine",
            "&max_screen"
          ],
          "line": 7357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 7354
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 7352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 7346
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic char *\nvboxDomainScreenshot(virDomainPtr dom,\n                     virStreamPtr st,\n                     unsigned int screen,\n                     unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IConsole *console = NULL;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    nsresult rc;\n    g_autofree char *tmp = NULL;\n    g_autofree char *cacheDir = NULL;\n    int tmp_fd = -1;\n    unsigned int max_screen;\n    bool privileged = geteuid() == 0;\n    char *ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        return NULL;\n\n    rc = gVBoxAPI.UIMachine.GetMonitorCount(machine, &max_screen);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"unable to get monitor count\"));\n        VBOX_RELEASE(machine);\n        return NULL;\n    }\n\n    if (screen >= max_screen) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"screen ID higher than monitor \"\n                         \"count (%d)\"), max_screen);\n        VBOX_RELEASE(machine);\n        return NULL;\n    }\n\n    if (privileged) {\n        cacheDir = g_strdup_printf(\"%s/cache/libvirt\", LOCALSTATEDIR);\n    } else {\n        cacheDir = virGetUserCacheDirectory();\n    }\n\n    tmp = g_strdup_printf(\"%s/vbox.screendump.XXXXXX\", cacheDir);\n\n    if ((tmp_fd = g_mkstemp_full(tmp, O_RDWR | O_CLOEXEC, S_IRUSR | S_IWUSR)) == -1) {\n        virReportSystemError(errno, _(\"g_mkstemp(\\\"%s\\\") failed\"), tmp);\n        VBOX_RELEASE(machine);\n        return NULL;\n    }\n\n\n    rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    if (NS_SUCCEEDED(rc)) {\n        rc = gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n        if (NS_SUCCEEDED(rc) && console) {\n            IDisplay *display = NULL;\n\n            gVBoxAPI.UIConsole.GetDisplay(console, &display);\n\n            if (display) {\n                PRUint32 width, height, bitsPerPixel;\n                PRUint32 screenDataSize;\n                PRUint8 *screenData;\n                PRInt32 xOrigin, yOrigin;\n\n                rc = gVBoxAPI.UIDisplay.GetScreenResolution(display, screen,\n                                                            &width, &height,\n                                                            &bitsPerPixel,\n                                                            &xOrigin, &yOrigin);\n\n                if (NS_FAILED(rc) || !width || !height) {\n                    virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                                   _(\"unable to get screen resolution\"));\n                    goto endjob;\n                }\n\n                rc = gVBoxAPI.UIDisplay.TakeScreenShotPNGToArray(display, screen,\n                                                                 width, height,\n                                                                 &screenDataSize,\n                                                                 &screenData);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                                   _(\"failed to take screenshot\"));\n                    goto endjob;\n                }\n\n                if (safewrite(tmp_fd, (char *) screenData,\n                              screenDataSize) < 0) {\n                    virReportSystemError(errno, _(\"unable to write data \"\n                                                  \"to '%s'\"), tmp);\n                    goto endjob;\n                }\n\n                if (VIR_CLOSE(tmp_fd) < 0) {\n                    virReportSystemError(errno, _(\"unable to close %s\"), tmp);\n                    goto endjob;\n                }\n\n                ret = g_strdup(\"image/png\");\n\n                if (virFDStreamOpenFile(st, tmp, 0, 0, O_RDONLY) < 0) {\n                    virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                                   _(\"unable to open stream\"));\n                    VIR_FREE(ret);\n                }\n endjob:\n                VIR_FREE(screenData);\n                VBOX_RELEASE(display);\n            }\n            VBOX_RELEASE(console);\n        }\n        gVBoxAPI.UISession.Close(data->vboxSession);\n    }\n\n    VIR_FORCE_CLOSE(tmp_fd);\n    unlink(tmp);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSnapshotDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "7247-7329",
    "snippet": "static int vboxDomainSnapshotDelete(virDomainSnapshotPtr snapshot,\n                                    unsigned int flags)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    IConsole *console = NULL;\n    PRUint32 state;\n    nsresult rc;\n    vboxArray snapChildren = VBOX_ARRAY_INITIALIZER;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN |\n                  VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name);\n    if (!snap)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIMachine.GetState(machine, &state);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get domain state\"));\n        goto cleanup;\n    }\n\n    /* In case we just want to delete the metadata, we will edit the vbox file in order\n     *to remove the node concerning the snapshot\n    */\n    if (flags & VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY) {\n        rc = gVBoxAPI.UArray.vboxArrayGet(&snapChildren, snap,\n                             gVBoxAPI.UArray.handleSnapshotGetChildren(snap));\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not get snapshot children\"));\n            goto cleanup;\n        }\n        if (snapChildren.count != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot delete metadata of a snapshot with children\"));\n            goto cleanup;\n        } else if (gVBoxAPI.vboxSnapshotRedefine) {\n            ret = vboxDomainSnapshotDeleteMetadataOnly(snapshot);\n        }\n        goto cleanup;\n    }\n\n    if (gVBoxAPI.machineStateChecker.Online(state)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"cannot delete snapshots of running domain\"));\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UISession.Open(data, &domiid, machine);\n    if (NS_SUCCEEDED(rc))\n        rc = gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not open VirtualBox session with domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN)\n        ret = vboxDomainSnapshotDeleteTree(data, console, snap);\n    else\n        ret = vboxDomainSnapshotDeleteSingle(data, console, snap);\n\n cleanup:\n    VBOX_RELEASE(console);\n    VBOX_RELEASE(snap);\n    vboxIIDUnalloc(&domiid);\n    gVBoxAPI.UISession.Close(data->vboxSession);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 7327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&domiid"
          ],
          "line": 7326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "snap"
          ],
          "line": 7325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "console"
          ],
          "line": 7324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotDeleteSingle",
          "args": [
            "data",
            "console",
            "snap"
          ],
          "line": 7321
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotDeleteSingle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "6728-6773",
          "snippet": "static int\nvboxDomainSnapshotDeleteSingle(vboxDriverPtr data,\n                               IConsole *console,\n                               ISnapshot *snapshot)\n{\n    IProgress *progress = NULL;\n    vboxIID iid;\n    int ret = -1;\n    nsresult rc;\n    resultCodeUnion result;\n\n    VBOX_IID_INITIALIZE(&iid);\n    rc = gVBoxAPI.UISnapshot.GetId(snapshot, &iid);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get snapshot UUID\"));\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIConsole.DeleteSnapshot(console, &iid, &progress);\n    if (NS_FAILED(rc) || !progress) {\n        if (rc == VBOX_E_INVALID_VM_STATE) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot delete domain snapshot for running domain\"));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not delete snapshot\"));\n        }\n        goto cleanup;\n    }\n\n    gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n    gVBoxAPI.UIProgress.GetResultCode(progress, &result);\n    if (RC_FAILED(result)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not delete snapshot\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(progress);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDomainSnapshotDeleteSingle(vboxDriverPtr data,\n                               IConsole *console,\n                               ISnapshot *snapshot)\n{\n    IProgress *progress = NULL;\n    vboxIID iid;\n    int ret = -1;\n    nsresult rc;\n    resultCodeUnion result;\n\n    VBOX_IID_INITIALIZE(&iid);\n    rc = gVBoxAPI.UISnapshot.GetId(snapshot, &iid);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get snapshot UUID\"));\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIConsole.DeleteSnapshot(console, &iid, &progress);\n    if (NS_FAILED(rc) || !progress) {\n        if (rc == VBOX_E_INVALID_VM_STATE) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot delete domain snapshot for running domain\"));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not delete snapshot\"));\n        }\n        goto cleanup;\n    }\n\n    gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n    gVBoxAPI.UIProgress.GetResultCode(progress, &result);\n    if (RC_FAILED(result)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not delete snapshot\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(progress);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotDeleteTree",
          "args": [
            "data",
            "console",
            "snap"
          ],
          "line": 7319
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotDeleteTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "6775-6803",
          "snippet": "static int\nvboxDomainSnapshotDeleteTree(vboxDriverPtr data,\n                             IConsole *console,\n                             ISnapshot *snapshot)\n{\n    vboxArray children = VBOX_ARRAY_INITIALIZER;\n    int ret = -1;\n    nsresult rc;\n    size_t i;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&children, snapshot,\n                  gVBoxAPI.UArray.handleSnapshotGetChildren(snapshot));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get children snapshots\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < children.count; i++) {\n        if (vboxDomainSnapshotDeleteTree(data, console, children.items[i]))\n            goto cleanup;\n    }\n\n    ret = vboxDomainSnapshotDeleteSingle(data, console, snapshot);\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&children);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDomainSnapshotDeleteTree(vboxDriverPtr data,\n                             IConsole *console,\n                             ISnapshot *snapshot)\n{\n    vboxArray children = VBOX_ARRAY_INITIALIZER;\n    int ret = -1;\n    nsresult rc;\n    size_t i;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&children, snapshot,\n                  gVBoxAPI.UArray.handleSnapshotGetChildren(snapshot));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get children snapshots\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < children.count; i++) {\n        if (vboxDomainSnapshotDeleteTree(data, console, children.items[i]))\n            goto cleanup;\n    }\n\n    ret = vboxDomainSnapshotDeleteSingle(data, console, snapshot);\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&children);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not open VirtualBox session with domain %s\")",
            "dom->name"
          ],
          "line": 7312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not open VirtualBox session with domain %s\""
          ],
          "line": 7313
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetConsole",
          "args": [
            "data->vboxSession",
            "&console"
          ],
          "line": 7310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_SUCCEEDED",
          "args": [
            "rc"
          ],
          "line": 7309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Open",
          "args": [
            "data",
            "&domiid",
            "machine"
          ],
          "line": 7308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"cannot delete snapshots of running domain\")"
          ],
          "line": 7303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Online",
          "args": [
            "state"
          ],
          "line": 7302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotDeleteMetadataOnly",
          "args": [
            "snapshot"
          ],
          "line": 7297
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotDeleteMetadataOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "6805-7245",
          "snippet": "static int\nvboxDomainSnapshotDeleteMetadataOnly(virDomainSnapshotPtr snapshot)\n{\n    /*\n     * This function will remove the node in the vbox xml corresponding to the snapshot.\n     * It is usually called by vboxDomainSnapshotDelete() with the flag\n     * VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY.\n     * If you want to use it anywhere else, be careful, if the snapshot you want to delete\n     * has children, the result is not granted, they will probably will be deleted in the\n     * xml, but you may have a problem with hard drives.\n     *\n     * If the snapshot which is being deleted is the current one, we will set the current\n     * snapshot of the machine to the parent of this snapshot. Before writing the modified\n     * xml file, we undefine the machine from vbox. After writing the file, we redefine\n     * the machine with the new file.\n     */\n\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    virDomainSnapshotDefPtr def = NULL;\n    char *defXml = NULL;\n    vboxIID domiid;\n    nsresult rc;\n    IMachine *machine = NULL;\n    PRUnichar *settingsFilePathUtf16 = NULL;\n    char *settingsFilepath = NULL;\n    virVBoxSnapshotConfMachinePtr snapshotMachineDesc = NULL;\n    int isCurrent = -1;\n    char **searchResultTab = NULL;\n    ssize_t resultSize = 0;\n    int it = 0;\n    PRUnichar *machineNameUtf16 = NULL;\n    char *machineName = NULL;\n    char *nameTmpUse = NULL;\n    char *machineLocationPath = NULL;\n    PRUint32 aMediaSize = 0;\n    IMedium **aMedia = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&domiid);\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    defXml = vboxDomainSnapshotGetXMLDesc(snapshot, 0);\n    if (!defXml) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get XML Desc of snapshot\"));\n        goto cleanup;\n    }\n    def = virDomainSnapshotDefParseString(defXml,\n                                          data->xmlopt, NULL, NULL,\n                                          VIR_DOMAIN_SNAPSHOT_PARSE_DISKS |\n                                          VIR_DOMAIN_SNAPSHOT_PARSE_REDEFINE);\n    if (!def) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get a virDomainSnapshotDefPtr\"));\n        goto cleanup;\n    }\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n    rc = gVBoxAPI.UIMachine.GetSettingsFilePath(machine, &settingsFilePathUtf16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get settings file path\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(settingsFilePathUtf16, &settingsFilepath);\n\n    /* Getting the machine name to retrieve the machine location path. */\n    rc = gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get machine name\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineName);\n    nameTmpUse = g_strdup_printf(\"%s.vbox\", machineName);\n    machineLocationPath = virStringReplace(settingsFilepath, nameTmpUse, \"\");\n    if (machineLocationPath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get the machine location path\"));\n        goto cleanup;\n    }\n    snapshotMachineDesc = virVBoxSnapshotConfLoadVboxFile(settingsFilepath, machineLocationPath);\n    if (!snapshotMachineDesc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot create a vboxSnapshotXmlPtr\"));\n        goto cleanup;\n    }\n\n    isCurrent = virVBoxSnapshotConfIsCurrentSnapshot(snapshotMachineDesc, def->parent.name);\n    if (isCurrent < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to know if the snapshot is the current snapshot\"));\n        goto cleanup;\n    }\n    if (isCurrent) {\n        /*\n         * If the snapshot is the current snapshot, it means that the machine has read-write\n         * disks. The first thing to do is to manipulate VirtualBox API to create\n         * differential read-write disks if the parent snapshot is not null.\n         */\n        if (def->parent.parent_name != NULL) {\n            for (it = 0; it < def->parent.dom->ndisks; it++) {\n                virVBoxSnapshotConfHardDiskPtr readOnly = NULL;\n                IMedium *medium = NULL;\n                PRUnichar *locationUtf16 = NULL;\n                char *parentUuid = NULL;\n                IMedium *newMedium = NULL;\n                PRUnichar *formatUtf16 = NULL;\n                PRUnichar *newLocation = NULL;\n                char *newLocationUtf8 = NULL;\n                IProgress *progress = NULL;\n                virVBoxSnapshotConfHardDiskPtr disk = NULL;\n                char *uuid = NULL;\n                char *format = NULL;\n                char *tmp = NULL;\n                vboxIID iid, parentiid;\n                resultCodeUnion resultCode;\n\n                VBOX_IID_INITIALIZE(&iid);\n                VBOX_IID_INITIALIZE(&parentiid);\n                readOnly = virVBoxSnapshotConfHardDiskPtrByLocation(snapshotMachineDesc,\n                                                 def->parent.dom->disks[it]->src->path);\n                if (!readOnly) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Cannot get hard disk by location\"));\n                    goto cleanup;\n                }\n                if (readOnly->parent == NULL) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"The read only disk has no parent\"));\n                    goto cleanup;\n                }\n\n                VBOX_UTF8_TO_UTF16(readOnly->parent->location, &locationUtf16);\n                rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                      locationUtf16,\n                                                      DeviceType_HardDisk,\n                                                      AccessMode_ReadWrite,\n                                                      &medium);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to open HardDisk, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n\n                rc = gVBoxAPI.UIMedium.GetId(medium, &parentiid);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to get hardDisk Id, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n                gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n                vboxIIDUnalloc(&parentiid);\n                VBOX_UTF16_FREE(locationUtf16);\n                VBOX_UTF8_TO_UTF16(\"VDI\", &formatUtf16);\n\n                newLocationUtf8 = g_strdup_printf(\"%sfakedisk-%s-%d.vdi\",\n                                                  machineLocationPath, def->parent.parent_name, it);\n                VBOX_UTF8_TO_UTF16(newLocationUtf8, &newLocation);\n                rc = gVBoxAPI.UIVirtualBox.CreateHardDisk(data->vboxObj,\n                                                          formatUtf16,\n                                                          newLocation,\n                                                          &newMedium);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to create HardDisk, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n                VBOX_UTF16_FREE(formatUtf16);\n                VBOX_UTF16_FREE(newLocation);\n\n                PRUint32 tab[1];\n                tab[0] = MediumVariant_Diff;\n                gVBoxAPI.UIMedium.CreateDiffStorage(medium, newMedium, 1, tab, &progress);\n\n                gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n                gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n                if (RC_FAILED(resultCode)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Error while creating diff storage, rc=%08x\"),\n                                   resultCode.uResultCode);\n                    goto cleanup;\n                }\n                VBOX_RELEASE(progress);\n                /*\n                 * The differential disk is created, we add it to the media registry and\n                 * the machine storage controller.\n                 */\n\n                if (VIR_ALLOC(disk) < 0)\n                    goto cleanup;\n\n                rc = gVBoxAPI.UIMedium.GetId(newMedium, &iid);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to get medium uuid, rc=%08x\"),\n                                   (unsigned)rc);\n                    VIR_FREE(disk);\n                    goto cleanup;\n                }\n                gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n                disk->uuid = uuid;\n                vboxIIDUnalloc(&iid);\n\n                disk->location = g_strdup(newLocationUtf8);\n\n                rc = gVBoxAPI.UIMedium.GetFormat(newMedium, &formatUtf16);\n                VBOX_UTF16_TO_UTF8(formatUtf16, &format);\n                disk->format = format;\n                VBOX_UTF16_FREE(formatUtf16);\n\n                if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(disk,\n                                               snapshotMachineDesc->mediaRegistry,\n                                               parentUuid) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Unable to add hard disk to the media registry\"));\n                    goto cleanup;\n                }\n                /* Adding fake disks to the machine storage controllers */\n\n                resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                             VBOX_UUID_REGEX,\n                                             it + 1,\n                                             &searchResultTab);\n                if (resultSize != it + 1) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to find UUID %s\"), searchResultTab[it]);\n                    goto cleanup;\n                }\n\n                tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                       searchResultTab[it],\n                                       disk->uuid);\n                VIR_FREE(snapshotMachineDesc->storageController);\n                if (!tmp)\n                    goto cleanup;\n                snapshotMachineDesc->storageController = g_strdup(tmp);\n\n                VIR_FREE(tmp);\n                /* Closing the \"fake\" disk */\n                rc = gVBoxAPI.UIMedium.Close(newMedium);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to close the new medium, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n            }\n        } else {\n            for (it = 0; it < def->parent.dom->ndisks; it++) {\n                const char *uuidRO = NULL;\n                char *tmp = NULL;\n                uuidRO = virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                      def->parent.dom->disks[it]->src->path);\n                if (!uuidRO) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"No such disk in media registry %s\"),\n                                   def->parent.dom->disks[it]->src->path);\n                    goto cleanup;\n                }\n\n                resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                             VBOX_UUID_REGEX,\n                                             it + 1,\n                                             &searchResultTab);\n                if (resultSize != it + 1) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to find UUID %s\"),\n                                   searchResultTab[it]);\n                    goto cleanup;\n                }\n\n                tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                       searchResultTab[it],\n                                       uuidRO);\n                VIR_FREE(snapshotMachineDesc->storageController);\n                if (!tmp)\n                    goto cleanup;\n                snapshotMachineDesc->storageController = g_strdup(tmp);\n\n                VIR_FREE(tmp);\n            }\n        }\n    }\n    /* We remove the read write disks from the media registry */\n    for (it = 0; it < def->ndisks; it++) {\n        const char *uuidRW =\n            virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                      def->disks[it].src->path);\n        if (!uuidRW) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to find UUID for location %s\"), def->disks[it].src->path);\n            goto cleanup;\n        }\n        if (virVBoxSnapshotConfRemoveHardDisk(snapshotMachineDesc->mediaRegistry, uuidRW) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to remove disk from media registry. uuid = %s\"), uuidRW);\n            goto cleanup;\n        }\n    }\n    /* If the parent snapshot is not NULL, we remove the-read only disks from the media registry */\n    if (def->parent.parent_name != NULL) {\n        for (it = 0; it < def->parent.dom->ndisks; it++) {\n            const char *uuidRO =\n                virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                          def->parent.dom->disks[it]->src->path);\n            if (!uuidRO) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to find UUID for location %s\"), def->parent.dom->disks[it]->src->path);\n                goto cleanup;\n            }\n            if (virVBoxSnapshotConfRemoveHardDisk(snapshotMachineDesc->mediaRegistry, uuidRO) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to remove disk from media registry. uuid = %s\"), uuidRO);\n                goto cleanup;\n            }\n        }\n    }\n    rc = gVBoxAPI.UIMachine.Unregister(machine,\n                                       CleanupMode_DetachAllReturnHardDisksOnly,\n                                       &aMediaSize,\n                                       &aMedia);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to unregister machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n    VBOX_RELEASE(machine);\n    for (it = 0; it < aMediaSize; it++) {\n        IMedium *medium = aMedia[it];\n        PRUnichar *locationUtf16 = NULL;\n        char *locationUtf8 = NULL;\n\n        if (!medium)\n            continue;\n\n        rc = gVBoxAPI.UIMedium.GetLocation(medium, &locationUtf16);\n        VBOX_UTF16_TO_UTF8(locationUtf16, &locationUtf8);\n        if (isCurrent && strstr(locationUtf8, \"fake\") != NULL) {\n            /* we delete the fake disk because we don't need it anymore */\n            IProgress *progress = NULL;\n            resultCodeUnion resultCode;\n            rc = gVBoxAPI.UIMedium.DeleteStorage(medium, &progress);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to delete medium, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n            gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n            if (RC_FAILED(resultCode)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Error while closing medium, rc=%08x\"),\n                               resultCode.uResultCode);\n                goto cleanup;\n            }\n            VBOX_RELEASE(progress);\n        } else {\n            /* This a comment from vboxmanage code in the handleUnregisterVM\n             * function in VBoxManageMisc.cpp :\n             * Note that the IMachine::Unregister method will return the medium\n             * reference in a sane order, which means that closing will normally\n             * succeed, unless there is still another machine which uses the\n             * medium. No harm done if we ignore the error. */\n            ignore_value(gVBoxAPI.UIMedium.Close(medium));\n        }\n        VBOX_UTF16_FREE(locationUtf16);\n        VBOX_UTF8_FREE(locationUtf8);\n    }\n\n    /* removing the snapshot */\n    if (virVBoxSnapshotConfRemoveSnapshot(snapshotMachineDesc, def->parent.name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to remove snapshot %s\"), def->parent.name);\n        goto cleanup;\n    }\n\n    if (isCurrent) {\n        VIR_FREE(snapshotMachineDesc->currentSnapshot);\n        if (def->parent.parent_name != NULL) {\n            virVBoxSnapshotConfSnapshotPtr snap = virVBoxSnapshotConfSnapshotByName(snapshotMachineDesc->snapshot, def->parent.parent_name);\n            if (!snap) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get the snapshot to remove\"));\n                goto cleanup;\n            }\n            snapshotMachineDesc->currentSnapshot = g_strdup(snap->uuid);\n        }\n    }\n\n    /* Registering the machine */\n    if (virVBoxSnapshotConfSaveVboxFile(snapshotMachineDesc, settingsFilepath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to serialize the machine description\"));\n        goto cleanup;\n    }\n    rc = gVBoxAPI.UIVirtualBox.OpenMachine(data->vboxObj,\n                                           settingsFilePathUtf16,\n                                           &machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to open Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIVirtualBox.RegisterMachine(data->vboxObj, machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to register Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(def);\n    VIR_FREE(defXml);\n    VBOX_RELEASE(machine);\n    VBOX_UTF16_FREE(settingsFilePathUtf16);\n    VBOX_UTF8_FREE(settingsFilepath);\n    virStringListFree(searchResultTab);\n    VIR_FREE(snapshotMachineDesc);\n    VBOX_UTF16_FREE(machineNameUtf16);\n    VBOX_UTF8_FREE(machineName);\n    VIR_FREE(machineLocationPath);\n    VIR_FREE(nameTmpUse);\n\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDomainSnapshotDeleteMetadataOnly(virDomainSnapshotPtr snapshot)\n{\n    /*\n     * This function will remove the node in the vbox xml corresponding to the snapshot.\n     * It is usually called by vboxDomainSnapshotDelete() with the flag\n     * VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY.\n     * If you want to use it anywhere else, be careful, if the snapshot you want to delete\n     * has children, the result is not granted, they will probably will be deleted in the\n     * xml, but you may have a problem with hard drives.\n     *\n     * If the snapshot which is being deleted is the current one, we will set the current\n     * snapshot of the machine to the parent of this snapshot. Before writing the modified\n     * xml file, we undefine the machine from vbox. After writing the file, we redefine\n     * the machine with the new file.\n     */\n\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    virDomainSnapshotDefPtr def = NULL;\n    char *defXml = NULL;\n    vboxIID domiid;\n    nsresult rc;\n    IMachine *machine = NULL;\n    PRUnichar *settingsFilePathUtf16 = NULL;\n    char *settingsFilepath = NULL;\n    virVBoxSnapshotConfMachinePtr snapshotMachineDesc = NULL;\n    int isCurrent = -1;\n    char **searchResultTab = NULL;\n    ssize_t resultSize = 0;\n    int it = 0;\n    PRUnichar *machineNameUtf16 = NULL;\n    char *machineName = NULL;\n    char *nameTmpUse = NULL;\n    char *machineLocationPath = NULL;\n    PRUint32 aMediaSize = 0;\n    IMedium **aMedia = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&domiid);\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    defXml = vboxDomainSnapshotGetXMLDesc(snapshot, 0);\n    if (!defXml) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get XML Desc of snapshot\"));\n        goto cleanup;\n    }\n    def = virDomainSnapshotDefParseString(defXml,\n                                          data->xmlopt, NULL, NULL,\n                                          VIR_DOMAIN_SNAPSHOT_PARSE_DISKS |\n                                          VIR_DOMAIN_SNAPSHOT_PARSE_REDEFINE);\n    if (!def) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get a virDomainSnapshotDefPtr\"));\n        goto cleanup;\n    }\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n    rc = gVBoxAPI.UIMachine.GetSettingsFilePath(machine, &settingsFilePathUtf16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get settings file path\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(settingsFilePathUtf16, &settingsFilepath);\n\n    /* Getting the machine name to retrieve the machine location path. */\n    rc = gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get machine name\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineName);\n    nameTmpUse = g_strdup_printf(\"%s.vbox\", machineName);\n    machineLocationPath = virStringReplace(settingsFilepath, nameTmpUse, \"\");\n    if (machineLocationPath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get the machine location path\"));\n        goto cleanup;\n    }\n    snapshotMachineDesc = virVBoxSnapshotConfLoadVboxFile(settingsFilepath, machineLocationPath);\n    if (!snapshotMachineDesc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot create a vboxSnapshotXmlPtr\"));\n        goto cleanup;\n    }\n\n    isCurrent = virVBoxSnapshotConfIsCurrentSnapshot(snapshotMachineDesc, def->parent.name);\n    if (isCurrent < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to know if the snapshot is the current snapshot\"));\n        goto cleanup;\n    }\n    if (isCurrent) {\n        /*\n         * If the snapshot is the current snapshot, it means that the machine has read-write\n         * disks. The first thing to do is to manipulate VirtualBox API to create\n         * differential read-write disks if the parent snapshot is not null.\n         */\n        if (def->parent.parent_name != NULL) {\n            for (it = 0; it < def->parent.dom->ndisks; it++) {\n                virVBoxSnapshotConfHardDiskPtr readOnly = NULL;\n                IMedium *medium = NULL;\n                PRUnichar *locationUtf16 = NULL;\n                char *parentUuid = NULL;\n                IMedium *newMedium = NULL;\n                PRUnichar *formatUtf16 = NULL;\n                PRUnichar *newLocation = NULL;\n                char *newLocationUtf8 = NULL;\n                IProgress *progress = NULL;\n                virVBoxSnapshotConfHardDiskPtr disk = NULL;\n                char *uuid = NULL;\n                char *format = NULL;\n                char *tmp = NULL;\n                vboxIID iid, parentiid;\n                resultCodeUnion resultCode;\n\n                VBOX_IID_INITIALIZE(&iid);\n                VBOX_IID_INITIALIZE(&parentiid);\n                readOnly = virVBoxSnapshotConfHardDiskPtrByLocation(snapshotMachineDesc,\n                                                 def->parent.dom->disks[it]->src->path);\n                if (!readOnly) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Cannot get hard disk by location\"));\n                    goto cleanup;\n                }\n                if (readOnly->parent == NULL) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"The read only disk has no parent\"));\n                    goto cleanup;\n                }\n\n                VBOX_UTF8_TO_UTF16(readOnly->parent->location, &locationUtf16);\n                rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                      locationUtf16,\n                                                      DeviceType_HardDisk,\n                                                      AccessMode_ReadWrite,\n                                                      &medium);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to open HardDisk, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n\n                rc = gVBoxAPI.UIMedium.GetId(medium, &parentiid);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to get hardDisk Id, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n                gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n                vboxIIDUnalloc(&parentiid);\n                VBOX_UTF16_FREE(locationUtf16);\n                VBOX_UTF8_TO_UTF16(\"VDI\", &formatUtf16);\n\n                newLocationUtf8 = g_strdup_printf(\"%sfakedisk-%s-%d.vdi\",\n                                                  machineLocationPath, def->parent.parent_name, it);\n                VBOX_UTF8_TO_UTF16(newLocationUtf8, &newLocation);\n                rc = gVBoxAPI.UIVirtualBox.CreateHardDisk(data->vboxObj,\n                                                          formatUtf16,\n                                                          newLocation,\n                                                          &newMedium);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to create HardDisk, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n                VBOX_UTF16_FREE(formatUtf16);\n                VBOX_UTF16_FREE(newLocation);\n\n                PRUint32 tab[1];\n                tab[0] = MediumVariant_Diff;\n                gVBoxAPI.UIMedium.CreateDiffStorage(medium, newMedium, 1, tab, &progress);\n\n                gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n                gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n                if (RC_FAILED(resultCode)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Error while creating diff storage, rc=%08x\"),\n                                   resultCode.uResultCode);\n                    goto cleanup;\n                }\n                VBOX_RELEASE(progress);\n                /*\n                 * The differential disk is created, we add it to the media registry and\n                 * the machine storage controller.\n                 */\n\n                if (VIR_ALLOC(disk) < 0)\n                    goto cleanup;\n\n                rc = gVBoxAPI.UIMedium.GetId(newMedium, &iid);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to get medium uuid, rc=%08x\"),\n                                   (unsigned)rc);\n                    VIR_FREE(disk);\n                    goto cleanup;\n                }\n                gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n                disk->uuid = uuid;\n                vboxIIDUnalloc(&iid);\n\n                disk->location = g_strdup(newLocationUtf8);\n\n                rc = gVBoxAPI.UIMedium.GetFormat(newMedium, &formatUtf16);\n                VBOX_UTF16_TO_UTF8(formatUtf16, &format);\n                disk->format = format;\n                VBOX_UTF16_FREE(formatUtf16);\n\n                if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(disk,\n                                               snapshotMachineDesc->mediaRegistry,\n                                               parentUuid) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Unable to add hard disk to the media registry\"));\n                    goto cleanup;\n                }\n                /* Adding fake disks to the machine storage controllers */\n\n                resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                             VBOX_UUID_REGEX,\n                                             it + 1,\n                                             &searchResultTab);\n                if (resultSize != it + 1) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to find UUID %s\"), searchResultTab[it]);\n                    goto cleanup;\n                }\n\n                tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                       searchResultTab[it],\n                                       disk->uuid);\n                VIR_FREE(snapshotMachineDesc->storageController);\n                if (!tmp)\n                    goto cleanup;\n                snapshotMachineDesc->storageController = g_strdup(tmp);\n\n                VIR_FREE(tmp);\n                /* Closing the \"fake\" disk */\n                rc = gVBoxAPI.UIMedium.Close(newMedium);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to close the new medium, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n            }\n        } else {\n            for (it = 0; it < def->parent.dom->ndisks; it++) {\n                const char *uuidRO = NULL;\n                char *tmp = NULL;\n                uuidRO = virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                      def->parent.dom->disks[it]->src->path);\n                if (!uuidRO) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"No such disk in media registry %s\"),\n                                   def->parent.dom->disks[it]->src->path);\n                    goto cleanup;\n                }\n\n                resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                             VBOX_UUID_REGEX,\n                                             it + 1,\n                                             &searchResultTab);\n                if (resultSize != it + 1) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to find UUID %s\"),\n                                   searchResultTab[it]);\n                    goto cleanup;\n                }\n\n                tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                       searchResultTab[it],\n                                       uuidRO);\n                VIR_FREE(snapshotMachineDesc->storageController);\n                if (!tmp)\n                    goto cleanup;\n                snapshotMachineDesc->storageController = g_strdup(tmp);\n\n                VIR_FREE(tmp);\n            }\n        }\n    }\n    /* We remove the read write disks from the media registry */\n    for (it = 0; it < def->ndisks; it++) {\n        const char *uuidRW =\n            virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                      def->disks[it].src->path);\n        if (!uuidRW) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to find UUID for location %s\"), def->disks[it].src->path);\n            goto cleanup;\n        }\n        if (virVBoxSnapshotConfRemoveHardDisk(snapshotMachineDesc->mediaRegistry, uuidRW) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to remove disk from media registry. uuid = %s\"), uuidRW);\n            goto cleanup;\n        }\n    }\n    /* If the parent snapshot is not NULL, we remove the-read only disks from the media registry */\n    if (def->parent.parent_name != NULL) {\n        for (it = 0; it < def->parent.dom->ndisks; it++) {\n            const char *uuidRO =\n                virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                          def->parent.dom->disks[it]->src->path);\n            if (!uuidRO) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to find UUID for location %s\"), def->parent.dom->disks[it]->src->path);\n                goto cleanup;\n            }\n            if (virVBoxSnapshotConfRemoveHardDisk(snapshotMachineDesc->mediaRegistry, uuidRO) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to remove disk from media registry. uuid = %s\"), uuidRO);\n                goto cleanup;\n            }\n        }\n    }\n    rc = gVBoxAPI.UIMachine.Unregister(machine,\n                                       CleanupMode_DetachAllReturnHardDisksOnly,\n                                       &aMediaSize,\n                                       &aMedia);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to unregister machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n    VBOX_RELEASE(machine);\n    for (it = 0; it < aMediaSize; it++) {\n        IMedium *medium = aMedia[it];\n        PRUnichar *locationUtf16 = NULL;\n        char *locationUtf8 = NULL;\n\n        if (!medium)\n            continue;\n\n        rc = gVBoxAPI.UIMedium.GetLocation(medium, &locationUtf16);\n        VBOX_UTF16_TO_UTF8(locationUtf16, &locationUtf8);\n        if (isCurrent && strstr(locationUtf8, \"fake\") != NULL) {\n            /* we delete the fake disk because we don't need it anymore */\n            IProgress *progress = NULL;\n            resultCodeUnion resultCode;\n            rc = gVBoxAPI.UIMedium.DeleteStorage(medium, &progress);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to delete medium, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n            gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n            if (RC_FAILED(resultCode)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Error while closing medium, rc=%08x\"),\n                               resultCode.uResultCode);\n                goto cleanup;\n            }\n            VBOX_RELEASE(progress);\n        } else {\n            /* This a comment from vboxmanage code in the handleUnregisterVM\n             * function in VBoxManageMisc.cpp :\n             * Note that the IMachine::Unregister method will return the medium\n             * reference in a sane order, which means that closing will normally\n             * succeed, unless there is still another machine which uses the\n             * medium. No harm done if we ignore the error. */\n            ignore_value(gVBoxAPI.UIMedium.Close(medium));\n        }\n        VBOX_UTF16_FREE(locationUtf16);\n        VBOX_UTF8_FREE(locationUtf8);\n    }\n\n    /* removing the snapshot */\n    if (virVBoxSnapshotConfRemoveSnapshot(snapshotMachineDesc, def->parent.name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to remove snapshot %s\"), def->parent.name);\n        goto cleanup;\n    }\n\n    if (isCurrent) {\n        VIR_FREE(snapshotMachineDesc->currentSnapshot);\n        if (def->parent.parent_name != NULL) {\n            virVBoxSnapshotConfSnapshotPtr snap = virVBoxSnapshotConfSnapshotByName(snapshotMachineDesc->snapshot, def->parent.parent_name);\n            if (!snap) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get the snapshot to remove\"));\n                goto cleanup;\n            }\n            snapshotMachineDesc->currentSnapshot = g_strdup(snap->uuid);\n        }\n    }\n\n    /* Registering the machine */\n    if (virVBoxSnapshotConfSaveVboxFile(snapshotMachineDesc, settingsFilepath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to serialize the machine description\"));\n        goto cleanup;\n    }\n    rc = gVBoxAPI.UIVirtualBox.OpenMachine(data->vboxObj,\n                                           settingsFilePathUtf16,\n                                           &machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to open Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIVirtualBox.RegisterMachine(data->vboxObj, machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to register Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(def);\n    VIR_FREE(defXml);\n    VBOX_RELEASE(machine);\n    VBOX_UTF16_FREE(settingsFilePathUtf16);\n    VBOX_UTF8_FREE(settingsFilepath);\n    virStringListFree(searchResultTab);\n    VIR_FREE(snapshotMachineDesc);\n    VBOX_UTF16_FREE(machineNameUtf16);\n    VBOX_UTF8_FREE(machineName);\n    VIR_FREE(machineLocationPath);\n    VIR_FREE(nameTmpUse);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot delete metadata of a snapshot with children\")"
          ],
          "line": 7293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get snapshot children\")"
          ],
          "line": 7288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&snapChildren",
            "snap",
            "gVBoxAPI.UArray.handleSnapshotGetChildren(snap)"
          ],
          "line": 7285
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleSnapshotGetChildren",
          "args": [
            "snap"
          ],
          "line": 7286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get domain state\")"
          ],
          "line": 7276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 7274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotGet",
          "args": [
            "data",
            "dom",
            "machine",
            "snapshot->name"
          ],
          "line": 7270
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "5606-5654",
          "snippet": "static ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&domiid",
            "&machine"
          ],
          "line": 7267
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN |\n                  VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY",
            "-1"
          ],
          "line": 7264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainSnapshotDelete(virDomainSnapshotPtr snapshot,\n                                    unsigned int flags)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    IConsole *console = NULL;\n    PRUint32 state;\n    nsresult rc;\n    vboxArray snapChildren = VBOX_ARRAY_INITIALIZER;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN |\n                  VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name);\n    if (!snap)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIMachine.GetState(machine, &state);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get domain state\"));\n        goto cleanup;\n    }\n\n    /* In case we just want to delete the metadata, we will edit the vbox file in order\n     *to remove the node concerning the snapshot\n    */\n    if (flags & VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY) {\n        rc = gVBoxAPI.UArray.vboxArrayGet(&snapChildren, snap,\n                             gVBoxAPI.UArray.handleSnapshotGetChildren(snap));\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not get snapshot children\"));\n            goto cleanup;\n        }\n        if (snapChildren.count != 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot delete metadata of a snapshot with children\"));\n            goto cleanup;\n        } else if (gVBoxAPI.vboxSnapshotRedefine) {\n            ret = vboxDomainSnapshotDeleteMetadataOnly(snapshot);\n        }\n        goto cleanup;\n    }\n\n    if (gVBoxAPI.machineStateChecker.Online(state)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"cannot delete snapshots of running domain\"));\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UISession.Open(data, &domiid, machine);\n    if (NS_SUCCEEDED(rc))\n        rc = gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not open VirtualBox session with domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN)\n        ret = vboxDomainSnapshotDeleteTree(data, console, snap);\n    else\n        ret = vboxDomainSnapshotDeleteSingle(data, console, snap);\n\n cleanup:\n    VBOX_RELEASE(console);\n    VBOX_RELEASE(snap);\n    vboxIIDUnalloc(&domiid);\n    gVBoxAPI.UISession.Close(data->vboxSession);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSnapshotDeleteMetadataOnly",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "6805-7245",
    "snippet": "static int\nvboxDomainSnapshotDeleteMetadataOnly(virDomainSnapshotPtr snapshot)\n{\n    /*\n     * This function will remove the node in the vbox xml corresponding to the snapshot.\n     * It is usually called by vboxDomainSnapshotDelete() with the flag\n     * VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY.\n     * If you want to use it anywhere else, be careful, if the snapshot you want to delete\n     * has children, the result is not granted, they will probably will be deleted in the\n     * xml, but you may have a problem with hard drives.\n     *\n     * If the snapshot which is being deleted is the current one, we will set the current\n     * snapshot of the machine to the parent of this snapshot. Before writing the modified\n     * xml file, we undefine the machine from vbox. After writing the file, we redefine\n     * the machine with the new file.\n     */\n\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    virDomainSnapshotDefPtr def = NULL;\n    char *defXml = NULL;\n    vboxIID domiid;\n    nsresult rc;\n    IMachine *machine = NULL;\n    PRUnichar *settingsFilePathUtf16 = NULL;\n    char *settingsFilepath = NULL;\n    virVBoxSnapshotConfMachinePtr snapshotMachineDesc = NULL;\n    int isCurrent = -1;\n    char **searchResultTab = NULL;\n    ssize_t resultSize = 0;\n    int it = 0;\n    PRUnichar *machineNameUtf16 = NULL;\n    char *machineName = NULL;\n    char *nameTmpUse = NULL;\n    char *machineLocationPath = NULL;\n    PRUint32 aMediaSize = 0;\n    IMedium **aMedia = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&domiid);\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    defXml = vboxDomainSnapshotGetXMLDesc(snapshot, 0);\n    if (!defXml) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get XML Desc of snapshot\"));\n        goto cleanup;\n    }\n    def = virDomainSnapshotDefParseString(defXml,\n                                          data->xmlopt, NULL, NULL,\n                                          VIR_DOMAIN_SNAPSHOT_PARSE_DISKS |\n                                          VIR_DOMAIN_SNAPSHOT_PARSE_REDEFINE);\n    if (!def) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get a virDomainSnapshotDefPtr\"));\n        goto cleanup;\n    }\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n    rc = gVBoxAPI.UIMachine.GetSettingsFilePath(machine, &settingsFilePathUtf16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get settings file path\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(settingsFilePathUtf16, &settingsFilepath);\n\n    /* Getting the machine name to retrieve the machine location path. */\n    rc = gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get machine name\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineName);\n    nameTmpUse = g_strdup_printf(\"%s.vbox\", machineName);\n    machineLocationPath = virStringReplace(settingsFilepath, nameTmpUse, \"\");\n    if (machineLocationPath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get the machine location path\"));\n        goto cleanup;\n    }\n    snapshotMachineDesc = virVBoxSnapshotConfLoadVboxFile(settingsFilepath, machineLocationPath);\n    if (!snapshotMachineDesc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot create a vboxSnapshotXmlPtr\"));\n        goto cleanup;\n    }\n\n    isCurrent = virVBoxSnapshotConfIsCurrentSnapshot(snapshotMachineDesc, def->parent.name);\n    if (isCurrent < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to know if the snapshot is the current snapshot\"));\n        goto cleanup;\n    }\n    if (isCurrent) {\n        /*\n         * If the snapshot is the current snapshot, it means that the machine has read-write\n         * disks. The first thing to do is to manipulate VirtualBox API to create\n         * differential read-write disks if the parent snapshot is not null.\n         */\n        if (def->parent.parent_name != NULL) {\n            for (it = 0; it < def->parent.dom->ndisks; it++) {\n                virVBoxSnapshotConfHardDiskPtr readOnly = NULL;\n                IMedium *medium = NULL;\n                PRUnichar *locationUtf16 = NULL;\n                char *parentUuid = NULL;\n                IMedium *newMedium = NULL;\n                PRUnichar *formatUtf16 = NULL;\n                PRUnichar *newLocation = NULL;\n                char *newLocationUtf8 = NULL;\n                IProgress *progress = NULL;\n                virVBoxSnapshotConfHardDiskPtr disk = NULL;\n                char *uuid = NULL;\n                char *format = NULL;\n                char *tmp = NULL;\n                vboxIID iid, parentiid;\n                resultCodeUnion resultCode;\n\n                VBOX_IID_INITIALIZE(&iid);\n                VBOX_IID_INITIALIZE(&parentiid);\n                readOnly = virVBoxSnapshotConfHardDiskPtrByLocation(snapshotMachineDesc,\n                                                 def->parent.dom->disks[it]->src->path);\n                if (!readOnly) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Cannot get hard disk by location\"));\n                    goto cleanup;\n                }\n                if (readOnly->parent == NULL) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"The read only disk has no parent\"));\n                    goto cleanup;\n                }\n\n                VBOX_UTF8_TO_UTF16(readOnly->parent->location, &locationUtf16);\n                rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                      locationUtf16,\n                                                      DeviceType_HardDisk,\n                                                      AccessMode_ReadWrite,\n                                                      &medium);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to open HardDisk, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n\n                rc = gVBoxAPI.UIMedium.GetId(medium, &parentiid);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to get hardDisk Id, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n                gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n                vboxIIDUnalloc(&parentiid);\n                VBOX_UTF16_FREE(locationUtf16);\n                VBOX_UTF8_TO_UTF16(\"VDI\", &formatUtf16);\n\n                newLocationUtf8 = g_strdup_printf(\"%sfakedisk-%s-%d.vdi\",\n                                                  machineLocationPath, def->parent.parent_name, it);\n                VBOX_UTF8_TO_UTF16(newLocationUtf8, &newLocation);\n                rc = gVBoxAPI.UIVirtualBox.CreateHardDisk(data->vboxObj,\n                                                          formatUtf16,\n                                                          newLocation,\n                                                          &newMedium);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to create HardDisk, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n                VBOX_UTF16_FREE(formatUtf16);\n                VBOX_UTF16_FREE(newLocation);\n\n                PRUint32 tab[1];\n                tab[0] = MediumVariant_Diff;\n                gVBoxAPI.UIMedium.CreateDiffStorage(medium, newMedium, 1, tab, &progress);\n\n                gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n                gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n                if (RC_FAILED(resultCode)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Error while creating diff storage, rc=%08x\"),\n                                   resultCode.uResultCode);\n                    goto cleanup;\n                }\n                VBOX_RELEASE(progress);\n                /*\n                 * The differential disk is created, we add it to the media registry and\n                 * the machine storage controller.\n                 */\n\n                if (VIR_ALLOC(disk) < 0)\n                    goto cleanup;\n\n                rc = gVBoxAPI.UIMedium.GetId(newMedium, &iid);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to get medium uuid, rc=%08x\"),\n                                   (unsigned)rc);\n                    VIR_FREE(disk);\n                    goto cleanup;\n                }\n                gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n                disk->uuid = uuid;\n                vboxIIDUnalloc(&iid);\n\n                disk->location = g_strdup(newLocationUtf8);\n\n                rc = gVBoxAPI.UIMedium.GetFormat(newMedium, &formatUtf16);\n                VBOX_UTF16_TO_UTF8(formatUtf16, &format);\n                disk->format = format;\n                VBOX_UTF16_FREE(formatUtf16);\n\n                if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(disk,\n                                               snapshotMachineDesc->mediaRegistry,\n                                               parentUuid) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Unable to add hard disk to the media registry\"));\n                    goto cleanup;\n                }\n                /* Adding fake disks to the machine storage controllers */\n\n                resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                             VBOX_UUID_REGEX,\n                                             it + 1,\n                                             &searchResultTab);\n                if (resultSize != it + 1) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to find UUID %s\"), searchResultTab[it]);\n                    goto cleanup;\n                }\n\n                tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                       searchResultTab[it],\n                                       disk->uuid);\n                VIR_FREE(snapshotMachineDesc->storageController);\n                if (!tmp)\n                    goto cleanup;\n                snapshotMachineDesc->storageController = g_strdup(tmp);\n\n                VIR_FREE(tmp);\n                /* Closing the \"fake\" disk */\n                rc = gVBoxAPI.UIMedium.Close(newMedium);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to close the new medium, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n            }\n        } else {\n            for (it = 0; it < def->parent.dom->ndisks; it++) {\n                const char *uuidRO = NULL;\n                char *tmp = NULL;\n                uuidRO = virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                      def->parent.dom->disks[it]->src->path);\n                if (!uuidRO) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"No such disk in media registry %s\"),\n                                   def->parent.dom->disks[it]->src->path);\n                    goto cleanup;\n                }\n\n                resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                             VBOX_UUID_REGEX,\n                                             it + 1,\n                                             &searchResultTab);\n                if (resultSize != it + 1) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to find UUID %s\"),\n                                   searchResultTab[it]);\n                    goto cleanup;\n                }\n\n                tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                       searchResultTab[it],\n                                       uuidRO);\n                VIR_FREE(snapshotMachineDesc->storageController);\n                if (!tmp)\n                    goto cleanup;\n                snapshotMachineDesc->storageController = g_strdup(tmp);\n\n                VIR_FREE(tmp);\n            }\n        }\n    }\n    /* We remove the read write disks from the media registry */\n    for (it = 0; it < def->ndisks; it++) {\n        const char *uuidRW =\n            virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                      def->disks[it].src->path);\n        if (!uuidRW) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to find UUID for location %s\"), def->disks[it].src->path);\n            goto cleanup;\n        }\n        if (virVBoxSnapshotConfRemoveHardDisk(snapshotMachineDesc->mediaRegistry, uuidRW) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to remove disk from media registry. uuid = %s\"), uuidRW);\n            goto cleanup;\n        }\n    }\n    /* If the parent snapshot is not NULL, we remove the-read only disks from the media registry */\n    if (def->parent.parent_name != NULL) {\n        for (it = 0; it < def->parent.dom->ndisks; it++) {\n            const char *uuidRO =\n                virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                          def->parent.dom->disks[it]->src->path);\n            if (!uuidRO) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to find UUID for location %s\"), def->parent.dom->disks[it]->src->path);\n                goto cleanup;\n            }\n            if (virVBoxSnapshotConfRemoveHardDisk(snapshotMachineDesc->mediaRegistry, uuidRO) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to remove disk from media registry. uuid = %s\"), uuidRO);\n                goto cleanup;\n            }\n        }\n    }\n    rc = gVBoxAPI.UIMachine.Unregister(machine,\n                                       CleanupMode_DetachAllReturnHardDisksOnly,\n                                       &aMediaSize,\n                                       &aMedia);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to unregister machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n    VBOX_RELEASE(machine);\n    for (it = 0; it < aMediaSize; it++) {\n        IMedium *medium = aMedia[it];\n        PRUnichar *locationUtf16 = NULL;\n        char *locationUtf8 = NULL;\n\n        if (!medium)\n            continue;\n\n        rc = gVBoxAPI.UIMedium.GetLocation(medium, &locationUtf16);\n        VBOX_UTF16_TO_UTF8(locationUtf16, &locationUtf8);\n        if (isCurrent && strstr(locationUtf8, \"fake\") != NULL) {\n            /* we delete the fake disk because we don't need it anymore */\n            IProgress *progress = NULL;\n            resultCodeUnion resultCode;\n            rc = gVBoxAPI.UIMedium.DeleteStorage(medium, &progress);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to delete medium, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n            gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n            if (RC_FAILED(resultCode)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Error while closing medium, rc=%08x\"),\n                               resultCode.uResultCode);\n                goto cleanup;\n            }\n            VBOX_RELEASE(progress);\n        } else {\n            /* This a comment from vboxmanage code in the handleUnregisterVM\n             * function in VBoxManageMisc.cpp :\n             * Note that the IMachine::Unregister method will return the medium\n             * reference in a sane order, which means that closing will normally\n             * succeed, unless there is still another machine which uses the\n             * medium. No harm done if we ignore the error. */\n            ignore_value(gVBoxAPI.UIMedium.Close(medium));\n        }\n        VBOX_UTF16_FREE(locationUtf16);\n        VBOX_UTF8_FREE(locationUtf8);\n    }\n\n    /* removing the snapshot */\n    if (virVBoxSnapshotConfRemoveSnapshot(snapshotMachineDesc, def->parent.name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to remove snapshot %s\"), def->parent.name);\n        goto cleanup;\n    }\n\n    if (isCurrent) {\n        VIR_FREE(snapshotMachineDesc->currentSnapshot);\n        if (def->parent.parent_name != NULL) {\n            virVBoxSnapshotConfSnapshotPtr snap = virVBoxSnapshotConfSnapshotByName(snapshotMachineDesc->snapshot, def->parent.parent_name);\n            if (!snap) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get the snapshot to remove\"));\n                goto cleanup;\n            }\n            snapshotMachineDesc->currentSnapshot = g_strdup(snap->uuid);\n        }\n    }\n\n    /* Registering the machine */\n    if (virVBoxSnapshotConfSaveVboxFile(snapshotMachineDesc, settingsFilepath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to serialize the machine description\"));\n        goto cleanup;\n    }\n    rc = gVBoxAPI.UIVirtualBox.OpenMachine(data->vboxObj,\n                                           settingsFilePathUtf16,\n                                           &machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to open Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIVirtualBox.RegisterMachine(data->vboxObj, machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to register Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(def);\n    VIR_FREE(defXml);\n    VBOX_RELEASE(machine);\n    VBOX_UTF16_FREE(settingsFilePathUtf16);\n    VBOX_UTF8_FREE(settingsFilepath);\n    virStringListFree(searchResultTab);\n    VIR_FREE(snapshotMachineDesc);\n    VBOX_UTF16_FREE(machineNameUtf16);\n    VBOX_UTF8_FREE(machineName);\n    VIR_FREE(machineLocationPath);\n    VIR_FREE(nameTmpUse);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nameTmpUse"
          ],
          "line": 7242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machineLocationPath"
          ],
          "line": 7241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "machineName"
          ],
          "line": 7240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "machineNameUtf16"
          ],
          "line": 7239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshotMachineDesc"
          ],
          "line": 7238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "searchResultTab"
          ],
          "line": 7237
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "settingsFilepath"
          ],
          "line": 7236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "settingsFilePathUtf16"
          ],
          "line": 7235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 7234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "defXml"
          ],
          "line": 7233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def"
          ],
          "line": 7232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to register Machine, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 7224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to register Machine, rc=%08x\""
          ],
          "line": 7225
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.RegisterMachine",
          "args": [
            "data->vboxObj",
            "machine"
          ],
          "line": 7222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to open Machine, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 7216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.OpenMachine",
          "args": [
            "data->vboxObj",
            "settingsFilePathUtf16",
            "&machine"
          ],
          "line": 7212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to serialize the machine description\")"
          ],
          "line": 7208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfSaveVboxFile",
          "args": [
            "snapshotMachineDesc",
            "settingsFilepath"
          ],
          "line": 7207
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfSaveVboxFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "968-1217",
          "snippet": "int\nvirVBoxSnapshotConfSaveVboxFile(virVBoxSnapshotConfMachinePtr machine,\n                                const char *filePath)\n{\n    int ret = -1;\n    size_t i = 0;\n    xmlDocPtr xml = NULL;\n    xmlNodePtr mediaRegistryNode = NULL;\n    xmlNodePtr snapshotNode = NULL;\n    xmlNodePtr machineNode = NULL;\n    xmlNodePtr hardDisksNode = NULL;\n    xmlNodePtr cur = NULL;\n    xmlParserErrors parseError = XML_ERR_OK;\n    char *currentSnapshot = NULL;\n    char *timeStamp = NULL;\n\n    char **firstRegex = NULL;\n    int firstRegexResult = 0;\n    char **secondRegex = NULL;\n    int secondRegexResult = 0;\n\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Machine is null\"));\n        goto cleanup;\n    }\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Filepath is null\"));\n        goto cleanup;\n    }\n    xml = xmlNewDoc(BAD_CAST \"1.0\");\n    if (!xml) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    cur = xmlNewNode(NULL, BAD_CAST \"VirtualBox\");\n    if (!cur) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlNewProp(cur, BAD_CAST \"version\", BAD_CAST \"1.12-linux\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (xmlNewProp(cur,\n                   BAD_CAST \"xmlns\",\n                   BAD_CAST \"http://www.innotek.de/VirtualBox-settings\") == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    xmlDocSetRootElement(xml, cur);\n\n    cur = xmlNewDocComment(xml,\n                           BAD_CAST \"WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE\\n\"\n                           \"OVERWRITTEN AND LOST.\\n\"\n                           \"Changes to this xml configuration should be made using Virtualbox\\n\"\n                           \"or other application using the libvirt API\");\n    if (!cur) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlAddPrevSibling(xmlDocGetRootElement(xml), cur)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlAddPrevSibling\"));\n        goto cleanup;\n    }\n\n    machineNode = xmlNewNode(NULL, BAD_CAST \"Machine\");\n    if (!machineNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlNewProp(machineNode, BAD_CAST \"uuid\", BAD_CAST machine->uuid)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"name\", BAD_CAST machine->name)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    if (machine->currentSnapshot != NULL) {\n        currentSnapshot = g_strdup_printf(\"{%s}\", machine->currentSnapshot);\n        if (!xmlNewProp(machineNode, BAD_CAST \"currentSnapshot\", BAD_CAST currentSnapshot)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Error in xmlNewProp\"));\n            goto cleanup;\n        }\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"snapshotFolder\", BAD_CAST machine->snapshotFolder)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"currentStateModified\",\n               BAD_CAST(machine->currentStateModified == 0 ? \"false\" : \"true\"))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"OSType\", BAD_CAST \"Other\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    firstRegexResult = virStringSearch(machine->lastStateChange,\n                                       \"([0-9]{4}-[0-9]{2}-[0-9]{2})\",\n                                       1,\n                                       &firstRegex);\n    secondRegexResult = virStringSearch(machine->lastStateChange,\n                                        \"([0-9]{2}:[0-9]{2}:[0-9]{2})\",\n                                        1,\n                                        &secondRegex);\n    if (firstRegexResult < 1)\n        goto cleanup;\n    if (secondRegexResult < 1)\n        goto cleanup;\n\n    timeStamp = g_strdup_printf(\"%sT%sZ\", firstRegex[0], secondRegex[0]);\n    if (!xmlNewProp(machineNode, BAD_CAST \"lastStateChange\", BAD_CAST timeStamp)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    xmlAddChild(xmlDocGetRootElement(xml), machineNode);\n\n    mediaRegistryNode = xmlNewNode(NULL, BAD_CAST \"MediaRegistry\");\n    if (!mediaRegistryNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    xmlAddChild(machineNode, mediaRegistryNode);\n    for (i = 0; i < machine->mediaRegistry->notherMedia; i++) {\n        parseError = xmlParseInNodeContext(mediaRegistryNode,\n                              machine->mediaRegistry->otherMedia[i],\n                              (int)strlen(machine->mediaRegistry->otherMedia[i]),\n                              0,\n                              &cur);\n        if (parseError != XML_ERR_OK) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Unable to add media registry other media\"));\n            goto cleanup;\n        }\n        xmlAddChild(mediaRegistryNode, cur);\n    }\n    hardDisksNode = xmlNewNode(NULL, BAD_CAST \"HardDisks\");\n    if (!hardDisksNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        xmlNodePtr child = virVBoxSnapshotConfCreateHardDiskNode(machine->mediaRegistry->disks[i]);\n        if (child != NULL)\n            xmlAddChild(hardDisksNode, child);\n    }\n    xmlAddChild(mediaRegistryNode, hardDisksNode);\n\n    parseError = xmlParseInNodeContext(machineNode,\n                                       machine->hardware,\n                                       (int)strlen(machine->hardware),\n                                       0,\n                                       &cur);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add hardware machine\"));\n        goto cleanup;\n    }\n    xmlAddChild(machineNode, cur);\n\n    if (machine->extraData != NULL) {\n        parseError = xmlParseInNodeContext(xmlDocGetRootElement(xml),\n                                           machine->extraData,\n                                           (int)strlen(machine->extraData),\n                                           0,\n                                           &cur);\n        if (parseError != XML_ERR_OK) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Unable to add extra data\"));\n            goto cleanup;\n        }\n        xmlAddChild(machineNode, cur);\n    }\n\n    parseError = xmlParseInNodeContext(machineNode,\n                                       machine->storageController,\n                                       (int)strlen(machine->storageController),\n                                       0,\n                                       &cur);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add storage controller\"));\n        goto cleanup;\n    }\n    xmlAddChild(machineNode, cur);\n\n    if (machine->snapshot != NULL) {\n        snapshotNode = xmlNewNode(NULL, BAD_CAST \"Snapshot\");\n        xmlAddChild(machineNode, snapshotNode);\n        if (virVBoxSnapshotConfSerializeSnapshot(snapshotNode, machine->snapshot) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Failed to serialize snapshot\"));\n            goto cleanup;\n        }\n    }\n\n    if (xmlSaveFormatFileEnc(filePath, xml, \"ISO-8859-1\", 1) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to save the xml\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(currentSnapshot);\n    VIR_FREE(timeStamp);\n\n    xmlUnlinkNode(hardDisksNode);\n    xmlFreeNode(hardDisksNode);\n\n    xmlUnlinkNode(mediaRegistryNode);\n    xmlFreeNode(mediaRegistryNode);\n\n    xmlUnlinkNode(snapshotNode);\n    xmlFreeNode(snapshotNode);\n\n    xmlUnlinkNode(cur);\n    xmlFreeNode(cur);\n\n    xmlUnlinkNode(machineNode);\n    xmlFreeNode(machineNode);\n\n    xmlFreeDoc(xml);\n\n    virStringListFree(firstRegex);\n    virStringListFree(secondRegex);\n    return ret;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfSaveVboxFile(virVBoxSnapshotConfMachinePtr machine,\n                                const char *filePath)\n{\n    int ret = -1;\n    size_t i = 0;\n    xmlDocPtr xml = NULL;\n    xmlNodePtr mediaRegistryNode = NULL;\n    xmlNodePtr snapshotNode = NULL;\n    xmlNodePtr machineNode = NULL;\n    xmlNodePtr hardDisksNode = NULL;\n    xmlNodePtr cur = NULL;\n    xmlParserErrors parseError = XML_ERR_OK;\n    char *currentSnapshot = NULL;\n    char *timeStamp = NULL;\n\n    char **firstRegex = NULL;\n    int firstRegexResult = 0;\n    char **secondRegex = NULL;\n    int secondRegexResult = 0;\n\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Machine is null\"));\n        goto cleanup;\n    }\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Filepath is null\"));\n        goto cleanup;\n    }\n    xml = xmlNewDoc(BAD_CAST \"1.0\");\n    if (!xml) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    cur = xmlNewNode(NULL, BAD_CAST \"VirtualBox\");\n    if (!cur) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlNewProp(cur, BAD_CAST \"version\", BAD_CAST \"1.12-linux\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (xmlNewProp(cur,\n                   BAD_CAST \"xmlns\",\n                   BAD_CAST \"http://www.innotek.de/VirtualBox-settings\") == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    xmlDocSetRootElement(xml, cur);\n\n    cur = xmlNewDocComment(xml,\n                           BAD_CAST \"WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE\\n\"\n                           \"OVERWRITTEN AND LOST.\\n\"\n                           \"Changes to this xml configuration should be made using Virtualbox\\n\"\n                           \"or other application using the libvirt API\");\n    if (!cur) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlAddPrevSibling(xmlDocGetRootElement(xml), cur)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlAddPrevSibling\"));\n        goto cleanup;\n    }\n\n    machineNode = xmlNewNode(NULL, BAD_CAST \"Machine\");\n    if (!machineNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlNewProp(machineNode, BAD_CAST \"uuid\", BAD_CAST machine->uuid)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"name\", BAD_CAST machine->name)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    if (machine->currentSnapshot != NULL) {\n        currentSnapshot = g_strdup_printf(\"{%s}\", machine->currentSnapshot);\n        if (!xmlNewProp(machineNode, BAD_CAST \"currentSnapshot\", BAD_CAST currentSnapshot)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Error in xmlNewProp\"));\n            goto cleanup;\n        }\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"snapshotFolder\", BAD_CAST machine->snapshotFolder)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"currentStateModified\",\n               BAD_CAST(machine->currentStateModified == 0 ? \"false\" : \"true\"))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"OSType\", BAD_CAST \"Other\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    firstRegexResult = virStringSearch(machine->lastStateChange,\n                                       \"([0-9]{4}-[0-9]{2}-[0-9]{2})\",\n                                       1,\n                                       &firstRegex);\n    secondRegexResult = virStringSearch(machine->lastStateChange,\n                                        \"([0-9]{2}:[0-9]{2}:[0-9]{2})\",\n                                        1,\n                                        &secondRegex);\n    if (firstRegexResult < 1)\n        goto cleanup;\n    if (secondRegexResult < 1)\n        goto cleanup;\n\n    timeStamp = g_strdup_printf(\"%sT%sZ\", firstRegex[0], secondRegex[0]);\n    if (!xmlNewProp(machineNode, BAD_CAST \"lastStateChange\", BAD_CAST timeStamp)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    xmlAddChild(xmlDocGetRootElement(xml), machineNode);\n\n    mediaRegistryNode = xmlNewNode(NULL, BAD_CAST \"MediaRegistry\");\n    if (!mediaRegistryNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    xmlAddChild(machineNode, mediaRegistryNode);\n    for (i = 0; i < machine->mediaRegistry->notherMedia; i++) {\n        parseError = xmlParseInNodeContext(mediaRegistryNode,\n                              machine->mediaRegistry->otherMedia[i],\n                              (int)strlen(machine->mediaRegistry->otherMedia[i]),\n                              0,\n                              &cur);\n        if (parseError != XML_ERR_OK) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Unable to add media registry other media\"));\n            goto cleanup;\n        }\n        xmlAddChild(mediaRegistryNode, cur);\n    }\n    hardDisksNode = xmlNewNode(NULL, BAD_CAST \"HardDisks\");\n    if (!hardDisksNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        xmlNodePtr child = virVBoxSnapshotConfCreateHardDiskNode(machine->mediaRegistry->disks[i]);\n        if (child != NULL)\n            xmlAddChild(hardDisksNode, child);\n    }\n    xmlAddChild(mediaRegistryNode, hardDisksNode);\n\n    parseError = xmlParseInNodeContext(machineNode,\n                                       machine->hardware,\n                                       (int)strlen(machine->hardware),\n                                       0,\n                                       &cur);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add hardware machine\"));\n        goto cleanup;\n    }\n    xmlAddChild(machineNode, cur);\n\n    if (machine->extraData != NULL) {\n        parseError = xmlParseInNodeContext(xmlDocGetRootElement(xml),\n                                           machine->extraData,\n                                           (int)strlen(machine->extraData),\n                                           0,\n                                           &cur);\n        if (parseError != XML_ERR_OK) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Unable to add extra data\"));\n            goto cleanup;\n        }\n        xmlAddChild(machineNode, cur);\n    }\n\n    parseError = xmlParseInNodeContext(machineNode,\n                                       machine->storageController,\n                                       (int)strlen(machine->storageController),\n                                       0,\n                                       &cur);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add storage controller\"));\n        goto cleanup;\n    }\n    xmlAddChild(machineNode, cur);\n\n    if (machine->snapshot != NULL) {\n        snapshotNode = xmlNewNode(NULL, BAD_CAST \"Snapshot\");\n        xmlAddChild(machineNode, snapshotNode);\n        if (virVBoxSnapshotConfSerializeSnapshot(snapshotNode, machine->snapshot) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Failed to serialize snapshot\"));\n            goto cleanup;\n        }\n    }\n\n    if (xmlSaveFormatFileEnc(filePath, xml, \"ISO-8859-1\", 1) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to save the xml\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(currentSnapshot);\n    VIR_FREE(timeStamp);\n\n    xmlUnlinkNode(hardDisksNode);\n    xmlFreeNode(hardDisksNode);\n\n    xmlUnlinkNode(mediaRegistryNode);\n    xmlFreeNode(mediaRegistryNode);\n\n    xmlUnlinkNode(snapshotNode);\n    xmlFreeNode(snapshotNode);\n\n    xmlUnlinkNode(cur);\n    xmlFreeNode(cur);\n\n    xmlUnlinkNode(machineNode);\n    xmlFreeNode(machineNode);\n\n    xmlFreeDoc(xml);\n\n    virStringListFree(firstRegex);\n    virStringListFree(secondRegex);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "snap->uuid"
          ],
          "line": 7202
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get the snapshot to remove\")"
          ],
          "line": 7198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfSnapshotByName",
          "args": [
            "snapshotMachineDesc->snapshot",
            "def->parent.parent_name"
          ],
          "line": 7196
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfSnapshotByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "278-292",
          "snippet": "virVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfSnapshotByName(virVBoxSnapshotConfSnapshotPtr snapshot,\n                                  const char *snapshotName)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfSnapshotPtr ret = NULL;\n    if (STREQ(snapshot->name, snapshotName))\n        return snapshot;\n    for (i = 0; i < snapshot->nchildren; i++) {\n        ret = virVBoxSnapshotConfSnapshotByName(snapshot->children[i], snapshotName);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvirVBoxSnapshotConfSnapshotPtr\nvirVBoxSnapshotConfSnapshotByName(virVBoxSnapshotConfSnapshotPtr snapshot,\n                                  const char *snapshotName)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfSnapshotPtr ret = NULL;\n    if (STREQ(snapshot->name, snapshotName))\n        return snapshot;\n    for (i = 0; i < snapshot->nchildren; i++) {\n        ret = virVBoxSnapshotConfSnapshotByName(snapshot->children[i], snapshotName);\n        if (ret != NULL)\n            return ret;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshotMachineDesc->currentSnapshot"
          ],
          "line": 7194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to remove snapshot %s\")",
            "def->parent.name"
          ],
          "line": 7188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfRemoveSnapshot",
          "args": [
            "snapshotMachineDesc",
            "def->parent.name"
          ],
          "line": 7187
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfRemoveSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "849-904",
          "snippet": "int\nvirVBoxSnapshotConfRemoveSnapshot(virVBoxSnapshotConfMachinePtr machine,\n                                  const char *snapshotName)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfSnapshotPtr snapshot = NULL;\n    virVBoxSnapshotConfSnapshotPtr parentSnapshot = NULL;\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"machine is null\"));\n        return -1;\n    }\n    if (snapshotName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"snapshotName is null\"));\n        return -1;\n    }\n    if (machine->snapshot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"the machine has no snapshot\"));\n        return -1;\n    }\n    snapshot = virVBoxSnapshotConfSnapshotByName(machine->snapshot, snapshotName);\n    if (snapshot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find the snapshot with name %s\"), snapshotName);\n        return -1;\n    }\n    if (snapshot->nchildren > 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"This snapshot has children, \"\n                         \"please delete theses snapshots before\"));\n        return -1;\n    }\n\n    if (snapshot->parent == NULL) {\n        if (machine->snapshot != snapshot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"You are trying to remove a snapshot which does not exists\"));\n            return -1;\n        }\n        machine->snapshot = NULL;\n        virVBoxSnapshotConfSnapshotFree(snapshot);\n\n        return 0;\n    }\n    parentSnapshot = snapshot->parent;\n\n    snapshot->parent = NULL;\n    while (i < parentSnapshot->nchildren && parentSnapshot->children[i] != snapshot)\n        ++i;\n    if (VIR_DELETE_ELEMENT(parentSnapshot->children, i, parentSnapshot->nchildren) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfRemoveSnapshot(virVBoxSnapshotConfMachinePtr machine,\n                                  const char *snapshotName)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfSnapshotPtr snapshot = NULL;\n    virVBoxSnapshotConfSnapshotPtr parentSnapshot = NULL;\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"machine is null\"));\n        return -1;\n    }\n    if (snapshotName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"snapshotName is null\"));\n        return -1;\n    }\n    if (machine->snapshot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"the machine has no snapshot\"));\n        return -1;\n    }\n    snapshot = virVBoxSnapshotConfSnapshotByName(machine->snapshot, snapshotName);\n    if (snapshot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find the snapshot with name %s\"), snapshotName);\n        return -1;\n    }\n    if (snapshot->nchildren > 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"This snapshot has children, \"\n                         \"please delete theses snapshots before\"));\n        return -1;\n    }\n\n    if (snapshot->parent == NULL) {\n        if (machine->snapshot != snapshot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"You are trying to remove a snapshot which does not exists\"));\n            return -1;\n        }\n        machine->snapshot = NULL;\n        virVBoxSnapshotConfSnapshotFree(snapshot);\n\n        return 0;\n    }\n    parentSnapshot = snapshot->parent;\n\n    snapshot->parent = NULL;\n    while (i < parentSnapshot->nchildren && parentSnapshot->children[i] != snapshot)\n        ++i;\n    if (VIR_DELETE_ELEMENT(parentSnapshot->children, i, parentSnapshot->nchildren) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "locationUtf8"
          ],
          "line": 7183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "locationUtf16"
          ],
          "line": 7182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "gVBoxAPI.UIMedium.Close(medium)"
          ],
          "line": 7180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.Close",
          "args": [
            "medium"
          ],
          "line": 7180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "progress"
          ],
          "line": 7172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Error while closing medium, rc=%08x\")",
            "resultCode.uResultCode"
          ],
          "line": 7167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RC_FAILED",
          "args": [
            "resultCode"
          ],
          "line": 7166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.GetResultCode",
          "args": [
            "progress",
            "&resultCode"
          ],
          "line": 7165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.WaitForCompletion",
          "args": [
            "progress",
            "-1"
          ],
          "line": 7164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to delete medium, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 7159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.DeleteStorage",
          "args": [
            "medium",
            "&progress"
          ],
          "line": 7157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "locationUtf8",
            "\"fake\""
          ],
          "line": 7153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "locationUtf16",
            "&locationUtf8"
          ],
          "line": 7152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetLocation",
          "args": [
            "medium",
            "&locationUtf16"
          ],
          "line": 7151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 7142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to unregister machine, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 7137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.Unregister",
          "args": [
            "machine",
            "CleanupMode_DetachAllReturnHardDisksOnly",
            "&aMediaSize",
            "&aMedia"
          ],
          "line": 7132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to remove disk from media registry. uuid = %s\")",
            "uuidRO"
          ],
          "line": 7126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfRemoveHardDisk",
          "args": [
            "snapshotMachineDesc->mediaRegistry",
            "uuidRO"
          ],
          "line": 7125
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfRemoveHardDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "912-961",
          "snippet": "int\nvirVBoxSnapshotConfRemoveHardDisk(virVBoxSnapshotConfMediaRegistryPtr mediaRegistry,\n                                  const char *uuid)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    virVBoxSnapshotConfHardDiskPtr parentHardDisk = NULL;\n    if (mediaRegistry == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Media registry is null\"));\n        return -1;\n    }\n    if (uuid == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Uuid is null\"));\n        return -1;\n    }\n\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskById(mediaRegistry->disks[i], uuid);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find the hard disk with uuid %s\"), uuid);\n        return -1;\n    }\n    if (hardDisk->parent == NULL) {\n        /* it means that the hard disk is in 'root' */\n        for (i = 0; i < mediaRegistry->ndisks; i++) {\n            if (hardDisk == mediaRegistry->disks[i])\n                break;\n        }\n        if (VIR_DELETE_ELEMENT(mediaRegistry->disks, i, mediaRegistry->ndisks) < 0)\n            return -1;\n\n        return 0;\n    }\n\n    parentHardDisk = hardDisk->parent;\n    i = 0;\n    while (i < parentHardDisk->nchildren && parentHardDisk->children[i] != hardDisk)\n        ++i;\n    hardDisk->parent = NULL;\n    if (VIR_DELETE_ELEMENT(parentHardDisk->children, i, parentHardDisk->nchildren) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfRemoveHardDisk(virVBoxSnapshotConfMediaRegistryPtr mediaRegistry,\n                                  const char *uuid)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    virVBoxSnapshotConfHardDiskPtr parentHardDisk = NULL;\n    if (mediaRegistry == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Media registry is null\"));\n        return -1;\n    }\n    if (uuid == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Uuid is null\"));\n        return -1;\n    }\n\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskById(mediaRegistry->disks[i], uuid);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find the hard disk with uuid %s\"), uuid);\n        return -1;\n    }\n    if (hardDisk->parent == NULL) {\n        /* it means that the hard disk is in 'root' */\n        for (i = 0; i < mediaRegistry->ndisks; i++) {\n            if (hardDisk == mediaRegistry->disks[i])\n                break;\n        }\n        if (VIR_DELETE_ELEMENT(mediaRegistry->disks, i, mediaRegistry->ndisks) < 0)\n            return -1;\n\n        return 0;\n    }\n\n    parentHardDisk = hardDisk->parent;\n    i = 0;\n    while (i < parentHardDisk->nchildren && parentHardDisk->children[i] != hardDisk)\n        ++i;\n    hardDisk->parent = NULL;\n    if (VIR_DELETE_ELEMENT(parentHardDisk->children, i, parentHardDisk->nchildren) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to find UUID for location %s\")",
            "def->parent.dom->disks[it]->src->path"
          ],
          "line": 7121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfHardDiskUuidByLocation",
          "args": [
            "snapshotMachineDesc",
            "def->parent.dom->disks[it]->src->path"
          ],
          "line": 7118
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfHardDiskUuidByLocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "1374-1388",
          "snippet": "const char *\nvirVBoxSnapshotConfHardDiskUuidByLocation(virVBoxSnapshotConfMachinePtr machine,\n                                          const char *location)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[i], location);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL)\n        return NULL;\n    return hardDisk->uuid;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nconst char *\nvirVBoxSnapshotConfHardDiskUuidByLocation(virVBoxSnapshotConfMachinePtr machine,\n                                          const char *location)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[i], location);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL)\n        return NULL;\n    return hardDisk->uuid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to remove disk from media registry. uuid = %s\")",
            "uuidRW"
          ],
          "line": 7109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to find UUID for location %s\")",
            "def->disks[it].src->path"
          ],
          "line": 7104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 7094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshotMachineDesc->storageController"
          ],
          "line": 7089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringReplace",
          "args": [
            "snapshotMachineDesc->storageController",
            "searchResultTab[it]",
            "uuidRO"
          ],
          "line": 7086
        },
        "resolved": true,
        "details": {
          "function_name": "virStringReplace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1067-1095",
          "snippet": "char *\nvirStringReplace(const char *haystack,\n                 const char *oldneedle,\n                 const char *newneedle)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *tmp1, *tmp2;\n    size_t oldneedlelen = strlen(oldneedle);\n    size_t newneedlelen = strlen(newneedle);\n\n    tmp1 = haystack;\n    tmp2 = NULL;\n\n    while (tmp1) {\n        tmp2 = strstr(tmp1, oldneedle);\n\n        if (tmp2) {\n            virBufferAdd(&buf, tmp1, (tmp2 - tmp1));\n            virBufferAdd(&buf, newneedle, newneedlelen);\n            tmp2 += oldneedlelen;\n        } else {\n            virBufferAdd(&buf, tmp1, -1);\n        }\n\n        tmp1 = tmp2;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar *\nvirStringReplace(const char *haystack,\n                 const char *oldneedle,\n                 const char *newneedle)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *tmp1, *tmp2;\n    size_t oldneedlelen = strlen(oldneedle);\n    size_t newneedlelen = strlen(newneedle);\n\n    tmp1 = haystack;\n    tmp2 = NULL;\n\n    while (tmp1) {\n        tmp2 = strstr(tmp1, oldneedle);\n\n        if (tmp2) {\n            virBufferAdd(&buf, tmp1, (tmp2 - tmp1));\n            virBufferAdd(&buf, newneedle, newneedlelen);\n            tmp2 += oldneedlelen;\n        } else {\n            virBufferAdd(&buf, tmp1, -1);\n        }\n\n        tmp1 = tmp2;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to find UUID %s\")",
            "searchResultTab[it]"
          ],
          "line": 7080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSearch",
          "args": [
            "snapshotMachineDesc->storageController",
            "VBOX_UUID_REGEX",
            "it + 1",
            "&searchResultTab"
          ],
          "line": 7075
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "965-1029",
          "snippet": "ssize_t\nvirStringSearch(const char *str,\n                const char *regexp,\n                size_t max_matches,\n                char ***matches)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    size_t nmatches = 0;\n    ssize_t ret = -1;\n\n    *matches = NULL;\n\n    VIR_DEBUG(\"search '%s' for '%s'\", str, regexp);\n\n    regex = g_regex_new(regexp, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (g_regex_get_capture_count(regex) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Regular expression '%s' must have exactly 1 match group, not %d\"),\n                       regexp, g_regex_get_capture_count(regex));\n        goto cleanup;\n    }\n\n    /* '*matches' must always be NULL terminated in every iteration\n     * of the loop, so start by allocating 1 element\n     */\n    if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n        goto cleanup;\n\n    while ((nmatches - 1) < max_matches) {\n        g_autoptr(GMatchInfo) info = NULL;\n        char *match;\n        int endpos;\n\n        if (!g_regex_match(regex, str, 0, &info))\n            break;\n\n        if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n            goto cleanup;\n\n        match = g_match_info_fetch(info, 1);\n\n        VIR_DEBUG(\"Got '%s'\", match);\n\n        (*matches)[nmatches-2] = match;\n\n        g_match_info_fetch_pos(info, 1, NULL, &endpos);\n        str += endpos;\n    }\n\n    ret = nmatches - 1; /* don't count the trailing null */\n\n cleanup:\n    if (ret < 0) {\n        virStringListFree(*matches);\n        *matches = NULL;\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nssize_t\nvirStringSearch(const char *str,\n                const char *regexp,\n                size_t max_matches,\n                char ***matches)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    size_t nmatches = 0;\n    ssize_t ret = -1;\n\n    *matches = NULL;\n\n    VIR_DEBUG(\"search '%s' for '%s'\", str, regexp);\n\n    regex = g_regex_new(regexp, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (g_regex_get_capture_count(regex) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Regular expression '%s' must have exactly 1 match group, not %d\"),\n                       regexp, g_regex_get_capture_count(regex));\n        goto cleanup;\n    }\n\n    /* '*matches' must always be NULL terminated in every iteration\n     * of the loop, so start by allocating 1 element\n     */\n    if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n        goto cleanup;\n\n    while ((nmatches - 1) < max_matches) {\n        g_autoptr(GMatchInfo) info = NULL;\n        char *match;\n        int endpos;\n\n        if (!g_regex_match(regex, str, 0, &info))\n            break;\n\n        if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n            goto cleanup;\n\n        match = g_match_info_fetch(info, 1);\n\n        VIR_DEBUG(\"Got '%s'\", match);\n\n        (*matches)[nmatches-2] = match;\n\n        g_match_info_fetch_pos(info, 1, NULL, &endpos);\n        str += endpos;\n    }\n\n    ret = nmatches - 1; /* don't count the trailing null */\n\n cleanup:\n    if (ret < 0) {\n        virStringListFree(*matches);\n        *matches = NULL;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"No such disk in media registry %s\")",
            "def->parent.dom->disks[it]->src->path"
          ],
          "line": 7069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to close the new medium, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 7056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.Close",
          "args": [
            "newMedium"
          ],
          "line": 7054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 7052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshotMachineDesc->storageController"
          ],
          "line": 7047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to find UUID %s\")",
            "searchResultTab[it]"
          ],
          "line": 7039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to add hard disk to the media registry\")"
          ],
          "line": 7028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfAddHardDiskToMediaRegistry",
          "args": [
            "disk",
            "snapshotMachineDesc->mediaRegistry",
            "parentUuid"
          ],
          "line": 7025
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfAddHardDiskToMediaRegistry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "804-841",
          "snippet": "int\nvirVBoxSnapshotConfAddHardDiskToMediaRegistry(virVBoxSnapshotConfHardDiskPtr hardDisk,\n                                              virVBoxSnapshotConfMediaRegistryPtr mediaRegistry,\n                                              const char *parentHardDiskId)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr parentDisk = NULL;\n    if (hardDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Hard disk is null\"));\n        return -1;\n    }\n    if (mediaRegistry == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Media Registry is null\"));\n        return -1;\n    }\n\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        parentDisk = virVBoxSnapshotConfHardDiskById(mediaRegistry->disks[i], parentHardDiskId);\n        if (parentDisk != NULL)\n            break;\n    }\n    if (parentDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get the parent disk\"));\n        return -1;\n    }\n    /* Hard disk found */\n    if (VIR_EXPAND_N(parentDisk->children, parentDisk->nchildren, 1) < 0)\n        return -1;\n\n    parentDisk->children[parentDisk->nchildren - 1] = hardDisk;\n    if (hardDisk->parent == NULL)\n        hardDisk->parent = parentDisk;\n\n    return 0;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfAddHardDiskToMediaRegistry(virVBoxSnapshotConfHardDiskPtr hardDisk,\n                                              virVBoxSnapshotConfMediaRegistryPtr mediaRegistry,\n                                              const char *parentHardDiskId)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr parentDisk = NULL;\n    if (hardDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Hard disk is null\"));\n        return -1;\n    }\n    if (mediaRegistry == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Media Registry is null\"));\n        return -1;\n    }\n\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        parentDisk = virVBoxSnapshotConfHardDiskById(mediaRegistry->disks[i], parentHardDiskId);\n        if (parentDisk != NULL)\n            break;\n    }\n    if (parentDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get the parent disk\"));\n        return -1;\n    }\n    /* Hard disk found */\n    if (VIR_EXPAND_N(parentDisk->children, parentDisk->nchildren, 1) < 0)\n        return -1;\n\n    parentDisk->children[parentDisk->nchildren - 1] = hardDisk;\n    if (hardDisk->parent == NULL)\n        hardDisk->parent = parentDisk;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "formatUtf16"
          ],
          "line": 7023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "formatUtf16",
            "&format"
          ],
          "line": 7021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetFormat",
          "args": [
            "newMedium",
            "&formatUtf16"
          ],
          "line": 7020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 7016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIID.vboxIIDToUtf8",
          "args": [
            "data",
            "&iid",
            "&uuid"
          ],
          "line": 7014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disk"
          ],
          "line": 7011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to get medium uuid, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 7008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 7007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetId",
          "args": [
            "newMedium",
            "&iid"
          ],
          "line": 7006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "disk"
          ],
          "line": 7003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "progress"
          ],
          "line": 6997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Error while creating diff storage, rc=%08x\")",
            "resultCode.uResultCode"
          ],
          "line": 6992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RC_FAILED",
          "args": [
            "resultCode"
          ],
          "line": 6991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.GetResultCode",
          "args": [
            "progress",
            "&resultCode"
          ],
          "line": 6990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.WaitForCompletion",
          "args": [
            "progress",
            "-1"
          ],
          "line": 6989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.CreateDiffStorage",
          "args": [
            "medium",
            "newMedium",
            "1",
            "tab",
            "&progress"
          ],
          "line": 6987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "newLocation"
          ],
          "line": 6983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "formatUtf16"
          ],
          "line": 6982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to create HardDisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 6977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.CreateHardDisk",
          "args": [
            "data->vboxObj",
            "formatUtf16",
            "newLocation",
            "&newMedium"
          ],
          "line": 6972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "newLocationUtf8",
            "&newLocation"
          ],
          "line": 6971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"VDI\"",
            "&formatUtf16"
          ],
          "line": 6967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "locationUtf16"
          ],
          "line": 6966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&parentiid"
          ],
          "line": 6965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIID.vboxIIDToUtf8",
          "args": [
            "data",
            "&parentiid",
            "&parentUuid"
          ],
          "line": 6964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to get hardDisk Id, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 6959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetId",
          "args": [
            "medium",
            "&parentiid"
          ],
          "line": 6957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to open HardDisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 6951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.OpenMedium",
          "args": [
            "data->vboxObj",
            "locationUtf16",
            "DeviceType_HardDisk",
            "AccessMode_ReadWrite",
            "&medium"
          ],
          "line": 6945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "readOnly->parent->location",
            "&locationUtf16"
          ],
          "line": 6944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"The read only disk has no parent\")"
          ],
          "line": 6939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get hard disk by location\")"
          ],
          "line": 6934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfHardDiskPtrByLocation",
          "args": [
            "snapshotMachineDesc",
            "def->parent.dom->disks[it]->src->path"
          ],
          "line": 6931
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfHardDiskPtrByLocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "1528-1540",
          "snippet": "virVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskPtrByLocation(virVBoxSnapshotConfMachinePtr machine,\n                                         const char *location)\n{\n    int it = 0;\n    virVBoxSnapshotConfHardDiskPtr disk = NULL;\n    for (it = 0; it < machine->mediaRegistry->ndisks; it++) {\n        disk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[it], location);\n        if (disk != NULL)\n            break;\n    }\n    return disk;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvirVBoxSnapshotConfHardDiskPtr\nvirVBoxSnapshotConfHardDiskPtrByLocation(virVBoxSnapshotConfMachinePtr machine,\n                                         const char *location)\n{\n    int it = 0;\n    virVBoxSnapshotConfHardDiskPtr disk = NULL;\n    for (it = 0; it < machine->mediaRegistry->ndisks; it++) {\n        disk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[it], location);\n        if (disk != NULL)\n            break;\n    }\n    return disk;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&parentiid"
          ],
          "line": 6930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 6929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to know if the snapshot is the current snapshot\")"
          ],
          "line": 6901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfIsCurrentSnapshot",
          "args": [
            "snapshotMachineDesc",
            "def->parent.name"
          ],
          "line": 6899
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfIsCurrentSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "1223-1245",
          "snippet": "int\nvirVBoxSnapshotConfIsCurrentSnapshot(virVBoxSnapshotConfMachinePtr machine,\n                                     const char *snapshotName)\n{\n    virVBoxSnapshotConfSnapshotPtr snapshot = NULL;\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Machine is null\"));\n        return 0;\n    }\n    if (snapshotName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"snapshotName is null\"));\n        return 0;\n    }\n    snapshot = virVBoxSnapshotConfSnapshotByName(machine->snapshot, snapshotName);\n    if (snapshot == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Unable to find the snapshot %s\"), snapshotName);\n        return 0;\n    }\n    return STREQ(snapshot->uuid, machine->currentSnapshot);\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfIsCurrentSnapshot(virVBoxSnapshotConfMachinePtr machine,\n                                     const char *snapshotName)\n{\n    virVBoxSnapshotConfSnapshotPtr snapshot = NULL;\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Machine is null\"));\n        return 0;\n    }\n    if (snapshotName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"snapshotName is null\"));\n        return 0;\n    }\n    snapshot = virVBoxSnapshotConfSnapshotByName(machine->snapshot, snapshotName);\n    if (snapshot == NULL) {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Unable to find the snapshot %s\"), snapshotName);\n        return 0;\n    }\n    return STREQ(snapshot->uuid, machine->currentSnapshot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot create a vboxSnapshotXmlPtr\")"
          ],
          "line": 6894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfLoadVboxFile",
          "args": [
            "settingsFilepath",
            "machineLocationPath"
          ],
          "line": 6892
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfLoadVboxFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "580-739",
          "snippet": "virVBoxSnapshotConfMachinePtr\nvirVBoxSnapshotConfLoadVboxFile(const char *filePath,\n                                const char *machineLocation)\n{\n    int ret = -1;\n    virVBoxSnapshotConfMachinePtr machineDescription = NULL;\n    xmlDocPtr xml = NULL;\n    xmlNodePtr machineNode = NULL;\n    xmlNodePtr cur = NULL;\n    xmlXPathContextPtr xPathContext = NULL;\n    char *currentStateModifiedString = NULL;\n\n    char **searchResultTab = NULL;\n    ssize_t searchResultSize = 0;\n    char *currentSnapshotAttribute = NULL;\n\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Filepath is Null\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC(machineDescription) < 0)\n        goto cleanup;\n\n    xml = virXMLParse(filePath, NULL, NULL);\n    if (xml == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to parse the xml\"));\n        goto cleanup;\n    }\n    if (!(xPathContext = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    if (xmlXPathRegisterNs(xPathContext,\n                           BAD_CAST \"vbox\",\n                           BAD_CAST \"http://www.innotek.de/VirtualBox-settings\") < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Failed to register xml namespace \"\n                         \"'http://www.innotek.de/VirtualBox-settings'\"));\n        goto cleanup;\n    }\n\n    /* Retrieve MachineNode */\n    cur = xmlDocGetRootElement(xml);\n    xPathContext->node = cur;\n    machineNode = virXPathNode(\"./vbox:Machine\", xPathContext);\n    if (machineNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <VirtualBox> <Machine> node\"));\n        goto cleanup;\n    }\n\n    machineDescription->uuid = virXMLPropString(machineNode, \"uuid\");\n    if (machineDescription->uuid == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    machineDescription->name = virXMLPropString(machineNode, \"name\");\n    if (machineDescription->name == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'name' attribute\"));\n        goto cleanup;\n    }\n\n    currentSnapshotAttribute = virXMLPropString(machineNode, \"currentSnapshot\");\n    if (currentSnapshotAttribute != NULL) {\n        /* we use virStringSearch because the uuid is between brackets */\n        searchResultSize = virStringSearch(currentSnapshotAttribute,\n                                           VBOX_UUID_REGEX,\n                                           1,\n                                           &searchResultTab);\n        if (searchResultSize != 1) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Cannot parse <Machine> 'currentSnapshot' attribute\"));\n            goto cleanup;\n        }\n        machineDescription->currentSnapshot = g_strdup(searchResultTab[0]);\n    }\n\n    machineDescription->snapshotFolder = virXMLPropString(machineNode, \"snapshotFolder\");\n    if (machineDescription->snapshotFolder == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'snapshotFolder' attribute\"));\n        goto cleanup;\n    }\n\n    currentStateModifiedString = virXMLPropString(machineNode, \"currentStateModified\");\n    if (currentStateModifiedString != NULL && STREQ(currentStateModifiedString, \"true\")) {\n        machineDescription->currentStateModified = 1;\n    } else {\n        machineDescription->currentStateModified = 0;\n    }\n    machineDescription->lastStateChange = virXMLPropString(machineNode, \"lastStateChange\");\n    if (machineDescription->lastStateChange == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'lastStateChange' attribute\"));\n        goto cleanup;\n    }\n\n    xPathContext->node = machineNode;\n    cur = virXPathNode(\"./vbox:Hardware\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <Hardware> node\"));\n        goto cleanup;\n    }\n    machineDescription->hardware = virXMLNodeToString(xml, cur);\n\n    cur = virXPathNode(\"./vbox:ExtraData\", xPathContext);\n    if (cur)\n        machineDescription->extraData = virXMLNodeToString(xml, cur);\n\n    cur = virXPathNode(\"./vbox:StorageControllers\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <StorageControllers> node\"));\n        goto cleanup;\n    }\n    machineDescription->storageController = virXMLNodeToString(xml, cur);\n\n    /* retrieve mediaRegistry */\n    cur = virXPathNode(\"./vbox:MediaRegistry\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <MediaRegistry> node\"));\n        goto cleanup;\n    }\n    machineDescription->mediaRegistry = virVBoxSnapshotConfRetrieveMediaRegistry(cur, xPathContext, machineLocation);\n    if (machineDescription->mediaRegistry == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to create media registry\"));\n        goto cleanup;\n    }\n\n    /* retrieve snapshot */\n    xPathContext->node = machineNode;\n    cur = virXPathNode(\"./vbox:Snapshot\", xPathContext);\n    if (cur != NULL) {\n        machineDescription->snapshot = virVBoxSnapshotConfRetrieveSnapshot(cur, xPathContext);\n        if (!machineDescription->snapshot)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    xmlXPathFreeContext(xPathContext);\n    xmlFreeDoc(xml);\n\n    VIR_FREE(currentStateModifiedString);\n    VIR_FREE(currentSnapshotAttribute);\n    virStringListFree(searchResultTab);\n    if (ret < 0) {\n        virVBoxSnapshotConfMachineFree(machineDescription);\n        machineDescription = NULL;\n    }\n    return machineDescription;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvirVBoxSnapshotConfMachinePtr\nvirVBoxSnapshotConfLoadVboxFile(const char *filePath,\n                                const char *machineLocation)\n{\n    int ret = -1;\n    virVBoxSnapshotConfMachinePtr machineDescription = NULL;\n    xmlDocPtr xml = NULL;\n    xmlNodePtr machineNode = NULL;\n    xmlNodePtr cur = NULL;\n    xmlXPathContextPtr xPathContext = NULL;\n    char *currentStateModifiedString = NULL;\n\n    char **searchResultTab = NULL;\n    ssize_t searchResultSize = 0;\n    char *currentSnapshotAttribute = NULL;\n\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Filepath is Null\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC(machineDescription) < 0)\n        goto cleanup;\n\n    xml = virXMLParse(filePath, NULL, NULL);\n    if (xml == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to parse the xml\"));\n        goto cleanup;\n    }\n    if (!(xPathContext = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    if (xmlXPathRegisterNs(xPathContext,\n                           BAD_CAST \"vbox\",\n                           BAD_CAST \"http://www.innotek.de/VirtualBox-settings\") < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Failed to register xml namespace \"\n                         \"'http://www.innotek.de/VirtualBox-settings'\"));\n        goto cleanup;\n    }\n\n    /* Retrieve MachineNode */\n    cur = xmlDocGetRootElement(xml);\n    xPathContext->node = cur;\n    machineNode = virXPathNode(\"./vbox:Machine\", xPathContext);\n    if (machineNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <VirtualBox> <Machine> node\"));\n        goto cleanup;\n    }\n\n    machineDescription->uuid = virXMLPropString(machineNode, \"uuid\");\n    if (machineDescription->uuid == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    machineDescription->name = virXMLPropString(machineNode, \"name\");\n    if (machineDescription->name == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'name' attribute\"));\n        goto cleanup;\n    }\n\n    currentSnapshotAttribute = virXMLPropString(machineNode, \"currentSnapshot\");\n    if (currentSnapshotAttribute != NULL) {\n        /* we use virStringSearch because the uuid is between brackets */\n        searchResultSize = virStringSearch(currentSnapshotAttribute,\n                                           VBOX_UUID_REGEX,\n                                           1,\n                                           &searchResultTab);\n        if (searchResultSize != 1) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Cannot parse <Machine> 'currentSnapshot' attribute\"));\n            goto cleanup;\n        }\n        machineDescription->currentSnapshot = g_strdup(searchResultTab[0]);\n    }\n\n    machineDescription->snapshotFolder = virXMLPropString(machineNode, \"snapshotFolder\");\n    if (machineDescription->snapshotFolder == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'snapshotFolder' attribute\"));\n        goto cleanup;\n    }\n\n    currentStateModifiedString = virXMLPropString(machineNode, \"currentStateModified\");\n    if (currentStateModifiedString != NULL && STREQ(currentStateModifiedString, \"true\")) {\n        machineDescription->currentStateModified = 1;\n    } else {\n        machineDescription->currentStateModified = 0;\n    }\n    machineDescription->lastStateChange = virXMLPropString(machineNode, \"lastStateChange\");\n    if (machineDescription->lastStateChange == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'lastStateChange' attribute\"));\n        goto cleanup;\n    }\n\n    xPathContext->node = machineNode;\n    cur = virXPathNode(\"./vbox:Hardware\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <Hardware> node\"));\n        goto cleanup;\n    }\n    machineDescription->hardware = virXMLNodeToString(xml, cur);\n\n    cur = virXPathNode(\"./vbox:ExtraData\", xPathContext);\n    if (cur)\n        machineDescription->extraData = virXMLNodeToString(xml, cur);\n\n    cur = virXPathNode(\"./vbox:StorageControllers\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <StorageControllers> node\"));\n        goto cleanup;\n    }\n    machineDescription->storageController = virXMLNodeToString(xml, cur);\n\n    /* retrieve mediaRegistry */\n    cur = virXPathNode(\"./vbox:MediaRegistry\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <MediaRegistry> node\"));\n        goto cleanup;\n    }\n    machineDescription->mediaRegistry = virVBoxSnapshotConfRetrieveMediaRegistry(cur, xPathContext, machineLocation);\n    if (machineDescription->mediaRegistry == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to create media registry\"));\n        goto cleanup;\n    }\n\n    /* retrieve snapshot */\n    xPathContext->node = machineNode;\n    cur = virXPathNode(\"./vbox:Snapshot\", xPathContext);\n    if (cur != NULL) {\n        machineDescription->snapshot = virVBoxSnapshotConfRetrieveSnapshot(cur, xPathContext);\n        if (!machineDescription->snapshot)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    xmlXPathFreeContext(xPathContext);\n    xmlFreeDoc(xml);\n\n    VIR_FREE(currentStateModifiedString);\n    VIR_FREE(currentSnapshotAttribute);\n    virStringListFree(searchResultTab);\n    if (ret < 0) {\n        virVBoxSnapshotConfMachineFree(machineDescription);\n        machineDescription = NULL;\n    }\n    return machineDescription;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get the machine location path\")"
          ],
          "line": 6888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "machineNameUtf16",
            "&machineName"
          ],
          "line": 6884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot get machine name\")"
          ],
          "line": 6880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetName",
          "args": [
            "machine",
            "&machineNameUtf16"
          ],
          "line": 6878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "settingsFilePathUtf16",
            "&settingsFilepath"
          ],
          "line": 6875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot get settings file path\")"
          ],
          "line": 6871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetSettingsFilePath",
          "args": [
            "machine",
            "&settingsFilePathUtf16"
          ],
          "line": 6869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&domiid",
            "&machine"
          ],
          "line": 6867
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get a virDomainSnapshotDefPtr\")"
          ],
          "line": 6862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDefParseString",
          "args": [
            "defXml",
            "data->xmlopt",
            "NULL",
            "NULL",
            "VIR_DOMAIN_SNAPSHOT_PARSE_DISKS |\n                                          VIR_DOMAIN_SNAPSHOT_PARSE_REDEFINE"
          ],
          "line": 6857
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "452-473",
          "snippet": "virDomainSnapshotDefPtr\nvirDomainSnapshotDefParseString(const char *xmlStr,\n                                virDomainXMLOptionPtr xmlopt,\n                                void *parseOpaque,\n                                bool *current,\n                                unsigned int flags)\n{\n    virDomainSnapshotDefPtr ret = NULL;\n    xmlDocPtr xml;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_snapshot)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainSnapshotDefParseNode(xml, xmlDocGetRootElement(xml),\n                                            xmlopt, parseOpaque,\n                                            current, flags);\n        xmlFreeDoc(xml);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainSnapshotDefPtr\nvirDomainSnapshotDefParseString(const char *xmlStr,\n                                virDomainXMLOptionPtr xmlopt,\n                                void *parseOpaque,\n                                bool *current,\n                                unsigned int flags)\n{\n    virDomainSnapshotDefPtr ret = NULL;\n    xmlDocPtr xml;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_snapshot)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainSnapshotDefParseNode(xml, xmlDocGetRootElement(xml),\n                                            xmlopt, parseOpaque,\n                                            current, flags);\n        xmlFreeDoc(xml);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get XML Desc of snapshot\")"
          ],
          "line": 6853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotGetXMLDesc",
          "args": [
            "snapshot",
            "0"
          ],
          "line": 6851
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotGetXMLDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "6115-6252",
          "snippet": "static char *vboxDomainSnapshotGetXMLDesc(virDomainSnapshotPtr snapshot,\n                                          unsigned int flags)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    ISnapshot *parent = NULL;\n    nsresult rc;\n    PRUnichar *str16;\n    char *str8;\n    PRInt64 timestamp;\n    PRBool online = PR_FALSE;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *ret = NULL;\n    virDomainDefPtr defdom;\n    g_autoptr(virDomainSnapshotDef) def = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    if (!(def = virDomainSnapshotDefNew()) ||\n        !(def->parent.dom = virDomainDefNew()))\n        goto cleanup;\n    defdom = def->parent.dom;\n    def->parent.name = g_strdup(snapshot->name);\n\n    if (gVBoxAPI.vboxSnapshotRedefine) {\n        /* Register def->dom properties for them to be saved inside the snapshot XMl\n         * Otherwise, there is a problem while parsing the xml\n         */\n        PRUint32 memorySize = 0;\n        PRUint32 CPUCount = 0;\n\n        defdom->virtType = VIR_DOMAIN_VIRT_VBOX;\n        defdom->id = dom->id;\n        memcpy(defdom->uuid, dom->uuid, VIR_UUID_BUFLEN);\n        defdom->name = g_strdup(dom->name);\n        gVBoxAPI.UIMachine.GetMemorySize(machine, &memorySize);\n        defdom->mem.cur_balloon = memorySize * 1024;\n        /* Currently setting memory and maxMemory as same, cause\n         * the notation here seems to be inconsistent while\n         * reading and while dumping xml\n         */\n        virDomainDefSetMemoryTotal(defdom, memorySize * 1024);\n        defdom->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        defdom->os.arch = virArchFromHost();\n        gVBoxAPI.UIMachine.GetCPUCount(machine, &CPUCount);\n        if (virDomainDefSetVcpusMax(defdom, CPUCount, data->xmlopt) < 0)\n            goto cleanup;\n\n        if (virDomainDefSetVcpus(defdom, CPUCount) < 0)\n            goto cleanup;\n\n        if (vboxSnapshotGetReadWriteDisks(def, snapshot) < 0)\n            VIR_DEBUG(\"Could not get read write disks for snapshot\");\n\n        if (vboxSnapshotGetReadOnlyDisks(def, snapshot) < 0)\n            VIR_DEBUG(\"Could not get Readonly disks for snapshot\");\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetDescription(snap, &str16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get description of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    if (str16) {\n        VBOX_UTF16_TO_UTF8(str16, &str8);\n        VBOX_UTF16_FREE(str16);\n        def->parent.description = g_strdup(str8);\n        VBOX_UTF8_FREE(str8);\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetTimeStamp(snap, &timestamp);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get creation time of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    /* timestamp is in milliseconds while creationTime in seconds */\n    def->parent.creationTime = timestamp / 1000;\n\n    rc = gVBoxAPI.UISnapshot.GetParent(snap, &parent);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get parent of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    if (parent) {\n        rc = gVBoxAPI.UISnapshot.GetName(parent, &str16);\n        if (NS_FAILED(rc) || !str16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not get name of parent of snapshot %s\"),\n                           snapshot->name);\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(str16, &str8);\n        VBOX_UTF16_FREE(str16);\n        def->parent.parent_name = g_strdup(str8);\n        VBOX_UTF8_FREE(str8);\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetOnline(snap, &online);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get online state of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    if (online)\n        def->state = VIR_DOMAIN_SNAPSHOT_RUNNING;\n    else\n        def->state = VIR_DOMAIN_SNAPSHOT_SHUTOFF;\n\n    virUUIDFormat(dom->uuid, uuidstr);\n    memcpy(defdom->uuid, dom->uuid, VIR_UUID_BUFLEN);\n    ret = virDomainSnapshotDefFormat(uuidstr, def, data->xmlopt, 0);\n\n cleanup:\n    VBOX_RELEASE(parent);\n    VBOX_RELEASE(snap);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&domiid);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic char *vboxDomainSnapshotGetXMLDesc(virDomainSnapshotPtr snapshot,\n                                          unsigned int flags)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    ISnapshot *parent = NULL;\n    nsresult rc;\n    PRUnichar *str16;\n    char *str8;\n    PRInt64 timestamp;\n    PRBool online = PR_FALSE;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *ret = NULL;\n    virDomainDefPtr defdom;\n    g_autoptr(virDomainSnapshotDef) def = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    if (!(def = virDomainSnapshotDefNew()) ||\n        !(def->parent.dom = virDomainDefNew()))\n        goto cleanup;\n    defdom = def->parent.dom;\n    def->parent.name = g_strdup(snapshot->name);\n\n    if (gVBoxAPI.vboxSnapshotRedefine) {\n        /* Register def->dom properties for them to be saved inside the snapshot XMl\n         * Otherwise, there is a problem while parsing the xml\n         */\n        PRUint32 memorySize = 0;\n        PRUint32 CPUCount = 0;\n\n        defdom->virtType = VIR_DOMAIN_VIRT_VBOX;\n        defdom->id = dom->id;\n        memcpy(defdom->uuid, dom->uuid, VIR_UUID_BUFLEN);\n        defdom->name = g_strdup(dom->name);\n        gVBoxAPI.UIMachine.GetMemorySize(machine, &memorySize);\n        defdom->mem.cur_balloon = memorySize * 1024;\n        /* Currently setting memory and maxMemory as same, cause\n         * the notation here seems to be inconsistent while\n         * reading and while dumping xml\n         */\n        virDomainDefSetMemoryTotal(defdom, memorySize * 1024);\n        defdom->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        defdom->os.arch = virArchFromHost();\n        gVBoxAPI.UIMachine.GetCPUCount(machine, &CPUCount);\n        if (virDomainDefSetVcpusMax(defdom, CPUCount, data->xmlopt) < 0)\n            goto cleanup;\n\n        if (virDomainDefSetVcpus(defdom, CPUCount) < 0)\n            goto cleanup;\n\n        if (vboxSnapshotGetReadWriteDisks(def, snapshot) < 0)\n            VIR_DEBUG(\"Could not get read write disks for snapshot\");\n\n        if (vboxSnapshotGetReadOnlyDisks(def, snapshot) < 0)\n            VIR_DEBUG(\"Could not get Readonly disks for snapshot\");\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetDescription(snap, &str16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get description of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    if (str16) {\n        VBOX_UTF16_TO_UTF8(str16, &str8);\n        VBOX_UTF16_FREE(str16);\n        def->parent.description = g_strdup(str8);\n        VBOX_UTF8_FREE(str8);\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetTimeStamp(snap, &timestamp);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get creation time of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    /* timestamp is in milliseconds while creationTime in seconds */\n    def->parent.creationTime = timestamp / 1000;\n\n    rc = gVBoxAPI.UISnapshot.GetParent(snap, &parent);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get parent of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    if (parent) {\n        rc = gVBoxAPI.UISnapshot.GetName(parent, &str16);\n        if (NS_FAILED(rc) || !str16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not get name of parent of snapshot %s\"),\n                           snapshot->name);\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(str16, &str8);\n        VBOX_UTF16_FREE(str16);\n        def->parent.parent_name = g_strdup(str8);\n        VBOX_UTF8_FREE(str8);\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetOnline(snap, &online);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get online state of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    if (online)\n        def->state = VIR_DOMAIN_SNAPSHOT_RUNNING;\n    else\n        def->state = VIR_DOMAIN_SNAPSHOT_SHUTOFF;\n\n    virUUIDFormat(dom->uuid, uuidstr);\n    memcpy(defdom->uuid, dom->uuid, VIR_UUID_BUFLEN);\n    ret = virDomainSnapshotDefFormat(uuidstr, def, data->xmlopt, 0);\n\n cleanup:\n    VBOX_RELEASE(parent);\n    VBOX_RELEASE(snap);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&domiid);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"This function may not work in current version\""
          ],
          "line": 6849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&domiid"
          ],
          "line": 6847
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDomainSnapshotDeleteMetadataOnly(virDomainSnapshotPtr snapshot)\n{\n    /*\n     * This function will remove the node in the vbox xml corresponding to the snapshot.\n     * It is usually called by vboxDomainSnapshotDelete() with the flag\n     * VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY.\n     * If you want to use it anywhere else, be careful, if the snapshot you want to delete\n     * has children, the result is not granted, they will probably will be deleted in the\n     * xml, but you may have a problem with hard drives.\n     *\n     * If the snapshot which is being deleted is the current one, we will set the current\n     * snapshot of the machine to the parent of this snapshot. Before writing the modified\n     * xml file, we undefine the machine from vbox. After writing the file, we redefine\n     * the machine with the new file.\n     */\n\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    virDomainSnapshotDefPtr def = NULL;\n    char *defXml = NULL;\n    vboxIID domiid;\n    nsresult rc;\n    IMachine *machine = NULL;\n    PRUnichar *settingsFilePathUtf16 = NULL;\n    char *settingsFilepath = NULL;\n    virVBoxSnapshotConfMachinePtr snapshotMachineDesc = NULL;\n    int isCurrent = -1;\n    char **searchResultTab = NULL;\n    ssize_t resultSize = 0;\n    int it = 0;\n    PRUnichar *machineNameUtf16 = NULL;\n    char *machineName = NULL;\n    char *nameTmpUse = NULL;\n    char *machineLocationPath = NULL;\n    PRUint32 aMediaSize = 0;\n    IMedium **aMedia = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&domiid);\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    defXml = vboxDomainSnapshotGetXMLDesc(snapshot, 0);\n    if (!defXml) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get XML Desc of snapshot\"));\n        goto cleanup;\n    }\n    def = virDomainSnapshotDefParseString(defXml,\n                                          data->xmlopt, NULL, NULL,\n                                          VIR_DOMAIN_SNAPSHOT_PARSE_DISKS |\n                                          VIR_DOMAIN_SNAPSHOT_PARSE_REDEFINE);\n    if (!def) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get a virDomainSnapshotDefPtr\"));\n        goto cleanup;\n    }\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n    rc = gVBoxAPI.UIMachine.GetSettingsFilePath(machine, &settingsFilePathUtf16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get settings file path\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(settingsFilePathUtf16, &settingsFilepath);\n\n    /* Getting the machine name to retrieve the machine location path. */\n    rc = gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get machine name\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineName);\n    nameTmpUse = g_strdup_printf(\"%s.vbox\", machineName);\n    machineLocationPath = virStringReplace(settingsFilepath, nameTmpUse, \"\");\n    if (machineLocationPath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get the machine location path\"));\n        goto cleanup;\n    }\n    snapshotMachineDesc = virVBoxSnapshotConfLoadVboxFile(settingsFilepath, machineLocationPath);\n    if (!snapshotMachineDesc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot create a vboxSnapshotXmlPtr\"));\n        goto cleanup;\n    }\n\n    isCurrent = virVBoxSnapshotConfIsCurrentSnapshot(snapshotMachineDesc, def->parent.name);\n    if (isCurrent < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to know if the snapshot is the current snapshot\"));\n        goto cleanup;\n    }\n    if (isCurrent) {\n        /*\n         * If the snapshot is the current snapshot, it means that the machine has read-write\n         * disks. The first thing to do is to manipulate VirtualBox API to create\n         * differential read-write disks if the parent snapshot is not null.\n         */\n        if (def->parent.parent_name != NULL) {\n            for (it = 0; it < def->parent.dom->ndisks; it++) {\n                virVBoxSnapshotConfHardDiskPtr readOnly = NULL;\n                IMedium *medium = NULL;\n                PRUnichar *locationUtf16 = NULL;\n                char *parentUuid = NULL;\n                IMedium *newMedium = NULL;\n                PRUnichar *formatUtf16 = NULL;\n                PRUnichar *newLocation = NULL;\n                char *newLocationUtf8 = NULL;\n                IProgress *progress = NULL;\n                virVBoxSnapshotConfHardDiskPtr disk = NULL;\n                char *uuid = NULL;\n                char *format = NULL;\n                char *tmp = NULL;\n                vboxIID iid, parentiid;\n                resultCodeUnion resultCode;\n\n                VBOX_IID_INITIALIZE(&iid);\n                VBOX_IID_INITIALIZE(&parentiid);\n                readOnly = virVBoxSnapshotConfHardDiskPtrByLocation(snapshotMachineDesc,\n                                                 def->parent.dom->disks[it]->src->path);\n                if (!readOnly) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Cannot get hard disk by location\"));\n                    goto cleanup;\n                }\n                if (readOnly->parent == NULL) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"The read only disk has no parent\"));\n                    goto cleanup;\n                }\n\n                VBOX_UTF8_TO_UTF16(readOnly->parent->location, &locationUtf16);\n                rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                      locationUtf16,\n                                                      DeviceType_HardDisk,\n                                                      AccessMode_ReadWrite,\n                                                      &medium);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to open HardDisk, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n\n                rc = gVBoxAPI.UIMedium.GetId(medium, &parentiid);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to get hardDisk Id, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n                gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n                vboxIIDUnalloc(&parentiid);\n                VBOX_UTF16_FREE(locationUtf16);\n                VBOX_UTF8_TO_UTF16(\"VDI\", &formatUtf16);\n\n                newLocationUtf8 = g_strdup_printf(\"%sfakedisk-%s-%d.vdi\",\n                                                  machineLocationPath, def->parent.parent_name, it);\n                VBOX_UTF8_TO_UTF16(newLocationUtf8, &newLocation);\n                rc = gVBoxAPI.UIVirtualBox.CreateHardDisk(data->vboxObj,\n                                                          formatUtf16,\n                                                          newLocation,\n                                                          &newMedium);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to create HardDisk, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n                VBOX_UTF16_FREE(formatUtf16);\n                VBOX_UTF16_FREE(newLocation);\n\n                PRUint32 tab[1];\n                tab[0] = MediumVariant_Diff;\n                gVBoxAPI.UIMedium.CreateDiffStorage(medium, newMedium, 1, tab, &progress);\n\n                gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n                gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n                if (RC_FAILED(resultCode)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Error while creating diff storage, rc=%08x\"),\n                                   resultCode.uResultCode);\n                    goto cleanup;\n                }\n                VBOX_RELEASE(progress);\n                /*\n                 * The differential disk is created, we add it to the media registry and\n                 * the machine storage controller.\n                 */\n\n                if (VIR_ALLOC(disk) < 0)\n                    goto cleanup;\n\n                rc = gVBoxAPI.UIMedium.GetId(newMedium, &iid);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to get medium uuid, rc=%08x\"),\n                                   (unsigned)rc);\n                    VIR_FREE(disk);\n                    goto cleanup;\n                }\n                gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n                disk->uuid = uuid;\n                vboxIIDUnalloc(&iid);\n\n                disk->location = g_strdup(newLocationUtf8);\n\n                rc = gVBoxAPI.UIMedium.GetFormat(newMedium, &formatUtf16);\n                VBOX_UTF16_TO_UTF8(formatUtf16, &format);\n                disk->format = format;\n                VBOX_UTF16_FREE(formatUtf16);\n\n                if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(disk,\n                                               snapshotMachineDesc->mediaRegistry,\n                                               parentUuid) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Unable to add hard disk to the media registry\"));\n                    goto cleanup;\n                }\n                /* Adding fake disks to the machine storage controllers */\n\n                resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                             VBOX_UUID_REGEX,\n                                             it + 1,\n                                             &searchResultTab);\n                if (resultSize != it + 1) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to find UUID %s\"), searchResultTab[it]);\n                    goto cleanup;\n                }\n\n                tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                       searchResultTab[it],\n                                       disk->uuid);\n                VIR_FREE(snapshotMachineDesc->storageController);\n                if (!tmp)\n                    goto cleanup;\n                snapshotMachineDesc->storageController = g_strdup(tmp);\n\n                VIR_FREE(tmp);\n                /* Closing the \"fake\" disk */\n                rc = gVBoxAPI.UIMedium.Close(newMedium);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to close the new medium, rc=%08x\"),\n                                   (unsigned)rc);\n                    goto cleanup;\n                }\n            }\n        } else {\n            for (it = 0; it < def->parent.dom->ndisks; it++) {\n                const char *uuidRO = NULL;\n                char *tmp = NULL;\n                uuidRO = virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                      def->parent.dom->disks[it]->src->path);\n                if (!uuidRO) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"No such disk in media registry %s\"),\n                                   def->parent.dom->disks[it]->src->path);\n                    goto cleanup;\n                }\n\n                resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                             VBOX_UUID_REGEX,\n                                             it + 1,\n                                             &searchResultTab);\n                if (resultSize != it + 1) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to find UUID %s\"),\n                                   searchResultTab[it]);\n                    goto cleanup;\n                }\n\n                tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                       searchResultTab[it],\n                                       uuidRO);\n                VIR_FREE(snapshotMachineDesc->storageController);\n                if (!tmp)\n                    goto cleanup;\n                snapshotMachineDesc->storageController = g_strdup(tmp);\n\n                VIR_FREE(tmp);\n            }\n        }\n    }\n    /* We remove the read write disks from the media registry */\n    for (it = 0; it < def->ndisks; it++) {\n        const char *uuidRW =\n            virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                      def->disks[it].src->path);\n        if (!uuidRW) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to find UUID for location %s\"), def->disks[it].src->path);\n            goto cleanup;\n        }\n        if (virVBoxSnapshotConfRemoveHardDisk(snapshotMachineDesc->mediaRegistry, uuidRW) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to remove disk from media registry. uuid = %s\"), uuidRW);\n            goto cleanup;\n        }\n    }\n    /* If the parent snapshot is not NULL, we remove the-read only disks from the media registry */\n    if (def->parent.parent_name != NULL) {\n        for (it = 0; it < def->parent.dom->ndisks; it++) {\n            const char *uuidRO =\n                virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                          def->parent.dom->disks[it]->src->path);\n            if (!uuidRO) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to find UUID for location %s\"), def->parent.dom->disks[it]->src->path);\n                goto cleanup;\n            }\n            if (virVBoxSnapshotConfRemoveHardDisk(snapshotMachineDesc->mediaRegistry, uuidRO) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to remove disk from media registry. uuid = %s\"), uuidRO);\n                goto cleanup;\n            }\n        }\n    }\n    rc = gVBoxAPI.UIMachine.Unregister(machine,\n                                       CleanupMode_DetachAllReturnHardDisksOnly,\n                                       &aMediaSize,\n                                       &aMedia);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to unregister machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n    VBOX_RELEASE(machine);\n    for (it = 0; it < aMediaSize; it++) {\n        IMedium *medium = aMedia[it];\n        PRUnichar *locationUtf16 = NULL;\n        char *locationUtf8 = NULL;\n\n        if (!medium)\n            continue;\n\n        rc = gVBoxAPI.UIMedium.GetLocation(medium, &locationUtf16);\n        VBOX_UTF16_TO_UTF8(locationUtf16, &locationUtf8);\n        if (isCurrent && strstr(locationUtf8, \"fake\") != NULL) {\n            /* we delete the fake disk because we don't need it anymore */\n            IProgress *progress = NULL;\n            resultCodeUnion resultCode;\n            rc = gVBoxAPI.UIMedium.DeleteStorage(medium, &progress);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to delete medium, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n            gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n            if (RC_FAILED(resultCode)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Error while closing medium, rc=%08x\"),\n                               resultCode.uResultCode);\n                goto cleanup;\n            }\n            VBOX_RELEASE(progress);\n        } else {\n            /* This a comment from vboxmanage code in the handleUnregisterVM\n             * function in VBoxManageMisc.cpp :\n             * Note that the IMachine::Unregister method will return the medium\n             * reference in a sane order, which means that closing will normally\n             * succeed, unless there is still another machine which uses the\n             * medium. No harm done if we ignore the error. */\n            ignore_value(gVBoxAPI.UIMedium.Close(medium));\n        }\n        VBOX_UTF16_FREE(locationUtf16);\n        VBOX_UTF8_FREE(locationUtf8);\n    }\n\n    /* removing the snapshot */\n    if (virVBoxSnapshotConfRemoveSnapshot(snapshotMachineDesc, def->parent.name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to remove snapshot %s\"), def->parent.name);\n        goto cleanup;\n    }\n\n    if (isCurrent) {\n        VIR_FREE(snapshotMachineDesc->currentSnapshot);\n        if (def->parent.parent_name != NULL) {\n            virVBoxSnapshotConfSnapshotPtr snap = virVBoxSnapshotConfSnapshotByName(snapshotMachineDesc->snapshot, def->parent.parent_name);\n            if (!snap) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get the snapshot to remove\"));\n                goto cleanup;\n            }\n            snapshotMachineDesc->currentSnapshot = g_strdup(snap->uuid);\n        }\n    }\n\n    /* Registering the machine */\n    if (virVBoxSnapshotConfSaveVboxFile(snapshotMachineDesc, settingsFilepath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to serialize the machine description\"));\n        goto cleanup;\n    }\n    rc = gVBoxAPI.UIVirtualBox.OpenMachine(data->vboxObj,\n                                           settingsFilePathUtf16,\n                                           &machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to open Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIVirtualBox.RegisterMachine(data->vboxObj, machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to register Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(def);\n    VIR_FREE(defXml);\n    VBOX_RELEASE(machine);\n    VBOX_UTF16_FREE(settingsFilePathUtf16);\n    VBOX_UTF8_FREE(settingsFilepath);\n    virStringListFree(searchResultTab);\n    VIR_FREE(snapshotMachineDesc);\n    VBOX_UTF16_FREE(machineNameUtf16);\n    VBOX_UTF8_FREE(machineName);\n    VIR_FREE(machineLocationPath);\n    VIR_FREE(nameTmpUse);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSnapshotDeleteTree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "6775-6803",
    "snippet": "static int\nvboxDomainSnapshotDeleteTree(vboxDriverPtr data,\n                             IConsole *console,\n                             ISnapshot *snapshot)\n{\n    vboxArray children = VBOX_ARRAY_INITIALIZER;\n    int ret = -1;\n    nsresult rc;\n    size_t i;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&children, snapshot,\n                  gVBoxAPI.UArray.handleSnapshotGetChildren(snapshot));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get children snapshots\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < children.count; i++) {\n        if (vboxDomainSnapshotDeleteTree(data, console, children.items[i]))\n            goto cleanup;\n    }\n\n    ret = vboxDomainSnapshotDeleteSingle(data, console, snapshot);\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&children);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&children"
          ],
          "line": 6801
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotDeleteSingle",
          "args": [
            "data",
            "console",
            "snapshot"
          ],
          "line": 6798
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotDeleteSingle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "6728-6773",
          "snippet": "static int\nvboxDomainSnapshotDeleteSingle(vboxDriverPtr data,\n                               IConsole *console,\n                               ISnapshot *snapshot)\n{\n    IProgress *progress = NULL;\n    vboxIID iid;\n    int ret = -1;\n    nsresult rc;\n    resultCodeUnion result;\n\n    VBOX_IID_INITIALIZE(&iid);\n    rc = gVBoxAPI.UISnapshot.GetId(snapshot, &iid);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get snapshot UUID\"));\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIConsole.DeleteSnapshot(console, &iid, &progress);\n    if (NS_FAILED(rc) || !progress) {\n        if (rc == VBOX_E_INVALID_VM_STATE) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot delete domain snapshot for running domain\"));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not delete snapshot\"));\n        }\n        goto cleanup;\n    }\n\n    gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n    gVBoxAPI.UIProgress.GetResultCode(progress, &result);\n    if (RC_FAILED(result)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not delete snapshot\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(progress);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDomainSnapshotDeleteSingle(vboxDriverPtr data,\n                               IConsole *console,\n                               ISnapshot *snapshot)\n{\n    IProgress *progress = NULL;\n    vboxIID iid;\n    int ret = -1;\n    nsresult rc;\n    resultCodeUnion result;\n\n    VBOX_IID_INITIALIZE(&iid);\n    rc = gVBoxAPI.UISnapshot.GetId(snapshot, &iid);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get snapshot UUID\"));\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIConsole.DeleteSnapshot(console, &iid, &progress);\n    if (NS_FAILED(rc) || !progress) {\n        if (rc == VBOX_E_INVALID_VM_STATE) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot delete domain snapshot for running domain\"));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not delete snapshot\"));\n        }\n        goto cleanup;\n    }\n\n    gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n    gVBoxAPI.UIProgress.GetResultCode(progress, &result);\n    if (RC_FAILED(result)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not delete snapshot\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(progress);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotDeleteTree",
          "args": [
            "data",
            "console",
            "children.items[i]"
          ],
          "line": 6794
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotDeleteTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "6775-6803",
          "snippet": "static int\nvboxDomainSnapshotDeleteTree(vboxDriverPtr data,\n                             IConsole *console,\n                             ISnapshot *snapshot)\n{\n    vboxArray children = VBOX_ARRAY_INITIALIZER;\n    int ret = -1;\n    nsresult rc;\n    size_t i;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&children, snapshot,\n                  gVBoxAPI.UArray.handleSnapshotGetChildren(snapshot));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get children snapshots\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < children.count; i++) {\n        if (vboxDomainSnapshotDeleteTree(data, console, children.items[i]))\n            goto cleanup;\n    }\n\n    ret = vboxDomainSnapshotDeleteSingle(data, console, snapshot);\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&children);\n    return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get children snapshots\")"
          ],
          "line": 6788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not get children snapshots\""
          ],
          "line": 6789
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&children",
            "snapshot",
            "gVBoxAPI.UArray.handleSnapshotGetChildren(snapshot)"
          ],
          "line": 6785
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleSnapshotGetChildren",
          "args": [
            "snapshot"
          ],
          "line": 6786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDomainSnapshotDeleteTree(vboxDriverPtr data,\n                             IConsole *console,\n                             ISnapshot *snapshot)\n{\n    vboxArray children = VBOX_ARRAY_INITIALIZER;\n    int ret = -1;\n    nsresult rc;\n    size_t i;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&children, snapshot,\n                  gVBoxAPI.UArray.handleSnapshotGetChildren(snapshot));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get children snapshots\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < children.count; i++) {\n        if (vboxDomainSnapshotDeleteTree(data, console, children.items[i]))\n            goto cleanup;\n    }\n\n    ret = vboxDomainSnapshotDeleteSingle(data, console, snapshot);\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&children);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSnapshotDeleteSingle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "6728-6773",
    "snippet": "static int\nvboxDomainSnapshotDeleteSingle(vboxDriverPtr data,\n                               IConsole *console,\n                               ISnapshot *snapshot)\n{\n    IProgress *progress = NULL;\n    vboxIID iid;\n    int ret = -1;\n    nsresult rc;\n    resultCodeUnion result;\n\n    VBOX_IID_INITIALIZE(&iid);\n    rc = gVBoxAPI.UISnapshot.GetId(snapshot, &iid);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get snapshot UUID\"));\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIConsole.DeleteSnapshot(console, &iid, &progress);\n    if (NS_FAILED(rc) || !progress) {\n        if (rc == VBOX_E_INVALID_VM_STATE) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot delete domain snapshot for running domain\"));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not delete snapshot\"));\n        }\n        goto cleanup;\n    }\n\n    gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n    gVBoxAPI.UIProgress.GetResultCode(progress, &result);\n    if (RC_FAILED(result)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not delete snapshot\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(progress);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 6771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "progress"
          ],
          "line": 6770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not delete snapshot\")"
          ],
          "line": 6762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not delete snapshot\""
          ],
          "line": 6763
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RC_FAILED",
          "args": [
            "result"
          ],
          "line": 6761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.GetResultCode",
          "args": [
            "progress",
            "&result"
          ],
          "line": 6760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.WaitForCompletion",
          "args": [
            "progress",
            "-1"
          ],
          "line": 6759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not delete snapshot\")"
          ],
          "line": 6753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"cannot delete domain snapshot for running domain\")"
          ],
          "line": 6750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIConsole.DeleteSnapshot",
          "args": [
            "console",
            "&iid",
            "&progress"
          ],
          "line": 6747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get snapshot UUID\")"
          ],
          "line": 6742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetId",
          "args": [
            "snapshot",
            "&iid"
          ],
          "line": 6740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 6739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDomainSnapshotDeleteSingle(vboxDriverPtr data,\n                               IConsole *console,\n                               ISnapshot *snapshot)\n{\n    IProgress *progress = NULL;\n    vboxIID iid;\n    int ret = -1;\n    nsresult rc;\n    resultCodeUnion result;\n\n    VBOX_IID_INITIALIZE(&iid);\n    rc = gVBoxAPI.UISnapshot.GetId(snapshot, &iid);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get snapshot UUID\"));\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIConsole.DeleteSnapshot(console, &iid, &progress);\n    if (NS_FAILED(rc) || !progress) {\n        if (rc == VBOX_E_INVALID_VM_STATE) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot delete domain snapshot for running domain\"));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"could not delete snapshot\"));\n        }\n        goto cleanup;\n    }\n\n    gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n    gVBoxAPI.UIProgress.GetResultCode(progress, &result);\n    if (RC_FAILED(result)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not delete snapshot\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(progress);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainRevertToSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "6655-6726",
    "snippet": "static int vboxDomainRevertToSnapshot(virDomainSnapshotPtr snapshot,\n                                      unsigned int flags)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    ISnapshot *newSnapshot = NULL;\n    ISnapshot *prevSnapshot = NULL;\n    PRBool online = PR_FALSE;\n    PRUint32 state;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    newSnapshot = vboxDomainSnapshotGet(data, dom, machine, snapshot->name);\n    if (!newSnapshot)\n        goto cleanup;\n\n    rc = gVBoxAPI.UISnapshot.GetOnline(newSnapshot, &online);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get online state of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIMachine.GetCurrentSnapshot(machine, &prevSnapshot);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get current snapshot of domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIMachine.GetState(machine, &state);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get domain state\"));\n        goto cleanup;\n    }\n\n    if (gVBoxAPI.machineStateChecker.Online(state)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"cannot revert snapshot of running domain\"));\n        goto cleanup;\n    }\n\n    if (gVBoxAPI.snapshotRestore(dom, machine, newSnapshot))\n        goto cleanup;\n\n    if (online) {\n        ret = vboxDomainCreate(dom);\n        if (!ret)\n            gVBoxAPI.snapshotRestore(dom, machine, prevSnapshot);\n    } else {\n        ret = 0;\n    }\n\n cleanup:\n    VBOX_RELEASE(prevSnapshot);\n    VBOX_RELEASE(newSnapshot);\n    vboxIIDUnalloc(&domiid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&domiid"
          ],
          "line": 6724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "newSnapshot"
          ],
          "line": 6723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "prevSnapshot"
          ],
          "line": 6722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.snapshotRestore",
          "args": [
            "dom",
            "machine",
            "prevSnapshot"
          ],
          "line": 6716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxDomainCreate",
          "args": [
            "dom"
          ],
          "line": 6714
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "2260-2263",
          "snippet": "static int vboxDomainCreate(virDomainPtr dom)\n{\n    return vboxDomainCreateWithFlags(dom, 0);\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxDomainCreate(virDomainPtr dom)\n{\n    return vboxDomainCreateWithFlags(dom, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.snapshotRestore",
          "args": [
            "dom",
            "machine",
            "newSnapshot"
          ],
          "line": 6710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"cannot revert snapshot of running domain\")"
          ],
          "line": 6705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot revert snapshot of running domain\""
          ],
          "line": 6706
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Online",
          "args": [
            "state"
          ],
          "line": 6704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get domain state\")"
          ],
          "line": 6699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 6697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get current snapshot of domain %s\")",
            "dom->name"
          ],
          "line": 6691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetCurrentSnapshot",
          "args": [
            "machine",
            "&prevSnapshot"
          ],
          "line": 6689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get online state of snapshot %s\")",
            "snapshot->name"
          ],
          "line": 6683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetOnline",
          "args": [
            "newSnapshot",
            "&online"
          ],
          "line": 6681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotGet",
          "args": [
            "data",
            "dom",
            "machine",
            "snapshot->name"
          ],
          "line": 6677
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "5606-5654",
          "snippet": "static ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&domiid",
            "&machine"
          ],
          "line": 6674
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 6672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainRevertToSnapshot(virDomainSnapshotPtr snapshot,\n                                      unsigned int flags)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    ISnapshot *newSnapshot = NULL;\n    ISnapshot *prevSnapshot = NULL;\n    PRBool online = PR_FALSE;\n    PRUint32 state;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    newSnapshot = vboxDomainSnapshotGet(data, dom, machine, snapshot->name);\n    if (!newSnapshot)\n        goto cleanup;\n\n    rc = gVBoxAPI.UISnapshot.GetOnline(newSnapshot, &online);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get online state of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIMachine.GetCurrentSnapshot(machine, &prevSnapshot);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get current snapshot of domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIMachine.GetState(machine, &state);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get domain state\"));\n        goto cleanup;\n    }\n\n    if (gVBoxAPI.machineStateChecker.Online(state)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"cannot revert snapshot of running domain\"));\n        goto cleanup;\n    }\n\n    if (gVBoxAPI.snapshotRestore(dom, machine, newSnapshot))\n        goto cleanup;\n\n    if (online) {\n        ret = vboxDomainCreate(dom);\n        if (!ret)\n            gVBoxAPI.snapshotRestore(dom, machine, prevSnapshot);\n    } else {\n        ret = 0;\n    }\n\n cleanup:\n    VBOX_RELEASE(prevSnapshot);\n    VBOX_RELEASE(newSnapshot);\n    vboxIIDUnalloc(&domiid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSnapshotHasMetadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "6624-6653",
    "snippet": "static int vboxDomainSnapshotHasMetadata(virDomainSnapshotPtr snapshot,\n                                         unsigned int flags)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    /* Check that snapshot exists.  If so, there is no metadata.  */\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(snap);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 6651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 6650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "snap"
          ],
          "line": 6649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotGet",
          "args": [
            "data",
            "dom",
            "machine",
            "snapshot->name"
          ],
          "line": 6643
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "5606-5654",
          "snippet": "static ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 6639
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 6637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxDomainSnapshotHasMetadata(virDomainSnapshotPtr snapshot,\n                                         unsigned int flags)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    /* Check that snapshot exists.  If so, there is no metadata.  */\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(snap);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSnapshotIsCurrent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "6563-6622",
    "snippet": "static int vboxDomainSnapshotIsCurrent(virDomainSnapshotPtr snapshot,\n                                       unsigned int flags)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    ISnapshot *current = NULL;\n    PRUnichar *nameUtf16 = NULL;\n    char *name = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    rc = gVBoxAPI.UIMachine.GetCurrentSnapshot(machine, &current);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get current snapshot\"));\n        goto cleanup;\n    }\n    if (!current) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetName(current, &nameUtf16);\n    if (NS_FAILED(rc) || !nameUtf16) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get current snapshot name\"));\n        goto cleanup;\n    }\n\n    VBOX_UTF16_TO_UTF8(nameUtf16, &name);\n    if (!name) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    ret = STREQ(snapshot->name, name);\n\n cleanup:\n    VBOX_UTF8_FREE(name);\n    VBOX_UTF16_FREE(nameUtf16);\n    VBOX_RELEASE(snap);\n    VBOX_RELEASE(current);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 6620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 6619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "current"
          ],
          "line": 6618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "snap"
          ],
          "line": 6617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "nameUtf16"
          ],
          "line": 6616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "name"
          ],
          "line": 6615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "snapshot->name",
            "name"
          ],
          "line": 6612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 6608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "nameUtf16",
            "&name"
          ],
          "line": 6606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get current snapshot name\")"
          ],
          "line": 6601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not get current snapshot name\""
          ],
          "line": 6602
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetName",
          "args": [
            "current",
            "&nameUtf16"
          ],
          "line": 6599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get current snapshot\")"
          ],
          "line": 6590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetCurrentSnapshot",
          "args": [
            "machine",
            "&current"
          ],
          "line": 6588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotGet",
          "args": [
            "data",
            "dom",
            "machine",
            "snapshot->name"
          ],
          "line": 6585
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "5606-5654",
          "snippet": "static ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 6582
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 6580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainSnapshotIsCurrent(virDomainSnapshotPtr snapshot,\n                                       unsigned int flags)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    ISnapshot *current = NULL;\n    PRUnichar *nameUtf16 = NULL;\n    char *name = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    rc = gVBoxAPI.UIMachine.GetCurrentSnapshot(machine, &current);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get current snapshot\"));\n        goto cleanup;\n    }\n    if (!current) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetName(current, &nameUtf16);\n    if (NS_FAILED(rc) || !nameUtf16) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get current snapshot name\"));\n        goto cleanup;\n    }\n\n    VBOX_UTF16_TO_UTF8(nameUtf16, &name);\n    if (!name) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    ret = STREQ(snapshot->name, name);\n\n cleanup:\n    VBOX_UTF8_FREE(name);\n    VBOX_UTF16_FREE(nameUtf16);\n    VBOX_RELEASE(snap);\n    VBOX_RELEASE(current);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSnapshotCurrent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "6506-6561",
    "snippet": "static virDomainSnapshotPtr\nvboxDomainSnapshotCurrent(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    ISnapshot *snapshot = NULL;\n    PRUnichar *nameUtf16 = NULL;\n    char *name = NULL;\n    nsresult rc;\n    virDomainSnapshotPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIMachine.GetCurrentSnapshot(machine, &snapshot);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get current snapshot\"));\n        goto cleanup;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"domain has no snapshots\"));\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetName(snapshot, &nameUtf16);\n    if (NS_FAILED(rc) || !nameUtf16) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get current snapshot name\"));\n        goto cleanup;\n    }\n\n    VBOX_UTF16_TO_UTF8(nameUtf16, &name);\n    if (!name) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    ret = virGetDomainSnapshot(dom, name);\n\n cleanup:\n    VBOX_UTF8_FREE(name);\n    VBOX_UTF16_FREE(nameUtf16);\n    VBOX_RELEASE(snapshot);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 6559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 6558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "snapshot"
          ],
          "line": 6557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "nameUtf16"
          ],
          "line": 6556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "name"
          ],
          "line": 6555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetDomainSnapshot",
          "args": [
            "dom",
            "name"
          ],
          "line": 6552
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomainSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "1023-1045",
          "snippet": "virDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainSnapshotClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainSnapshotClass;\n\nvirDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 6548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "nameUtf16",
            "&name"
          ],
          "line": 6546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get current snapshot name\")"
          ],
          "line": 6541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not get current snapshot name\""
          ],
          "line": 6542
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetName",
          "args": [
            "snapshot",
            "&nameUtf16"
          ],
          "line": 6539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"domain has no snapshots\")"
          ],
          "line": 6534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get current snapshot\")"
          ],
          "line": 6528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetCurrentSnapshot",
          "args": [
            "machine",
            "&snapshot"
          ],
          "line": 6526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 6523
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 6521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virDomainSnapshotPtr\nvboxDomainSnapshotCurrent(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    ISnapshot *snapshot = NULL;\n    PRUnichar *nameUtf16 = NULL;\n    char *name = NULL;\n    nsresult rc;\n    virDomainSnapshotPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIMachine.GetCurrentSnapshot(machine, &snapshot);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get current snapshot\"));\n        goto cleanup;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"domain has no snapshots\"));\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetName(snapshot, &nameUtf16);\n    if (NS_FAILED(rc) || !nameUtf16) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get current snapshot name\"));\n        goto cleanup;\n    }\n\n    VBOX_UTF16_TO_UTF8(nameUtf16, &name);\n    if (!name) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    ret = virGetDomainSnapshot(dom, name);\n\n cleanup:\n    VBOX_UTF8_FREE(name);\n    VBOX_UTF16_FREE(nameUtf16);\n    VBOX_RELEASE(snapshot);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSnapshotGetParent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "6441-6504",
    "snippet": "static virDomainSnapshotPtr\nvboxDomainSnapshotGetParent(virDomainSnapshotPtr snapshot,\n                            unsigned int flags)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    ISnapshot *parent = NULL;\n    PRUnichar *nameUtf16 = NULL;\n    char *name = NULL;\n    nsresult rc;\n    virDomainSnapshotPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISnapshot.GetParent(snap, &parent);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get parent of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    if (!parent) {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"snapshot '%s' does not have a parent\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetName(parent, &nameUtf16);\n    if (NS_FAILED(rc) || !nameUtf16) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get name of parent of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(nameUtf16, &name);\n    if (!name) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    ret = virGetDomainSnapshot(dom, name);\n\n cleanup:\n    VBOX_UTF8_FREE(name);\n    VBOX_UTF16_FREE(nameUtf16);\n    VBOX_RELEASE(snap);\n    VBOX_RELEASE(parent);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 6502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 6501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "parent"
          ],
          "line": 6500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "snap"
          ],
          "line": 6499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "nameUtf16"
          ],
          "line": 6498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "name"
          ],
          "line": 6497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetDomainSnapshot",
          "args": [
            "dom",
            "name"
          ],
          "line": 6494
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomainSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "1023-1045",
          "snippet": "virDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainSnapshotClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainSnapshotClass;\n\nvirDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 6490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "nameUtf16",
            "&name"
          ],
          "line": 6488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get name of parent of snapshot %s\")",
            "snapshot->name"
          ],
          "line": 6483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not get name of parent of snapshot %s\""
          ],
          "line": 6484
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetName",
          "args": [
            "parent",
            "&nameUtf16"
          ],
          "line": 6481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN_SNAPSHOT",
            "_(\"snapshot '%s' does not have a parent\")",
            "snapshot->name"
          ],
          "line": 6475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get parent of snapshot %s\")",
            "snapshot->name"
          ],
          "line": 6469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetParent",
          "args": [
            "snap",
            "&parent"
          ],
          "line": 6467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotGet",
          "args": [
            "data",
            "dom",
            "machine",
            "snapshot->name"
          ],
          "line": 6464
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "5606-5654",
          "snippet": "static ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 6461
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 6459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virDomainSnapshotPtr\nvboxDomainSnapshotGetParent(virDomainSnapshotPtr snapshot,\n                            unsigned int flags)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    ISnapshot *parent = NULL;\n    PRUnichar *nameUtf16 = NULL;\n    char *name = NULL;\n    nsresult rc;\n    virDomainSnapshotPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISnapshot.GetParent(snap, &parent);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get parent of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    if (!parent) {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"snapshot '%s' does not have a parent\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetName(parent, &nameUtf16);\n    if (NS_FAILED(rc) || !nameUtf16) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get name of parent of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(nameUtf16, &name);\n    if (!name) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    ret = virGetDomainSnapshot(dom, name);\n\n cleanup:\n    VBOX_UTF8_FREE(name);\n    VBOX_UTF16_FREE(nameUtf16);\n    VBOX_RELEASE(snap);\n    VBOX_RELEASE(parent);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainHasCurrentSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "6405-6439",
    "snippet": "static int vboxDomainHasCurrentSnapshot(virDomainPtr dom,\n                                        unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIMachine.GetCurrentSnapshot(machine, &snapshot);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get current snapshot\"));\n        goto cleanup;\n    }\n\n    if (snapshot)\n        ret = 1;\n    else\n        ret = 0;\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 6437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 6436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get current snapshot\")"
          ],
          "line": 6425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not get current snapshot\""
          ],
          "line": 6426
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetCurrentSnapshot",
          "args": [
            "machine",
            "&snapshot"
          ],
          "line": 6423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 6420
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 6418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainHasCurrentSnapshot(virDomainPtr dom,\n                                        unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIMachine.GetCurrentSnapshot(machine, &snapshot);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get current snapshot\"));\n        goto cleanup;\n    }\n\n    if (snapshot)\n        ret = 1;\n    else\n        ret = 0;\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSnapshotLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "6375-6403",
    "snippet": "static virDomainSnapshotPtr\nvboxDomainSnapshotLookupByName(virDomainPtr dom, const char *name,\n                               unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    ISnapshot *snapshot = NULL;\n    virDomainSnapshotPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snapshot = vboxDomainSnapshotGet(data, dom, machine, name)))\n        goto cleanup;\n\n    ret = virGetDomainSnapshot(dom, name);\n\n cleanup:\n    VBOX_RELEASE(snapshot);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 6401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 6400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "snapshot"
          ],
          "line": 6399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetDomainSnapshot",
          "args": [
            "dom",
            "name"
          ],
          "line": 6396
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomainSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "1023-1045",
          "snippet": "virDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainSnapshotClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainSnapshotClass;\n\nvirDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotGet",
          "args": [
            "data",
            "dom",
            "machine",
            "name"
          ],
          "line": 6393
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "5606-5654",
          "snippet": "static ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 6390
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 6388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virDomainSnapshotPtr\nvboxDomainSnapshotLookupByName(virDomainPtr dom, const char *name,\n                               unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    ISnapshot *snapshot = NULL;\n    virDomainSnapshotPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snapshot = vboxDomainSnapshotGet(data, dom, machine, name)))\n        goto cleanup;\n\n    ret = virGetDomainSnapshot(dom, name);\n\n cleanup:\n    VBOX_RELEASE(snapshot);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSnapshotListNames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "6298-6373",
    "snippet": "static int vboxDomainSnapshotListNames(virDomainPtr dom, char **names,\n                                       int nameslen, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    nsresult rc;\n    ISnapshot **snapshots = NULL;\n    ssize_t i, count = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_LIST_ROOTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_LIST_METADATA) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_LIST_ROOTS) {\n        vboxIID empty;\n\n        VBOX_IID_INITIALIZE(&empty);\n        if (VIR_ALLOC_N(snapshots, 1) < 0)\n            goto cleanup;\n        rc = gVBoxAPI.UIMachine.FindSnapshot(machine, &empty, snapshots);\n        if (NS_FAILED(rc) || !snapshots[0]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not get root snapshot for domain %s\"),\n                           dom->name);\n            goto cleanup;\n        }\n        count = 1;\n    } else {\n        if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < nameslen; i++) {\n        PRUnichar *nameUtf16;\n        char *name;\n\n        if (i >= count)\n            break;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &name);\n        VBOX_UTF16_FREE(nameUtf16);\n        names[i] = g_strdup(name);\n        VBOX_UTF8_FREE(name);\n    }\n\n    if (count <= nameslen)\n        ret = count;\n    else\n        ret = nameslen;\n\n cleanup:\n    for (i = 0; i < count; i++)\n        VBOX_RELEASE(snapshots[i]);\n    VIR_FREE(snapshots);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 6371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 6370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshots"
          ],
          "line": 6369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "snapshots[i]"
          ],
          "line": 6368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "name"
          ],
          "line": 6358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "name"
          ],
          "line": 6357
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "nameUtf16"
          ],
          "line": 6356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "nameUtf16",
            "&name"
          ],
          "line": 6355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get snapshot name\")"
          ],
          "line": 6351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not get snapshot name\""
          ],
          "line": 6352
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetName",
          "args": [
            "snapshots[i]",
            "&nameUtf16"
          ],
          "line": 6349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotGetAll",
          "args": [
            "dom",
            "machine",
            "&snapshots"
          ],
          "line": 6338
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotGetAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "5522-5604",
          "snippet": "static int\nvboxDomainSnapshotGetAll(virDomainPtr dom,\n                         IMachine *machine,\n                         ISnapshot ***snapshots)\n{\n    vboxIID empty;\n    ISnapshot **list = NULL;\n    PRUint32 count;\n    nsresult rc;\n    unsigned int next;\n    unsigned int top;\n\n    VBOX_IID_INITIALIZE(&empty);\n    rc = gVBoxAPI.UIMachine.GetSnapshotCount(machine, &count);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get snapshot count for domain %s\"),\n                       dom->name);\n        goto error;\n    }\n\n    if (count == 0)\n        goto out;\n\n    if (VIR_ALLOC_N(list, count) < 0)\n        goto error;\n\n    rc = gVBoxAPI.UIMachine.FindSnapshot(machine, &empty, list);\n    if (NS_FAILED(rc) || !list[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get root snapshot for domain %s\"),\n                       dom->name);\n        goto error;\n    }\n\n    /* BFS walk through snapshot tree */\n    top = 1;\n    for (next = 0; next < count; next++) {\n        vboxArray children = VBOX_ARRAY_INITIALIZER;\n        size_t i;\n\n        if (!list[next]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected number of snapshots < %u\"), count);\n            goto error;\n        }\n\n        rc = gVBoxAPI.UArray.vboxArrayGet(&children, list[next],\n                                          gVBoxAPI.UArray.handleSnapshotGetChildren(list[next]));\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get children snapshots\"));\n            goto error;\n        }\n        for (i = 0; i < children.count; i++) {\n            ISnapshot *child = children.items[i];\n            if (!child)\n                continue;\n            if (top == count) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unexpected number of snapshots > %u\"), count);\n                gVBoxAPI.UArray.vboxArrayRelease(&children);\n                goto error;\n            }\n            VBOX_ADDREF(child);\n            list[top++] = child;\n        }\n        gVBoxAPI.UArray.vboxArrayRelease(&children);\n    }\n\n out:\n    *snapshots = list;\n    return count;\n\n error:\n    if (list) {\n        for (next = 0; next < count; next++)\n            VBOX_RELEASE(list[next]);\n    }\n    VIR_FREE(list);\n\n    return -1;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDomainSnapshotGetAll(virDomainPtr dom,\n                         IMachine *machine,\n                         ISnapshot ***snapshots)\n{\n    vboxIID empty;\n    ISnapshot **list = NULL;\n    PRUint32 count;\n    nsresult rc;\n    unsigned int next;\n    unsigned int top;\n\n    VBOX_IID_INITIALIZE(&empty);\n    rc = gVBoxAPI.UIMachine.GetSnapshotCount(machine, &count);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get snapshot count for domain %s\"),\n                       dom->name);\n        goto error;\n    }\n\n    if (count == 0)\n        goto out;\n\n    if (VIR_ALLOC_N(list, count) < 0)\n        goto error;\n\n    rc = gVBoxAPI.UIMachine.FindSnapshot(machine, &empty, list);\n    if (NS_FAILED(rc) || !list[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get root snapshot for domain %s\"),\n                       dom->name);\n        goto error;\n    }\n\n    /* BFS walk through snapshot tree */\n    top = 1;\n    for (next = 0; next < count; next++) {\n        vboxArray children = VBOX_ARRAY_INITIALIZER;\n        size_t i;\n\n        if (!list[next]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected number of snapshots < %u\"), count);\n            goto error;\n        }\n\n        rc = gVBoxAPI.UArray.vboxArrayGet(&children, list[next],\n                                          gVBoxAPI.UArray.handleSnapshotGetChildren(list[next]));\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get children snapshots\"));\n            goto error;\n        }\n        for (i = 0; i < children.count; i++) {\n            ISnapshot *child = children.items[i];\n            if (!child)\n                continue;\n            if (top == count) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unexpected number of snapshots > %u\"), count);\n                gVBoxAPI.UArray.vboxArrayRelease(&children);\n                goto error;\n            }\n            VBOX_ADDREF(child);\n            list[top++] = child;\n        }\n        gVBoxAPI.UArray.vboxArrayRelease(&children);\n    }\n\n out:\n    *snapshots = list;\n    return count;\n\n error:\n    if (list) {\n        for (next = 0; next < count; next++)\n            VBOX_RELEASE(list[next]);\n    }\n    VIR_FREE(list);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get root snapshot for domain %s\")",
            "dom->name"
          ],
          "line": 6331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.FindSnapshot",
          "args": [
            "machine",
            "&empty",
            "snapshots"
          ],
          "line": 6329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "snapshots",
            "1"
          ],
          "line": 6327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&empty"
          ],
          "line": 6326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 6315
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_SNAPSHOT_LIST_ROOTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA",
            "-1"
          ],
          "line": 6312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainSnapshotListNames(virDomainPtr dom, char **names,\n                                       int nameslen, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    nsresult rc;\n    ISnapshot **snapshots = NULL;\n    ssize_t i, count = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_LIST_ROOTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_LIST_METADATA) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_LIST_ROOTS) {\n        vboxIID empty;\n\n        VBOX_IID_INITIALIZE(&empty);\n        if (VIR_ALLOC_N(snapshots, 1) < 0)\n            goto cleanup;\n        rc = gVBoxAPI.UIMachine.FindSnapshot(machine, &empty, snapshots);\n        if (NS_FAILED(rc) || !snapshots[0]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not get root snapshot for domain %s\"),\n                           dom->name);\n            goto cleanup;\n        }\n        count = 1;\n    } else {\n        if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < nameslen; i++) {\n        PRUnichar *nameUtf16;\n        char *name;\n\n        if (i >= count)\n            break;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &name);\n        VBOX_UTF16_FREE(nameUtf16);\n        names[i] = g_strdup(name);\n        VBOX_UTF8_FREE(name);\n    }\n\n    if (count <= nameslen)\n        ret = count;\n    else\n        ret = nameslen;\n\n cleanup:\n    for (i = 0; i < count; i++)\n        VBOX_RELEASE(snapshots[i]);\n    VIR_FREE(snapshots);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSnapshotNum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "6254-6296",
    "snippet": "static int vboxDomainSnapshotNum(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    nsresult rc;\n    PRUint32 snapshotCount;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_LIST_ROOTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    /* VBox snapshots do not require libvirt to maintain any metadata.  */\n    if (flags & VIR_DOMAIN_SNAPSHOT_LIST_METADATA) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIMachine.GetSnapshotCount(machine, &snapshotCount);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get snapshot count for domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    /* VBox has at most one root snapshot.  */\n    if (snapshotCount && (flags & VIR_DOMAIN_SNAPSHOT_LIST_ROOTS))\n        ret = 1;\n    else\n        ret = snapshotCount;\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 6294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 6293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get snapshot count for domain %s\")",
            "dom->name"
          ],
          "line": 6280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not get snapshot count for domain %s\""
          ],
          "line": 6281
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetSnapshotCount",
          "args": [
            "machine",
            "&snapshotCount"
          ],
          "line": 6278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 6269
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_SNAPSHOT_LIST_ROOTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA",
            "-1"
          ],
          "line": 6266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainSnapshotNum(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    nsresult rc;\n    PRUint32 snapshotCount;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_LIST_ROOTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    /* VBox snapshots do not require libvirt to maintain any metadata.  */\n    if (flags & VIR_DOMAIN_SNAPSHOT_LIST_METADATA) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIMachine.GetSnapshotCount(machine, &snapshotCount);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get snapshot count for domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    /* VBox has at most one root snapshot.  */\n    if (snapshotCount && (flags & VIR_DOMAIN_SNAPSHOT_LIST_ROOTS))\n        ret = 1;\n    else\n        ret = snapshotCount;\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSnapshotGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "6115-6252",
    "snippet": "static char *vboxDomainSnapshotGetXMLDesc(virDomainSnapshotPtr snapshot,\n                                          unsigned int flags)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    ISnapshot *parent = NULL;\n    nsresult rc;\n    PRUnichar *str16;\n    char *str8;\n    PRInt64 timestamp;\n    PRBool online = PR_FALSE;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *ret = NULL;\n    virDomainDefPtr defdom;\n    g_autoptr(virDomainSnapshotDef) def = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    if (!(def = virDomainSnapshotDefNew()) ||\n        !(def->parent.dom = virDomainDefNew()))\n        goto cleanup;\n    defdom = def->parent.dom;\n    def->parent.name = g_strdup(snapshot->name);\n\n    if (gVBoxAPI.vboxSnapshotRedefine) {\n        /* Register def->dom properties for them to be saved inside the snapshot XMl\n         * Otherwise, there is a problem while parsing the xml\n         */\n        PRUint32 memorySize = 0;\n        PRUint32 CPUCount = 0;\n\n        defdom->virtType = VIR_DOMAIN_VIRT_VBOX;\n        defdom->id = dom->id;\n        memcpy(defdom->uuid, dom->uuid, VIR_UUID_BUFLEN);\n        defdom->name = g_strdup(dom->name);\n        gVBoxAPI.UIMachine.GetMemorySize(machine, &memorySize);\n        defdom->mem.cur_balloon = memorySize * 1024;\n        /* Currently setting memory and maxMemory as same, cause\n         * the notation here seems to be inconsistent while\n         * reading and while dumping xml\n         */\n        virDomainDefSetMemoryTotal(defdom, memorySize * 1024);\n        defdom->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        defdom->os.arch = virArchFromHost();\n        gVBoxAPI.UIMachine.GetCPUCount(machine, &CPUCount);\n        if (virDomainDefSetVcpusMax(defdom, CPUCount, data->xmlopt) < 0)\n            goto cleanup;\n\n        if (virDomainDefSetVcpus(defdom, CPUCount) < 0)\n            goto cleanup;\n\n        if (vboxSnapshotGetReadWriteDisks(def, snapshot) < 0)\n            VIR_DEBUG(\"Could not get read write disks for snapshot\");\n\n        if (vboxSnapshotGetReadOnlyDisks(def, snapshot) < 0)\n            VIR_DEBUG(\"Could not get Readonly disks for snapshot\");\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetDescription(snap, &str16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get description of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    if (str16) {\n        VBOX_UTF16_TO_UTF8(str16, &str8);\n        VBOX_UTF16_FREE(str16);\n        def->parent.description = g_strdup(str8);\n        VBOX_UTF8_FREE(str8);\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetTimeStamp(snap, &timestamp);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get creation time of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    /* timestamp is in milliseconds while creationTime in seconds */\n    def->parent.creationTime = timestamp / 1000;\n\n    rc = gVBoxAPI.UISnapshot.GetParent(snap, &parent);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get parent of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    if (parent) {\n        rc = gVBoxAPI.UISnapshot.GetName(parent, &str16);\n        if (NS_FAILED(rc) || !str16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not get name of parent of snapshot %s\"),\n                           snapshot->name);\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(str16, &str8);\n        VBOX_UTF16_FREE(str16);\n        def->parent.parent_name = g_strdup(str8);\n        VBOX_UTF8_FREE(str8);\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetOnline(snap, &online);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get online state of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    if (online)\n        def->state = VIR_DOMAIN_SNAPSHOT_RUNNING;\n    else\n        def->state = VIR_DOMAIN_SNAPSHOT_SHUTOFF;\n\n    virUUIDFormat(dom->uuid, uuidstr);\n    memcpy(defdom->uuid, dom->uuid, VIR_UUID_BUFLEN);\n    ret = virDomainSnapshotDefFormat(uuidstr, def, data->xmlopt, 0);\n\n cleanup:\n    VBOX_RELEASE(parent);\n    VBOX_RELEASE(snap);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&domiid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&domiid"
          ],
          "line": 6250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 6249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "snap"
          ],
          "line": 6248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "parent"
          ],
          "line": 6247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDefFormat",
          "args": [
            "uuidstr",
            "def",
            "data->xmlopt",
            "0"
          ],
          "line": 6244
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "926-942",
          "snippet": "char *\nvirDomainSnapshotDefFormat(const char *uuidstr,\n                           virDomainSnapshotDefPtr def,\n                           virDomainXMLOptionPtr xmlopt,\n                           unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_INTERNAL |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_CURRENT, NULL);\n    if (virDomainSnapshotDefFormatInternal(&buf, uuidstr, def,\n                                           xmlopt, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *\nvirDomainSnapshotDefFormat(const char *uuidstr,\n                           virDomainSnapshotDefPtr def,\n                           virDomainXMLOptionPtr xmlopt,\n                           unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_INTERNAL |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_CURRENT, NULL);\n    if (virDomainSnapshotDefFormatInternal(&buf, uuidstr, def,\n                                           xmlopt, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "defdom->uuid",
            "dom->uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 6243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "dom->uuid",
            "uuidstr"
          ],
          "line": 6242
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get online state of snapshot %s\")",
            "snapshot->name"
          ],
          "line": 6232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not get online state of snapshot %s\""
          ],
          "line": 6233
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetOnline",
          "args": [
            "snap",
            "&online"
          ],
          "line": 6230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "str8"
          ],
          "line": 6227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "str8"
          ],
          "line": 6226
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "str16"
          ],
          "line": 6225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "str16",
            "&str8"
          ],
          "line": 6224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get name of parent of snapshot %s\")",
            "snapshot->name"
          ],
          "line": 6219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetName",
          "args": [
            "parent",
            "&str16"
          ],
          "line": 6217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get parent of snapshot %s\")",
            "snapshot->name"
          ],
          "line": 6211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetParent",
          "args": [
            "snap",
            "&parent"
          ],
          "line": 6209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get creation time of snapshot %s\")",
            "snapshot->name"
          ],
          "line": 6201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetTimeStamp",
          "args": [
            "snap",
            "&timestamp"
          ],
          "line": 6199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "str8"
          ],
          "line": 6196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "str16"
          ],
          "line": 6194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "str16",
            "&str8"
          ],
          "line": 6193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get description of snapshot %s\")",
            "snapshot->name"
          ],
          "line": 6187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetDescription",
          "args": [
            "snap",
            "&str16"
          ],
          "line": 6185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Could not get Readonly disks for snapshot\""
          ],
          "line": 6182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxSnapshotGetReadOnlyDisks",
          "args": [
            "def",
            "snapshot"
          ],
          "line": 6181
        },
        "resolved": true,
        "details": {
          "function_name": "vboxSnapshotGetReadOnlyDisks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "5891-6113",
          "snippet": "static int\nvboxSnapshotGetReadOnlyDisks(virDomainSnapshotDefPtr def,\n                             virDomainSnapshotPtr snapshot)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    ISnapshot *snap = NULL;\n    IMachine *machine = NULL;\n    IMachine *snapMachine = NULL;\n    IStorageController *storageController = NULL;\n    IMedium *disk = NULL;\n    nsresult rc;\n    vboxArray mediumAttachments = VBOX_ARRAY_INITIALIZER;\n    size_t i = 0, diskCount = 0, sdCount = 0;\n    int ret = -1;\n    virDomainDefPtr defdom = def->parent.dom;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISnapshot.GetMachine(snap, &snapMachine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get machine\"));\n        goto cleanup;\n    }\n    /*\n     * Get READ ONLY disks\n     * In the snapshot metadata, these are the disks written inside the <domain> node\n    */\n    rc = gVBoxAPI.UArray.vboxArrayGet(&mediumAttachments, snapMachine,\n                                      gVBoxAPI.UArray.handleMachineGetMediumAttachments(snapMachine));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get medium attachments\"));\n        goto cleanup;\n    }\n    /* get the number of attachments */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        if (imediumattach) {\n            IMedium *medium = NULL;\n\n            rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot get medium\"));\n                goto cleanup;\n            }\n            if (medium) {\n                defdom->ndisks++;\n                VBOX_RELEASE(medium);\n            }\n        }\n    }\n\n    /* Allocate mem, if fails return error */\n    if (VIR_ALLOC_N(defdom->disks, defdom->ndisks) >= 0) {\n        for (i = 0; i < defdom->ndisks; i++) {\n            virDomainDiskDefPtr diskDef = virDomainDiskDefNew(NULL);\n            if (!diskDef)\n                goto cleanup;\n            defdom->disks[i] = diskDef;\n        }\n    } else {\n        goto cleanup;\n    }\n\n    /* get the attachment details here */\n    for (i = 0; i < mediumAttachments.count && diskCount < defdom->ndisks; i++) {\n        PRUnichar *storageControllerName = NULL;\n        PRUint32 deviceType = DeviceType_Null;\n        PRUint32 storageBus = StorageBus_Null;\n        PRBool readOnly = PR_FALSE;\n        PRUnichar *mediumLocUtf16 = NULL;\n        char *mediumLocUtf8 = NULL;\n        PRInt32 devicePort = 0;\n        PRInt32 deviceSlot = 0;\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        if (!imediumattach)\n            continue;\n        rc = gVBoxAPI.UIMediumAttachment.GetController(imediumattach, &storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller name\"));\n            goto cleanup;\n        }\n        if (!storageControllerName)\n            continue;\n        rc = gVBoxAPI.UIMachine.GetStorageControllerByName(machine,\n                                                           storageControllerName,\n                                                           &storageController);\n        VBOX_UTF16_FREE(storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller\"));\n            goto cleanup;\n        }\n        if (!storageController)\n            continue;\n        rc = gVBoxAPI.UIStorageController.GetBus(storageController, &storageBus);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller bus\"));\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetPort(imediumattach, &devicePort);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment port\"));\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetDevice(imediumattach, &deviceSlot);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get device slot\"));\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &disk);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium\"));\n            goto cleanup;\n        }\n\n        /* skip empty removable disk */\n        if (!disk) {\n            /* removable disks with empty (ejected) media won't be displayed\n             * in XML, but we need to update \"sdCount\" so that device names match\n             * in domain dumpxml and snapshot dumpxml\n             */\n            if (storageBus == StorageBus_SATA || storageBus == StorageBus_SCSI ||\n                storageBus == StorageBus_SAS)\n                sdCount++;\n\n            VBOX_RELEASE(storageController);\n            continue;\n        }\n\n        rc = gVBoxAPI.UIMedium.GetLocation(disk, &mediumLocUtf16);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get disk location\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(mediumLocUtf16, &mediumLocUtf8);\n        VBOX_UTF16_FREE(mediumLocUtf16);\n        defdom->disks[diskCount]->src->path = g_strdup(mediumLocUtf8);\n\n        VBOX_UTF8_FREE(mediumLocUtf8);\n        rc = gVBoxAPI.UIMedium.GetReadOnly(disk, &readOnly);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get read only attribute\"));\n            goto cleanup;\n        }\n\n        defdom->disks[diskCount]->dst = vboxGenerateMediumName(storageBus,\n                                                               devicePort,\n                                                               deviceSlot,\n                                                               sdCount);\n        if (!defdom->disks[diskCount]->dst) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not generate medium name for the disk \"\n                             \"at: port:%d, slot:%d\"), devicePort, deviceSlot);\n            ret = -1;\n            goto cleanup;\n        }\n\n        if (storageBus == StorageBus_IDE) {\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_IDE;\n        } else if (storageBus == StorageBus_SATA) {\n            sdCount++;\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_SATA;\n        } else if (storageBus == StorageBus_SCSI ||\n                   storageBus == StorageBus_SAS) {\n            sdCount++;\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_SCSI;\n        } else if (storageBus == StorageBus_Floppy) {\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_FDC;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetType(imediumattach, &deviceType);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot get medium attachment type\"));\n            goto cleanup;\n        }\n        if (deviceType == DeviceType_HardDisk)\n            defdom->disks[diskCount]->device = VIR_DOMAIN_DISK_DEVICE_DISK;\n        else if (deviceType == DeviceType_Floppy)\n            defdom->disks[diskCount]->device = VIR_DOMAIN_DISK_DEVICE_FLOPPY;\n        else if (deviceType == DeviceType_DVD)\n            defdom->disks[diskCount]->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n\n        if (readOnly == PR_TRUE)\n            defdom->disks[diskCount]->src->readonly = true;\n        defdom->disks[diskCount]->src->type = VIR_STORAGE_TYPE_FILE;\n\n        diskCount++;\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(disk);\n    VBOX_RELEASE(storageController);\n    gVBoxAPI.UArray.vboxArrayRelease(&mediumAttachments);\n    VBOX_RELEASE(snap);\n\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxSnapshotGetReadOnlyDisks(virDomainSnapshotDefPtr def,\n                             virDomainSnapshotPtr snapshot)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    ISnapshot *snap = NULL;\n    IMachine *machine = NULL;\n    IMachine *snapMachine = NULL;\n    IStorageController *storageController = NULL;\n    IMedium *disk = NULL;\n    nsresult rc;\n    vboxArray mediumAttachments = VBOX_ARRAY_INITIALIZER;\n    size_t i = 0, diskCount = 0, sdCount = 0;\n    int ret = -1;\n    virDomainDefPtr defdom = def->parent.dom;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISnapshot.GetMachine(snap, &snapMachine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get machine\"));\n        goto cleanup;\n    }\n    /*\n     * Get READ ONLY disks\n     * In the snapshot metadata, these are the disks written inside the <domain> node\n    */\n    rc = gVBoxAPI.UArray.vboxArrayGet(&mediumAttachments, snapMachine,\n                                      gVBoxAPI.UArray.handleMachineGetMediumAttachments(snapMachine));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get medium attachments\"));\n        goto cleanup;\n    }\n    /* get the number of attachments */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        if (imediumattach) {\n            IMedium *medium = NULL;\n\n            rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot get medium\"));\n                goto cleanup;\n            }\n            if (medium) {\n                defdom->ndisks++;\n                VBOX_RELEASE(medium);\n            }\n        }\n    }\n\n    /* Allocate mem, if fails return error */\n    if (VIR_ALLOC_N(defdom->disks, defdom->ndisks) >= 0) {\n        for (i = 0; i < defdom->ndisks; i++) {\n            virDomainDiskDefPtr diskDef = virDomainDiskDefNew(NULL);\n            if (!diskDef)\n                goto cleanup;\n            defdom->disks[i] = diskDef;\n        }\n    } else {\n        goto cleanup;\n    }\n\n    /* get the attachment details here */\n    for (i = 0; i < mediumAttachments.count && diskCount < defdom->ndisks; i++) {\n        PRUnichar *storageControllerName = NULL;\n        PRUint32 deviceType = DeviceType_Null;\n        PRUint32 storageBus = StorageBus_Null;\n        PRBool readOnly = PR_FALSE;\n        PRUnichar *mediumLocUtf16 = NULL;\n        char *mediumLocUtf8 = NULL;\n        PRInt32 devicePort = 0;\n        PRInt32 deviceSlot = 0;\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        if (!imediumattach)\n            continue;\n        rc = gVBoxAPI.UIMediumAttachment.GetController(imediumattach, &storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller name\"));\n            goto cleanup;\n        }\n        if (!storageControllerName)\n            continue;\n        rc = gVBoxAPI.UIMachine.GetStorageControllerByName(machine,\n                                                           storageControllerName,\n                                                           &storageController);\n        VBOX_UTF16_FREE(storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller\"));\n            goto cleanup;\n        }\n        if (!storageController)\n            continue;\n        rc = gVBoxAPI.UIStorageController.GetBus(storageController, &storageBus);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller bus\"));\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetPort(imediumattach, &devicePort);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment port\"));\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetDevice(imediumattach, &deviceSlot);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get device slot\"));\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &disk);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium\"));\n            goto cleanup;\n        }\n\n        /* skip empty removable disk */\n        if (!disk) {\n            /* removable disks with empty (ejected) media won't be displayed\n             * in XML, but we need to update \"sdCount\" so that device names match\n             * in domain dumpxml and snapshot dumpxml\n             */\n            if (storageBus == StorageBus_SATA || storageBus == StorageBus_SCSI ||\n                storageBus == StorageBus_SAS)\n                sdCount++;\n\n            VBOX_RELEASE(storageController);\n            continue;\n        }\n\n        rc = gVBoxAPI.UIMedium.GetLocation(disk, &mediumLocUtf16);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get disk location\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(mediumLocUtf16, &mediumLocUtf8);\n        VBOX_UTF16_FREE(mediumLocUtf16);\n        defdom->disks[diskCount]->src->path = g_strdup(mediumLocUtf8);\n\n        VBOX_UTF8_FREE(mediumLocUtf8);\n        rc = gVBoxAPI.UIMedium.GetReadOnly(disk, &readOnly);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get read only attribute\"));\n            goto cleanup;\n        }\n\n        defdom->disks[diskCount]->dst = vboxGenerateMediumName(storageBus,\n                                                               devicePort,\n                                                               deviceSlot,\n                                                               sdCount);\n        if (!defdom->disks[diskCount]->dst) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not generate medium name for the disk \"\n                             \"at: port:%d, slot:%d\"), devicePort, deviceSlot);\n            ret = -1;\n            goto cleanup;\n        }\n\n        if (storageBus == StorageBus_IDE) {\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_IDE;\n        } else if (storageBus == StorageBus_SATA) {\n            sdCount++;\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_SATA;\n        } else if (storageBus == StorageBus_SCSI ||\n                   storageBus == StorageBus_SAS) {\n            sdCount++;\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_SCSI;\n        } else if (storageBus == StorageBus_Floppy) {\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_FDC;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetType(imediumattach, &deviceType);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot get medium attachment type\"));\n            goto cleanup;\n        }\n        if (deviceType == DeviceType_HardDisk)\n            defdom->disks[diskCount]->device = VIR_DOMAIN_DISK_DEVICE_DISK;\n        else if (deviceType == DeviceType_Floppy)\n            defdom->disks[diskCount]->device = VIR_DOMAIN_DISK_DEVICE_FLOPPY;\n        else if (deviceType == DeviceType_DVD)\n            defdom->disks[diskCount]->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n\n        if (readOnly == PR_TRUE)\n            defdom->disks[diskCount]->src->readonly = true;\n        defdom->disks[diskCount]->src->type = VIR_STORAGE_TYPE_FILE;\n\n        diskCount++;\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(disk);\n    VBOX_RELEASE(storageController);\n    gVBoxAPI.UArray.vboxArrayRelease(&mediumAttachments);\n    VBOX_RELEASE(snap);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Could not get read write disks for snapshot\""
          ],
          "line": 6179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxSnapshotGetReadWriteDisks",
          "args": [
            "def",
            "snapshot"
          ],
          "line": 6178
        },
        "resolved": true,
        "details": {
          "function_name": "vboxSnapshotGetReadWriteDisks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "5656-5889",
          "snippet": "static int\nvboxSnapshotGetReadWriteDisks(virDomainSnapshotDefPtr def,\n                              virDomainSnapshotPtr snapshot)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    IMachine *snapMachine = NULL;\n    vboxArray mediumAttachments = VBOX_ARRAY_INITIALIZER;\n    size_t diskCount = 0, sdCount = 0;\n    nsresult rc;\n    vboxIID snapIid;\n    char *snapshotUuidStr = NULL;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    VBOX_IID_INITIALIZE(&snapIid);\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISnapshot.GetId(snap, &snapIid);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not get snapshot id\"));\n        goto cleanup;\n    }\n\n    gVBoxAPI.UIID.vboxIIDToUtf8(data, &snapIid, &snapshotUuidStr);\n    vboxIIDUnalloc(&snapIid);\n    rc = gVBoxAPI.UISnapshot.GetMachine(snap, &snapMachine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get machine\"));\n        goto cleanup;\n    }\n    def->ndisks = 0;\n    rc = gVBoxAPI.UArray.vboxArrayGet(&mediumAttachments, snapMachine,\n                                      gVBoxAPI.UArray.handleMachineGetMediumAttachments(snapMachine));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no medium attachments\"));\n        goto cleanup;\n    }\n    /* get the number of attachments */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        if (imediumattach) {\n            IMedium *medium = NULL;\n\n            rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot get medium\"));\n                goto cleanup;\n            }\n            if (medium) {\n                def->ndisks++;\n                VBOX_RELEASE(medium);\n            }\n        }\n    }\n    /* Allocate mem, if fails return error */\n    if (VIR_ALLOC_N(def->disks, def->ndisks) < 0)\n        goto cleanup;\n    for (i = 0; i < def->ndisks; i++) {\n        if (VIR_ALLOC(def->disks[i].src) < 0)\n            goto cleanup;\n    }\n\n    /* get the attachment details here */\n    for (i = 0; i < mediumAttachments.count && diskCount < def->ndisks; i++) {\n        IStorageController *storageController = NULL;\n        PRUnichar *storageControllerName = NULL;\n        PRUint32 deviceType = DeviceType_Null;\n        PRUint32 storageBus = StorageBus_Null;\n        IMedium *disk = NULL;\n        PRUnichar *childLocUtf16 = NULL;\n        char *childLocUtf8 = NULL;\n        PRInt32 devicePort = 0;\n        PRInt32 deviceSlot = 0;\n        vboxArray children = VBOX_ARRAY_INITIALIZER;\n        vboxArray snapshotIids = VBOX_ARRAY_INITIALIZER;\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        void *handle;\n        size_t j = 0;\n        size_t k = 0;\n\n        if (!imediumattach)\n            continue;\n\n        rc = gVBoxAPI.UIMediumAttachment.GetController(imediumattach,\n                                                       &storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller name\"));\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMachine.GetStorageControllerByName(machine,\n                                                           storageControllerName,\n                                                           &storageController);\n        VBOX_UTF16_FREE(storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller by name\"));\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIStorageController.GetBus(storageController, &storageBus);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller bus\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetType(imediumattach, &deviceType);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment type\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetPort(imediumattach, &devicePort);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment port\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetDevice(imediumattach, &deviceSlot);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment slot\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &disk);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n\n        /* skip empty removable disk */\n        if (!disk) {\n            /* removable disks with empty (ejected) media won't be displayed\n             * in XML, but we need to update \"sdCount\" so that device names match\n             * in domain dumpxml and snapshot dumpxml\n             */\n            if (storageBus == StorageBus_SATA || storageBus == StorageBus_SCSI ||\n                storageBus == StorageBus_SAS)\n                sdCount++;\n\n            VBOX_RELEASE(storageController);\n            continue;\n        }\n\n        handle = gVBoxAPI.UArray.handleMediumGetChildren(disk);\n        rc = gVBoxAPI.UArray.vboxArrayGet(&children, disk, handle);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot get children disk\"));\n            goto cleanup;\n        }\n        handle = gVBoxAPI.UArray.handleMediumGetSnapshotIds(disk);\n        rc = gVBoxAPI.UArray.vboxArrayGetWithIIDArg(&snapshotIids, disk,\n                                                    handle, &domiid);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot get snapshot ids\"));\n            goto cleanup;\n        }\n        for (j = 0; j < children.count; ++j) {\n            IMedium *child = children.items[j];\n            for (k = 0; k < snapshotIids.count; ++k) {\n                PRUnichar *diskSnapId = snapshotIids.items[k];\n                char *diskSnapIdStr = NULL;\n                VBOX_UTF16_TO_UTF8(diskSnapId, &diskSnapIdStr);\n                if (STREQ(diskSnapIdStr, snapshotUuidStr)) {\n                    rc = gVBoxAPI.UIMedium.GetLocation(child, &childLocUtf16);\n                    if (NS_FAILED(rc)) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                       _(\"cannot get disk location\"));\n                        VBOX_RELEASE(storageController);\n                        VBOX_RELEASE(disk);\n                        VBOX_RELEASE(child);\n                        goto cleanup;\n                    }\n                    VBOX_UTF16_TO_UTF8(childLocUtf16, &childLocUtf8);\n                    VBOX_UTF16_FREE(childLocUtf16);\n                    def->disks[diskCount].src->path = g_strdup(childLocUtf8);\n                    VBOX_UTF8_FREE(childLocUtf8);\n\n                    def->disks[diskCount].src->type = VIR_STORAGE_TYPE_FILE;\n                    def->disks[diskCount].name = vboxGenerateMediumName(storageBus,\n                                                                        devicePort,\n                                                                        deviceSlot,\n                                                                        sdCount);\n                }\n                VBOX_UTF8_FREE(diskSnapIdStr);\n            }\n        }\n        VBOX_RELEASE(storageController);\n        VBOX_RELEASE(disk);\n        diskCount++;\n\n        if (storageBus == StorageBus_SATA || storageBus == StorageBus_SCSI ||\n            storageBus == StorageBus_SAS)\n            sdCount++;\n\n    }\n    gVBoxAPI.UArray.vboxArrayRelease(&mediumAttachments);\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(snap);\n\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxSnapshotGetReadWriteDisks(virDomainSnapshotDefPtr def,\n                              virDomainSnapshotPtr snapshot)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    IMachine *snapMachine = NULL;\n    vboxArray mediumAttachments = VBOX_ARRAY_INITIALIZER;\n    size_t diskCount = 0, sdCount = 0;\n    nsresult rc;\n    vboxIID snapIid;\n    char *snapshotUuidStr = NULL;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    VBOX_IID_INITIALIZE(&snapIid);\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISnapshot.GetId(snap, &snapIid);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not get snapshot id\"));\n        goto cleanup;\n    }\n\n    gVBoxAPI.UIID.vboxIIDToUtf8(data, &snapIid, &snapshotUuidStr);\n    vboxIIDUnalloc(&snapIid);\n    rc = gVBoxAPI.UISnapshot.GetMachine(snap, &snapMachine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get machine\"));\n        goto cleanup;\n    }\n    def->ndisks = 0;\n    rc = gVBoxAPI.UArray.vboxArrayGet(&mediumAttachments, snapMachine,\n                                      gVBoxAPI.UArray.handleMachineGetMediumAttachments(snapMachine));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no medium attachments\"));\n        goto cleanup;\n    }\n    /* get the number of attachments */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        if (imediumattach) {\n            IMedium *medium = NULL;\n\n            rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot get medium\"));\n                goto cleanup;\n            }\n            if (medium) {\n                def->ndisks++;\n                VBOX_RELEASE(medium);\n            }\n        }\n    }\n    /* Allocate mem, if fails return error */\n    if (VIR_ALLOC_N(def->disks, def->ndisks) < 0)\n        goto cleanup;\n    for (i = 0; i < def->ndisks; i++) {\n        if (VIR_ALLOC(def->disks[i].src) < 0)\n            goto cleanup;\n    }\n\n    /* get the attachment details here */\n    for (i = 0; i < mediumAttachments.count && diskCount < def->ndisks; i++) {\n        IStorageController *storageController = NULL;\n        PRUnichar *storageControllerName = NULL;\n        PRUint32 deviceType = DeviceType_Null;\n        PRUint32 storageBus = StorageBus_Null;\n        IMedium *disk = NULL;\n        PRUnichar *childLocUtf16 = NULL;\n        char *childLocUtf8 = NULL;\n        PRInt32 devicePort = 0;\n        PRInt32 deviceSlot = 0;\n        vboxArray children = VBOX_ARRAY_INITIALIZER;\n        vboxArray snapshotIids = VBOX_ARRAY_INITIALIZER;\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        void *handle;\n        size_t j = 0;\n        size_t k = 0;\n\n        if (!imediumattach)\n            continue;\n\n        rc = gVBoxAPI.UIMediumAttachment.GetController(imediumattach,\n                                                       &storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller name\"));\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMachine.GetStorageControllerByName(machine,\n                                                           storageControllerName,\n                                                           &storageController);\n        VBOX_UTF16_FREE(storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller by name\"));\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIStorageController.GetBus(storageController, &storageBus);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller bus\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetType(imediumattach, &deviceType);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment type\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetPort(imediumattach, &devicePort);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment port\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetDevice(imediumattach, &deviceSlot);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment slot\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &disk);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n\n        /* skip empty removable disk */\n        if (!disk) {\n            /* removable disks with empty (ejected) media won't be displayed\n             * in XML, but we need to update \"sdCount\" so that device names match\n             * in domain dumpxml and snapshot dumpxml\n             */\n            if (storageBus == StorageBus_SATA || storageBus == StorageBus_SCSI ||\n                storageBus == StorageBus_SAS)\n                sdCount++;\n\n            VBOX_RELEASE(storageController);\n            continue;\n        }\n\n        handle = gVBoxAPI.UArray.handleMediumGetChildren(disk);\n        rc = gVBoxAPI.UArray.vboxArrayGet(&children, disk, handle);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot get children disk\"));\n            goto cleanup;\n        }\n        handle = gVBoxAPI.UArray.handleMediumGetSnapshotIds(disk);\n        rc = gVBoxAPI.UArray.vboxArrayGetWithIIDArg(&snapshotIids, disk,\n                                                    handle, &domiid);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot get snapshot ids\"));\n            goto cleanup;\n        }\n        for (j = 0; j < children.count; ++j) {\n            IMedium *child = children.items[j];\n            for (k = 0; k < snapshotIids.count; ++k) {\n                PRUnichar *diskSnapId = snapshotIids.items[k];\n                char *diskSnapIdStr = NULL;\n                VBOX_UTF16_TO_UTF8(diskSnapId, &diskSnapIdStr);\n                if (STREQ(diskSnapIdStr, snapshotUuidStr)) {\n                    rc = gVBoxAPI.UIMedium.GetLocation(child, &childLocUtf16);\n                    if (NS_FAILED(rc)) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                       _(\"cannot get disk location\"));\n                        VBOX_RELEASE(storageController);\n                        VBOX_RELEASE(disk);\n                        VBOX_RELEASE(child);\n                        goto cleanup;\n                    }\n                    VBOX_UTF16_TO_UTF8(childLocUtf16, &childLocUtf8);\n                    VBOX_UTF16_FREE(childLocUtf16);\n                    def->disks[diskCount].src->path = g_strdup(childLocUtf8);\n                    VBOX_UTF8_FREE(childLocUtf8);\n\n                    def->disks[diskCount].src->type = VIR_STORAGE_TYPE_FILE;\n                    def->disks[diskCount].name = vboxGenerateMediumName(storageBus,\n                                                                        devicePort,\n                                                                        deviceSlot,\n                                                                        sdCount);\n                }\n                VBOX_UTF8_FREE(diskSnapIdStr);\n            }\n        }\n        VBOX_RELEASE(storageController);\n        VBOX_RELEASE(disk);\n        diskCount++;\n\n        if (storageBus == StorageBus_SATA || storageBus == StorageBus_SCSI ||\n            storageBus == StorageBus_SAS)\n            sdCount++;\n\n    }\n    gVBoxAPI.UArray.vboxArrayRelease(&mediumAttachments);\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(snap);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetVcpus",
          "args": [
            "defdom",
            "CPUCount"
          ],
          "line": 6175
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1889-1909",
          "snippet": "int\nvirDomainDefSetVcpus(virDomainDefPtr def,\n                     unsigned int vcpus)\n{\n    size_t i;\n\n    if (vcpus > def->maxvcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"maximum vCPU count must not be less than current \"\n                         \"vCPU count\"));\n        return -1;\n    }\n\n    for (i = 0; i < vcpus; i++)\n        def->vcpus[i]->online = true;\n\n    for (i = vcpus; i < def->maxvcpus; i++)\n        def->vcpus[i]->online = false;\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSetVcpus(virDomainDefPtr def,\n                     unsigned int vcpus)\n{\n    size_t i;\n\n    if (vcpus > def->maxvcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"maximum vCPU count must not be less than current \"\n                         \"vCPU count\"));\n        return -1;\n    }\n\n    for (i = 0; i < vcpus; i++)\n        def->vcpus[i]->online = true;\n\n    for (i = vcpus; i < def->maxvcpus; i++)\n        def->vcpus[i]->online = false;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetVcpusMax",
          "args": [
            "defdom",
            "CPUCount",
            "data->xmlopt"
          ],
          "line": 6172
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetVcpusMax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1838-1865",
          "snippet": "int\nvirDomainDefSetVcpusMax(virDomainDefPtr def,\n                        unsigned int maxvcpus,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    size_t oldmax = def->maxvcpus;\n    size_t i;\n\n    if (def->maxvcpus == maxvcpus)\n        return 0;\n\n    if (def->maxvcpus < maxvcpus) {\n        if (VIR_EXPAND_N(def->vcpus, def->maxvcpus, maxvcpus - def->maxvcpus) < 0)\n            return -1;\n\n        for (i = oldmax; i < def->maxvcpus; i++) {\n            if (!(def->vcpus[i] = virDomainVcpuDefNew(xmlopt)))\n                return -1;\n        }\n    } else {\n        for (i = maxvcpus; i < def->maxvcpus; i++)\n            virDomainVcpuDefFree(def->vcpus[i]);\n\n        VIR_SHRINK_N(def->vcpus, def->maxvcpus, def->maxvcpus - maxvcpus);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSetVcpusMax(virDomainDefPtr def,\n                        unsigned int maxvcpus,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    size_t oldmax = def->maxvcpus;\n    size_t i;\n\n    if (def->maxvcpus == maxvcpus)\n        return 0;\n\n    if (def->maxvcpus < maxvcpus) {\n        if (VIR_EXPAND_N(def->vcpus, def->maxvcpus, maxvcpus - def->maxvcpus) < 0)\n            return -1;\n\n        for (i = oldmax; i < def->maxvcpus; i++) {\n            if (!(def->vcpus[i] = virDomainVcpuDefNew(xmlopt)))\n                return -1;\n        }\n    } else {\n        for (i = maxvcpus; i < def->maxvcpus; i++)\n            virDomainVcpuDefFree(def->vcpus[i]);\n\n        VIR_SHRINK_N(def->vcpus, def->maxvcpus, def->maxvcpus - maxvcpus);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetCPUCount",
          "args": [
            "machine",
            "&CPUCount"
          ],
          "line": 6171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchFromHost",
          "args": [],
          "line": 6170
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "206-235",
          "snippet": "virArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nvirArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetMemoryTotal",
          "args": [
            "defdom",
            "memorySize * 1024"
          ],
          "line": 6168
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10931-10936",
          "snippet": "void\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetMemorySize",
          "args": [
            "machine",
            "&memorySize"
          ],
          "line": 6162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "defdom->uuid",
            "dom->uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 6160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefNew",
          "args": [],
          "line": 6146
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3574-3594",
          "snippet": "virDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDefNew",
          "args": [],
          "line": 6145
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "113-120",
          "snippet": "virDomainSnapshotDefPtr\nvirDomainSnapshotDefNew(void)\n{\n    if (virDomainSnapshotInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virDomainSnapshotDefClass);\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virDomainSnapshotDefClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virClassPtr virDomainSnapshotDefClass;\n\nvirDomainSnapshotDefPtr\nvirDomainSnapshotDefNew(void)\n{\n    if (virDomainSnapshotInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virDomainSnapshotDefClass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotGet",
          "args": [
            "data",
            "dom",
            "machine",
            "snapshot->name"
          ],
          "line": 6142
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "5606-5654",
          "snippet": "static ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&domiid",
            "&machine"
          ],
          "line": 6139
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 6137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic char *vboxDomainSnapshotGetXMLDesc(virDomainSnapshotPtr snapshot,\n                                          unsigned int flags)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    ISnapshot *parent = NULL;\n    nsresult rc;\n    PRUnichar *str16;\n    char *str8;\n    PRInt64 timestamp;\n    PRBool online = PR_FALSE;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    char *ret = NULL;\n    virDomainDefPtr defdom;\n    g_autoptr(virDomainSnapshotDef) def = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, NULL);\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    if (!(def = virDomainSnapshotDefNew()) ||\n        !(def->parent.dom = virDomainDefNew()))\n        goto cleanup;\n    defdom = def->parent.dom;\n    def->parent.name = g_strdup(snapshot->name);\n\n    if (gVBoxAPI.vboxSnapshotRedefine) {\n        /* Register def->dom properties for them to be saved inside the snapshot XMl\n         * Otherwise, there is a problem while parsing the xml\n         */\n        PRUint32 memorySize = 0;\n        PRUint32 CPUCount = 0;\n\n        defdom->virtType = VIR_DOMAIN_VIRT_VBOX;\n        defdom->id = dom->id;\n        memcpy(defdom->uuid, dom->uuid, VIR_UUID_BUFLEN);\n        defdom->name = g_strdup(dom->name);\n        gVBoxAPI.UIMachine.GetMemorySize(machine, &memorySize);\n        defdom->mem.cur_balloon = memorySize * 1024;\n        /* Currently setting memory and maxMemory as same, cause\n         * the notation here seems to be inconsistent while\n         * reading and while dumping xml\n         */\n        virDomainDefSetMemoryTotal(defdom, memorySize * 1024);\n        defdom->os.type = VIR_DOMAIN_OSTYPE_HVM;\n        defdom->os.arch = virArchFromHost();\n        gVBoxAPI.UIMachine.GetCPUCount(machine, &CPUCount);\n        if (virDomainDefSetVcpusMax(defdom, CPUCount, data->xmlopt) < 0)\n            goto cleanup;\n\n        if (virDomainDefSetVcpus(defdom, CPUCount) < 0)\n            goto cleanup;\n\n        if (vboxSnapshotGetReadWriteDisks(def, snapshot) < 0)\n            VIR_DEBUG(\"Could not get read write disks for snapshot\");\n\n        if (vboxSnapshotGetReadOnlyDisks(def, snapshot) < 0)\n            VIR_DEBUG(\"Could not get Readonly disks for snapshot\");\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetDescription(snap, &str16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get description of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    if (str16) {\n        VBOX_UTF16_TO_UTF8(str16, &str8);\n        VBOX_UTF16_FREE(str16);\n        def->parent.description = g_strdup(str8);\n        VBOX_UTF8_FREE(str8);\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetTimeStamp(snap, &timestamp);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get creation time of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    /* timestamp is in milliseconds while creationTime in seconds */\n    def->parent.creationTime = timestamp / 1000;\n\n    rc = gVBoxAPI.UISnapshot.GetParent(snap, &parent);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get parent of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    if (parent) {\n        rc = gVBoxAPI.UISnapshot.GetName(parent, &str16);\n        if (NS_FAILED(rc) || !str16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not get name of parent of snapshot %s\"),\n                           snapshot->name);\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(str16, &str8);\n        VBOX_UTF16_FREE(str16);\n        def->parent.parent_name = g_strdup(str8);\n        VBOX_UTF8_FREE(str8);\n    }\n\n    rc = gVBoxAPI.UISnapshot.GetOnline(snap, &online);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get online state of snapshot %s\"),\n                       snapshot->name);\n        goto cleanup;\n    }\n    if (online)\n        def->state = VIR_DOMAIN_SNAPSHOT_RUNNING;\n    else\n        def->state = VIR_DOMAIN_SNAPSHOT_SHUTOFF;\n\n    virUUIDFormat(dom->uuid, uuidstr);\n    memcpy(defdom->uuid, dom->uuid, VIR_UUID_BUFLEN);\n    ret = virDomainSnapshotDefFormat(uuidstr, def, data->xmlopt, 0);\n\n cleanup:\n    VBOX_RELEASE(parent);\n    VBOX_RELEASE(snap);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&domiid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxSnapshotGetReadOnlyDisks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "5891-6113",
    "snippet": "static int\nvboxSnapshotGetReadOnlyDisks(virDomainSnapshotDefPtr def,\n                             virDomainSnapshotPtr snapshot)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    ISnapshot *snap = NULL;\n    IMachine *machine = NULL;\n    IMachine *snapMachine = NULL;\n    IStorageController *storageController = NULL;\n    IMedium *disk = NULL;\n    nsresult rc;\n    vboxArray mediumAttachments = VBOX_ARRAY_INITIALIZER;\n    size_t i = 0, diskCount = 0, sdCount = 0;\n    int ret = -1;\n    virDomainDefPtr defdom = def->parent.dom;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISnapshot.GetMachine(snap, &snapMachine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get machine\"));\n        goto cleanup;\n    }\n    /*\n     * Get READ ONLY disks\n     * In the snapshot metadata, these are the disks written inside the <domain> node\n    */\n    rc = gVBoxAPI.UArray.vboxArrayGet(&mediumAttachments, snapMachine,\n                                      gVBoxAPI.UArray.handleMachineGetMediumAttachments(snapMachine));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get medium attachments\"));\n        goto cleanup;\n    }\n    /* get the number of attachments */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        if (imediumattach) {\n            IMedium *medium = NULL;\n\n            rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot get medium\"));\n                goto cleanup;\n            }\n            if (medium) {\n                defdom->ndisks++;\n                VBOX_RELEASE(medium);\n            }\n        }\n    }\n\n    /* Allocate mem, if fails return error */\n    if (VIR_ALLOC_N(defdom->disks, defdom->ndisks) >= 0) {\n        for (i = 0; i < defdom->ndisks; i++) {\n            virDomainDiskDefPtr diskDef = virDomainDiskDefNew(NULL);\n            if (!diskDef)\n                goto cleanup;\n            defdom->disks[i] = diskDef;\n        }\n    } else {\n        goto cleanup;\n    }\n\n    /* get the attachment details here */\n    for (i = 0; i < mediumAttachments.count && diskCount < defdom->ndisks; i++) {\n        PRUnichar *storageControllerName = NULL;\n        PRUint32 deviceType = DeviceType_Null;\n        PRUint32 storageBus = StorageBus_Null;\n        PRBool readOnly = PR_FALSE;\n        PRUnichar *mediumLocUtf16 = NULL;\n        char *mediumLocUtf8 = NULL;\n        PRInt32 devicePort = 0;\n        PRInt32 deviceSlot = 0;\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        if (!imediumattach)\n            continue;\n        rc = gVBoxAPI.UIMediumAttachment.GetController(imediumattach, &storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller name\"));\n            goto cleanup;\n        }\n        if (!storageControllerName)\n            continue;\n        rc = gVBoxAPI.UIMachine.GetStorageControllerByName(machine,\n                                                           storageControllerName,\n                                                           &storageController);\n        VBOX_UTF16_FREE(storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller\"));\n            goto cleanup;\n        }\n        if (!storageController)\n            continue;\n        rc = gVBoxAPI.UIStorageController.GetBus(storageController, &storageBus);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller bus\"));\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetPort(imediumattach, &devicePort);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment port\"));\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetDevice(imediumattach, &deviceSlot);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get device slot\"));\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &disk);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium\"));\n            goto cleanup;\n        }\n\n        /* skip empty removable disk */\n        if (!disk) {\n            /* removable disks with empty (ejected) media won't be displayed\n             * in XML, but we need to update \"sdCount\" so that device names match\n             * in domain dumpxml and snapshot dumpxml\n             */\n            if (storageBus == StorageBus_SATA || storageBus == StorageBus_SCSI ||\n                storageBus == StorageBus_SAS)\n                sdCount++;\n\n            VBOX_RELEASE(storageController);\n            continue;\n        }\n\n        rc = gVBoxAPI.UIMedium.GetLocation(disk, &mediumLocUtf16);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get disk location\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(mediumLocUtf16, &mediumLocUtf8);\n        VBOX_UTF16_FREE(mediumLocUtf16);\n        defdom->disks[diskCount]->src->path = g_strdup(mediumLocUtf8);\n\n        VBOX_UTF8_FREE(mediumLocUtf8);\n        rc = gVBoxAPI.UIMedium.GetReadOnly(disk, &readOnly);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get read only attribute\"));\n            goto cleanup;\n        }\n\n        defdom->disks[diskCount]->dst = vboxGenerateMediumName(storageBus,\n                                                               devicePort,\n                                                               deviceSlot,\n                                                               sdCount);\n        if (!defdom->disks[diskCount]->dst) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not generate medium name for the disk \"\n                             \"at: port:%d, slot:%d\"), devicePort, deviceSlot);\n            ret = -1;\n            goto cleanup;\n        }\n\n        if (storageBus == StorageBus_IDE) {\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_IDE;\n        } else if (storageBus == StorageBus_SATA) {\n            sdCount++;\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_SATA;\n        } else if (storageBus == StorageBus_SCSI ||\n                   storageBus == StorageBus_SAS) {\n            sdCount++;\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_SCSI;\n        } else if (storageBus == StorageBus_Floppy) {\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_FDC;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetType(imediumattach, &deviceType);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot get medium attachment type\"));\n            goto cleanup;\n        }\n        if (deviceType == DeviceType_HardDisk)\n            defdom->disks[diskCount]->device = VIR_DOMAIN_DISK_DEVICE_DISK;\n        else if (deviceType == DeviceType_Floppy)\n            defdom->disks[diskCount]->device = VIR_DOMAIN_DISK_DEVICE_FLOPPY;\n        else if (deviceType == DeviceType_DVD)\n            defdom->disks[diskCount]->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n\n        if (readOnly == PR_TRUE)\n            defdom->disks[diskCount]->src->readonly = true;\n        defdom->disks[diskCount]->src->type = VIR_STORAGE_TYPE_FILE;\n\n        diskCount++;\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(disk);\n    VBOX_RELEASE(storageController);\n    gVBoxAPI.UArray.vboxArrayRelease(&mediumAttachments);\n    VBOX_RELEASE(snap);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "snap"
          ],
          "line": 6110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&mediumAttachments"
          ],
          "line": 6109
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "storageController"
          ],
          "line": 6108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "disk"
          ],
          "line": 6107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot get medium attachment type\")"
          ],
          "line": 6086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot get medium attachment type\""
          ],
          "line": 6087
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetType",
          "args": [
            "imediumattach",
            "&deviceType"
          ],
          "line": 6084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not generate medium name for the disk \"\n                             \"at: port:%d, slot:%d\")",
            "devicePort",
            "deviceSlot"
          ],
          "line": 6064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxGenerateMediumName",
          "args": [
            "storageBus",
            "devicePort",
            "deviceSlot",
            "sdCount"
          ],
          "line": 6059
        },
        "resolved": true,
        "details": {
          "function_name": "vboxGenerateMediumName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "299-335",
          "snippet": "static char *\nvboxGenerateMediumName(PRUint32 storageBus,\n                       PRInt32 devicePort,\n                       PRInt32 deviceSlot,\n                       size_t sdCount)\n{\n    const char *prefix = NULL;\n    char *name = NULL;\n    int total = 0;\n\n    switch ((enum StorageBus) storageBus) {\n    case StorageBus_IDE:\n        prefix = \"hd\";\n        total = devicePort * 2 + deviceSlot;\n\n        break;\n    case StorageBus_SATA:\n    case StorageBus_SCSI:\n    case StorageBus_SAS:\n        prefix = \"sd\";\n        total = sdCount;\n\n        break;\n    case StorageBus_Floppy:\n        total = deviceSlot;\n        prefix = \"fd\";\n\n        break;\n    case StorageBus_Null:\n\n        return NULL;\n    }\n\n    name = virIndexToDiskName(total, prefix);\n\n    return name;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nvboxGenerateMediumName(PRUint32 storageBus,\n                       PRInt32 devicePort,\n                       PRInt32 deviceSlot,\n                       size_t sdCount)\n{\n    const char *prefix = NULL;\n    char *name = NULL;\n    int total = 0;\n\n    switch ((enum StorageBus) storageBus) {\n    case StorageBus_IDE:\n        prefix = \"hd\";\n        total = devicePort * 2 + deviceSlot;\n\n        break;\n    case StorageBus_SATA:\n    case StorageBus_SCSI:\n    case StorageBus_SAS:\n        prefix = \"sd\";\n        total = sdCount;\n\n        break;\n    case StorageBus_Floppy:\n        total = deviceSlot;\n        prefix = \"fd\";\n\n        break;\n    case StorageBus_Null:\n\n        return NULL;\n    }\n\n    name = virIndexToDiskName(total, prefix);\n\n    return name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get read only attribute\")"
          ],
          "line": 6054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetReadOnly",
          "args": [
            "disk",
            "&readOnly"
          ],
          "line": 6052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "mediumLocUtf8"
          ],
          "line": 6051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "mediumLocUtf8"
          ],
          "line": 6049
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "mediumLocUtf16"
          ],
          "line": 6048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "mediumLocUtf16",
            "&mediumLocUtf8"
          ],
          "line": 6047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get disk location\")"
          ],
          "line": 6043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetLocation",
          "args": [
            "disk",
            "&mediumLocUtf16"
          ],
          "line": 6041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "storageController"
          ],
          "line": 6037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get medium\")"
          ],
          "line": 6022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetMedium",
          "args": [
            "imediumattach",
            "&disk"
          ],
          "line": 6020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get device slot\")"
          ],
          "line": 6015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetDevice",
          "args": [
            "imediumattach",
            "&deviceSlot"
          ],
          "line": 6013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get medium attachment port\")"
          ],
          "line": 6009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetPort",
          "args": [
            "imediumattach",
            "&devicePort"
          ],
          "line": 6007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get storage controller bus\")"
          ],
          "line": 6003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 6002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIStorageController.GetBus",
          "args": [
            "storageController",
            "&storageBus"
          ],
          "line": 6001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get storage controller\")"
          ],
          "line": 5995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "storageControllerName"
          ],
          "line": 5993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetStorageControllerByName",
          "args": [
            "machine",
            "storageControllerName",
            "&storageController"
          ],
          "line": 5990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get storage controller name\")"
          ],
          "line": 5984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetController",
          "args": [
            "imediumattach",
            "&storageControllerName"
          ],
          "line": 5982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskDefNew",
          "args": [
            "NULL"
          ],
          "line": 5960
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2093-2114",
          "snippet": "virDomainDiskDefPtr\nvirDomainDiskDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDiskDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto error;\n\n    if (xmlopt &&\n        xmlopt->privateData.diskNew &&\n        !(ret->privateData = xmlopt->privateData.diskNew()))\n        goto error;\n\n    return ret;\n\n error:\n    virDomainDiskDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDiskDefPtr\nvirDomainDiskDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDiskDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto error;\n\n    if (xmlopt &&\n        xmlopt->privateData.diskNew &&\n        !(ret->privateData = xmlopt->privateData.diskNew()))\n        goto error;\n\n    return ret;\n\n error:\n    virDomainDiskDefFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "defdom->disks",
            "defdom->ndisks"
          ],
          "line": 5958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "medium"
          ],
          "line": 5952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot get medium\")"
          ],
          "line": 5946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetMedium",
          "args": [
            "imediumattach",
            "&medium"
          ],
          "line": 5944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot get medium attachments\")"
          ],
          "line": 5934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&mediumAttachments",
            "snapMachine",
            "gVBoxAPI.UArray.handleMachineGetMediumAttachments(snapMachine)"
          ],
          "line": 5931
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleMachineGetMediumAttachments",
          "args": [
            "snapMachine"
          ],
          "line": 5932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot get machine\")"
          ],
          "line": 5923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetMachine",
          "args": [
            "snap",
            "&snapMachine"
          ],
          "line": 5921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotGet",
          "args": [
            "data",
            "dom",
            "machine",
            "snapshot->name"
          ],
          "line": 5918
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "5606-5654",
          "snippet": "static ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&domiid",
            "&machine"
          ],
          "line": 5915
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"This function may not work in current version\""
          ],
          "line": 5913
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxSnapshotGetReadOnlyDisks(virDomainSnapshotDefPtr def,\n                             virDomainSnapshotPtr snapshot)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    ISnapshot *snap = NULL;\n    IMachine *machine = NULL;\n    IMachine *snapMachine = NULL;\n    IStorageController *storageController = NULL;\n    IMedium *disk = NULL;\n    nsresult rc;\n    vboxArray mediumAttachments = VBOX_ARRAY_INITIALIZER;\n    size_t i = 0, diskCount = 0, sdCount = 0;\n    int ret = -1;\n    virDomainDefPtr defdom = def->parent.dom;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISnapshot.GetMachine(snap, &snapMachine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get machine\"));\n        goto cleanup;\n    }\n    /*\n     * Get READ ONLY disks\n     * In the snapshot metadata, these are the disks written inside the <domain> node\n    */\n    rc = gVBoxAPI.UArray.vboxArrayGet(&mediumAttachments, snapMachine,\n                                      gVBoxAPI.UArray.handleMachineGetMediumAttachments(snapMachine));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get medium attachments\"));\n        goto cleanup;\n    }\n    /* get the number of attachments */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        if (imediumattach) {\n            IMedium *medium = NULL;\n\n            rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot get medium\"));\n                goto cleanup;\n            }\n            if (medium) {\n                defdom->ndisks++;\n                VBOX_RELEASE(medium);\n            }\n        }\n    }\n\n    /* Allocate mem, if fails return error */\n    if (VIR_ALLOC_N(defdom->disks, defdom->ndisks) >= 0) {\n        for (i = 0; i < defdom->ndisks; i++) {\n            virDomainDiskDefPtr diskDef = virDomainDiskDefNew(NULL);\n            if (!diskDef)\n                goto cleanup;\n            defdom->disks[i] = diskDef;\n        }\n    } else {\n        goto cleanup;\n    }\n\n    /* get the attachment details here */\n    for (i = 0; i < mediumAttachments.count && diskCount < defdom->ndisks; i++) {\n        PRUnichar *storageControllerName = NULL;\n        PRUint32 deviceType = DeviceType_Null;\n        PRUint32 storageBus = StorageBus_Null;\n        PRBool readOnly = PR_FALSE;\n        PRUnichar *mediumLocUtf16 = NULL;\n        char *mediumLocUtf8 = NULL;\n        PRInt32 devicePort = 0;\n        PRInt32 deviceSlot = 0;\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        if (!imediumattach)\n            continue;\n        rc = gVBoxAPI.UIMediumAttachment.GetController(imediumattach, &storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller name\"));\n            goto cleanup;\n        }\n        if (!storageControllerName)\n            continue;\n        rc = gVBoxAPI.UIMachine.GetStorageControllerByName(machine,\n                                                           storageControllerName,\n                                                           &storageController);\n        VBOX_UTF16_FREE(storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller\"));\n            goto cleanup;\n        }\n        if (!storageController)\n            continue;\n        rc = gVBoxAPI.UIStorageController.GetBus(storageController, &storageBus);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller bus\"));\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetPort(imediumattach, &devicePort);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment port\"));\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetDevice(imediumattach, &deviceSlot);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get device slot\"));\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &disk);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium\"));\n            goto cleanup;\n        }\n\n        /* skip empty removable disk */\n        if (!disk) {\n            /* removable disks with empty (ejected) media won't be displayed\n             * in XML, but we need to update \"sdCount\" so that device names match\n             * in domain dumpxml and snapshot dumpxml\n             */\n            if (storageBus == StorageBus_SATA || storageBus == StorageBus_SCSI ||\n                storageBus == StorageBus_SAS)\n                sdCount++;\n\n            VBOX_RELEASE(storageController);\n            continue;\n        }\n\n        rc = gVBoxAPI.UIMedium.GetLocation(disk, &mediumLocUtf16);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get disk location\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(mediumLocUtf16, &mediumLocUtf8);\n        VBOX_UTF16_FREE(mediumLocUtf16);\n        defdom->disks[diskCount]->src->path = g_strdup(mediumLocUtf8);\n\n        VBOX_UTF8_FREE(mediumLocUtf8);\n        rc = gVBoxAPI.UIMedium.GetReadOnly(disk, &readOnly);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get read only attribute\"));\n            goto cleanup;\n        }\n\n        defdom->disks[diskCount]->dst = vboxGenerateMediumName(storageBus,\n                                                               devicePort,\n                                                               deviceSlot,\n                                                               sdCount);\n        if (!defdom->disks[diskCount]->dst) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not generate medium name for the disk \"\n                             \"at: port:%d, slot:%d\"), devicePort, deviceSlot);\n            ret = -1;\n            goto cleanup;\n        }\n\n        if (storageBus == StorageBus_IDE) {\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_IDE;\n        } else if (storageBus == StorageBus_SATA) {\n            sdCount++;\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_SATA;\n        } else if (storageBus == StorageBus_SCSI ||\n                   storageBus == StorageBus_SAS) {\n            sdCount++;\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_SCSI;\n        } else if (storageBus == StorageBus_Floppy) {\n            defdom->disks[diskCount]->bus = VIR_DOMAIN_DISK_BUS_FDC;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetType(imediumattach, &deviceType);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot get medium attachment type\"));\n            goto cleanup;\n        }\n        if (deviceType == DeviceType_HardDisk)\n            defdom->disks[diskCount]->device = VIR_DOMAIN_DISK_DEVICE_DISK;\n        else if (deviceType == DeviceType_Floppy)\n            defdom->disks[diskCount]->device = VIR_DOMAIN_DISK_DEVICE_FLOPPY;\n        else if (deviceType == DeviceType_DVD)\n            defdom->disks[diskCount]->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n\n        if (readOnly == PR_TRUE)\n            defdom->disks[diskCount]->src->readonly = true;\n        defdom->disks[diskCount]->src->type = VIR_STORAGE_TYPE_FILE;\n\n        diskCount++;\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(disk);\n    VBOX_RELEASE(storageController);\n    gVBoxAPI.UArray.vboxArrayRelease(&mediumAttachments);\n    VBOX_RELEASE(snap);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxSnapshotGetReadWriteDisks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "5656-5889",
    "snippet": "static int\nvboxSnapshotGetReadWriteDisks(virDomainSnapshotDefPtr def,\n                              virDomainSnapshotPtr snapshot)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    IMachine *snapMachine = NULL;\n    vboxArray mediumAttachments = VBOX_ARRAY_INITIALIZER;\n    size_t diskCount = 0, sdCount = 0;\n    nsresult rc;\n    vboxIID snapIid;\n    char *snapshotUuidStr = NULL;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    VBOX_IID_INITIALIZE(&snapIid);\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISnapshot.GetId(snap, &snapIid);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not get snapshot id\"));\n        goto cleanup;\n    }\n\n    gVBoxAPI.UIID.vboxIIDToUtf8(data, &snapIid, &snapshotUuidStr);\n    vboxIIDUnalloc(&snapIid);\n    rc = gVBoxAPI.UISnapshot.GetMachine(snap, &snapMachine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get machine\"));\n        goto cleanup;\n    }\n    def->ndisks = 0;\n    rc = gVBoxAPI.UArray.vboxArrayGet(&mediumAttachments, snapMachine,\n                                      gVBoxAPI.UArray.handleMachineGetMediumAttachments(snapMachine));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no medium attachments\"));\n        goto cleanup;\n    }\n    /* get the number of attachments */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        if (imediumattach) {\n            IMedium *medium = NULL;\n\n            rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot get medium\"));\n                goto cleanup;\n            }\n            if (medium) {\n                def->ndisks++;\n                VBOX_RELEASE(medium);\n            }\n        }\n    }\n    /* Allocate mem, if fails return error */\n    if (VIR_ALLOC_N(def->disks, def->ndisks) < 0)\n        goto cleanup;\n    for (i = 0; i < def->ndisks; i++) {\n        if (VIR_ALLOC(def->disks[i].src) < 0)\n            goto cleanup;\n    }\n\n    /* get the attachment details here */\n    for (i = 0; i < mediumAttachments.count && diskCount < def->ndisks; i++) {\n        IStorageController *storageController = NULL;\n        PRUnichar *storageControllerName = NULL;\n        PRUint32 deviceType = DeviceType_Null;\n        PRUint32 storageBus = StorageBus_Null;\n        IMedium *disk = NULL;\n        PRUnichar *childLocUtf16 = NULL;\n        char *childLocUtf8 = NULL;\n        PRInt32 devicePort = 0;\n        PRInt32 deviceSlot = 0;\n        vboxArray children = VBOX_ARRAY_INITIALIZER;\n        vboxArray snapshotIids = VBOX_ARRAY_INITIALIZER;\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        void *handle;\n        size_t j = 0;\n        size_t k = 0;\n\n        if (!imediumattach)\n            continue;\n\n        rc = gVBoxAPI.UIMediumAttachment.GetController(imediumattach,\n                                                       &storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller name\"));\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMachine.GetStorageControllerByName(machine,\n                                                           storageControllerName,\n                                                           &storageController);\n        VBOX_UTF16_FREE(storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller by name\"));\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIStorageController.GetBus(storageController, &storageBus);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller bus\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetType(imediumattach, &deviceType);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment type\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetPort(imediumattach, &devicePort);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment port\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetDevice(imediumattach, &deviceSlot);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment slot\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &disk);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n\n        /* skip empty removable disk */\n        if (!disk) {\n            /* removable disks with empty (ejected) media won't be displayed\n             * in XML, but we need to update \"sdCount\" so that device names match\n             * in domain dumpxml and snapshot dumpxml\n             */\n            if (storageBus == StorageBus_SATA || storageBus == StorageBus_SCSI ||\n                storageBus == StorageBus_SAS)\n                sdCount++;\n\n            VBOX_RELEASE(storageController);\n            continue;\n        }\n\n        handle = gVBoxAPI.UArray.handleMediumGetChildren(disk);\n        rc = gVBoxAPI.UArray.vboxArrayGet(&children, disk, handle);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot get children disk\"));\n            goto cleanup;\n        }\n        handle = gVBoxAPI.UArray.handleMediumGetSnapshotIds(disk);\n        rc = gVBoxAPI.UArray.vboxArrayGetWithIIDArg(&snapshotIids, disk,\n                                                    handle, &domiid);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot get snapshot ids\"));\n            goto cleanup;\n        }\n        for (j = 0; j < children.count; ++j) {\n            IMedium *child = children.items[j];\n            for (k = 0; k < snapshotIids.count; ++k) {\n                PRUnichar *diskSnapId = snapshotIids.items[k];\n                char *diskSnapIdStr = NULL;\n                VBOX_UTF16_TO_UTF8(diskSnapId, &diskSnapIdStr);\n                if (STREQ(diskSnapIdStr, snapshotUuidStr)) {\n                    rc = gVBoxAPI.UIMedium.GetLocation(child, &childLocUtf16);\n                    if (NS_FAILED(rc)) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                       _(\"cannot get disk location\"));\n                        VBOX_RELEASE(storageController);\n                        VBOX_RELEASE(disk);\n                        VBOX_RELEASE(child);\n                        goto cleanup;\n                    }\n                    VBOX_UTF16_TO_UTF8(childLocUtf16, &childLocUtf8);\n                    VBOX_UTF16_FREE(childLocUtf16);\n                    def->disks[diskCount].src->path = g_strdup(childLocUtf8);\n                    VBOX_UTF8_FREE(childLocUtf8);\n\n                    def->disks[diskCount].src->type = VIR_STORAGE_TYPE_FILE;\n                    def->disks[diskCount].name = vboxGenerateMediumName(storageBus,\n                                                                        devicePort,\n                                                                        deviceSlot,\n                                                                        sdCount);\n                }\n                VBOX_UTF8_FREE(diskSnapIdStr);\n            }\n        }\n        VBOX_RELEASE(storageController);\n        VBOX_RELEASE(disk);\n        diskCount++;\n\n        if (storageBus == StorageBus_SATA || storageBus == StorageBus_SCSI ||\n            storageBus == StorageBus_SAS)\n            sdCount++;\n\n    }\n    gVBoxAPI.UArray.vboxArrayRelease(&mediumAttachments);\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(snap);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "snap"
          ],
          "line": 5886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&mediumAttachments"
          ],
          "line": 5881
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "disk"
          ],
          "line": 5873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "storageController"
          ],
          "line": 5872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "diskSnapIdStr"
          ],
          "line": 5869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxGenerateMediumName",
          "args": [
            "storageBus",
            "devicePort",
            "deviceSlot",
            "sdCount"
          ],
          "line": 5864
        },
        "resolved": true,
        "details": {
          "function_name": "vboxGenerateMediumName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "299-335",
          "snippet": "static char *\nvboxGenerateMediumName(PRUint32 storageBus,\n                       PRInt32 devicePort,\n                       PRInt32 deviceSlot,\n                       size_t sdCount)\n{\n    const char *prefix = NULL;\n    char *name = NULL;\n    int total = 0;\n\n    switch ((enum StorageBus) storageBus) {\n    case StorageBus_IDE:\n        prefix = \"hd\";\n        total = devicePort * 2 + deviceSlot;\n\n        break;\n    case StorageBus_SATA:\n    case StorageBus_SCSI:\n    case StorageBus_SAS:\n        prefix = \"sd\";\n        total = sdCount;\n\n        break;\n    case StorageBus_Floppy:\n        total = deviceSlot;\n        prefix = \"fd\";\n\n        break;\n    case StorageBus_Null:\n\n        return NULL;\n    }\n\n    name = virIndexToDiskName(total, prefix);\n\n    return name;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nvboxGenerateMediumName(PRUint32 storageBus,\n                       PRInt32 devicePort,\n                       PRInt32 deviceSlot,\n                       size_t sdCount)\n{\n    const char *prefix = NULL;\n    char *name = NULL;\n    int total = 0;\n\n    switch ((enum StorageBus) storageBus) {\n    case StorageBus_IDE:\n        prefix = \"hd\";\n        total = devicePort * 2 + deviceSlot;\n\n        break;\n    case StorageBus_SATA:\n    case StorageBus_SCSI:\n    case StorageBus_SAS:\n        prefix = \"sd\";\n        total = sdCount;\n\n        break;\n    case StorageBus_Floppy:\n        total = deviceSlot;\n        prefix = \"fd\";\n\n        break;\n    case StorageBus_Null:\n\n        return NULL;\n    }\n\n    name = virIndexToDiskName(total, prefix);\n\n    return name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "childLocUtf8"
          ],
          "line": 5861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "childLocUtf8"
          ],
          "line": 5860
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "childLocUtf16"
          ],
          "line": 5859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "childLocUtf16",
            "&childLocUtf8"
          ],
          "line": 5858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "child"
          ],
          "line": 5855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "disk"
          ],
          "line": 5854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "storageController"
          ],
          "line": 5853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot get disk location\")"
          ],
          "line": 5851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot get disk location\""
          ],
          "line": 5852
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetLocation",
          "args": [
            "child",
            "&childLocUtf16"
          ],
          "line": 5849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "diskSnapIdStr",
            "snapshotUuidStr"
          ],
          "line": 5848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "diskSnapId",
            "&diskSnapIdStr"
          ],
          "line": 5847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot get snapshot ids\")"
          ],
          "line": 5838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGetWithIIDArg",
          "args": [
            "&snapshotIids",
            "disk",
            "handle",
            "&domiid"
          ],
          "line": 5835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleMediumGetSnapshotIds",
          "args": [
            "disk"
          ],
          "line": 5834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot get children disk\")"
          ],
          "line": 5830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&children",
            "disk",
            "handle"
          ],
          "line": 5828
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleMediumGetChildren",
          "args": [
            "disk"
          ],
          "line": 5827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "storageController"
          ],
          "line": 5823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "storageController"
          ],
          "line": 5809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get medium\")"
          ],
          "line": 5807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetMedium",
          "args": [
            "imediumattach",
            "&disk"
          ],
          "line": 5805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "storageController"
          ],
          "line": 5801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get medium attachment slot\")"
          ],
          "line": 5799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetDevice",
          "args": [
            "imediumattach",
            "&deviceSlot"
          ],
          "line": 5797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "storageController"
          ],
          "line": 5794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get medium attachment port\")"
          ],
          "line": 5792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetPort",
          "args": [
            "imediumattach",
            "&devicePort"
          ],
          "line": 5790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "storageController"
          ],
          "line": 5787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get medium attachment type\")"
          ],
          "line": 5785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetType",
          "args": [
            "imediumattach",
            "&deviceType"
          ],
          "line": 5783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "storageController"
          ],
          "line": 5779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get storage controller bus\")"
          ],
          "line": 5777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIStorageController.GetBus",
          "args": [
            "storageController",
            "&storageBus"
          ],
          "line": 5775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get storage controller by name\")"
          ],
          "line": 5770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "storageControllerName"
          ],
          "line": 5768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetStorageControllerByName",
          "args": [
            "machine",
            "storageControllerName",
            "&storageController"
          ],
          "line": 5765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot get storage controller name\")"
          ],
          "line": 5760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetController",
          "args": [
            "imediumattach",
            "&storageControllerName"
          ],
          "line": 5757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def->disks[i].src"
          ],
          "line": 5732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->disks",
            "def->ndisks"
          ],
          "line": 5729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "medium"
          ],
          "line": 5724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot get medium\")"
          ],
          "line": 5718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetMedium",
          "args": [
            "imediumattach",
            "&medium"
          ],
          "line": 5716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no medium attachments\")"
          ],
          "line": 5706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleMachineGetMediumAttachments",
          "args": [
            "snapMachine"
          ],
          "line": 5704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get machine\")"
          ],
          "line": 5698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetMachine",
          "args": [
            "snap",
            "&snapMachine"
          ],
          "line": 5696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&snapIid"
          ],
          "line": 5695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIID.vboxIIDToUtf8",
          "args": [
            "data",
            "&snapIid",
            "&snapshotUuidStr"
          ],
          "line": 5694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not get snapshot id\")"
          ],
          "line": 5689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetId",
          "args": [
            "snap",
            "&snapIid"
          ],
          "line": 5687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotGet",
          "args": [
            "data",
            "dom",
            "machine",
            "snapshot->name"
          ],
          "line": 5684
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "5606-5654",
          "snippet": "static ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&domiid",
            "&machine"
          ],
          "line": 5681
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&snapIid"
          ],
          "line": 5680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"This function may not work in current version\""
          ],
          "line": 5678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxSnapshotGetReadWriteDisks(virDomainSnapshotDefPtr def,\n                              virDomainSnapshotPtr snapshot)\n{\n    virDomainPtr dom = snapshot->domain;\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    ISnapshot *snap = NULL;\n    IMachine *snapMachine = NULL;\n    vboxArray mediumAttachments = VBOX_ARRAY_INITIALIZER;\n    size_t diskCount = 0, sdCount = 0;\n    nsresult rc;\n    vboxIID snapIid;\n    char *snapshotUuidStr = NULL;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    VBOX_IID_INITIALIZE(&snapIid);\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    if (!(snap = vboxDomainSnapshotGet(data, dom, machine, snapshot->name)))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISnapshot.GetId(snap, &snapIid);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not get snapshot id\"));\n        goto cleanup;\n    }\n\n    gVBoxAPI.UIID.vboxIIDToUtf8(data, &snapIid, &snapshotUuidStr);\n    vboxIIDUnalloc(&snapIid);\n    rc = gVBoxAPI.UISnapshot.GetMachine(snap, &snapMachine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get machine\"));\n        goto cleanup;\n    }\n    def->ndisks = 0;\n    rc = gVBoxAPI.UArray.vboxArrayGet(&mediumAttachments, snapMachine,\n                                      gVBoxAPI.UArray.handleMachineGetMediumAttachments(snapMachine));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no medium attachments\"));\n        goto cleanup;\n    }\n    /* get the number of attachments */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        if (imediumattach) {\n            IMedium *medium = NULL;\n\n            rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot get medium\"));\n                goto cleanup;\n            }\n            if (medium) {\n                def->ndisks++;\n                VBOX_RELEASE(medium);\n            }\n        }\n    }\n    /* Allocate mem, if fails return error */\n    if (VIR_ALLOC_N(def->disks, def->ndisks) < 0)\n        goto cleanup;\n    for (i = 0; i < def->ndisks; i++) {\n        if (VIR_ALLOC(def->disks[i].src) < 0)\n            goto cleanup;\n    }\n\n    /* get the attachment details here */\n    for (i = 0; i < mediumAttachments.count && diskCount < def->ndisks; i++) {\n        IStorageController *storageController = NULL;\n        PRUnichar *storageControllerName = NULL;\n        PRUint32 deviceType = DeviceType_Null;\n        PRUint32 storageBus = StorageBus_Null;\n        IMedium *disk = NULL;\n        PRUnichar *childLocUtf16 = NULL;\n        char *childLocUtf8 = NULL;\n        PRInt32 devicePort = 0;\n        PRInt32 deviceSlot = 0;\n        vboxArray children = VBOX_ARRAY_INITIALIZER;\n        vboxArray snapshotIids = VBOX_ARRAY_INITIALIZER;\n        IMediumAttachment *imediumattach = mediumAttachments.items[i];\n        void *handle;\n        size_t j = 0;\n        size_t k = 0;\n\n        if (!imediumattach)\n            continue;\n\n        rc = gVBoxAPI.UIMediumAttachment.GetController(imediumattach,\n                                                       &storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller name\"));\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMachine.GetStorageControllerByName(machine,\n                                                           storageControllerName,\n                                                           &storageController);\n        VBOX_UTF16_FREE(storageControllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller by name\"));\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIStorageController.GetBus(storageController, &storageBus);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get storage controller bus\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetType(imediumattach, &deviceType);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment type\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetPort(imediumattach, &devicePort);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment port\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetDevice(imediumattach, &deviceSlot);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium attachment slot\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(imediumattach, &disk);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Cannot get medium\"));\n            VBOX_RELEASE(storageController);\n            goto cleanup;\n        }\n\n        /* skip empty removable disk */\n        if (!disk) {\n            /* removable disks with empty (ejected) media won't be displayed\n             * in XML, but we need to update \"sdCount\" so that device names match\n             * in domain dumpxml and snapshot dumpxml\n             */\n            if (storageBus == StorageBus_SATA || storageBus == StorageBus_SCSI ||\n                storageBus == StorageBus_SAS)\n                sdCount++;\n\n            VBOX_RELEASE(storageController);\n            continue;\n        }\n\n        handle = gVBoxAPI.UArray.handleMediumGetChildren(disk);\n        rc = gVBoxAPI.UArray.vboxArrayGet(&children, disk, handle);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot get children disk\"));\n            goto cleanup;\n        }\n        handle = gVBoxAPI.UArray.handleMediumGetSnapshotIds(disk);\n        rc = gVBoxAPI.UArray.vboxArrayGetWithIIDArg(&snapshotIids, disk,\n                                                    handle, &domiid);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"cannot get snapshot ids\"));\n            goto cleanup;\n        }\n        for (j = 0; j < children.count; ++j) {\n            IMedium *child = children.items[j];\n            for (k = 0; k < snapshotIids.count; ++k) {\n                PRUnichar *diskSnapId = snapshotIids.items[k];\n                char *diskSnapIdStr = NULL;\n                VBOX_UTF16_TO_UTF8(diskSnapId, &diskSnapIdStr);\n                if (STREQ(diskSnapIdStr, snapshotUuidStr)) {\n                    rc = gVBoxAPI.UIMedium.GetLocation(child, &childLocUtf16);\n                    if (NS_FAILED(rc)) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                       _(\"cannot get disk location\"));\n                        VBOX_RELEASE(storageController);\n                        VBOX_RELEASE(disk);\n                        VBOX_RELEASE(child);\n                        goto cleanup;\n                    }\n                    VBOX_UTF16_TO_UTF8(childLocUtf16, &childLocUtf8);\n                    VBOX_UTF16_FREE(childLocUtf16);\n                    def->disks[diskCount].src->path = g_strdup(childLocUtf8);\n                    VBOX_UTF8_FREE(childLocUtf8);\n\n                    def->disks[diskCount].src->type = VIR_STORAGE_TYPE_FILE;\n                    def->disks[diskCount].name = vboxGenerateMediumName(storageBus,\n                                                                        devicePort,\n                                                                        deviceSlot,\n                                                                        sdCount);\n                }\n                VBOX_UTF8_FREE(diskSnapIdStr);\n            }\n        }\n        VBOX_RELEASE(storageController);\n        VBOX_RELEASE(disk);\n        diskCount++;\n\n        if (storageBus == StorageBus_SATA || storageBus == StorageBus_SCSI ||\n            storageBus == StorageBus_SAS)\n            sdCount++;\n\n    }\n    gVBoxAPI.UArray.vboxArrayRelease(&mediumAttachments);\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(snap);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSnapshotGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "5606-5654",
    "snippet": "static ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshots"
          ],
          "line": 5652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "snapshots[i]"
          ],
          "line": 5650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"domain %s has no snapshots with name %s\")",
            "dom->name",
            "name"
          ],
          "line": 5641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"domain %s has no snapshots with name %s\""
          ],
          "line": 5642
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "nameUtf8"
          ],
          "line": 5634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "nameUtf8"
          ],
          "line": 5632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "nameUtf16"
          ],
          "line": 5631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "nameUtf16",
            "&nameUtf8"
          ],
          "line": 5630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get snapshot name\")"
          ],
          "line": 5626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISnapshot.GetName",
          "args": [
            "snapshots[i]",
            "&nameUtf16"
          ],
          "line": 5624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxDomainSnapshotGetAll",
          "args": [
            "dom",
            "machine",
            "&snapshots"
          ],
          "line": 5617
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSnapshotGetAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "5522-5604",
          "snippet": "static int\nvboxDomainSnapshotGetAll(virDomainPtr dom,\n                         IMachine *machine,\n                         ISnapshot ***snapshots)\n{\n    vboxIID empty;\n    ISnapshot **list = NULL;\n    PRUint32 count;\n    nsresult rc;\n    unsigned int next;\n    unsigned int top;\n\n    VBOX_IID_INITIALIZE(&empty);\n    rc = gVBoxAPI.UIMachine.GetSnapshotCount(machine, &count);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get snapshot count for domain %s\"),\n                       dom->name);\n        goto error;\n    }\n\n    if (count == 0)\n        goto out;\n\n    if (VIR_ALLOC_N(list, count) < 0)\n        goto error;\n\n    rc = gVBoxAPI.UIMachine.FindSnapshot(machine, &empty, list);\n    if (NS_FAILED(rc) || !list[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get root snapshot for domain %s\"),\n                       dom->name);\n        goto error;\n    }\n\n    /* BFS walk through snapshot tree */\n    top = 1;\n    for (next = 0; next < count; next++) {\n        vboxArray children = VBOX_ARRAY_INITIALIZER;\n        size_t i;\n\n        if (!list[next]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected number of snapshots < %u\"), count);\n            goto error;\n        }\n\n        rc = gVBoxAPI.UArray.vboxArrayGet(&children, list[next],\n                                          gVBoxAPI.UArray.handleSnapshotGetChildren(list[next]));\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get children snapshots\"));\n            goto error;\n        }\n        for (i = 0; i < children.count; i++) {\n            ISnapshot *child = children.items[i];\n            if (!child)\n                continue;\n            if (top == count) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unexpected number of snapshots > %u\"), count);\n                gVBoxAPI.UArray.vboxArrayRelease(&children);\n                goto error;\n            }\n            VBOX_ADDREF(child);\n            list[top++] = child;\n        }\n        gVBoxAPI.UArray.vboxArrayRelease(&children);\n    }\n\n out:\n    *snapshots = list;\n    return count;\n\n error:\n    if (list) {\n        for (next = 0; next < count; next++)\n            VBOX_RELEASE(list[next]);\n    }\n    VIR_FREE(list);\n\n    return -1;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDomainSnapshotGetAll(virDomainPtr dom,\n                         IMachine *machine,\n                         ISnapshot ***snapshots)\n{\n    vboxIID empty;\n    ISnapshot **list = NULL;\n    PRUint32 count;\n    nsresult rc;\n    unsigned int next;\n    unsigned int top;\n\n    VBOX_IID_INITIALIZE(&empty);\n    rc = gVBoxAPI.UIMachine.GetSnapshotCount(machine, &count);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get snapshot count for domain %s\"),\n                       dom->name);\n        goto error;\n    }\n\n    if (count == 0)\n        goto out;\n\n    if (VIR_ALLOC_N(list, count) < 0)\n        goto error;\n\n    rc = gVBoxAPI.UIMachine.FindSnapshot(machine, &empty, list);\n    if (NS_FAILED(rc) || !list[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get root snapshot for domain %s\"),\n                       dom->name);\n        goto error;\n    }\n\n    /* BFS walk through snapshot tree */\n    top = 1;\n    for (next = 0; next < count; next++) {\n        vboxArray children = VBOX_ARRAY_INITIALIZER;\n        size_t i;\n\n        if (!list[next]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected number of snapshots < %u\"), count);\n            goto error;\n        }\n\n        rc = gVBoxAPI.UArray.vboxArrayGet(&children, list[next],\n                                          gVBoxAPI.UArray.handleSnapshotGetChildren(list[next]));\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get children snapshots\"));\n            goto error;\n        }\n        for (i = 0; i < children.count; i++) {\n            ISnapshot *child = children.items[i];\n            if (!child)\n                continue;\n            if (top == count) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unexpected number of snapshots > %u\"), count);\n                gVBoxAPI.UArray.vboxArrayRelease(&children);\n                goto error;\n            }\n            VBOX_ADDREF(child);\n            list[top++] = child;\n        }\n        gVBoxAPI.UArray.vboxArrayRelease(&children);\n    }\n\n out:\n    *snapshots = list;\n    return count;\n\n error:\n    if (list) {\n        for (next = 0; next < count; next++)\n            VBOX_RELEASE(list[next]);\n    }\n    VIR_FREE(list);\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic ISnapshot *\nvboxDomainSnapshotGet(vboxDriverPtr data,\n                      virDomainPtr dom,\n                      IMachine *machine,\n                      const char *name)\n{\n    ISnapshot **snapshots = NULL;\n    ISnapshot *snapshot = NULL;\n    nsresult rc;\n    ssize_t i, count = 0;\n\n    if ((count = vboxDomainSnapshotGetAll(dom, machine, &snapshots)) < 0)\n        return NULL;\n\n    for (i = 0; i < count; i++) {\n        PRUnichar *nameUtf16;\n        char *nameUtf8;\n\n        rc = gVBoxAPI.UISnapshot.GetName(snapshots[i], &nameUtf16);\n        if (NS_FAILED(rc) || !nameUtf16) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get snapshot name\"));\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(nameUtf16, &nameUtf8);\n        VBOX_UTF16_FREE(nameUtf16);\n        if (STREQ(name, nameUtf8))\n            snapshot = snapshots[i];\n        VBOX_UTF8_FREE(nameUtf8);\n\n        if (snapshot)\n            break;\n    }\n\n    if (!snapshot) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"domain %s has no snapshots with name %s\"),\n                       dom->name, name);\n        goto cleanup;\n    }\n\n cleanup:\n    for (i = 0; i < count; i++) {\n        if (snapshots[i] != snapshot)\n            VBOX_RELEASE(snapshots[i]);\n    }\n    VIR_FREE(snapshots);\n    return snapshot;\n}"
  },
  {
    "function_name": "vboxDomainSnapshotGetAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "5522-5604",
    "snippet": "static int\nvboxDomainSnapshotGetAll(virDomainPtr dom,\n                         IMachine *machine,\n                         ISnapshot ***snapshots)\n{\n    vboxIID empty;\n    ISnapshot **list = NULL;\n    PRUint32 count;\n    nsresult rc;\n    unsigned int next;\n    unsigned int top;\n\n    VBOX_IID_INITIALIZE(&empty);\n    rc = gVBoxAPI.UIMachine.GetSnapshotCount(machine, &count);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get snapshot count for domain %s\"),\n                       dom->name);\n        goto error;\n    }\n\n    if (count == 0)\n        goto out;\n\n    if (VIR_ALLOC_N(list, count) < 0)\n        goto error;\n\n    rc = gVBoxAPI.UIMachine.FindSnapshot(machine, &empty, list);\n    if (NS_FAILED(rc) || !list[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get root snapshot for domain %s\"),\n                       dom->name);\n        goto error;\n    }\n\n    /* BFS walk through snapshot tree */\n    top = 1;\n    for (next = 0; next < count; next++) {\n        vboxArray children = VBOX_ARRAY_INITIALIZER;\n        size_t i;\n\n        if (!list[next]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected number of snapshots < %u\"), count);\n            goto error;\n        }\n\n        rc = gVBoxAPI.UArray.vboxArrayGet(&children, list[next],\n                                          gVBoxAPI.UArray.handleSnapshotGetChildren(list[next]));\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get children snapshots\"));\n            goto error;\n        }\n        for (i = 0; i < children.count; i++) {\n            ISnapshot *child = children.items[i];\n            if (!child)\n                continue;\n            if (top == count) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unexpected number of snapshots > %u\"), count);\n                gVBoxAPI.UArray.vboxArrayRelease(&children);\n                goto error;\n            }\n            VBOX_ADDREF(child);\n            list[top++] = child;\n        }\n        gVBoxAPI.UArray.vboxArrayRelease(&children);\n    }\n\n out:\n    *snapshots = list;\n    return count;\n\n error:\n    if (list) {\n        for (next = 0; next < count; next++)\n            VBOX_RELEASE(list[next]);\n    }\n    VIR_FREE(list);\n\n    return -1;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "list"
          ],
          "line": 5601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "list[next]"
          ],
          "line": 5599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&children"
          ],
          "line": 5589
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_ADDREF",
          "args": [
            "child"
          ],
          "line": 5586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected number of snapshots > %u\")",
            "count"
          ],
          "line": 5581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unexpected number of snapshots > %u\""
          ],
          "line": 5582
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get children snapshots\")"
          ],
          "line": 5572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&children",
            "list[next]",
            "gVBoxAPI.UArray.handleSnapshotGetChildren(list[next])"
          ],
          "line": 5569
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleSnapshotGetChildren",
          "args": [
            "list[next]"
          ],
          "line": 5570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unexpected number of snapshots < %u\")",
            "count"
          ],
          "line": 5564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get root snapshot for domain %s\")",
            "dom->name"
          ],
          "line": 5551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.FindSnapshot",
          "args": [
            "machine",
            "&empty",
            "list"
          ],
          "line": 5549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "list",
            "count"
          ],
          "line": 5546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get snapshot count for domain %s\")",
            "dom->name"
          ],
          "line": 5537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetSnapshotCount",
          "args": [
            "machine",
            "&count"
          ],
          "line": 5535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&empty"
          ],
          "line": 5534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDomainSnapshotGetAll(virDomainPtr dom,\n                         IMachine *machine,\n                         ISnapshot ***snapshots)\n{\n    vboxIID empty;\n    ISnapshot **list = NULL;\n    PRUint32 count;\n    nsresult rc;\n    unsigned int next;\n    unsigned int top;\n\n    VBOX_IID_INITIALIZE(&empty);\n    rc = gVBoxAPI.UIMachine.GetSnapshotCount(machine, &count);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get snapshot count for domain %s\"),\n                       dom->name);\n        goto error;\n    }\n\n    if (count == 0)\n        goto out;\n\n    if (VIR_ALLOC_N(list, count) < 0)\n        goto error;\n\n    rc = gVBoxAPI.UIMachine.FindSnapshot(machine, &empty, list);\n    if (NS_FAILED(rc) || !list[0]) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get root snapshot for domain %s\"),\n                       dom->name);\n        goto error;\n    }\n\n    /* BFS walk through snapshot tree */\n    top = 1;\n    for (next = 0; next < count; next++) {\n        vboxArray children = VBOX_ARRAY_INITIALIZER;\n        size_t i;\n\n        if (!list[next]) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected number of snapshots < %u\"), count);\n            goto error;\n        }\n\n        rc = gVBoxAPI.UArray.vboxArrayGet(&children, list[next],\n                                          gVBoxAPI.UArray.handleSnapshotGetChildren(list[next]));\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"could not get children snapshots\"));\n            goto error;\n        }\n        for (i = 0; i < children.count; i++) {\n            ISnapshot *child = children.items[i];\n            if (!child)\n                continue;\n            if (top == count) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"unexpected number of snapshots > %u\"), count);\n                gVBoxAPI.UArray.vboxArrayRelease(&children);\n                goto error;\n            }\n            VBOX_ADDREF(child);\n            list[top++] = child;\n        }\n        gVBoxAPI.UArray.vboxArrayRelease(&children);\n    }\n\n out:\n    *snapshots = list;\n    return count;\n\n error:\n    if (list) {\n        for (next = 0; next < count; next++)\n            VBOX_RELEASE(list[next]);\n    }\n    VIR_FREE(list);\n\n    return -1;\n}"
  },
  {
    "function_name": "vboxDomainSnapshotCreateXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "5397-5520",
    "snippet": "static virDomainSnapshotPtr\nvboxDomainSnapshotCreateXML(virDomainPtr dom,\n                            const char *xmlDesc,\n                            unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    IConsole *console = NULL;\n    IProgress *progress = NULL;\n    ISnapshot *snapshot = NULL;\n    PRUnichar *name = NULL;\n    PRUnichar *description = NULL;\n    PRUint32 state;\n    nsresult rc;\n    resultCodeUnion result;\n    virDomainSnapshotPtr ret = NULL;\n    unsigned int parse_flags = (VIR_DOMAIN_SNAPSHOT_PARSE_DISKS |\n                                VIR_DOMAIN_SNAPSHOT_PARSE_REDEFINE);\n    g_autoptr(virDomainSnapshotDef) def = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&domiid);\n    /* VBox has no snapshot metadata, so this flag is trivial.  */\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_CREATE_VALIDATE)\n        parse_flags |= VIR_DOMAIN_SNAPSHOT_PARSE_VALIDATE;\n\n    if (!(def = virDomainSnapshotDefParseString(xmlDesc,\n                                                data->xmlopt, NULL, NULL,\n                                                parse_flags)))\n        goto cleanup;\n\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    if (gVBoxAPI.vboxSnapshotRedefine) {\n        PRBool isCurrent = flags & VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT;\n        if (flags & VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE) {\n            if (vboxSnapshotRedefine(dom, def, isCurrent) < 0)\n                goto cleanup;\n            ret = virGetDomainSnapshot(dom, def->parent.name);\n            goto cleanup;\n        }\n    }\n\n    rc = gVBoxAPI.UIMachine.GetState(machine, &state);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get domain state\"));\n        goto cleanup;\n    }\n\n    if (gVBoxAPI.machineStateChecker.Online(state)) {\n        rc = gVBoxAPI.UISession.OpenExisting(data, &domiid, machine);\n    } else {\n        rc = gVBoxAPI.UISession.Open(data, &domiid, machine);\n    }\n\n    if (NS_SUCCEEDED(rc))\n        rc = gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not open VirtualBox session with domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    VBOX_UTF8_TO_UTF16(def->parent.name, &name);\n    if (!name) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (def->parent.description) {\n        VBOX_UTF8_TO_UTF16(def->parent.description, &description);\n        if (!description) {\n            virReportOOMError();\n            goto cleanup;\n        }\n    }\n\n    rc = gVBoxAPI.UIConsole.TakeSnapshot(console, name, description, &progress);\n    if (NS_FAILED(rc) || !progress) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not take snapshot of domain %s\"), dom->name);\n        goto cleanup;\n    }\n\n    gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n    gVBoxAPI.UIProgress.GetResultCode(progress, &result);\n    if (RC_FAILED(result)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not take snapshot of domain %s\"), dom->name);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIMachine.GetCurrentSnapshot(machine, &snapshot);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get current snapshot of domain %s\"),\n                  dom->name);\n        goto cleanup;\n    }\n\n    ret = virGetDomainSnapshot(dom, def->parent.name);\n\n cleanup:\n    VBOX_RELEASE(progress);\n    VBOX_UTF16_FREE(description);\n    VBOX_UTF16_FREE(name);\n    VBOX_RELEASE(console);\n    gVBoxAPI.UISession.Close(data->vboxSession);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&domiid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&domiid"
          ],
          "line": 5518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 5517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 5516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "console"
          ],
          "line": 5515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "name"
          ],
          "line": 5514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "description"
          ],
          "line": 5513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "progress"
          ],
          "line": 5512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetDomainSnapshot",
          "args": [
            "dom",
            "def->parent.name"
          ],
          "line": 5509
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomainSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "1023-1045",
          "snippet": "virDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainSnapshotClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainSnapshotClass;\n\nvirDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not get current snapshot of domain %s\")",
            "dom->name"
          ],
          "line": 5503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not get current snapshot of domain %s\""
          ],
          "line": 5504
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetCurrentSnapshot",
          "args": [
            "machine",
            "&snapshot"
          ],
          "line": 5501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not take snapshot of domain %s\")",
            "dom->name"
          ],
          "line": 5496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RC_FAILED",
          "args": [
            "result"
          ],
          "line": 5495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.GetResultCode",
          "args": [
            "progress",
            "&result"
          ],
          "line": 5494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.WaitForCompletion",
          "args": [
            "progress",
            "-1"
          ],
          "line": 5493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not take snapshot of domain %s\")",
            "dom->name"
          ],
          "line": 5488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIConsole.TakeSnapshot",
          "args": [
            "console",
            "name",
            "description",
            "&progress"
          ],
          "line": 5486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 5481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "def->parent.description",
            "&description"
          ],
          "line": 5479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 5474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "def->parent.name",
            "&name"
          ],
          "line": 5472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not open VirtualBox session with domain %s\")",
            "dom->name"
          ],
          "line": 5466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetConsole",
          "args": [
            "data->vboxSession",
            "&console"
          ],
          "line": 5464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_SUCCEEDED",
          "args": [
            "rc"
          ],
          "line": 5463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Open",
          "args": [
            "data",
            "&domiid",
            "machine"
          ],
          "line": 5460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.OpenExisting",
          "args": [
            "data",
            "&domiid",
            "machine"
          ],
          "line": 5458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Online",
          "args": [
            "state"
          ],
          "line": 5457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"could not get domain state\")"
          ],
          "line": 5452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 5450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxSnapshotRedefine",
          "args": [
            "dom",
            "def",
            "isCurrent"
          ],
          "line": 5443
        },
        "resolved": true,
        "details": {
          "function_name": "vboxSnapshotRedefine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "4522-5395",
          "snippet": "static int\nvboxSnapshotRedefine(virDomainPtr dom,\n                     virDomainSnapshotDefPtr def,\n                     bool isCurrent)\n{\n    /*\n     * If your snapshot has a parent,\n     * it will only be redefined if you have already\n     * redefined the parent.\n     *\n     * The general algorithm of this function is below :\n     * First of all, we are going to create our vboxSnapshotXmlMachinePtr struct from\n     * the machine settings path.\n     * Then, if the machine current snapshot xml file is saved in the machine location,\n     * it means that this snapshot was previously modified by us and has fake disks.\n     * Fake disks are added when the flag VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT was not set\n     * yet, in order to not corrupt read-only disks. The first thing to do is to remove those\n     * disks and restore the read-write disks, if any, in the vboxSnapshotXmlMachinePtr struct.\n     * We also delete the current snapshot xml file.\n     *\n     * After that, we are going to register the snapshot read-only disks that we want to redefine,\n     * if they are not in the media registry struct.\n     *\n     * The next step is to unregister the machine and close all disks.\n     *\n     * Then, we check if the flag VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE has already been set.\n     * If this flag was set, we just add read-write disks to the media registry\n     * struct. Otherwise, we save the snapshot xml file into the machine location in order\n     * to recover the read-write disks during the next redefine and we create differential disks\n     * from the snapshot read-only disks and add them to the media registry struct.\n     *\n     * Finally, we register the machine with the new virtualbox description file.\n     */\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    nsresult rc;\n    PRUnichar *settingsFilePath = NULL;\n    char *settingsFilePath_Utf8 = NULL;\n    virVBoxSnapshotConfMachinePtr snapshotMachineDesc = NULL;\n    char *currentSnapshotXmlFilePath = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    char *machineName = NULL;\n    char **realReadWriteDisksPath = NULL;\n    int realReadWriteDisksPathSize = 0;\n    char **realReadOnlyDisksPath = NULL;\n    int realReadOnlyDisksPathSize = 0;\n    virVBoxSnapshotConfSnapshotPtr newSnapshotPtr = NULL;\n    unsigned char snapshotUuid[VIR_UUID_BUFLEN];\n    virVBoxSnapshotConfHardDiskPtr *hardDiskToOpen = NULL;\n    size_t hardDiskToOpenSize = 0;\n    virVBoxSnapshotConfHardDiskPtr newHardDisk = NULL;\n    char **searchResultTab = NULL;\n    ssize_t resultSize = 0;\n    int it = 0;\n    int jt = 0;\n    PRUint32 aMediaSize = 0;\n    IMedium **aMedia = NULL;\n    char *machineLocationPath = NULL;\n    char *nameTmpUse = NULL;\n    bool snapshotFileExists = false;\n    bool needToChangeStorageController = false;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIMachine.SaveSettings(machine);\n    /* It may failed when the machine is not mutable. */\n    rc = gVBoxAPI.UIMachine.GetSettingsFilePath(machine, &settingsFilePath);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get settings file path\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(settingsFilePath, &settingsFilePath_Utf8);\n\n    /* Getting the machine name to retrieve the machine location path. */\n    rc = gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get machine name\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineName);\n\n    nameTmpUse = g_strdup_printf(\"%s.vbox\", machineName);\n    machineLocationPath = virStringReplace(settingsFilePath_Utf8, nameTmpUse, \"\");\n    if (machineLocationPath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get the machine location path\"));\n        goto cleanup;\n    }\n\n    /* We create the xml struct with the settings file path. */\n    snapshotMachineDesc = virVBoxSnapshotConfLoadVboxFile(settingsFilePath_Utf8, machineLocationPath);\n    if (snapshotMachineDesc == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot create a vboxSnapshotXmlPtr\"));\n        goto cleanup;\n    }\n    if (snapshotMachineDesc->currentSnapshot != NULL) {\n        currentSnapshotXmlFilePath = g_strdup_printf(\"%s%s.xml\",\n                                                     machineLocationPath, snapshotMachineDesc->currentSnapshot);\n        snapshotFileExists = virFileExists(currentSnapshotXmlFilePath);\n    }\n\n    if (snapshotFileExists) {\n        /*\n         * We have created fake disks, so we have to remove them and replace them with\n         * the read-write disks if there are any. The fake disks will be closed during\n         * the machine unregistration.\n         */\n        if (virVBoxSnapshotConfRemoveFakeDisks(snapshotMachineDesc) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to remove Fake Disks\"));\n            goto cleanup;\n        }\n        realReadWriteDisksPathSize = virVBoxSnapshotConfGetRWDisksPathsFromLibvirtXML(currentSnapshotXmlFilePath,\n                                                             &realReadWriteDisksPath);\n        realReadOnlyDisksPathSize = virVBoxSnapshotConfGetRODisksPathsFromLibvirtXML(currentSnapshotXmlFilePath,\n                                                                         &realReadOnlyDisksPath);\n        /* The read-only disk number is necessarily greater or equal to the\n         * read-write disk number */\n        if (realReadOnlyDisksPathSize < realReadWriteDisksPathSize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"The read only disk number must be greater or equal to the \"\n                           \" read write disk number\"));\n            goto cleanup;\n        }\n        for (it = 0; it < realReadWriteDisksPathSize; it++) {\n            virVBoxSnapshotConfHardDiskPtr readWriteDisk = NULL;\n            PRUnichar *locationUtf = NULL;\n            IMedium *readWriteMedium = NULL;\n            char *uuid = NULL;\n            PRUnichar *formatUtf = NULL;\n            char *format = NULL;\n            const char *parentUuid = NULL;\n            vboxIID iid;\n\n            VBOX_IID_INITIALIZE(&iid);\n            VBOX_UTF8_TO_UTF16(realReadWriteDisksPath[it], &locationUtf);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &readWriteMedium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                VBOX_UTF16_FREE(locationUtf);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf);\n\n            rc = gVBoxAPI.UIMedium.GetId(readWriteMedium, &iid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get the read write medium id\"));\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n            vboxIIDUnalloc(&iid);\n\n            rc = gVBoxAPI.UIMedium.GetFormat(readWriteMedium, &formatUtf);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get the read write medium format\"));\n                goto cleanup;\n            }\n            VBOX_UTF16_TO_UTF8(formatUtf, &format);\n            VBOX_UTF16_FREE(formatUtf);\n\n            if (VIR_ALLOC(readWriteDisk) < 0) {\n                VIR_FREE(formatUtf);\n                goto cleanup;\n            }\n\n            readWriteDisk->format = format;\n            readWriteDisk->uuid = uuid;\n            readWriteDisk->location = realReadWriteDisksPath[it];\n            /*\n             * We get the current snapshot's read-only disk uuid in order to add the\n             * read-write disk to the media registry as its child. The read-only disk\n             * is already in the media registry because it is the fake disk's parent.\n             */\n            parentUuid = virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                                   realReadOnlyDisksPath[it]);\n            if (parentUuid == NULL) {\n                VIR_FREE(readWriteDisk);\n                goto cleanup;\n            }\n\n            if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(readWriteDisk,\n                                           snapshotMachineDesc->mediaRegistry,\n                                           parentUuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to add hard disk to media Registry\"));\n                VIR_FREE(readWriteDisk);\n                goto cleanup;\n            }\n            rc = gVBoxAPI.UIMedium.Close(readWriteMedium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n        /*\n         * Now we have done this swap, we remove the snapshot xml file from the\n         * current machine location.\n         */\n        if (unlink(currentSnapshotXmlFilePath) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to delete file %s\"), currentSnapshotXmlFilePath);\n            goto cleanup;\n        }\n    }\n    /*\n     * Before unregistering the machine, while all disks are still open, ensure that all\n     * read-only disks are in the redefined snapshot's media registry (the disks need to\n     * be open to query their uuid).\n     */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        int diskInMediaRegistry = 0;\n        IMedium *readOnlyMedium = NULL;\n        PRUnichar *locationUtf = NULL;\n        char *uuid = NULL;\n        PRUnichar *formatUtf = NULL;\n        char *format = NULL;\n        char *parentUuid = NULL;\n        virVBoxSnapshotConfHardDiskPtr readOnlyDisk = NULL;\n        vboxIID iid, parentiid;\n\n        VBOX_IID_INITIALIZE(&iid);\n        VBOX_IID_INITIALIZE(&parentiid);\n        diskInMediaRegistry = virVBoxSnapshotConfDiskIsInMediaRegistry(snapshotMachineDesc,\n                                                        def->parent.dom->disks[it]->src->path);\n        if (diskInMediaRegistry == -1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to know if disk is in media registry\"));\n            goto cleanup;\n        }\n        if (diskInMediaRegistry == 1) /* Nothing to do. */\n            continue;\n        /* The read only disk is not in the media registry */\n\n        VBOX_UTF8_TO_UTF16(def->parent.dom->disks[it]->src->path, &locationUtf);\n        rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                              locationUtf,\n                                              DeviceType_HardDisk,\n                                              AccessMode_ReadWrite,\n                                              &readOnlyMedium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to open HardDisk, rc=%08x\"),\n                           (unsigned)rc);\n            VBOX_UTF16_FREE(locationUtf);\n            goto cleanup;\n        }\n        VBOX_UTF16_FREE(locationUtf);\n\n        rc = gVBoxAPI.UIMedium.GetId(readOnlyMedium, &iid);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get hard disk id\"));\n            goto cleanup;\n        }\n        gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n        vboxIIDUnalloc(&iid);\n\n        rc = gVBoxAPI.UIMedium.GetFormat(readOnlyMedium, &formatUtf);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get hard disk format\"));\n            VIR_FREE(uuid);\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(formatUtf, &format);\n        VBOX_UTF16_FREE(formatUtf);\n\n        /* This disk is already in the media registry */\n        IMedium *parentReadOnlyMedium = NULL;\n        rc = gVBoxAPI.UIMedium.GetParent(readOnlyMedium, &parentReadOnlyMedium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get parent hard disk\"));\n            VIR_FREE(uuid);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMedium.GetId(parentReadOnlyMedium, &parentiid);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to get hard disk id, rc=%08x\"),\n                           (unsigned)rc);\n            VIR_FREE(uuid);\n            goto cleanup;\n        }\n        gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n        vboxIIDUnalloc(&parentiid);\n\n        rc = gVBoxAPI.UIMedium.Close(readOnlyMedium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to close HardDisk, rc=%08x\"),\n                           (unsigned)rc);\n            VIR_FREE(uuid);\n            VIR_FREE(parentUuid);\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC(readOnlyDisk) < 0) {\n            VIR_FREE(uuid);\n            VIR_FREE(parentUuid);\n            goto cleanup;\n        }\n\n        readOnlyDisk->format = format;\n        readOnlyDisk->uuid = uuid;\n        readOnlyDisk->location = g_strdup(def->parent.dom->disks[it]->src->path);\n\n        if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(readOnlyDisk, snapshotMachineDesc->mediaRegistry,\n                                       parentUuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to add hard disk to media registry\"));\n            VIR_FREE(readOnlyDisk);\n            goto cleanup;\n        }\n    }\n\n    /* Now, we can unregister the machine */\n    rc = gVBoxAPI.UIMachine.Unregister(machine,\n                                       CleanupMode_DetachAllReturnHardDisksOnly,\n                                       &aMediaSize,\n                                       &aMedia);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to unregister machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n    VBOX_RELEASE(machine);\n\n    /*\n     * Unregister the machine, and then close all disks returned by the unregister method.\n     * Some close operations will fail because some disks that need to be closed will not\n     * be returned by virtualbox. We will close them just after. We have to use this\n     * solution because it is the only way to delete fake disks.\n     */\n    for (it = 0; it < aMediaSize; it++) {\n        IMedium *medium = aMedia[it];\n        if (medium) {\n            PRUnichar *locationUtf16 = NULL;\n            char *locationUtf8 = NULL;\n            rc = gVBoxAPI.UIMedium.GetLocation(medium, &locationUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get medium location\"));\n                goto cleanup;\n            }\n            VBOX_UTF16_TO_UTF8(locationUtf16, &locationUtf8);\n            VBOX_UTF16_FREE(locationUtf16);\n            if (strstr(locationUtf8, \"fake\") != NULL) {\n                /* we delete the fake disk because we don't need it anymore */\n                IProgress *progress = NULL;\n                resultCodeUnion resultCode;\n                rc = gVBoxAPI.UIMedium.DeleteStorage(medium, &progress);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to delete medium, rc=%08x\"),\n                                   (unsigned)rc);\n                    VIR_FREE(locationUtf8);\n                    goto cleanup;\n                }\n                gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n                gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n                if (RC_FAILED(resultCode)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Error while closing medium, rc=%08x\"),\n                                   resultCode.uResultCode);\n                    VIR_FREE(locationUtf8);\n                    goto cleanup;\n                }\n                VBOX_RELEASE(progress);\n            } else {\n                /*\n                 * This a comment from vboxmanage code in the handleUnregisterVM\n                 * function in VBoxManageMisc.cpp :\n                 * Note that the IMachine::Unregister method will return the medium\n                 * reference in a sane order, which means that closing will normally\n                 * succeed, unless there is still another machine which uses the\n                 * medium. No harm done if we ignore the error.\n                 */\n                ignore_value(gVBoxAPI.UIMedium.Close(medium));\n            }\n            VBOX_UTF8_FREE(locationUtf8);\n        }\n    }\n    /* Close all disks that failed to close normally. */\n    for (it = 0; it < snapshotMachineDesc->mediaRegistry->ndisks; it++) {\n        if (vboxCloseDisksRecursively(dom, snapshotMachineDesc->mediaRegistry->disks[it]->location) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to close recursively all disks\"));\n            goto cleanup;\n        }\n    }\n    /* Here, all disks are closed or deleted */\n\n    /* We are now going to create and fill the Snapshot xml struct */\n    if (VIR_ALLOC(newSnapshotPtr) < 0)\n        goto cleanup;\n\n    if (virUUIDGenerate(snapshotUuid) < 0)\n        goto cleanup;\n\n    char uuidtmp[VIR_UUID_STRING_BUFLEN];\n    virUUIDFormat(snapshotUuid, uuidtmp);\n    newSnapshotPtr->uuid = g_strdup(uuidtmp);\n\n    VIR_DEBUG(\"New snapshot UUID: %s\", newSnapshotPtr->uuid);\n    newSnapshotPtr->name = g_strdup(def->parent.name);\n\n    newSnapshotPtr->timeStamp = virTimeStringThen(def->parent.creationTime * 1000);\n\n    newSnapshotPtr->description = g_strdup(def->parent.description);\n\n    newSnapshotPtr->hardware = g_strdup(snapshotMachineDesc->hardware);\n\n    newSnapshotPtr->storageController = g_strdup(snapshotMachineDesc->storageController);\n\n    /* We get the parent disk uuid from the parent disk location\n     * to correctly fill the storage controller. */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        char *location = NULL;\n        const char *uuidReplacing = NULL;\n        char *tmp = NULL;\n\n        location = def->parent.dom->disks[it]->src->path;\n        if (!location)\n            goto cleanup;\n        /* Replacing the uuid */\n        uuidReplacing = virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc, location);\n        if (uuidReplacing == NULL)\n            goto cleanup;\n\n        resultSize = virStringSearch(newSnapshotPtr->storageController,\n                                     VBOX_UUID_REGEX,\n                                     it + 1,\n                                     &searchResultTab);\n        if (resultSize != it + 1)\n            goto cleanup;\n\n        tmp = virStringReplace(newSnapshotPtr->storageController,\n                               searchResultTab[it],\n                               uuidReplacing);\n        virStringListFree(searchResultTab);\n        searchResultTab = NULL;\n        VIR_FREE(newSnapshotPtr->storageController);\n        if (!tmp)\n            goto cleanup;\n        newSnapshotPtr->storageController = g_strdup(tmp);\n\n        VIR_FREE(tmp);\n    }\n    if (virVBoxSnapshotConfAddSnapshotToXmlMachine(newSnapshotPtr, snapshotMachineDesc, def->parent.parent_name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to add the snapshot to the machine description\"));\n        goto cleanup;\n    }\n    /*\n     * We change the current snapshot only if there is no current snapshot or if the\n     * snapshotFile exists, otherwise, it means that the correct current snapshot is\n     * already set.\n     */\n\n    if (snapshotMachineDesc->currentSnapshot == NULL || snapshotFileExists) {\n        snapshotMachineDesc->currentSnapshot = newSnapshotPtr->uuid;\n        needToChangeStorageController = true;\n    }\n\n    /*\n     * Open the snapshot's read-write disk's full ancestry to allow opening the\n     * read-write disk itself.\n     */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        char *location = NULL;\n\n        location = def->parent.dom->disks[it]->src->path;\n        if (!location)\n            goto cleanup;\n\n        hardDiskToOpenSize = virVBoxSnapshotConfDiskListToOpen(snapshotMachineDesc,\n                                                   &hardDiskToOpen, location);\n        for (jt = hardDiskToOpenSize -1; jt >= 0; jt--) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            VBOX_UTF8_TO_UTF16(hardDiskToOpen[jt]->location, &locationUtf16);\n\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf16,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &medium);\n            VBOX_UTF16_FREE(locationUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n    }\n    if (isCurrent || !needToChangeStorageController) {\n        /* We don't create a differential hard disk because either the current snapshot\n         * has already been defined or the snapshot to redefine is the current snapshot.\n         * If the snapshot to redefine is the current snapshot, we add read-write disks in\n         * the machine storage controllers.\n         */\n        for (it = 0; it < def->ndisks; it++) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            virVBoxSnapshotConfHardDiskPtr disk = NULL;\n            PRUnichar *formatUtf16 = NULL;\n            char *format = NULL;\n            char *uuid = NULL;\n            IMedium *parentDisk = NULL;\n            char *parentUuid = NULL;\n            vboxIID iid, parentiid;\n\n            VBOX_IID_INITIALIZE(&iid);\n            VBOX_IID_INITIALIZE(&parentiid);\n            VBOX_UTF8_TO_UTF16(def->disks[it].src->path, &locationUtf16);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                 locationUtf16,\n                                                 DeviceType_HardDisk,\n                                                 AccessMode_ReadWrite,\n                                                 &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf16);\n\n            if (VIR_ALLOC(disk) < 0)\n                goto cleanup;\n\n            rc = gVBoxAPI.UIMedium.GetFormat(medium, &formatUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get disk format\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n\n            VBOX_UTF16_TO_UTF8(formatUtf16, &format);\n            disk->format = format;\n            VBOX_UTF16_FREE(formatUtf16);\n\n            disk->location = g_strdup(def->disks[it].src->path);\n\n            rc = gVBoxAPI.UIMedium.GetId(medium, &iid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get disk uuid\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n            disk->uuid = uuid;\n            vboxIIDUnalloc(&iid);\n\n            rc = gVBoxAPI.UIMedium.GetParent(medium, &parentDisk);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get disk parent\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n\n            gVBoxAPI.UIMedium.GetId(parentDisk, &parentiid);\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n            vboxIIDUnalloc(&parentiid);\n            if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(disk,\n                                           snapshotMachineDesc->mediaRegistry,\n                                           parentUuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to add hard disk to the media registry\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n\n            if (needToChangeStorageController) {\n                /* We need to append this disk in the storage controller */\n                char *tmp = NULL;\n                resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                             VBOX_UUID_REGEX,\n                                             it + 1,\n                                             &searchResultTab);\n                if (resultSize != it + 1) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to find UUID %s\"), searchResultTab[it]);\n                    goto cleanup;\n                }\n\n                tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                       searchResultTab[it],\n                                       disk->uuid);\n                VIR_FREE(snapshotMachineDesc->storageController);\n                if (!tmp)\n                    goto cleanup;\n                snapshotMachineDesc->storageController = g_strdup(tmp);\n\n                VIR_FREE(tmp);\n            }\n            /* Close disk */\n            rc = gVBoxAPI.UIMedium.Close(medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n    } else {\n        /* Create a \"fake\" disk to avoid corrupting children snapshot disks. */\n        for (it = 0; it < def->parent.dom->ndisks; it++) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            char *parentUuid = NULL;\n            IMedium *newMedium = NULL;\n            PRUnichar *formatUtf16 = NULL;\n            PRUnichar *newLocation = NULL;\n            char *newLocationUtf8 = NULL;\n            resultCodeUnion resultCode;\n            char *uuid = NULL;\n            char *format = NULL;\n            char *tmp = NULL;\n            vboxIID iid, parentiid;\n\n            VBOX_IID_INITIALIZE(&iid);\n            VBOX_IID_INITIALIZE(&parentiid);\n            VBOX_UTF8_TO_UTF16(def->parent.dom->disks[it]->src->path, &locationUtf16);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf16,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                VBOX_UTF16_FREE(locationUtf16);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf16);\n\n            rc = gVBoxAPI.UIMedium.GetId(medium, &parentiid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to get hardDisk Id, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n            vboxIIDUnalloc(&parentiid);\n            VBOX_UTF8_TO_UTF16(\"VDI\", &formatUtf16);\n\n            newLocationUtf8 = g_strdup_printf(\"%sfakedisk-%d.vdi\",\n                                              machineLocationPath, it);\n            VBOX_UTF8_TO_UTF16(newLocationUtf8, &newLocation);\n            rc = gVBoxAPI.UIVirtualBox.CreateHardDisk(data->vboxObj,\n                                                      formatUtf16,\n                                                      newLocation,\n                                                      &newMedium);\n            VBOX_UTF16_FREE(newLocation);\n            VBOX_UTF16_FREE(formatUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to create HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n\n            IProgress *progress = NULL;\n            PRUint32 tab[1];\n            tab[0] = MediumVariant_Diff;\n            gVBoxAPI.UIMedium.CreateDiffStorage(medium, newMedium, 1, tab, &progress);\n\n            gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n            gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n            if (RC_FAILED(resultCode)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Error while creating diff storage, rc=%08x\"),\n                               resultCode.uResultCode);\n                goto cleanup;\n            }\n            VBOX_RELEASE(progress);\n            /*\n             * The differential newHardDisk is created, we add it to the\n             * media registry and the machine storage controllers.\n             */\n\n            if (VIR_ALLOC(newHardDisk) < 0)\n                goto cleanup;\n\n            rc = gVBoxAPI.UIMedium.GetId(newMedium, &iid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to get medium uuid, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n            newHardDisk->uuid = uuid;\n            vboxIIDUnalloc(&iid);\n\n            newHardDisk->location = g_strdup(newLocationUtf8);\n\n            rc = gVBoxAPI.UIMedium.GetFormat(newMedium, &formatUtf16);\n            VBOX_UTF16_TO_UTF8(formatUtf16, &format);\n            newHardDisk->format = format;\n            VBOX_UTF16_FREE(formatUtf16);\n\n            if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(newHardDisk,\n                                           snapshotMachineDesc->mediaRegistry,\n                                           parentUuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to add hard disk to the media registry\"));\n                goto cleanup;\n            }\n            newHardDisk = NULL;  /* Consumed by above */\n            /* Adding the fake disk to the machine storage controllers */\n\n            resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                         VBOX_UUID_REGEX,\n                                         it + 1,\n                                         &searchResultTab);\n            if (resultSize != it + 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to find UUID %s\"), searchResultTab[it]);\n                goto cleanup;\n            }\n\n            tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                   searchResultTab[it],\n                                   uuid);\n            VIR_FREE(snapshotMachineDesc->storageController);\n            if (!tmp)\n                goto cleanup;\n            snapshotMachineDesc->storageController = g_strdup(tmp);\n\n            VIR_FREE(tmp);\n            /* Closing the \"fake\" disk */\n            rc = gVBoxAPI.UIMedium.Close(newMedium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close the new medium, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n        /*\n         * We save the snapshot xml file to retrieve the real read-write disk during the\n         * next define. This file is saved as \"'machineLocation'/snapshot-'uuid'.xml\"\n         */\n        VIR_FREE(currentSnapshotXmlFilePath);\n        currentSnapshotXmlFilePath = g_strdup_printf(\"%s%s.xml\",\n                                                     machineLocationPath, snapshotMachineDesc->currentSnapshot);\n        char *snapshotContent = virDomainSnapshotDefFormat(NULL, def,\n                                                           data->xmlopt,\n                                                           VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE);\n        if (snapshotContent == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get snapshot content\"));\n            goto cleanup;\n        }\n        if (virFileWriteStr(currentSnapshotXmlFilePath, snapshotContent, 0644) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to save new snapshot xml file\"));\n            goto cleanup;\n        }\n        VIR_FREE(snapshotContent);\n    }\n    /*\n     * All the snapshot structure manipulation is done, we close the disks we have\n     * previously opened.\n     */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        char *location = def->parent.dom->disks[it]->src->path;\n        if (!location)\n            goto cleanup;\n\n        hardDiskToOpenSize = virVBoxSnapshotConfDiskListToOpen(snapshotMachineDesc,\n                                                   &hardDiskToOpen, location);\n        for (jt = 0; jt < hardDiskToOpenSize; jt++) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            VBOX_UTF8_TO_UTF16(hardDiskToOpen[jt]->location, &locationUtf16);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf16,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            rc = gVBoxAPI.UIMedium.Close(medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf16);\n        }\n    }\n\n    /* Now, we rewrite the 'machineName'.vbox file to redefine the machine. */\n    if (virVBoxSnapshotConfSaveVboxFile(snapshotMachineDesc, settingsFilePath_Utf8) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to serialize the machine description\"));\n        goto cleanup;\n    }\n    rc = gVBoxAPI.UIVirtualBox.OpenMachine(data->vboxObj,\n                                           settingsFilePath,\n                                           &machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to open Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIVirtualBox.RegisterMachine(data->vboxObj, machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to register Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VBOX_RELEASE(machine);\n    VBOX_UTF16_FREE(settingsFilePath);\n    VBOX_UTF8_FREE(settingsFilePath_Utf8);\n    VIR_FREE(snapshotMachineDesc);\n    VIR_FREE(currentSnapshotXmlFilePath);\n    VBOX_UTF16_FREE(machineNameUtf16);\n    VBOX_UTF8_FREE(machineName);\n    virStringListFree(realReadOnlyDisksPath);\n    virStringListFree(realReadWriteDisksPath);\n    virStringListFree(searchResultTab);\n    virVboxSnapshotConfHardDiskFree(newHardDisk);\n    VIR_FREE(hardDiskToOpen);\n    VIR_FREE(newSnapshotPtr);\n    VIR_FREE(machineLocationPath);\n    VIR_FREE(nameTmpUse);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxSnapshotRedefine(virDomainPtr dom,\n                     virDomainSnapshotDefPtr def,\n                     bool isCurrent)\n{\n    /*\n     * If your snapshot has a parent,\n     * it will only be redefined if you have already\n     * redefined the parent.\n     *\n     * The general algorithm of this function is below :\n     * First of all, we are going to create our vboxSnapshotXmlMachinePtr struct from\n     * the machine settings path.\n     * Then, if the machine current snapshot xml file is saved in the machine location,\n     * it means that this snapshot was previously modified by us and has fake disks.\n     * Fake disks are added when the flag VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT was not set\n     * yet, in order to not corrupt read-only disks. The first thing to do is to remove those\n     * disks and restore the read-write disks, if any, in the vboxSnapshotXmlMachinePtr struct.\n     * We also delete the current snapshot xml file.\n     *\n     * After that, we are going to register the snapshot read-only disks that we want to redefine,\n     * if they are not in the media registry struct.\n     *\n     * The next step is to unregister the machine and close all disks.\n     *\n     * Then, we check if the flag VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE has already been set.\n     * If this flag was set, we just add read-write disks to the media registry\n     * struct. Otherwise, we save the snapshot xml file into the machine location in order\n     * to recover the read-write disks during the next redefine and we create differential disks\n     * from the snapshot read-only disks and add them to the media registry struct.\n     *\n     * Finally, we register the machine with the new virtualbox description file.\n     */\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    nsresult rc;\n    PRUnichar *settingsFilePath = NULL;\n    char *settingsFilePath_Utf8 = NULL;\n    virVBoxSnapshotConfMachinePtr snapshotMachineDesc = NULL;\n    char *currentSnapshotXmlFilePath = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    char *machineName = NULL;\n    char **realReadWriteDisksPath = NULL;\n    int realReadWriteDisksPathSize = 0;\n    char **realReadOnlyDisksPath = NULL;\n    int realReadOnlyDisksPathSize = 0;\n    virVBoxSnapshotConfSnapshotPtr newSnapshotPtr = NULL;\n    unsigned char snapshotUuid[VIR_UUID_BUFLEN];\n    virVBoxSnapshotConfHardDiskPtr *hardDiskToOpen = NULL;\n    size_t hardDiskToOpenSize = 0;\n    virVBoxSnapshotConfHardDiskPtr newHardDisk = NULL;\n    char **searchResultTab = NULL;\n    ssize_t resultSize = 0;\n    int it = 0;\n    int jt = 0;\n    PRUint32 aMediaSize = 0;\n    IMedium **aMedia = NULL;\n    char *machineLocationPath = NULL;\n    char *nameTmpUse = NULL;\n    bool snapshotFileExists = false;\n    bool needToChangeStorageController = false;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIMachine.SaveSettings(machine);\n    /* It may failed when the machine is not mutable. */\n    rc = gVBoxAPI.UIMachine.GetSettingsFilePath(machine, &settingsFilePath);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get settings file path\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(settingsFilePath, &settingsFilePath_Utf8);\n\n    /* Getting the machine name to retrieve the machine location path. */\n    rc = gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get machine name\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineName);\n\n    nameTmpUse = g_strdup_printf(\"%s.vbox\", machineName);\n    machineLocationPath = virStringReplace(settingsFilePath_Utf8, nameTmpUse, \"\");\n    if (machineLocationPath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get the machine location path\"));\n        goto cleanup;\n    }\n\n    /* We create the xml struct with the settings file path. */\n    snapshotMachineDesc = virVBoxSnapshotConfLoadVboxFile(settingsFilePath_Utf8, machineLocationPath);\n    if (snapshotMachineDesc == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot create a vboxSnapshotXmlPtr\"));\n        goto cleanup;\n    }\n    if (snapshotMachineDesc->currentSnapshot != NULL) {\n        currentSnapshotXmlFilePath = g_strdup_printf(\"%s%s.xml\",\n                                                     machineLocationPath, snapshotMachineDesc->currentSnapshot);\n        snapshotFileExists = virFileExists(currentSnapshotXmlFilePath);\n    }\n\n    if (snapshotFileExists) {\n        /*\n         * We have created fake disks, so we have to remove them and replace them with\n         * the read-write disks if there are any. The fake disks will be closed during\n         * the machine unregistration.\n         */\n        if (virVBoxSnapshotConfRemoveFakeDisks(snapshotMachineDesc) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to remove Fake Disks\"));\n            goto cleanup;\n        }\n        realReadWriteDisksPathSize = virVBoxSnapshotConfGetRWDisksPathsFromLibvirtXML(currentSnapshotXmlFilePath,\n                                                             &realReadWriteDisksPath);\n        realReadOnlyDisksPathSize = virVBoxSnapshotConfGetRODisksPathsFromLibvirtXML(currentSnapshotXmlFilePath,\n                                                                         &realReadOnlyDisksPath);\n        /* The read-only disk number is necessarily greater or equal to the\n         * read-write disk number */\n        if (realReadOnlyDisksPathSize < realReadWriteDisksPathSize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"The read only disk number must be greater or equal to the \"\n                           \" read write disk number\"));\n            goto cleanup;\n        }\n        for (it = 0; it < realReadWriteDisksPathSize; it++) {\n            virVBoxSnapshotConfHardDiskPtr readWriteDisk = NULL;\n            PRUnichar *locationUtf = NULL;\n            IMedium *readWriteMedium = NULL;\n            char *uuid = NULL;\n            PRUnichar *formatUtf = NULL;\n            char *format = NULL;\n            const char *parentUuid = NULL;\n            vboxIID iid;\n\n            VBOX_IID_INITIALIZE(&iid);\n            VBOX_UTF8_TO_UTF16(realReadWriteDisksPath[it], &locationUtf);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &readWriteMedium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                VBOX_UTF16_FREE(locationUtf);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf);\n\n            rc = gVBoxAPI.UIMedium.GetId(readWriteMedium, &iid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get the read write medium id\"));\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n            vboxIIDUnalloc(&iid);\n\n            rc = gVBoxAPI.UIMedium.GetFormat(readWriteMedium, &formatUtf);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get the read write medium format\"));\n                goto cleanup;\n            }\n            VBOX_UTF16_TO_UTF8(formatUtf, &format);\n            VBOX_UTF16_FREE(formatUtf);\n\n            if (VIR_ALLOC(readWriteDisk) < 0) {\n                VIR_FREE(formatUtf);\n                goto cleanup;\n            }\n\n            readWriteDisk->format = format;\n            readWriteDisk->uuid = uuid;\n            readWriteDisk->location = realReadWriteDisksPath[it];\n            /*\n             * We get the current snapshot's read-only disk uuid in order to add the\n             * read-write disk to the media registry as its child. The read-only disk\n             * is already in the media registry because it is the fake disk's parent.\n             */\n            parentUuid = virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                                   realReadOnlyDisksPath[it]);\n            if (parentUuid == NULL) {\n                VIR_FREE(readWriteDisk);\n                goto cleanup;\n            }\n\n            if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(readWriteDisk,\n                                           snapshotMachineDesc->mediaRegistry,\n                                           parentUuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to add hard disk to media Registry\"));\n                VIR_FREE(readWriteDisk);\n                goto cleanup;\n            }\n            rc = gVBoxAPI.UIMedium.Close(readWriteMedium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n        /*\n         * Now we have done this swap, we remove the snapshot xml file from the\n         * current machine location.\n         */\n        if (unlink(currentSnapshotXmlFilePath) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to delete file %s\"), currentSnapshotXmlFilePath);\n            goto cleanup;\n        }\n    }\n    /*\n     * Before unregistering the machine, while all disks are still open, ensure that all\n     * read-only disks are in the redefined snapshot's media registry (the disks need to\n     * be open to query their uuid).\n     */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        int diskInMediaRegistry = 0;\n        IMedium *readOnlyMedium = NULL;\n        PRUnichar *locationUtf = NULL;\n        char *uuid = NULL;\n        PRUnichar *formatUtf = NULL;\n        char *format = NULL;\n        char *parentUuid = NULL;\n        virVBoxSnapshotConfHardDiskPtr readOnlyDisk = NULL;\n        vboxIID iid, parentiid;\n\n        VBOX_IID_INITIALIZE(&iid);\n        VBOX_IID_INITIALIZE(&parentiid);\n        diskInMediaRegistry = virVBoxSnapshotConfDiskIsInMediaRegistry(snapshotMachineDesc,\n                                                        def->parent.dom->disks[it]->src->path);\n        if (diskInMediaRegistry == -1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to know if disk is in media registry\"));\n            goto cleanup;\n        }\n        if (diskInMediaRegistry == 1) /* Nothing to do. */\n            continue;\n        /* The read only disk is not in the media registry */\n\n        VBOX_UTF8_TO_UTF16(def->parent.dom->disks[it]->src->path, &locationUtf);\n        rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                              locationUtf,\n                                              DeviceType_HardDisk,\n                                              AccessMode_ReadWrite,\n                                              &readOnlyMedium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to open HardDisk, rc=%08x\"),\n                           (unsigned)rc);\n            VBOX_UTF16_FREE(locationUtf);\n            goto cleanup;\n        }\n        VBOX_UTF16_FREE(locationUtf);\n\n        rc = gVBoxAPI.UIMedium.GetId(readOnlyMedium, &iid);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get hard disk id\"));\n            goto cleanup;\n        }\n        gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n        vboxIIDUnalloc(&iid);\n\n        rc = gVBoxAPI.UIMedium.GetFormat(readOnlyMedium, &formatUtf);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get hard disk format\"));\n            VIR_FREE(uuid);\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(formatUtf, &format);\n        VBOX_UTF16_FREE(formatUtf);\n\n        /* This disk is already in the media registry */\n        IMedium *parentReadOnlyMedium = NULL;\n        rc = gVBoxAPI.UIMedium.GetParent(readOnlyMedium, &parentReadOnlyMedium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get parent hard disk\"));\n            VIR_FREE(uuid);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMedium.GetId(parentReadOnlyMedium, &parentiid);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to get hard disk id, rc=%08x\"),\n                           (unsigned)rc);\n            VIR_FREE(uuid);\n            goto cleanup;\n        }\n        gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n        vboxIIDUnalloc(&parentiid);\n\n        rc = gVBoxAPI.UIMedium.Close(readOnlyMedium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to close HardDisk, rc=%08x\"),\n                           (unsigned)rc);\n            VIR_FREE(uuid);\n            VIR_FREE(parentUuid);\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC(readOnlyDisk) < 0) {\n            VIR_FREE(uuid);\n            VIR_FREE(parentUuid);\n            goto cleanup;\n        }\n\n        readOnlyDisk->format = format;\n        readOnlyDisk->uuid = uuid;\n        readOnlyDisk->location = g_strdup(def->parent.dom->disks[it]->src->path);\n\n        if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(readOnlyDisk, snapshotMachineDesc->mediaRegistry,\n                                       parentUuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to add hard disk to media registry\"));\n            VIR_FREE(readOnlyDisk);\n            goto cleanup;\n        }\n    }\n\n    /* Now, we can unregister the machine */\n    rc = gVBoxAPI.UIMachine.Unregister(machine,\n                                       CleanupMode_DetachAllReturnHardDisksOnly,\n                                       &aMediaSize,\n                                       &aMedia);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to unregister machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n    VBOX_RELEASE(machine);\n\n    /*\n     * Unregister the machine, and then close all disks returned by the unregister method.\n     * Some close operations will fail because some disks that need to be closed will not\n     * be returned by virtualbox. We will close them just after. We have to use this\n     * solution because it is the only way to delete fake disks.\n     */\n    for (it = 0; it < aMediaSize; it++) {\n        IMedium *medium = aMedia[it];\n        if (medium) {\n            PRUnichar *locationUtf16 = NULL;\n            char *locationUtf8 = NULL;\n            rc = gVBoxAPI.UIMedium.GetLocation(medium, &locationUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get medium location\"));\n                goto cleanup;\n            }\n            VBOX_UTF16_TO_UTF8(locationUtf16, &locationUtf8);\n            VBOX_UTF16_FREE(locationUtf16);\n            if (strstr(locationUtf8, \"fake\") != NULL) {\n                /* we delete the fake disk because we don't need it anymore */\n                IProgress *progress = NULL;\n                resultCodeUnion resultCode;\n                rc = gVBoxAPI.UIMedium.DeleteStorage(medium, &progress);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to delete medium, rc=%08x\"),\n                                   (unsigned)rc);\n                    VIR_FREE(locationUtf8);\n                    goto cleanup;\n                }\n                gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n                gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n                if (RC_FAILED(resultCode)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Error while closing medium, rc=%08x\"),\n                                   resultCode.uResultCode);\n                    VIR_FREE(locationUtf8);\n                    goto cleanup;\n                }\n                VBOX_RELEASE(progress);\n            } else {\n                /*\n                 * This a comment from vboxmanage code in the handleUnregisterVM\n                 * function in VBoxManageMisc.cpp :\n                 * Note that the IMachine::Unregister method will return the medium\n                 * reference in a sane order, which means that closing will normally\n                 * succeed, unless there is still another machine which uses the\n                 * medium. No harm done if we ignore the error.\n                 */\n                ignore_value(gVBoxAPI.UIMedium.Close(medium));\n            }\n            VBOX_UTF8_FREE(locationUtf8);\n        }\n    }\n    /* Close all disks that failed to close normally. */\n    for (it = 0; it < snapshotMachineDesc->mediaRegistry->ndisks; it++) {\n        if (vboxCloseDisksRecursively(dom, snapshotMachineDesc->mediaRegistry->disks[it]->location) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to close recursively all disks\"));\n            goto cleanup;\n        }\n    }\n    /* Here, all disks are closed or deleted */\n\n    /* We are now going to create and fill the Snapshot xml struct */\n    if (VIR_ALLOC(newSnapshotPtr) < 0)\n        goto cleanup;\n\n    if (virUUIDGenerate(snapshotUuid) < 0)\n        goto cleanup;\n\n    char uuidtmp[VIR_UUID_STRING_BUFLEN];\n    virUUIDFormat(snapshotUuid, uuidtmp);\n    newSnapshotPtr->uuid = g_strdup(uuidtmp);\n\n    VIR_DEBUG(\"New snapshot UUID: %s\", newSnapshotPtr->uuid);\n    newSnapshotPtr->name = g_strdup(def->parent.name);\n\n    newSnapshotPtr->timeStamp = virTimeStringThen(def->parent.creationTime * 1000);\n\n    newSnapshotPtr->description = g_strdup(def->parent.description);\n\n    newSnapshotPtr->hardware = g_strdup(snapshotMachineDesc->hardware);\n\n    newSnapshotPtr->storageController = g_strdup(snapshotMachineDesc->storageController);\n\n    /* We get the parent disk uuid from the parent disk location\n     * to correctly fill the storage controller. */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        char *location = NULL;\n        const char *uuidReplacing = NULL;\n        char *tmp = NULL;\n\n        location = def->parent.dom->disks[it]->src->path;\n        if (!location)\n            goto cleanup;\n        /* Replacing the uuid */\n        uuidReplacing = virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc, location);\n        if (uuidReplacing == NULL)\n            goto cleanup;\n\n        resultSize = virStringSearch(newSnapshotPtr->storageController,\n                                     VBOX_UUID_REGEX,\n                                     it + 1,\n                                     &searchResultTab);\n        if (resultSize != it + 1)\n            goto cleanup;\n\n        tmp = virStringReplace(newSnapshotPtr->storageController,\n                               searchResultTab[it],\n                               uuidReplacing);\n        virStringListFree(searchResultTab);\n        searchResultTab = NULL;\n        VIR_FREE(newSnapshotPtr->storageController);\n        if (!tmp)\n            goto cleanup;\n        newSnapshotPtr->storageController = g_strdup(tmp);\n\n        VIR_FREE(tmp);\n    }\n    if (virVBoxSnapshotConfAddSnapshotToXmlMachine(newSnapshotPtr, snapshotMachineDesc, def->parent.parent_name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to add the snapshot to the machine description\"));\n        goto cleanup;\n    }\n    /*\n     * We change the current snapshot only if there is no current snapshot or if the\n     * snapshotFile exists, otherwise, it means that the correct current snapshot is\n     * already set.\n     */\n\n    if (snapshotMachineDesc->currentSnapshot == NULL || snapshotFileExists) {\n        snapshotMachineDesc->currentSnapshot = newSnapshotPtr->uuid;\n        needToChangeStorageController = true;\n    }\n\n    /*\n     * Open the snapshot's read-write disk's full ancestry to allow opening the\n     * read-write disk itself.\n     */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        char *location = NULL;\n\n        location = def->parent.dom->disks[it]->src->path;\n        if (!location)\n            goto cleanup;\n\n        hardDiskToOpenSize = virVBoxSnapshotConfDiskListToOpen(snapshotMachineDesc,\n                                                   &hardDiskToOpen, location);\n        for (jt = hardDiskToOpenSize -1; jt >= 0; jt--) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            VBOX_UTF8_TO_UTF16(hardDiskToOpen[jt]->location, &locationUtf16);\n\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf16,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &medium);\n            VBOX_UTF16_FREE(locationUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n    }\n    if (isCurrent || !needToChangeStorageController) {\n        /* We don't create a differential hard disk because either the current snapshot\n         * has already been defined or the snapshot to redefine is the current snapshot.\n         * If the snapshot to redefine is the current snapshot, we add read-write disks in\n         * the machine storage controllers.\n         */\n        for (it = 0; it < def->ndisks; it++) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            virVBoxSnapshotConfHardDiskPtr disk = NULL;\n            PRUnichar *formatUtf16 = NULL;\n            char *format = NULL;\n            char *uuid = NULL;\n            IMedium *parentDisk = NULL;\n            char *parentUuid = NULL;\n            vboxIID iid, parentiid;\n\n            VBOX_IID_INITIALIZE(&iid);\n            VBOX_IID_INITIALIZE(&parentiid);\n            VBOX_UTF8_TO_UTF16(def->disks[it].src->path, &locationUtf16);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                 locationUtf16,\n                                                 DeviceType_HardDisk,\n                                                 AccessMode_ReadWrite,\n                                                 &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf16);\n\n            if (VIR_ALLOC(disk) < 0)\n                goto cleanup;\n\n            rc = gVBoxAPI.UIMedium.GetFormat(medium, &formatUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get disk format\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n\n            VBOX_UTF16_TO_UTF8(formatUtf16, &format);\n            disk->format = format;\n            VBOX_UTF16_FREE(formatUtf16);\n\n            disk->location = g_strdup(def->disks[it].src->path);\n\n            rc = gVBoxAPI.UIMedium.GetId(medium, &iid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get disk uuid\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n            disk->uuid = uuid;\n            vboxIIDUnalloc(&iid);\n\n            rc = gVBoxAPI.UIMedium.GetParent(medium, &parentDisk);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get disk parent\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n\n            gVBoxAPI.UIMedium.GetId(parentDisk, &parentiid);\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n            vboxIIDUnalloc(&parentiid);\n            if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(disk,\n                                           snapshotMachineDesc->mediaRegistry,\n                                           parentUuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to add hard disk to the media registry\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n\n            if (needToChangeStorageController) {\n                /* We need to append this disk in the storage controller */\n                char *tmp = NULL;\n                resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                             VBOX_UUID_REGEX,\n                                             it + 1,\n                                             &searchResultTab);\n                if (resultSize != it + 1) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to find UUID %s\"), searchResultTab[it]);\n                    goto cleanup;\n                }\n\n                tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                       searchResultTab[it],\n                                       disk->uuid);\n                VIR_FREE(snapshotMachineDesc->storageController);\n                if (!tmp)\n                    goto cleanup;\n                snapshotMachineDesc->storageController = g_strdup(tmp);\n\n                VIR_FREE(tmp);\n            }\n            /* Close disk */\n            rc = gVBoxAPI.UIMedium.Close(medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n    } else {\n        /* Create a \"fake\" disk to avoid corrupting children snapshot disks. */\n        for (it = 0; it < def->parent.dom->ndisks; it++) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            char *parentUuid = NULL;\n            IMedium *newMedium = NULL;\n            PRUnichar *formatUtf16 = NULL;\n            PRUnichar *newLocation = NULL;\n            char *newLocationUtf8 = NULL;\n            resultCodeUnion resultCode;\n            char *uuid = NULL;\n            char *format = NULL;\n            char *tmp = NULL;\n            vboxIID iid, parentiid;\n\n            VBOX_IID_INITIALIZE(&iid);\n            VBOX_IID_INITIALIZE(&parentiid);\n            VBOX_UTF8_TO_UTF16(def->parent.dom->disks[it]->src->path, &locationUtf16);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf16,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                VBOX_UTF16_FREE(locationUtf16);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf16);\n\n            rc = gVBoxAPI.UIMedium.GetId(medium, &parentiid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to get hardDisk Id, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n            vboxIIDUnalloc(&parentiid);\n            VBOX_UTF8_TO_UTF16(\"VDI\", &formatUtf16);\n\n            newLocationUtf8 = g_strdup_printf(\"%sfakedisk-%d.vdi\",\n                                              machineLocationPath, it);\n            VBOX_UTF8_TO_UTF16(newLocationUtf8, &newLocation);\n            rc = gVBoxAPI.UIVirtualBox.CreateHardDisk(data->vboxObj,\n                                                      formatUtf16,\n                                                      newLocation,\n                                                      &newMedium);\n            VBOX_UTF16_FREE(newLocation);\n            VBOX_UTF16_FREE(formatUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to create HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n\n            IProgress *progress = NULL;\n            PRUint32 tab[1];\n            tab[0] = MediumVariant_Diff;\n            gVBoxAPI.UIMedium.CreateDiffStorage(medium, newMedium, 1, tab, &progress);\n\n            gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n            gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n            if (RC_FAILED(resultCode)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Error while creating diff storage, rc=%08x\"),\n                               resultCode.uResultCode);\n                goto cleanup;\n            }\n            VBOX_RELEASE(progress);\n            /*\n             * The differential newHardDisk is created, we add it to the\n             * media registry and the machine storage controllers.\n             */\n\n            if (VIR_ALLOC(newHardDisk) < 0)\n                goto cleanup;\n\n            rc = gVBoxAPI.UIMedium.GetId(newMedium, &iid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to get medium uuid, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n            newHardDisk->uuid = uuid;\n            vboxIIDUnalloc(&iid);\n\n            newHardDisk->location = g_strdup(newLocationUtf8);\n\n            rc = gVBoxAPI.UIMedium.GetFormat(newMedium, &formatUtf16);\n            VBOX_UTF16_TO_UTF8(formatUtf16, &format);\n            newHardDisk->format = format;\n            VBOX_UTF16_FREE(formatUtf16);\n\n            if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(newHardDisk,\n                                           snapshotMachineDesc->mediaRegistry,\n                                           parentUuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to add hard disk to the media registry\"));\n                goto cleanup;\n            }\n            newHardDisk = NULL;  /* Consumed by above */\n            /* Adding the fake disk to the machine storage controllers */\n\n            resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                         VBOX_UUID_REGEX,\n                                         it + 1,\n                                         &searchResultTab);\n            if (resultSize != it + 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to find UUID %s\"), searchResultTab[it]);\n                goto cleanup;\n            }\n\n            tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                   searchResultTab[it],\n                                   uuid);\n            VIR_FREE(snapshotMachineDesc->storageController);\n            if (!tmp)\n                goto cleanup;\n            snapshotMachineDesc->storageController = g_strdup(tmp);\n\n            VIR_FREE(tmp);\n            /* Closing the \"fake\" disk */\n            rc = gVBoxAPI.UIMedium.Close(newMedium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close the new medium, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n        /*\n         * We save the snapshot xml file to retrieve the real read-write disk during the\n         * next define. This file is saved as \"'machineLocation'/snapshot-'uuid'.xml\"\n         */\n        VIR_FREE(currentSnapshotXmlFilePath);\n        currentSnapshotXmlFilePath = g_strdup_printf(\"%s%s.xml\",\n                                                     machineLocationPath, snapshotMachineDesc->currentSnapshot);\n        char *snapshotContent = virDomainSnapshotDefFormat(NULL, def,\n                                                           data->xmlopt,\n                                                           VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE);\n        if (snapshotContent == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get snapshot content\"));\n            goto cleanup;\n        }\n        if (virFileWriteStr(currentSnapshotXmlFilePath, snapshotContent, 0644) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to save new snapshot xml file\"));\n            goto cleanup;\n        }\n        VIR_FREE(snapshotContent);\n    }\n    /*\n     * All the snapshot structure manipulation is done, we close the disks we have\n     * previously opened.\n     */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        char *location = def->parent.dom->disks[it]->src->path;\n        if (!location)\n            goto cleanup;\n\n        hardDiskToOpenSize = virVBoxSnapshotConfDiskListToOpen(snapshotMachineDesc,\n                                                   &hardDiskToOpen, location);\n        for (jt = 0; jt < hardDiskToOpenSize; jt++) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            VBOX_UTF8_TO_UTF16(hardDiskToOpen[jt]->location, &locationUtf16);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf16,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            rc = gVBoxAPI.UIMedium.Close(medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf16);\n        }\n    }\n\n    /* Now, we rewrite the 'machineName'.vbox file to redefine the machine. */\n    if (virVBoxSnapshotConfSaveVboxFile(snapshotMachineDesc, settingsFilePath_Utf8) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to serialize the machine description\"));\n        goto cleanup;\n    }\n    rc = gVBoxAPI.UIVirtualBox.OpenMachine(data->vboxObj,\n                                           settingsFilePath,\n                                           &machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to open Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIVirtualBox.RegisterMachine(data->vboxObj, machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to register Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VBOX_RELEASE(machine);\n    VBOX_UTF16_FREE(settingsFilePath);\n    VBOX_UTF8_FREE(settingsFilePath_Utf8);\n    VIR_FREE(snapshotMachineDesc);\n    VIR_FREE(currentSnapshotXmlFilePath);\n    VBOX_UTF16_FREE(machineNameUtf16);\n    VBOX_UTF8_FREE(machineName);\n    virStringListFree(realReadOnlyDisksPath);\n    virStringListFree(realReadWriteDisksPath);\n    virStringListFree(searchResultTab);\n    virVboxSnapshotConfHardDiskFree(newHardDisk);\n    VIR_FREE(hardDiskToOpen);\n    VIR_FREE(newSnapshotPtr);\n    VIR_FREE(machineLocationPath);\n    VIR_FREE(nameTmpUse);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&domiid",
            "&machine"
          ],
          "line": 5437
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDefParseString",
          "args": [
            "xmlDesc",
            "data->xmlopt",
            "NULL",
            "NULL",
            "parse_flags"
          ],
          "line": 5431
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "452-473",
          "snippet": "virDomainSnapshotDefPtr\nvirDomainSnapshotDefParseString(const char *xmlStr,\n                                virDomainXMLOptionPtr xmlopt,\n                                void *parseOpaque,\n                                bool *current,\n                                unsigned int flags)\n{\n    virDomainSnapshotDefPtr ret = NULL;\n    xmlDocPtr xml;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_snapshot)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainSnapshotDefParseNode(xml, xmlDocGetRootElement(xml),\n                                            xmlopt, parseOpaque,\n                                            current, flags);\n        xmlFreeDoc(xml);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainSnapshotDefPtr\nvirDomainSnapshotDefParseString(const char *xmlStr,\n                                virDomainXMLOptionPtr xmlopt,\n                                void *parseOpaque,\n                                bool *current,\n                                unsigned int flags)\n{\n    virDomainSnapshotDefPtr ret = NULL;\n    xmlDocPtr xml;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_snapshot)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainSnapshotDefParseNode(xml, xmlDocGetRootElement(xml),\n                                            xmlopt, parseOpaque,\n                                            current, flags);\n        xmlFreeDoc(xml);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_VALIDATE",
            "NULL"
          ],
          "line": 5423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&domiid"
          ],
          "line": 5421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virDomainSnapshotPtr\nvboxDomainSnapshotCreateXML(virDomainPtr dom,\n                            const char *xmlDesc,\n                            unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    IConsole *console = NULL;\n    IProgress *progress = NULL;\n    ISnapshot *snapshot = NULL;\n    PRUnichar *name = NULL;\n    PRUnichar *description = NULL;\n    PRUint32 state;\n    nsresult rc;\n    resultCodeUnion result;\n    virDomainSnapshotPtr ret = NULL;\n    unsigned int parse_flags = (VIR_DOMAIN_SNAPSHOT_PARSE_DISKS |\n                                VIR_DOMAIN_SNAPSHOT_PARSE_REDEFINE);\n    g_autoptr(virDomainSnapshotDef) def = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&domiid);\n    /* VBox has no snapshot metadata, so this flag is trivial.  */\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_CREATE_VALIDATE)\n        parse_flags |= VIR_DOMAIN_SNAPSHOT_PARSE_VALIDATE;\n\n    if (!(def = virDomainSnapshotDefParseString(xmlDesc,\n                                                data->xmlopt, NULL, NULL,\n                                                parse_flags)))\n        goto cleanup;\n\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    if (gVBoxAPI.vboxSnapshotRedefine) {\n        PRBool isCurrent = flags & VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT;\n        if (flags & VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE) {\n            if (vboxSnapshotRedefine(dom, def, isCurrent) < 0)\n                goto cleanup;\n            ret = virGetDomainSnapshot(dom, def->parent.name);\n            goto cleanup;\n        }\n    }\n\n    rc = gVBoxAPI.UIMachine.GetState(machine, &state);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"could not get domain state\"));\n        goto cleanup;\n    }\n\n    if (gVBoxAPI.machineStateChecker.Online(state)) {\n        rc = gVBoxAPI.UISession.OpenExisting(data, &domiid, machine);\n    } else {\n        rc = gVBoxAPI.UISession.Open(data, &domiid, machine);\n    }\n\n    if (NS_SUCCEEDED(rc))\n        rc = gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not open VirtualBox session with domain %s\"),\n                       dom->name);\n        goto cleanup;\n    }\n\n    VBOX_UTF8_TO_UTF16(def->parent.name, &name);\n    if (!name) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (def->parent.description) {\n        VBOX_UTF8_TO_UTF16(def->parent.description, &description);\n        if (!description) {\n            virReportOOMError();\n            goto cleanup;\n        }\n    }\n\n    rc = gVBoxAPI.UIConsole.TakeSnapshot(console, name, description, &progress);\n    if (NS_FAILED(rc) || !progress) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not take snapshot of domain %s\"), dom->name);\n        goto cleanup;\n    }\n\n    gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n    gVBoxAPI.UIProgress.GetResultCode(progress, &result);\n    if (RC_FAILED(result)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not take snapshot of domain %s\"), dom->name);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIMachine.GetCurrentSnapshot(machine, &snapshot);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not get current snapshot of domain %s\"),\n                  dom->name);\n        goto cleanup;\n    }\n\n    ret = virGetDomainSnapshot(dom, def->parent.name);\n\n cleanup:\n    VBOX_RELEASE(progress);\n    VBOX_UTF16_FREE(description);\n    VBOX_UTF16_FREE(name);\n    VBOX_RELEASE(console);\n    gVBoxAPI.UISession.Close(data->vboxSession);\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&domiid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxSnapshotRedefine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "4522-5395",
    "snippet": "static int\nvboxSnapshotRedefine(virDomainPtr dom,\n                     virDomainSnapshotDefPtr def,\n                     bool isCurrent)\n{\n    /*\n     * If your snapshot has a parent,\n     * it will only be redefined if you have already\n     * redefined the parent.\n     *\n     * The general algorithm of this function is below :\n     * First of all, we are going to create our vboxSnapshotXmlMachinePtr struct from\n     * the machine settings path.\n     * Then, if the machine current snapshot xml file is saved in the machine location,\n     * it means that this snapshot was previously modified by us and has fake disks.\n     * Fake disks are added when the flag VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT was not set\n     * yet, in order to not corrupt read-only disks. The first thing to do is to remove those\n     * disks and restore the read-write disks, if any, in the vboxSnapshotXmlMachinePtr struct.\n     * We also delete the current snapshot xml file.\n     *\n     * After that, we are going to register the snapshot read-only disks that we want to redefine,\n     * if they are not in the media registry struct.\n     *\n     * The next step is to unregister the machine and close all disks.\n     *\n     * Then, we check if the flag VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE has already been set.\n     * If this flag was set, we just add read-write disks to the media registry\n     * struct. Otherwise, we save the snapshot xml file into the machine location in order\n     * to recover the read-write disks during the next redefine and we create differential disks\n     * from the snapshot read-only disks and add them to the media registry struct.\n     *\n     * Finally, we register the machine with the new virtualbox description file.\n     */\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    nsresult rc;\n    PRUnichar *settingsFilePath = NULL;\n    char *settingsFilePath_Utf8 = NULL;\n    virVBoxSnapshotConfMachinePtr snapshotMachineDesc = NULL;\n    char *currentSnapshotXmlFilePath = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    char *machineName = NULL;\n    char **realReadWriteDisksPath = NULL;\n    int realReadWriteDisksPathSize = 0;\n    char **realReadOnlyDisksPath = NULL;\n    int realReadOnlyDisksPathSize = 0;\n    virVBoxSnapshotConfSnapshotPtr newSnapshotPtr = NULL;\n    unsigned char snapshotUuid[VIR_UUID_BUFLEN];\n    virVBoxSnapshotConfHardDiskPtr *hardDiskToOpen = NULL;\n    size_t hardDiskToOpenSize = 0;\n    virVBoxSnapshotConfHardDiskPtr newHardDisk = NULL;\n    char **searchResultTab = NULL;\n    ssize_t resultSize = 0;\n    int it = 0;\n    int jt = 0;\n    PRUint32 aMediaSize = 0;\n    IMedium **aMedia = NULL;\n    char *machineLocationPath = NULL;\n    char *nameTmpUse = NULL;\n    bool snapshotFileExists = false;\n    bool needToChangeStorageController = false;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIMachine.SaveSettings(machine);\n    /* It may failed when the machine is not mutable. */\n    rc = gVBoxAPI.UIMachine.GetSettingsFilePath(machine, &settingsFilePath);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get settings file path\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(settingsFilePath, &settingsFilePath_Utf8);\n\n    /* Getting the machine name to retrieve the machine location path. */\n    rc = gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get machine name\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineName);\n\n    nameTmpUse = g_strdup_printf(\"%s.vbox\", machineName);\n    machineLocationPath = virStringReplace(settingsFilePath_Utf8, nameTmpUse, \"\");\n    if (machineLocationPath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get the machine location path\"));\n        goto cleanup;\n    }\n\n    /* We create the xml struct with the settings file path. */\n    snapshotMachineDesc = virVBoxSnapshotConfLoadVboxFile(settingsFilePath_Utf8, machineLocationPath);\n    if (snapshotMachineDesc == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot create a vboxSnapshotXmlPtr\"));\n        goto cleanup;\n    }\n    if (snapshotMachineDesc->currentSnapshot != NULL) {\n        currentSnapshotXmlFilePath = g_strdup_printf(\"%s%s.xml\",\n                                                     machineLocationPath, snapshotMachineDesc->currentSnapshot);\n        snapshotFileExists = virFileExists(currentSnapshotXmlFilePath);\n    }\n\n    if (snapshotFileExists) {\n        /*\n         * We have created fake disks, so we have to remove them and replace them with\n         * the read-write disks if there are any. The fake disks will be closed during\n         * the machine unregistration.\n         */\n        if (virVBoxSnapshotConfRemoveFakeDisks(snapshotMachineDesc) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to remove Fake Disks\"));\n            goto cleanup;\n        }\n        realReadWriteDisksPathSize = virVBoxSnapshotConfGetRWDisksPathsFromLibvirtXML(currentSnapshotXmlFilePath,\n                                                             &realReadWriteDisksPath);\n        realReadOnlyDisksPathSize = virVBoxSnapshotConfGetRODisksPathsFromLibvirtXML(currentSnapshotXmlFilePath,\n                                                                         &realReadOnlyDisksPath);\n        /* The read-only disk number is necessarily greater or equal to the\n         * read-write disk number */\n        if (realReadOnlyDisksPathSize < realReadWriteDisksPathSize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"The read only disk number must be greater or equal to the \"\n                           \" read write disk number\"));\n            goto cleanup;\n        }\n        for (it = 0; it < realReadWriteDisksPathSize; it++) {\n            virVBoxSnapshotConfHardDiskPtr readWriteDisk = NULL;\n            PRUnichar *locationUtf = NULL;\n            IMedium *readWriteMedium = NULL;\n            char *uuid = NULL;\n            PRUnichar *formatUtf = NULL;\n            char *format = NULL;\n            const char *parentUuid = NULL;\n            vboxIID iid;\n\n            VBOX_IID_INITIALIZE(&iid);\n            VBOX_UTF8_TO_UTF16(realReadWriteDisksPath[it], &locationUtf);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &readWriteMedium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                VBOX_UTF16_FREE(locationUtf);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf);\n\n            rc = gVBoxAPI.UIMedium.GetId(readWriteMedium, &iid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get the read write medium id\"));\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n            vboxIIDUnalloc(&iid);\n\n            rc = gVBoxAPI.UIMedium.GetFormat(readWriteMedium, &formatUtf);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get the read write medium format\"));\n                goto cleanup;\n            }\n            VBOX_UTF16_TO_UTF8(formatUtf, &format);\n            VBOX_UTF16_FREE(formatUtf);\n\n            if (VIR_ALLOC(readWriteDisk) < 0) {\n                VIR_FREE(formatUtf);\n                goto cleanup;\n            }\n\n            readWriteDisk->format = format;\n            readWriteDisk->uuid = uuid;\n            readWriteDisk->location = realReadWriteDisksPath[it];\n            /*\n             * We get the current snapshot's read-only disk uuid in order to add the\n             * read-write disk to the media registry as its child. The read-only disk\n             * is already in the media registry because it is the fake disk's parent.\n             */\n            parentUuid = virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                                   realReadOnlyDisksPath[it]);\n            if (parentUuid == NULL) {\n                VIR_FREE(readWriteDisk);\n                goto cleanup;\n            }\n\n            if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(readWriteDisk,\n                                           snapshotMachineDesc->mediaRegistry,\n                                           parentUuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to add hard disk to media Registry\"));\n                VIR_FREE(readWriteDisk);\n                goto cleanup;\n            }\n            rc = gVBoxAPI.UIMedium.Close(readWriteMedium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n        /*\n         * Now we have done this swap, we remove the snapshot xml file from the\n         * current machine location.\n         */\n        if (unlink(currentSnapshotXmlFilePath) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to delete file %s\"), currentSnapshotXmlFilePath);\n            goto cleanup;\n        }\n    }\n    /*\n     * Before unregistering the machine, while all disks are still open, ensure that all\n     * read-only disks are in the redefined snapshot's media registry (the disks need to\n     * be open to query their uuid).\n     */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        int diskInMediaRegistry = 0;\n        IMedium *readOnlyMedium = NULL;\n        PRUnichar *locationUtf = NULL;\n        char *uuid = NULL;\n        PRUnichar *formatUtf = NULL;\n        char *format = NULL;\n        char *parentUuid = NULL;\n        virVBoxSnapshotConfHardDiskPtr readOnlyDisk = NULL;\n        vboxIID iid, parentiid;\n\n        VBOX_IID_INITIALIZE(&iid);\n        VBOX_IID_INITIALIZE(&parentiid);\n        diskInMediaRegistry = virVBoxSnapshotConfDiskIsInMediaRegistry(snapshotMachineDesc,\n                                                        def->parent.dom->disks[it]->src->path);\n        if (diskInMediaRegistry == -1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to know if disk is in media registry\"));\n            goto cleanup;\n        }\n        if (diskInMediaRegistry == 1) /* Nothing to do. */\n            continue;\n        /* The read only disk is not in the media registry */\n\n        VBOX_UTF8_TO_UTF16(def->parent.dom->disks[it]->src->path, &locationUtf);\n        rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                              locationUtf,\n                                              DeviceType_HardDisk,\n                                              AccessMode_ReadWrite,\n                                              &readOnlyMedium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to open HardDisk, rc=%08x\"),\n                           (unsigned)rc);\n            VBOX_UTF16_FREE(locationUtf);\n            goto cleanup;\n        }\n        VBOX_UTF16_FREE(locationUtf);\n\n        rc = gVBoxAPI.UIMedium.GetId(readOnlyMedium, &iid);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get hard disk id\"));\n            goto cleanup;\n        }\n        gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n        vboxIIDUnalloc(&iid);\n\n        rc = gVBoxAPI.UIMedium.GetFormat(readOnlyMedium, &formatUtf);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get hard disk format\"));\n            VIR_FREE(uuid);\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(formatUtf, &format);\n        VBOX_UTF16_FREE(formatUtf);\n\n        /* This disk is already in the media registry */\n        IMedium *parentReadOnlyMedium = NULL;\n        rc = gVBoxAPI.UIMedium.GetParent(readOnlyMedium, &parentReadOnlyMedium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get parent hard disk\"));\n            VIR_FREE(uuid);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMedium.GetId(parentReadOnlyMedium, &parentiid);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to get hard disk id, rc=%08x\"),\n                           (unsigned)rc);\n            VIR_FREE(uuid);\n            goto cleanup;\n        }\n        gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n        vboxIIDUnalloc(&parentiid);\n\n        rc = gVBoxAPI.UIMedium.Close(readOnlyMedium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to close HardDisk, rc=%08x\"),\n                           (unsigned)rc);\n            VIR_FREE(uuid);\n            VIR_FREE(parentUuid);\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC(readOnlyDisk) < 0) {\n            VIR_FREE(uuid);\n            VIR_FREE(parentUuid);\n            goto cleanup;\n        }\n\n        readOnlyDisk->format = format;\n        readOnlyDisk->uuid = uuid;\n        readOnlyDisk->location = g_strdup(def->parent.dom->disks[it]->src->path);\n\n        if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(readOnlyDisk, snapshotMachineDesc->mediaRegistry,\n                                       parentUuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to add hard disk to media registry\"));\n            VIR_FREE(readOnlyDisk);\n            goto cleanup;\n        }\n    }\n\n    /* Now, we can unregister the machine */\n    rc = gVBoxAPI.UIMachine.Unregister(machine,\n                                       CleanupMode_DetachAllReturnHardDisksOnly,\n                                       &aMediaSize,\n                                       &aMedia);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to unregister machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n    VBOX_RELEASE(machine);\n\n    /*\n     * Unregister the machine, and then close all disks returned by the unregister method.\n     * Some close operations will fail because some disks that need to be closed will not\n     * be returned by virtualbox. We will close them just after. We have to use this\n     * solution because it is the only way to delete fake disks.\n     */\n    for (it = 0; it < aMediaSize; it++) {\n        IMedium *medium = aMedia[it];\n        if (medium) {\n            PRUnichar *locationUtf16 = NULL;\n            char *locationUtf8 = NULL;\n            rc = gVBoxAPI.UIMedium.GetLocation(medium, &locationUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get medium location\"));\n                goto cleanup;\n            }\n            VBOX_UTF16_TO_UTF8(locationUtf16, &locationUtf8);\n            VBOX_UTF16_FREE(locationUtf16);\n            if (strstr(locationUtf8, \"fake\") != NULL) {\n                /* we delete the fake disk because we don't need it anymore */\n                IProgress *progress = NULL;\n                resultCodeUnion resultCode;\n                rc = gVBoxAPI.UIMedium.DeleteStorage(medium, &progress);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to delete medium, rc=%08x\"),\n                                   (unsigned)rc);\n                    VIR_FREE(locationUtf8);\n                    goto cleanup;\n                }\n                gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n                gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n                if (RC_FAILED(resultCode)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Error while closing medium, rc=%08x\"),\n                                   resultCode.uResultCode);\n                    VIR_FREE(locationUtf8);\n                    goto cleanup;\n                }\n                VBOX_RELEASE(progress);\n            } else {\n                /*\n                 * This a comment from vboxmanage code in the handleUnregisterVM\n                 * function in VBoxManageMisc.cpp :\n                 * Note that the IMachine::Unregister method will return the medium\n                 * reference in a sane order, which means that closing will normally\n                 * succeed, unless there is still another machine which uses the\n                 * medium. No harm done if we ignore the error.\n                 */\n                ignore_value(gVBoxAPI.UIMedium.Close(medium));\n            }\n            VBOX_UTF8_FREE(locationUtf8);\n        }\n    }\n    /* Close all disks that failed to close normally. */\n    for (it = 0; it < snapshotMachineDesc->mediaRegistry->ndisks; it++) {\n        if (vboxCloseDisksRecursively(dom, snapshotMachineDesc->mediaRegistry->disks[it]->location) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to close recursively all disks\"));\n            goto cleanup;\n        }\n    }\n    /* Here, all disks are closed or deleted */\n\n    /* We are now going to create and fill the Snapshot xml struct */\n    if (VIR_ALLOC(newSnapshotPtr) < 0)\n        goto cleanup;\n\n    if (virUUIDGenerate(snapshotUuid) < 0)\n        goto cleanup;\n\n    char uuidtmp[VIR_UUID_STRING_BUFLEN];\n    virUUIDFormat(snapshotUuid, uuidtmp);\n    newSnapshotPtr->uuid = g_strdup(uuidtmp);\n\n    VIR_DEBUG(\"New snapshot UUID: %s\", newSnapshotPtr->uuid);\n    newSnapshotPtr->name = g_strdup(def->parent.name);\n\n    newSnapshotPtr->timeStamp = virTimeStringThen(def->parent.creationTime * 1000);\n\n    newSnapshotPtr->description = g_strdup(def->parent.description);\n\n    newSnapshotPtr->hardware = g_strdup(snapshotMachineDesc->hardware);\n\n    newSnapshotPtr->storageController = g_strdup(snapshotMachineDesc->storageController);\n\n    /* We get the parent disk uuid from the parent disk location\n     * to correctly fill the storage controller. */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        char *location = NULL;\n        const char *uuidReplacing = NULL;\n        char *tmp = NULL;\n\n        location = def->parent.dom->disks[it]->src->path;\n        if (!location)\n            goto cleanup;\n        /* Replacing the uuid */\n        uuidReplacing = virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc, location);\n        if (uuidReplacing == NULL)\n            goto cleanup;\n\n        resultSize = virStringSearch(newSnapshotPtr->storageController,\n                                     VBOX_UUID_REGEX,\n                                     it + 1,\n                                     &searchResultTab);\n        if (resultSize != it + 1)\n            goto cleanup;\n\n        tmp = virStringReplace(newSnapshotPtr->storageController,\n                               searchResultTab[it],\n                               uuidReplacing);\n        virStringListFree(searchResultTab);\n        searchResultTab = NULL;\n        VIR_FREE(newSnapshotPtr->storageController);\n        if (!tmp)\n            goto cleanup;\n        newSnapshotPtr->storageController = g_strdup(tmp);\n\n        VIR_FREE(tmp);\n    }\n    if (virVBoxSnapshotConfAddSnapshotToXmlMachine(newSnapshotPtr, snapshotMachineDesc, def->parent.parent_name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to add the snapshot to the machine description\"));\n        goto cleanup;\n    }\n    /*\n     * We change the current snapshot only if there is no current snapshot or if the\n     * snapshotFile exists, otherwise, it means that the correct current snapshot is\n     * already set.\n     */\n\n    if (snapshotMachineDesc->currentSnapshot == NULL || snapshotFileExists) {\n        snapshotMachineDesc->currentSnapshot = newSnapshotPtr->uuid;\n        needToChangeStorageController = true;\n    }\n\n    /*\n     * Open the snapshot's read-write disk's full ancestry to allow opening the\n     * read-write disk itself.\n     */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        char *location = NULL;\n\n        location = def->parent.dom->disks[it]->src->path;\n        if (!location)\n            goto cleanup;\n\n        hardDiskToOpenSize = virVBoxSnapshotConfDiskListToOpen(snapshotMachineDesc,\n                                                   &hardDiskToOpen, location);\n        for (jt = hardDiskToOpenSize -1; jt >= 0; jt--) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            VBOX_UTF8_TO_UTF16(hardDiskToOpen[jt]->location, &locationUtf16);\n\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf16,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &medium);\n            VBOX_UTF16_FREE(locationUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n    }\n    if (isCurrent || !needToChangeStorageController) {\n        /* We don't create a differential hard disk because either the current snapshot\n         * has already been defined or the snapshot to redefine is the current snapshot.\n         * If the snapshot to redefine is the current snapshot, we add read-write disks in\n         * the machine storage controllers.\n         */\n        for (it = 0; it < def->ndisks; it++) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            virVBoxSnapshotConfHardDiskPtr disk = NULL;\n            PRUnichar *formatUtf16 = NULL;\n            char *format = NULL;\n            char *uuid = NULL;\n            IMedium *parentDisk = NULL;\n            char *parentUuid = NULL;\n            vboxIID iid, parentiid;\n\n            VBOX_IID_INITIALIZE(&iid);\n            VBOX_IID_INITIALIZE(&parentiid);\n            VBOX_UTF8_TO_UTF16(def->disks[it].src->path, &locationUtf16);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                 locationUtf16,\n                                                 DeviceType_HardDisk,\n                                                 AccessMode_ReadWrite,\n                                                 &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf16);\n\n            if (VIR_ALLOC(disk) < 0)\n                goto cleanup;\n\n            rc = gVBoxAPI.UIMedium.GetFormat(medium, &formatUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get disk format\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n\n            VBOX_UTF16_TO_UTF8(formatUtf16, &format);\n            disk->format = format;\n            VBOX_UTF16_FREE(formatUtf16);\n\n            disk->location = g_strdup(def->disks[it].src->path);\n\n            rc = gVBoxAPI.UIMedium.GetId(medium, &iid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get disk uuid\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n            disk->uuid = uuid;\n            vboxIIDUnalloc(&iid);\n\n            rc = gVBoxAPI.UIMedium.GetParent(medium, &parentDisk);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get disk parent\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n\n            gVBoxAPI.UIMedium.GetId(parentDisk, &parentiid);\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n            vboxIIDUnalloc(&parentiid);\n            if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(disk,\n                                           snapshotMachineDesc->mediaRegistry,\n                                           parentUuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to add hard disk to the media registry\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n\n            if (needToChangeStorageController) {\n                /* We need to append this disk in the storage controller */\n                char *tmp = NULL;\n                resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                             VBOX_UUID_REGEX,\n                                             it + 1,\n                                             &searchResultTab);\n                if (resultSize != it + 1) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to find UUID %s\"), searchResultTab[it]);\n                    goto cleanup;\n                }\n\n                tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                       searchResultTab[it],\n                                       disk->uuid);\n                VIR_FREE(snapshotMachineDesc->storageController);\n                if (!tmp)\n                    goto cleanup;\n                snapshotMachineDesc->storageController = g_strdup(tmp);\n\n                VIR_FREE(tmp);\n            }\n            /* Close disk */\n            rc = gVBoxAPI.UIMedium.Close(medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n    } else {\n        /* Create a \"fake\" disk to avoid corrupting children snapshot disks. */\n        for (it = 0; it < def->parent.dom->ndisks; it++) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            char *parentUuid = NULL;\n            IMedium *newMedium = NULL;\n            PRUnichar *formatUtf16 = NULL;\n            PRUnichar *newLocation = NULL;\n            char *newLocationUtf8 = NULL;\n            resultCodeUnion resultCode;\n            char *uuid = NULL;\n            char *format = NULL;\n            char *tmp = NULL;\n            vboxIID iid, parentiid;\n\n            VBOX_IID_INITIALIZE(&iid);\n            VBOX_IID_INITIALIZE(&parentiid);\n            VBOX_UTF8_TO_UTF16(def->parent.dom->disks[it]->src->path, &locationUtf16);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf16,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                VBOX_UTF16_FREE(locationUtf16);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf16);\n\n            rc = gVBoxAPI.UIMedium.GetId(medium, &parentiid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to get hardDisk Id, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n            vboxIIDUnalloc(&parentiid);\n            VBOX_UTF8_TO_UTF16(\"VDI\", &formatUtf16);\n\n            newLocationUtf8 = g_strdup_printf(\"%sfakedisk-%d.vdi\",\n                                              machineLocationPath, it);\n            VBOX_UTF8_TO_UTF16(newLocationUtf8, &newLocation);\n            rc = gVBoxAPI.UIVirtualBox.CreateHardDisk(data->vboxObj,\n                                                      formatUtf16,\n                                                      newLocation,\n                                                      &newMedium);\n            VBOX_UTF16_FREE(newLocation);\n            VBOX_UTF16_FREE(formatUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to create HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n\n            IProgress *progress = NULL;\n            PRUint32 tab[1];\n            tab[0] = MediumVariant_Diff;\n            gVBoxAPI.UIMedium.CreateDiffStorage(medium, newMedium, 1, tab, &progress);\n\n            gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n            gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n            if (RC_FAILED(resultCode)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Error while creating diff storage, rc=%08x\"),\n                               resultCode.uResultCode);\n                goto cleanup;\n            }\n            VBOX_RELEASE(progress);\n            /*\n             * The differential newHardDisk is created, we add it to the\n             * media registry and the machine storage controllers.\n             */\n\n            if (VIR_ALLOC(newHardDisk) < 0)\n                goto cleanup;\n\n            rc = gVBoxAPI.UIMedium.GetId(newMedium, &iid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to get medium uuid, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n            newHardDisk->uuid = uuid;\n            vboxIIDUnalloc(&iid);\n\n            newHardDisk->location = g_strdup(newLocationUtf8);\n\n            rc = gVBoxAPI.UIMedium.GetFormat(newMedium, &formatUtf16);\n            VBOX_UTF16_TO_UTF8(formatUtf16, &format);\n            newHardDisk->format = format;\n            VBOX_UTF16_FREE(formatUtf16);\n\n            if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(newHardDisk,\n                                           snapshotMachineDesc->mediaRegistry,\n                                           parentUuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to add hard disk to the media registry\"));\n                goto cleanup;\n            }\n            newHardDisk = NULL;  /* Consumed by above */\n            /* Adding the fake disk to the machine storage controllers */\n\n            resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                         VBOX_UUID_REGEX,\n                                         it + 1,\n                                         &searchResultTab);\n            if (resultSize != it + 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to find UUID %s\"), searchResultTab[it]);\n                goto cleanup;\n            }\n\n            tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                   searchResultTab[it],\n                                   uuid);\n            VIR_FREE(snapshotMachineDesc->storageController);\n            if (!tmp)\n                goto cleanup;\n            snapshotMachineDesc->storageController = g_strdup(tmp);\n\n            VIR_FREE(tmp);\n            /* Closing the \"fake\" disk */\n            rc = gVBoxAPI.UIMedium.Close(newMedium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close the new medium, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n        /*\n         * We save the snapshot xml file to retrieve the real read-write disk during the\n         * next define. This file is saved as \"'machineLocation'/snapshot-'uuid'.xml\"\n         */\n        VIR_FREE(currentSnapshotXmlFilePath);\n        currentSnapshotXmlFilePath = g_strdup_printf(\"%s%s.xml\",\n                                                     machineLocationPath, snapshotMachineDesc->currentSnapshot);\n        char *snapshotContent = virDomainSnapshotDefFormat(NULL, def,\n                                                           data->xmlopt,\n                                                           VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE);\n        if (snapshotContent == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get snapshot content\"));\n            goto cleanup;\n        }\n        if (virFileWriteStr(currentSnapshotXmlFilePath, snapshotContent, 0644) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to save new snapshot xml file\"));\n            goto cleanup;\n        }\n        VIR_FREE(snapshotContent);\n    }\n    /*\n     * All the snapshot structure manipulation is done, we close the disks we have\n     * previously opened.\n     */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        char *location = def->parent.dom->disks[it]->src->path;\n        if (!location)\n            goto cleanup;\n\n        hardDiskToOpenSize = virVBoxSnapshotConfDiskListToOpen(snapshotMachineDesc,\n                                                   &hardDiskToOpen, location);\n        for (jt = 0; jt < hardDiskToOpenSize; jt++) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            VBOX_UTF8_TO_UTF16(hardDiskToOpen[jt]->location, &locationUtf16);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf16,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            rc = gVBoxAPI.UIMedium.Close(medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf16);\n        }\n    }\n\n    /* Now, we rewrite the 'machineName'.vbox file to redefine the machine. */\n    if (virVBoxSnapshotConfSaveVboxFile(snapshotMachineDesc, settingsFilePath_Utf8) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to serialize the machine description\"));\n        goto cleanup;\n    }\n    rc = gVBoxAPI.UIVirtualBox.OpenMachine(data->vboxObj,\n                                           settingsFilePath,\n                                           &machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to open Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIVirtualBox.RegisterMachine(data->vboxObj, machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to register Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VBOX_RELEASE(machine);\n    VBOX_UTF16_FREE(settingsFilePath);\n    VBOX_UTF8_FREE(settingsFilePath_Utf8);\n    VIR_FREE(snapshotMachineDesc);\n    VIR_FREE(currentSnapshotXmlFilePath);\n    VBOX_UTF16_FREE(machineNameUtf16);\n    VBOX_UTF8_FREE(machineName);\n    virStringListFree(realReadOnlyDisksPath);\n    virStringListFree(realReadWriteDisksPath);\n    virStringListFree(searchResultTab);\n    virVboxSnapshotConfHardDiskFree(newHardDisk);\n    VIR_FREE(hardDiskToOpen);\n    VIR_FREE(newSnapshotPtr);\n    VIR_FREE(machineLocationPath);\n    VIR_FREE(nameTmpUse);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nameTmpUse"
          ],
          "line": 5393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "machineLocationPath"
          ],
          "line": 5392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "newSnapshotPtr"
          ],
          "line": 5391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "hardDiskToOpen"
          ],
          "line": 5390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVboxSnapshotConfHardDiskFree",
          "args": [
            "newHardDisk"
          ],
          "line": 5389
        },
        "resolved": true,
        "details": {
          "function_name": "virVboxSnapshotConfHardDiskFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "499-515",
          "snippet": "void\nvirVboxSnapshotConfHardDiskFree(virVBoxSnapshotConfHardDiskPtr disk)\n{\n    size_t i = 0;\n\n    if (!disk)\n        return;\n\n    VIR_FREE(disk->uuid);\n    VIR_FREE(disk->location);\n    VIR_FREE(disk->format);\n    VIR_FREE(disk->type);\n    for (i = 0; i < disk->nchildren; i++)\n        virVboxSnapshotConfHardDiskFree(disk->children[i]);\n    VIR_FREE(disk->children);\n    VIR_FREE(disk);\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvoid\nvirVboxSnapshotConfHardDiskFree(virVBoxSnapshotConfHardDiskPtr disk)\n{\n    size_t i = 0;\n\n    if (!disk)\n        return;\n\n    VIR_FREE(disk->uuid);\n    VIR_FREE(disk->location);\n    VIR_FREE(disk->format);\n    VIR_FREE(disk->type);\n    for (i = 0; i < disk->nchildren; i++)\n        virVboxSnapshotConfHardDiskFree(disk->children[i]);\n    VIR_FREE(disk->children);\n    VIR_FREE(disk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "searchResultTab"
          ],
          "line": 5388
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "machineName"
          ],
          "line": 5385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "machineNameUtf16"
          ],
          "line": 5384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "currentSnapshotXmlFilePath"
          ],
          "line": 5383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshotMachineDesc"
          ],
          "line": 5382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "settingsFilePath_Utf8"
          ],
          "line": 5381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "settingsFilePath"
          ],
          "line": 5380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 5379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to register Machine, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 5371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to register Machine, rc=%08x\""
          ],
          "line": 5372
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.RegisterMachine",
          "args": [
            "data->vboxObj",
            "machine"
          ],
          "line": 5369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to open Machine, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 5363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.OpenMachine",
          "args": [
            "data->vboxObj",
            "settingsFilePath",
            "&machine"
          ],
          "line": 5359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to serialize the machine description\")"
          ],
          "line": 5355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfSaveVboxFile",
          "args": [
            "snapshotMachineDesc",
            "settingsFilePath_Utf8"
          ],
          "line": 5354
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfSaveVboxFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "968-1217",
          "snippet": "int\nvirVBoxSnapshotConfSaveVboxFile(virVBoxSnapshotConfMachinePtr machine,\n                                const char *filePath)\n{\n    int ret = -1;\n    size_t i = 0;\n    xmlDocPtr xml = NULL;\n    xmlNodePtr mediaRegistryNode = NULL;\n    xmlNodePtr snapshotNode = NULL;\n    xmlNodePtr machineNode = NULL;\n    xmlNodePtr hardDisksNode = NULL;\n    xmlNodePtr cur = NULL;\n    xmlParserErrors parseError = XML_ERR_OK;\n    char *currentSnapshot = NULL;\n    char *timeStamp = NULL;\n\n    char **firstRegex = NULL;\n    int firstRegexResult = 0;\n    char **secondRegex = NULL;\n    int secondRegexResult = 0;\n\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Machine is null\"));\n        goto cleanup;\n    }\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Filepath is null\"));\n        goto cleanup;\n    }\n    xml = xmlNewDoc(BAD_CAST \"1.0\");\n    if (!xml) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    cur = xmlNewNode(NULL, BAD_CAST \"VirtualBox\");\n    if (!cur) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlNewProp(cur, BAD_CAST \"version\", BAD_CAST \"1.12-linux\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (xmlNewProp(cur,\n                   BAD_CAST \"xmlns\",\n                   BAD_CAST \"http://www.innotek.de/VirtualBox-settings\") == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    xmlDocSetRootElement(xml, cur);\n\n    cur = xmlNewDocComment(xml,\n                           BAD_CAST \"WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE\\n\"\n                           \"OVERWRITTEN AND LOST.\\n\"\n                           \"Changes to this xml configuration should be made using Virtualbox\\n\"\n                           \"or other application using the libvirt API\");\n    if (!cur) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlAddPrevSibling(xmlDocGetRootElement(xml), cur)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlAddPrevSibling\"));\n        goto cleanup;\n    }\n\n    machineNode = xmlNewNode(NULL, BAD_CAST \"Machine\");\n    if (!machineNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlNewProp(machineNode, BAD_CAST \"uuid\", BAD_CAST machine->uuid)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"name\", BAD_CAST machine->name)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    if (machine->currentSnapshot != NULL) {\n        currentSnapshot = g_strdup_printf(\"{%s}\", machine->currentSnapshot);\n        if (!xmlNewProp(machineNode, BAD_CAST \"currentSnapshot\", BAD_CAST currentSnapshot)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Error in xmlNewProp\"));\n            goto cleanup;\n        }\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"snapshotFolder\", BAD_CAST machine->snapshotFolder)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"currentStateModified\",\n               BAD_CAST(machine->currentStateModified == 0 ? \"false\" : \"true\"))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"OSType\", BAD_CAST \"Other\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    firstRegexResult = virStringSearch(machine->lastStateChange,\n                                       \"([0-9]{4}-[0-9]{2}-[0-9]{2})\",\n                                       1,\n                                       &firstRegex);\n    secondRegexResult = virStringSearch(machine->lastStateChange,\n                                        \"([0-9]{2}:[0-9]{2}:[0-9]{2})\",\n                                        1,\n                                        &secondRegex);\n    if (firstRegexResult < 1)\n        goto cleanup;\n    if (secondRegexResult < 1)\n        goto cleanup;\n\n    timeStamp = g_strdup_printf(\"%sT%sZ\", firstRegex[0], secondRegex[0]);\n    if (!xmlNewProp(machineNode, BAD_CAST \"lastStateChange\", BAD_CAST timeStamp)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    xmlAddChild(xmlDocGetRootElement(xml), machineNode);\n\n    mediaRegistryNode = xmlNewNode(NULL, BAD_CAST \"MediaRegistry\");\n    if (!mediaRegistryNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    xmlAddChild(machineNode, mediaRegistryNode);\n    for (i = 0; i < machine->mediaRegistry->notherMedia; i++) {\n        parseError = xmlParseInNodeContext(mediaRegistryNode,\n                              machine->mediaRegistry->otherMedia[i],\n                              (int)strlen(machine->mediaRegistry->otherMedia[i]),\n                              0,\n                              &cur);\n        if (parseError != XML_ERR_OK) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Unable to add media registry other media\"));\n            goto cleanup;\n        }\n        xmlAddChild(mediaRegistryNode, cur);\n    }\n    hardDisksNode = xmlNewNode(NULL, BAD_CAST \"HardDisks\");\n    if (!hardDisksNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        xmlNodePtr child = virVBoxSnapshotConfCreateHardDiskNode(machine->mediaRegistry->disks[i]);\n        if (child != NULL)\n            xmlAddChild(hardDisksNode, child);\n    }\n    xmlAddChild(mediaRegistryNode, hardDisksNode);\n\n    parseError = xmlParseInNodeContext(machineNode,\n                                       machine->hardware,\n                                       (int)strlen(machine->hardware),\n                                       0,\n                                       &cur);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add hardware machine\"));\n        goto cleanup;\n    }\n    xmlAddChild(machineNode, cur);\n\n    if (machine->extraData != NULL) {\n        parseError = xmlParseInNodeContext(xmlDocGetRootElement(xml),\n                                           machine->extraData,\n                                           (int)strlen(machine->extraData),\n                                           0,\n                                           &cur);\n        if (parseError != XML_ERR_OK) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Unable to add extra data\"));\n            goto cleanup;\n        }\n        xmlAddChild(machineNode, cur);\n    }\n\n    parseError = xmlParseInNodeContext(machineNode,\n                                       machine->storageController,\n                                       (int)strlen(machine->storageController),\n                                       0,\n                                       &cur);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add storage controller\"));\n        goto cleanup;\n    }\n    xmlAddChild(machineNode, cur);\n\n    if (machine->snapshot != NULL) {\n        snapshotNode = xmlNewNode(NULL, BAD_CAST \"Snapshot\");\n        xmlAddChild(machineNode, snapshotNode);\n        if (virVBoxSnapshotConfSerializeSnapshot(snapshotNode, machine->snapshot) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Failed to serialize snapshot\"));\n            goto cleanup;\n        }\n    }\n\n    if (xmlSaveFormatFileEnc(filePath, xml, \"ISO-8859-1\", 1) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to save the xml\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(currentSnapshot);\n    VIR_FREE(timeStamp);\n\n    xmlUnlinkNode(hardDisksNode);\n    xmlFreeNode(hardDisksNode);\n\n    xmlUnlinkNode(mediaRegistryNode);\n    xmlFreeNode(mediaRegistryNode);\n\n    xmlUnlinkNode(snapshotNode);\n    xmlFreeNode(snapshotNode);\n\n    xmlUnlinkNode(cur);\n    xmlFreeNode(cur);\n\n    xmlUnlinkNode(machineNode);\n    xmlFreeNode(machineNode);\n\n    xmlFreeDoc(xml);\n\n    virStringListFree(firstRegex);\n    virStringListFree(secondRegex);\n    return ret;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfSaveVboxFile(virVBoxSnapshotConfMachinePtr machine,\n                                const char *filePath)\n{\n    int ret = -1;\n    size_t i = 0;\n    xmlDocPtr xml = NULL;\n    xmlNodePtr mediaRegistryNode = NULL;\n    xmlNodePtr snapshotNode = NULL;\n    xmlNodePtr machineNode = NULL;\n    xmlNodePtr hardDisksNode = NULL;\n    xmlNodePtr cur = NULL;\n    xmlParserErrors parseError = XML_ERR_OK;\n    char *currentSnapshot = NULL;\n    char *timeStamp = NULL;\n\n    char **firstRegex = NULL;\n    int firstRegexResult = 0;\n    char **secondRegex = NULL;\n    int secondRegexResult = 0;\n\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Machine is null\"));\n        goto cleanup;\n    }\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Filepath is null\"));\n        goto cleanup;\n    }\n    xml = xmlNewDoc(BAD_CAST \"1.0\");\n    if (!xml) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    cur = xmlNewNode(NULL, BAD_CAST \"VirtualBox\");\n    if (!cur) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlNewProp(cur, BAD_CAST \"version\", BAD_CAST \"1.12-linux\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (xmlNewProp(cur,\n                   BAD_CAST \"xmlns\",\n                   BAD_CAST \"http://www.innotek.de/VirtualBox-settings\") == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    xmlDocSetRootElement(xml, cur);\n\n    cur = xmlNewDocComment(xml,\n                           BAD_CAST \"WARNING: THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE\\n\"\n                           \"OVERWRITTEN AND LOST.\\n\"\n                           \"Changes to this xml configuration should be made using Virtualbox\\n\"\n                           \"or other application using the libvirt API\");\n    if (!cur) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlAddPrevSibling(xmlDocGetRootElement(xml), cur)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlAddPrevSibling\"));\n        goto cleanup;\n    }\n\n    machineNode = xmlNewNode(NULL, BAD_CAST \"Machine\");\n    if (!machineNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    if (!xmlNewProp(machineNode, BAD_CAST \"uuid\", BAD_CAST machine->uuid)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"name\", BAD_CAST machine->name)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    if (machine->currentSnapshot != NULL) {\n        currentSnapshot = g_strdup_printf(\"{%s}\", machine->currentSnapshot);\n        if (!xmlNewProp(machineNode, BAD_CAST \"currentSnapshot\", BAD_CAST currentSnapshot)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Error in xmlNewProp\"));\n            goto cleanup;\n        }\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"snapshotFolder\", BAD_CAST machine->snapshotFolder)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"currentStateModified\",\n               BAD_CAST(machine->currentStateModified == 0 ? \"false\" : \"true\"))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    if (!xmlNewProp(machineNode, BAD_CAST \"OSType\", BAD_CAST \"Other\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n\n    firstRegexResult = virStringSearch(machine->lastStateChange,\n                                       \"([0-9]{4}-[0-9]{2}-[0-9]{2})\",\n                                       1,\n                                       &firstRegex);\n    secondRegexResult = virStringSearch(machine->lastStateChange,\n                                        \"([0-9]{2}:[0-9]{2}:[0-9]{2})\",\n                                        1,\n                                        &secondRegex);\n    if (firstRegexResult < 1)\n        goto cleanup;\n    if (secondRegexResult < 1)\n        goto cleanup;\n\n    timeStamp = g_strdup_printf(\"%sT%sZ\", firstRegex[0], secondRegex[0]);\n    if (!xmlNewProp(machineNode, BAD_CAST \"lastStateChange\", BAD_CAST timeStamp)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Error in xmlNewProp\"));\n        goto cleanup;\n    }\n    xmlAddChild(xmlDocGetRootElement(xml), machineNode);\n\n    mediaRegistryNode = xmlNewNode(NULL, BAD_CAST \"MediaRegistry\");\n    if (!mediaRegistryNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n\n    xmlAddChild(machineNode, mediaRegistryNode);\n    for (i = 0; i < machine->mediaRegistry->notherMedia; i++) {\n        parseError = xmlParseInNodeContext(mediaRegistryNode,\n                              machine->mediaRegistry->otherMedia[i],\n                              (int)strlen(machine->mediaRegistry->otherMedia[i]),\n                              0,\n                              &cur);\n        if (parseError != XML_ERR_OK) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Unable to add media registry other media\"));\n            goto cleanup;\n        }\n        xmlAddChild(mediaRegistryNode, cur);\n    }\n    hardDisksNode = xmlNewNode(NULL, BAD_CAST \"HardDisks\");\n    if (!hardDisksNode) {\n        virReportOOMError();\n        goto cleanup;\n    }\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        xmlNodePtr child = virVBoxSnapshotConfCreateHardDiskNode(machine->mediaRegistry->disks[i]);\n        if (child != NULL)\n            xmlAddChild(hardDisksNode, child);\n    }\n    xmlAddChild(mediaRegistryNode, hardDisksNode);\n\n    parseError = xmlParseInNodeContext(machineNode,\n                                       machine->hardware,\n                                       (int)strlen(machine->hardware),\n                                       0,\n                                       &cur);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add hardware machine\"));\n        goto cleanup;\n    }\n    xmlAddChild(machineNode, cur);\n\n    if (machine->extraData != NULL) {\n        parseError = xmlParseInNodeContext(xmlDocGetRootElement(xml),\n                                           machine->extraData,\n                                           (int)strlen(machine->extraData),\n                                           0,\n                                           &cur);\n        if (parseError != XML_ERR_OK) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Unable to add extra data\"));\n            goto cleanup;\n        }\n        xmlAddChild(machineNode, cur);\n    }\n\n    parseError = xmlParseInNodeContext(machineNode,\n                                       machine->storageController,\n                                       (int)strlen(machine->storageController),\n                                       0,\n                                       &cur);\n    if (parseError != XML_ERR_OK) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to add storage controller\"));\n        goto cleanup;\n    }\n    xmlAddChild(machineNode, cur);\n\n    if (machine->snapshot != NULL) {\n        snapshotNode = xmlNewNode(NULL, BAD_CAST \"Snapshot\");\n        xmlAddChild(machineNode, snapshotNode);\n        if (virVBoxSnapshotConfSerializeSnapshot(snapshotNode, machine->snapshot) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Failed to serialize snapshot\"));\n            goto cleanup;\n        }\n    }\n\n    if (xmlSaveFormatFileEnc(filePath, xml, \"ISO-8859-1\", 1) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to save the xml\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(currentSnapshot);\n    VIR_FREE(timeStamp);\n\n    xmlUnlinkNode(hardDisksNode);\n    xmlFreeNode(hardDisksNode);\n\n    xmlUnlinkNode(mediaRegistryNode);\n    xmlFreeNode(mediaRegistryNode);\n\n    xmlUnlinkNode(snapshotNode);\n    xmlFreeNode(snapshotNode);\n\n    xmlUnlinkNode(cur);\n    xmlFreeNode(cur);\n\n    xmlUnlinkNode(machineNode);\n    xmlFreeNode(machineNode);\n\n    xmlFreeDoc(xml);\n\n    virStringListFree(firstRegex);\n    virStringListFree(secondRegex);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "locationUtf16"
          ],
          "line": 5349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to close HardDisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 5344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.Close",
          "args": [
            "medium"
          ],
          "line": 5342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to open HardDisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 5337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.OpenMedium",
          "args": [
            "data->vboxObj",
            "locationUtf16",
            "DeviceType_HardDisk",
            "AccessMode_ReadWrite",
            "&medium"
          ],
          "line": 5331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "hardDiskToOpen[jt]->location",
            "&locationUtf16"
          ],
          "line": 5330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfDiskListToOpen",
          "args": [
            "snapshotMachineDesc",
            "&hardDiskToOpen",
            "location"
          ],
          "line": 5325
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfDiskListToOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "1395-1425",
          "snippet": "size_t\nvirVBoxSnapshotConfDiskListToOpen(virVBoxSnapshotConfMachinePtr machine,\n                                  virVBoxSnapshotConfHardDiskPtr **hardDiskToOpen,\n                                  const char *location)\n{\n    size_t i = 0;\n    size_t returnSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *ret = NULL;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[i], location);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL)\n        return 0;\n    if (VIR_ALLOC_N(ret, 1) < 0)\n        return 0;\n\n    returnSize = 1;\n    ret[returnSize - 1] = hardDisk;\n\n    while (hardDisk->parent != NULL) {\n        if (VIR_EXPAND_N(ret, returnSize, 1) < 0)\n            return 0;\n        ret[returnSize - 1] = hardDisk->parent;\n        hardDisk = hardDisk->parent;\n    }\n    *hardDiskToOpen = ret;\n    return returnSize;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nsize_t\nvirVBoxSnapshotConfDiskListToOpen(virVBoxSnapshotConfMachinePtr machine,\n                                  virVBoxSnapshotConfHardDiskPtr **hardDiskToOpen,\n                                  const char *location)\n{\n    size_t i = 0;\n    size_t returnSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *ret = NULL;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[i], location);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL)\n        return 0;\n    if (VIR_ALLOC_N(ret, 1) < 0)\n        return 0;\n\n    returnSize = 1;\n    ret[returnSize - 1] = hardDisk;\n\n    while (hardDisk->parent != NULL) {\n        if (VIR_EXPAND_N(ret, returnSize, 1) < 0)\n            return 0;\n        ret[returnSize - 1] = hardDisk->parent;\n        hardDisk = hardDisk->parent;\n    }\n    *hardDiskToOpen = ret;\n    return returnSize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshotContent"
          ],
          "line": 5314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to save new snapshot xml file\")"
          ],
          "line": 5310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "currentSnapshotXmlFilePath",
            "snapshotContent",
            "0644"
          ],
          "line": 5309
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get snapshot content\")"
          ],
          "line": 5305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDefFormat",
          "args": [
            "NULL",
            "def",
            "data->xmlopt",
            "VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE"
          ],
          "line": 5301
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "926-942",
          "snippet": "char *\nvirDomainSnapshotDefFormat(const char *uuidstr,\n                           virDomainSnapshotDefPtr def,\n                           virDomainXMLOptionPtr xmlopt,\n                           unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_INTERNAL |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_CURRENT, NULL);\n    if (virDomainSnapshotDefFormatInternal(&buf, uuidstr, def,\n                                           xmlopt, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *\nvirDomainSnapshotDefFormat(const char *uuidstr,\n                           virDomainSnapshotDefPtr def,\n                           virDomainXMLOptionPtr xmlopt,\n                           unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_INTERNAL |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_CURRENT, NULL);\n    if (virDomainSnapshotDefFormatInternal(&buf, uuidstr, def,\n                                           xmlopt, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s%s.xml\"",
            "machineLocationPath",
            "snapshotMachineDesc->currentSnapshot"
          ],
          "line": 5299
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "currentSnapshotXmlFilePath"
          ],
          "line": 5298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to close the new medium, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 5288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.Close",
          "args": [
            "newMedium"
          ],
          "line": 5286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 5284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshotMachineDesc->storageController"
          ],
          "line": 5279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringReplace",
          "args": [
            "snapshotMachineDesc->storageController",
            "searchResultTab[it]",
            "uuid"
          ],
          "line": 5276
        },
        "resolved": true,
        "details": {
          "function_name": "virStringReplace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1067-1095",
          "snippet": "char *\nvirStringReplace(const char *haystack,\n                 const char *oldneedle,\n                 const char *newneedle)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *tmp1, *tmp2;\n    size_t oldneedlelen = strlen(oldneedle);\n    size_t newneedlelen = strlen(newneedle);\n\n    tmp1 = haystack;\n    tmp2 = NULL;\n\n    while (tmp1) {\n        tmp2 = strstr(tmp1, oldneedle);\n\n        if (tmp2) {\n            virBufferAdd(&buf, tmp1, (tmp2 - tmp1));\n            virBufferAdd(&buf, newneedle, newneedlelen);\n            tmp2 += oldneedlelen;\n        } else {\n            virBufferAdd(&buf, tmp1, -1);\n        }\n\n        tmp1 = tmp2;\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nchar *\nvirStringReplace(const char *haystack,\n                 const char *oldneedle,\n                 const char *newneedle)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *tmp1, *tmp2;\n    size_t oldneedlelen = strlen(oldneedle);\n    size_t newneedlelen = strlen(newneedle);\n\n    tmp1 = haystack;\n    tmp2 = NULL;\n\n    while (tmp1) {\n        tmp2 = strstr(tmp1, oldneedle);\n\n        if (tmp2) {\n            virBufferAdd(&buf, tmp1, (tmp2 - tmp1));\n            virBufferAdd(&buf, newneedle, newneedlelen);\n            tmp2 += oldneedlelen;\n        } else {\n            virBufferAdd(&buf, tmp1, -1);\n        }\n\n        tmp1 = tmp2;\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to find UUID %s\")",
            "searchResultTab[it]"
          ],
          "line": 5271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringSearch",
          "args": [
            "snapshotMachineDesc->storageController",
            "VBOX_UUID_REGEX",
            "it + 1",
            "&searchResultTab"
          ],
          "line": 5266
        },
        "resolved": true,
        "details": {
          "function_name": "virStringSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "965-1029",
          "snippet": "ssize_t\nvirStringSearch(const char *str,\n                const char *regexp,\n                size_t max_matches,\n                char ***matches)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    size_t nmatches = 0;\n    ssize_t ret = -1;\n\n    *matches = NULL;\n\n    VIR_DEBUG(\"search '%s' for '%s'\", str, regexp);\n\n    regex = g_regex_new(regexp, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (g_regex_get_capture_count(regex) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Regular expression '%s' must have exactly 1 match group, not %d\"),\n                       regexp, g_regex_get_capture_count(regex));\n        goto cleanup;\n    }\n\n    /* '*matches' must always be NULL terminated in every iteration\n     * of the loop, so start by allocating 1 element\n     */\n    if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n        goto cleanup;\n\n    while ((nmatches - 1) < max_matches) {\n        g_autoptr(GMatchInfo) info = NULL;\n        char *match;\n        int endpos;\n\n        if (!g_regex_match(regex, str, 0, &info))\n            break;\n\n        if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n            goto cleanup;\n\n        match = g_match_info_fetch(info, 1);\n\n        VIR_DEBUG(\"Got '%s'\", match);\n\n        (*matches)[nmatches-2] = match;\n\n        g_match_info_fetch_pos(info, 1, NULL, &endpos);\n        str += endpos;\n    }\n\n    ret = nmatches - 1; /* don't count the trailing null */\n\n cleanup:\n    if (ret < 0) {\n        virStringListFree(*matches);\n        *matches = NULL;\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nssize_t\nvirStringSearch(const char *str,\n                const char *regexp,\n                size_t max_matches,\n                char ***matches)\n{\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    size_t nmatches = 0;\n    ssize_t ret = -1;\n\n    *matches = NULL;\n\n    VIR_DEBUG(\"search '%s' for '%s'\", str, regexp);\n\n    regex = g_regex_new(regexp, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    if (g_regex_get_capture_count(regex) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Regular expression '%s' must have exactly 1 match group, not %d\"),\n                       regexp, g_regex_get_capture_count(regex));\n        goto cleanup;\n    }\n\n    /* '*matches' must always be NULL terminated in every iteration\n     * of the loop, so start by allocating 1 element\n     */\n    if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n        goto cleanup;\n\n    while ((nmatches - 1) < max_matches) {\n        g_autoptr(GMatchInfo) info = NULL;\n        char *match;\n        int endpos;\n\n        if (!g_regex_match(regex, str, 0, &info))\n            break;\n\n        if (VIR_EXPAND_N(*matches, nmatches, 1) < 0)\n            goto cleanup;\n\n        match = g_match_info_fetch(info, 1);\n\n        VIR_DEBUG(\"Got '%s'\", match);\n\n        (*matches)[nmatches-2] = match;\n\n        g_match_info_fetch_pos(info, 1, NULL, &endpos);\n        str += endpos;\n    }\n\n    ret = nmatches - 1; /* don't count the trailing null */\n\n cleanup:\n    if (ret < 0) {\n        virStringListFree(*matches);\n        *matches = NULL;\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to add hard disk to the media registry\")"
          ],
          "line": 5259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfAddHardDiskToMediaRegistry",
          "args": [
            "newHardDisk",
            "snapshotMachineDesc->mediaRegistry",
            "parentUuid"
          ],
          "line": 5256
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfAddHardDiskToMediaRegistry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "804-841",
          "snippet": "int\nvirVBoxSnapshotConfAddHardDiskToMediaRegistry(virVBoxSnapshotConfHardDiskPtr hardDisk,\n                                              virVBoxSnapshotConfMediaRegistryPtr mediaRegistry,\n                                              const char *parentHardDiskId)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr parentDisk = NULL;\n    if (hardDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Hard disk is null\"));\n        return -1;\n    }\n    if (mediaRegistry == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Media Registry is null\"));\n        return -1;\n    }\n\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        parentDisk = virVBoxSnapshotConfHardDiskById(mediaRegistry->disks[i], parentHardDiskId);\n        if (parentDisk != NULL)\n            break;\n    }\n    if (parentDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get the parent disk\"));\n        return -1;\n    }\n    /* Hard disk found */\n    if (VIR_EXPAND_N(parentDisk->children, parentDisk->nchildren, 1) < 0)\n        return -1;\n\n    parentDisk->children[parentDisk->nchildren - 1] = hardDisk;\n    if (hardDisk->parent == NULL)\n        hardDisk->parent = parentDisk;\n\n    return 0;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfAddHardDiskToMediaRegistry(virVBoxSnapshotConfHardDiskPtr hardDisk,\n                                              virVBoxSnapshotConfMediaRegistryPtr mediaRegistry,\n                                              const char *parentHardDiskId)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr parentDisk = NULL;\n    if (hardDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Hard disk is null\"));\n        return -1;\n    }\n    if (mediaRegistry == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Media Registry is null\"));\n        return -1;\n    }\n\n    for (i = 0; i < mediaRegistry->ndisks; i++) {\n        parentDisk = virVBoxSnapshotConfHardDiskById(mediaRegistry->disks[i], parentHardDiskId);\n        if (parentDisk != NULL)\n            break;\n    }\n    if (parentDisk == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get the parent disk\"));\n        return -1;\n    }\n    /* Hard disk found */\n    if (VIR_EXPAND_N(parentDisk->children, parentDisk->nchildren, 1) < 0)\n        return -1;\n\n    parentDisk->children[parentDisk->nchildren - 1] = hardDisk;\n    if (hardDisk->parent == NULL)\n        hardDisk->parent = parentDisk;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "formatUtf16"
          ],
          "line": 5254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "formatUtf16",
            "&format"
          ],
          "line": 5252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetFormat",
          "args": [
            "newMedium",
            "&formatUtf16"
          ],
          "line": 5251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 5247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIID.vboxIIDToUtf8",
          "args": [
            "data",
            "&iid",
            "&uuid"
          ],
          "line": 5245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to get medium uuid, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 5240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetId",
          "args": [
            "newMedium",
            "&iid"
          ],
          "line": 5238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "newHardDisk"
          ],
          "line": 5235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "progress"
          ],
          "line": 5229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Error while creating diff storage, rc=%08x\")",
            "resultCode.uResultCode"
          ],
          "line": 5224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RC_FAILED",
          "args": [
            "resultCode"
          ],
          "line": 5223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.GetResultCode",
          "args": [
            "progress",
            "&resultCode"
          ],
          "line": 5222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.WaitForCompletion",
          "args": [
            "progress",
            "-1"
          ],
          "line": 5221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.CreateDiffStorage",
          "args": [
            "medium",
            "newMedium",
            "1",
            "tab",
            "&progress"
          ],
          "line": 5219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to create HardDisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 5210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "formatUtf16"
          ],
          "line": 5208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "newLocation"
          ],
          "line": 5207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.CreateHardDisk",
          "args": [
            "data->vboxObj",
            "formatUtf16",
            "newLocation",
            "&newMedium"
          ],
          "line": 5203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "newLocationUtf8",
            "&newLocation"
          ],
          "line": 5202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"VDI\"",
            "&formatUtf16"
          ],
          "line": 5198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&parentiid"
          ],
          "line": 5197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIID.vboxIIDToUtf8",
          "args": [
            "data",
            "&parentiid",
            "&parentUuid"
          ],
          "line": 5196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to get hardDisk Id, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 5191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetId",
          "args": [
            "medium",
            "&parentiid"
          ],
          "line": 5189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "locationUtf16"
          ],
          "line": 5187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "locationUtf16"
          ],
          "line": 5184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to open HardDisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 5181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.OpenMedium",
          "args": [
            "data->vboxObj",
            "locationUtf16",
            "DeviceType_HardDisk",
            "AccessMode_ReadWrite",
            "&medium"
          ],
          "line": 5175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "def->parent.dom->disks[it]->src->path",
            "&locationUtf16"
          ],
          "line": 5174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&parentiid"
          ],
          "line": 5173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 5172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to close HardDisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 5150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.Close",
          "args": [
            "medium"
          ],
          "line": 5148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 5145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "snapshotMachineDesc->storageController"
          ],
          "line": 5140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to find UUID %s\")",
            "searchResultTab[it]"
          ],
          "line": 5132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disk"
          ],
          "line": 5120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to add hard disk to the media registry\")"
          ],
          "line": 5118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&parentiid"
          ],
          "line": 5114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIID.vboxIIDToUtf8",
          "args": [
            "data",
            "&parentiid",
            "&parentUuid"
          ],
          "line": 5113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetId",
          "args": [
            "parentDisk",
            "&parentiid"
          ],
          "line": 5112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disk"
          ],
          "line": 5108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get disk parent\")"
          ],
          "line": 5106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetParent",
          "args": [
            "medium",
            "&parentDisk"
          ],
          "line": 5104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 5102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIID.vboxIIDToUtf8",
          "args": [
            "data",
            "&iid",
            "&uuid"
          ],
          "line": 5100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disk"
          ],
          "line": 5097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get disk uuid\")"
          ],
          "line": 5095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetId",
          "args": [
            "medium",
            "&iid"
          ],
          "line": 5093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "formatUtf16"
          ],
          "line": 5089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "formatUtf16",
            "&format"
          ],
          "line": 5087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "disk"
          ],
          "line": 5083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get disk format\")"
          ],
          "line": 5081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetFormat",
          "args": [
            "medium",
            "&formatUtf16"
          ],
          "line": 5079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "disk"
          ],
          "line": 5076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "locationUtf16"
          ],
          "line": 5074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to open HardDisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 5069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.OpenMedium",
          "args": [
            "data->vboxObj",
            "locationUtf16",
            "DeviceType_HardDisk",
            "AccessMode_ReadWrite",
            "&medium"
          ],
          "line": 5063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "def->disks[it].src->path",
            "&locationUtf16"
          ],
          "line": 5062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&parentiid"
          ],
          "line": 5061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 5060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to open HardDisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 5036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 5035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "locationUtf16"
          ],
          "line": 5034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.OpenMedium",
          "args": [
            "data->vboxObj",
            "locationUtf16",
            "DeviceType_HardDisk",
            "AccessMode_ReadWrite",
            "&medium"
          ],
          "line": 5029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "hardDiskToOpen[jt]->location",
            "&locationUtf16"
          ],
          "line": 5027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to add the snapshot to the machine description\")"
          ],
          "line": 4996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfAddSnapshotToXmlMachine",
          "args": [
            "newSnapshotPtr",
            "snapshotMachineDesc",
            "def->parent.parent_name"
          ],
          "line": 4995
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfAddSnapshotToXmlMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "748-796",
          "snippet": "int\nvirVBoxSnapshotConfAddSnapshotToXmlMachine(virVBoxSnapshotConfSnapshotPtr snapshot,\n                                           virVBoxSnapshotConfMachinePtr machine,\n                                           const char *snapshotParentName)\n{\n    virVBoxSnapshotConfSnapshotPtr parentSnapshot = NULL;\n\n    if (snapshot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Snapshot is Null\"));\n        return -1;\n    }\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Machine is Null\"));\n        return -1;\n    }\n\n    /* If parent is NULL and the machine has no snapshot yet,\n     * it means that the added snapshot is the first snapshot */\n    if (snapshotParentName == NULL) {\n        if (machine->snapshot != NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to add this snapshot, there is already a snapshot \"\n                             \"linked to the machine\"));\n            return -1;\n        }\n        machine->snapshot = snapshot;\n        return 0;\n    } else {\n        if (machine->snapshot == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"The machine has no snapshot and it should have it\"));\n            return -1;\n        }\n        parentSnapshot = virVBoxSnapshotConfSnapshotByName(machine->snapshot, snapshotParentName);\n        if (parentSnapshot == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to find the snapshot %s\"), snapshotParentName);\n            return -1;\n        }\n        if (VIR_EXPAND_N(parentSnapshot->children, parentSnapshot->nchildren, 1) < 0)\n            return -1;\n\n        parentSnapshot->children[parentSnapshot->nchildren - 1] = snapshot;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfAddSnapshotToXmlMachine(virVBoxSnapshotConfSnapshotPtr snapshot,\n                                           virVBoxSnapshotConfMachinePtr machine,\n                                           const char *snapshotParentName)\n{\n    virVBoxSnapshotConfSnapshotPtr parentSnapshot = NULL;\n\n    if (snapshot == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Snapshot is Null\"));\n        return -1;\n    }\n    if (machine == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Machine is Null\"));\n        return -1;\n    }\n\n    /* If parent is NULL and the machine has no snapshot yet,\n     * it means that the added snapshot is the first snapshot */\n    if (snapshotParentName == NULL) {\n        if (machine->snapshot != NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to add this snapshot, there is already a snapshot \"\n                             \"linked to the machine\"));\n            return -1;\n        }\n        machine->snapshot = snapshot;\n        return 0;\n    } else {\n        if (machine->snapshot == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"The machine has no snapshot and it should have it\"));\n            return -1;\n        }\n        parentSnapshot = virVBoxSnapshotConfSnapshotByName(machine->snapshot, snapshotParentName);\n        if (parentSnapshot == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to find the snapshot %s\"), snapshotParentName);\n            return -1;\n        }\n        if (VIR_EXPAND_N(parentSnapshot->children, parentSnapshot->nchildren, 1) < 0)\n            return -1;\n\n        parentSnapshot->children[parentSnapshot->nchildren - 1] = snapshot;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 4993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "newSnapshotPtr->storageController"
          ],
          "line": 4988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfHardDiskUuidByLocation",
          "args": [
            "snapshotMachineDesc",
            "location"
          ],
          "line": 4972
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfHardDiskUuidByLocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "1374-1388",
          "snippet": "const char *\nvirVBoxSnapshotConfHardDiskUuidByLocation(virVBoxSnapshotConfMachinePtr machine,\n                                          const char *location)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[i], location);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL)\n        return NULL;\n    return hardDisk->uuid;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nconst char *\nvirVBoxSnapshotConfHardDiskUuidByLocation(virVBoxSnapshotConfMachinePtr machine,\n                                          const char *location)\n{\n    size_t i = 0;\n    virVBoxSnapshotConfHardDiskPtr hardDisk = NULL;\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        hardDisk = virVBoxSnapshotConfHardDiskByLocation(machine->mediaRegistry->disks[i], location);\n        if (hardDisk != NULL)\n            break;\n    }\n    if (hardDisk == NULL)\n        return NULL;\n    return hardDisk->uuid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTimeStringThen",
          "args": [
            "def->parent.creationTime * 1000"
          ],
          "line": 4953
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeStringThen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "285-300",
          "snippet": "char *virTimeStringThen(unsigned long long when)\n{\n    char *ret;\n\n    if (VIR_ALLOC_N(ret, VIR_TIME_STRING_BUFLEN) < 0)\n        return NULL;\n\n    if (virTimeStringThenRaw(when, ret) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format time\"));\n        VIR_FREE(ret);\n        return NULL;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virTimeStringThen(unsigned long long when)\n{\n    char *ret;\n\n    if (VIR_ALLOC_N(ret, VIR_TIME_STRING_BUFLEN) < 0)\n        return NULL;\n\n    if (virTimeStringThenRaw(when, ret) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format time\"));\n        VIR_FREE(ret);\n        return NULL;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"New snapshot UUID: %s\"",
            "newSnapshotPtr->uuid"
          ],
          "line": 4950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "snapshotUuid",
            "uuidtmp"
          ],
          "line": 4947
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDGenerate",
          "args": [
            "snapshotUuid"
          ],
          "line": 4943
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDGenerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "50-79",
          "snippet": "int\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "newSnapshotPtr"
          ],
          "line": 4940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to close recursively all disks\")"
          ],
          "line": 4932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxCloseDisksRecursively",
          "args": [
            "dom",
            "snapshotMachineDesc->mediaRegistry->disks[it]->location"
          ],
          "line": 4931
        },
        "resolved": true,
        "details": {
          "function_name": "vboxCloseDisksRecursively",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "4452-4520",
          "snippet": "static int vboxCloseDisksRecursively(virDomainPtr dom, char *location)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    nsresult rc;\n    size_t i = 0;\n    PRUnichar *locationUtf = NULL;\n    IMedium *medium = NULL;\n    IMedium **children = NULL;\n    PRUint32 childrenSize = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    VBOX_UTF8_TO_UTF16(location, &locationUtf);\n    rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                          locationUtf,\n                                          DeviceType_HardDisk,\n                                          AccessMode_ReadWrite,\n                                          &medium);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to open HardDisk, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n    rc = gVBoxAPI.UIMedium.GetChildren(medium, &childrenSize, &children);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get disk children\"));\n        goto cleanup;\n    }\n    for (i = 0; i < childrenSize; i++) {\n        IMedium *childMedium = children[i];\n        if (childMedium) {\n            PRUnichar *childLocationUtf = NULL;\n            char *childLocation = NULL;\n            rc = gVBoxAPI.UIMedium.GetLocation(childMedium, &childLocationUtf);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get childMedium location\"));\n                goto cleanup;\n            }\n            VBOX_UTF16_TO_UTF8(childLocationUtf, &childLocation);\n            VBOX_UTF16_FREE(childLocationUtf);\n            if (vboxCloseDisksRecursively(dom, childLocation) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to close disk children\"));\n                goto cleanup;\n            }\n            VIR_FREE(childLocation);\n        }\n    }\n    rc = gVBoxAPI.UIMedium.Close(medium);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to close HardDisk, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VBOX_UTF16_FREE(locationUtf);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxCloseDisksRecursively(virDomainPtr dom, char *location)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    nsresult rc;\n    size_t i = 0;\n    PRUnichar *locationUtf = NULL;\n    IMedium *medium = NULL;\n    IMedium **children = NULL;\n    PRUint32 childrenSize = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    VBOX_UTF8_TO_UTF16(location, &locationUtf);\n    rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                          locationUtf,\n                                          DeviceType_HardDisk,\n                                          AccessMode_ReadWrite,\n                                          &medium);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to open HardDisk, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n    rc = gVBoxAPI.UIMedium.GetChildren(medium, &childrenSize, &children);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get disk children\"));\n        goto cleanup;\n    }\n    for (i = 0; i < childrenSize; i++) {\n        IMedium *childMedium = children[i];\n        if (childMedium) {\n            PRUnichar *childLocationUtf = NULL;\n            char *childLocation = NULL;\n            rc = gVBoxAPI.UIMedium.GetLocation(childMedium, &childLocationUtf);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get childMedium location\"));\n                goto cleanup;\n            }\n            VBOX_UTF16_TO_UTF8(childLocationUtf, &childLocation);\n            VBOX_UTF16_FREE(childLocationUtf);\n            if (vboxCloseDisksRecursively(dom, childLocation) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to close disk children\"));\n                goto cleanup;\n            }\n            VIR_FREE(childLocation);\n        }\n    }\n    rc = gVBoxAPI.UIMedium.Close(medium);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to close HardDisk, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VBOX_UTF16_FREE(locationUtf);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "locationUtf8"
          ],
          "line": 4926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "gVBoxAPI.UIMedium.Close(medium)"
          ],
          "line": 4924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.Close",
          "args": [
            "medium"
          ],
          "line": 4924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "progress"
          ],
          "line": 4914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "locationUtf8"
          ],
          "line": 4911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Error while closing medium, rc=%08x\")",
            "resultCode.uResultCode"
          ],
          "line": 4908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RC_FAILED",
          "args": [
            "resultCode"
          ],
          "line": 4907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.GetResultCode",
          "args": [
            "progress",
            "&resultCode"
          ],
          "line": 4906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.WaitForCompletion",
          "args": [
            "progress",
            "-1"
          ],
          "line": 4905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "locationUtf8"
          ],
          "line": 4902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to delete medium, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 4899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.DeleteStorage",
          "args": [
            "medium",
            "&progress"
          ],
          "line": 4897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "locationUtf8",
            "\"fake\""
          ],
          "line": 4893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "locationUtf16"
          ],
          "line": 4892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "locationUtf16",
            "&locationUtf8"
          ],
          "line": 4891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get medium location\")"
          ],
          "line": 4887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetLocation",
          "args": [
            "medium",
            "&locationUtf16"
          ],
          "line": 4885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 4872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to unregister machine, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 4867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.Unregister",
          "args": [
            "machine",
            "CleanupMode_DetachAllReturnHardDisksOnly",
            "&aMediaSize",
            "&aMedia"
          ],
          "line": 4862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "readOnlyDisk"
          ],
          "line": 4856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to add hard disk to media registry\")"
          ],
          "line": 4854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "parentUuid"
          ],
          "line": 4844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid"
          ],
          "line": 4843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "readOnlyDisk"
          ],
          "line": 4842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "parentUuid"
          ],
          "line": 4838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid"
          ],
          "line": 4837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to close HardDisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 4834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.Close",
          "args": [
            "readOnlyMedium"
          ],
          "line": 4832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&parentiid"
          ],
          "line": 4830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIID.vboxIIDToUtf8",
          "args": [
            "data",
            "&parentiid",
            "&parentUuid"
          ],
          "line": 4829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid"
          ],
          "line": 4826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to get hard disk id, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 4823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetId",
          "args": [
            "parentReadOnlyMedium",
            "&parentiid"
          ],
          "line": 4821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid"
          ],
          "line": 4817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get parent hard disk\")"
          ],
          "line": 4815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetParent",
          "args": [
            "readOnlyMedium",
            "&parentReadOnlyMedium"
          ],
          "line": 4813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "formatUtf"
          ],
          "line": 4809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "formatUtf",
            "&format"
          ],
          "line": 4808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uuid"
          ],
          "line": 4805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get hard disk format\")"
          ],
          "line": 4803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetFormat",
          "args": [
            "readOnlyMedium",
            "&formatUtf"
          ],
          "line": 4801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 4799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIID.vboxIIDToUtf8",
          "args": [
            "data",
            "&iid",
            "&uuid"
          ],
          "line": 4798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get hard disk id\")"
          ],
          "line": 4794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetId",
          "args": [
            "readOnlyMedium",
            "&iid"
          ],
          "line": 4792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "locationUtf"
          ],
          "line": 4790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "locationUtf"
          ],
          "line": 4787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to open HardDisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 4784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.OpenMedium",
          "args": [
            "data->vboxObj",
            "locationUtf",
            "DeviceType_HardDisk",
            "AccessMode_ReadWrite",
            "&readOnlyMedium"
          ],
          "line": 4778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "def->parent.dom->disks[it]->src->path",
            "&locationUtf"
          ],
          "line": 4777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to know if disk is in media registry\")"
          ],
          "line": 4769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfDiskIsInMediaRegistry",
          "args": [
            "snapshotMachineDesc",
            "def->parent.dom->disks[it]->src->path"
          ],
          "line": 4766
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfDiskIsInMediaRegistry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "1483-1523",
          "snippet": "int\nvirVBoxSnapshotConfDiskIsInMediaRegistry(virVBoxSnapshotConfMachinePtr machine,\n                                         const char *location)\n{\n    int ret = -1;\n    size_t i = 0;\n    size_t j = 0;\n    size_t tempSize = 0;\n    size_t diskSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *tempList = NULL;\n    virVBoxSnapshotConfHardDiskPtr *diskList = NULL;\n\n    if (VIR_ALLOC_N(diskList, 0) < 0)\n        return -1;\n\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        tempSize = virVBoxSnapshotConfAllChildren(machine->mediaRegistry->disks[i], &tempList);\n        if (VIR_EXPAND_N(diskList, diskSize, tempSize) < 0)\n            goto cleanup;\n\n        for (j = 0; j < tempSize; j++)\n            diskList[diskSize - tempSize + j] = tempList[j];\n\n        VIR_FREE(tempList);\n    }\n\n    for (i = 0; i < diskSize; i++) {\n        if (STREQ(diskList[i]->location, location)) {\n            ret = 1;\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(diskList);\n    VIR_FREE(tempList);\n\n    return ret;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfDiskIsInMediaRegistry(virVBoxSnapshotConfMachinePtr machine,\n                                         const char *location)\n{\n    int ret = -1;\n    size_t i = 0;\n    size_t j = 0;\n    size_t tempSize = 0;\n    size_t diskSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *tempList = NULL;\n    virVBoxSnapshotConfHardDiskPtr *diskList = NULL;\n\n    if (VIR_ALLOC_N(diskList, 0) < 0)\n        return -1;\n\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        tempSize = virVBoxSnapshotConfAllChildren(machine->mediaRegistry->disks[i], &tempList);\n        if (VIR_EXPAND_N(diskList, diskSize, tempSize) < 0)\n            goto cleanup;\n\n        for (j = 0; j < tempSize; j++)\n            diskList[diskSize - tempSize + j] = tempList[j];\n\n        VIR_FREE(tempList);\n    }\n\n    for (i = 0; i < diskSize; i++) {\n        if (STREQ(diskList[i]->location, location)) {\n            ret = 1;\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(diskList);\n    VIR_FREE(tempList);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&parentiid"
          ],
          "line": 4765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 4764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to delete file %s\")",
            "currentSnapshotXmlFilePath"
          ],
          "line": 4743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "currentSnapshotXmlFilePath"
          ],
          "line": 4742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to close HardDisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 4732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.Close",
          "args": [
            "readWriteMedium"
          ],
          "line": 4730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "readWriteDisk"
          ],
          "line": 4727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to add hard disk to media Registry\")"
          ],
          "line": 4725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "readWriteDisk"
          ],
          "line": 4718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "formatUtf"
          ],
          "line": 4703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "readWriteDisk"
          ],
          "line": 4702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "formatUtf"
          ],
          "line": 4700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "formatUtf",
            "&format"
          ],
          "line": 4699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get the read write medium format\")"
          ],
          "line": 4695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetFormat",
          "args": [
            "readWriteMedium",
            "&formatUtf"
          ],
          "line": 4693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 4691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIID.vboxIIDToUtf8",
          "args": [
            "data",
            "&iid",
            "&uuid"
          ],
          "line": 4690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get the read write medium id\")"
          ],
          "line": 4686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetId",
          "args": [
            "readWriteMedium",
            "&iid"
          ],
          "line": 4684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "locationUtf"
          ],
          "line": 4682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "locationUtf"
          ],
          "line": 4679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to open HardDisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 4676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.OpenMedium",
          "args": [
            "data->vboxObj",
            "locationUtf",
            "DeviceType_HardDisk",
            "AccessMode_ReadWrite",
            "&readWriteMedium"
          ],
          "line": 4670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "realReadWriteDisksPath[it]",
            "&locationUtf"
          ],
          "line": 4669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 4668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"The read only disk number must be greater or equal to the \"\n                           \" read write disk number\")"
          ],
          "line": 4653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfGetRODisksPathsFromLibvirtXML",
          "args": [
            "currentSnapshotXmlFilePath",
            "&realReadOnlyDisksPath"
          ],
          "line": 4648
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfGetRODisksPathsFromLibvirtXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "1314-1368",
          "snippet": "int\nvirVBoxSnapshotConfGetRODisksPathsFromLibvirtXML(const char *filePath,\n                                                 char ***roDisksPath)\n{\n    int result = -1;\n    size_t i = 0;\n    char **ret = NULL;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr xPathContext = NULL;\n    xmlNodePtr *nodes = NULL;\n    int nodeSize = 0;\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filePath is null\"));\n        goto cleanup;\n    }\n    xml = virXMLParse(filePath, NULL, NULL);\n    if (xml == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to parse the xml\"));\n        goto cleanup;\n    }\n\n    if (!(xPathContext = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    xPathContext->node = xmlDocGetRootElement(xml);\n    if ((nodeSize = virXPathNodeSet(\"/domainsnapshot/domain/devices/disk\",\n                                    xPathContext,\n                                    &nodes)) < 0)\n        goto cleanup;\n    if (VIR_ALLOC_N(ret, nodeSize) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nodeSize; i++) {\n        xmlNodePtr node = nodes[i];\n        xPathContext->node = node;\n        xmlNodePtr sourceNode = virXPathNode(\"./source\", xPathContext);\n        if (sourceNode)\n            ret[i] = virXMLPropString(sourceNode, \"file\");\n    }\n    result = 0;\n\n cleanup:\n    xmlFreeDoc(xml);\n    xmlXPathFreeContext(xPathContext);\n    if (result < 0) {\n        virStringListFree(ret);\n        nodeSize = -1;\n    } else {\n        *roDisksPath = ret;\n    }\n    VIR_FREE(nodes);\n    return nodeSize;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfGetRODisksPathsFromLibvirtXML(const char *filePath,\n                                                 char ***roDisksPath)\n{\n    int result = -1;\n    size_t i = 0;\n    char **ret = NULL;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr xPathContext = NULL;\n    xmlNodePtr *nodes = NULL;\n    int nodeSize = 0;\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filePath is null\"));\n        goto cleanup;\n    }\n    xml = virXMLParse(filePath, NULL, NULL);\n    if (xml == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to parse the xml\"));\n        goto cleanup;\n    }\n\n    if (!(xPathContext = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    xPathContext->node = xmlDocGetRootElement(xml);\n    if ((nodeSize = virXPathNodeSet(\"/domainsnapshot/domain/devices/disk\",\n                                    xPathContext,\n                                    &nodes)) < 0)\n        goto cleanup;\n    if (VIR_ALLOC_N(ret, nodeSize) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nodeSize; i++) {\n        xmlNodePtr node = nodes[i];\n        xPathContext->node = node;\n        xmlNodePtr sourceNode = virXPathNode(\"./source\", xPathContext);\n        if (sourceNode)\n            ret[i] = virXMLPropString(sourceNode, \"file\");\n    }\n    result = 0;\n\n cleanup:\n    xmlFreeDoc(xml);\n    xmlXPathFreeContext(xPathContext);\n    if (result < 0) {\n        virStringListFree(ret);\n        nodeSize = -1;\n    } else {\n        *roDisksPath = ret;\n    }\n    VIR_FREE(nodes);\n    return nodeSize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfGetRWDisksPathsFromLibvirtXML",
          "args": [
            "currentSnapshotXmlFilePath",
            "&realReadWriteDisksPath"
          ],
          "line": 4646
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfGetRWDisksPathsFromLibvirtXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "1252-1307",
          "snippet": "int\nvirVBoxSnapshotConfGetRWDisksPathsFromLibvirtXML(const char *filePath,\n                                                 char ***rwDisksPath)\n{\n    int result = -1;\n    size_t i = 0;\n    char **ret = NULL;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr xPathContext = NULL;\n    xmlNodePtr *nodes = NULL;\n    int nodeSize = 0;\n    *rwDisksPath = NULL;\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filePath is null\"));\n        goto cleanup;\n    }\n    xml = virXMLParse(filePath, NULL, NULL);\n    if (xml == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to parse the xml\"));\n        goto cleanup;\n    }\n\n    if (!(xPathContext = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    xPathContext->node = xmlDocGetRootElement(xml);\n    if ((nodeSize = virXPathNodeSet(\"/domainsnapshot/disks/disk\",\n                                    xPathContext, &nodes)) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(ret, nodeSize) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nodeSize; i++) {\n        xmlNodePtr node = nodes[i];\n        xPathContext->node = node;\n        xmlNodePtr sourceNode = virXPathNode(\"./source\", xPathContext);\n        if (sourceNode)\n            ret[i] = virXMLPropString(sourceNode, \"file\");\n    }\n    result = 0;\n\n cleanup:\n    xmlFreeDoc(xml);\n    xmlXPathFreeContext(xPathContext);\n    if (result < 0) {\n        virStringListFree(ret);\n        nodeSize = -1;\n    } else {\n        *rwDisksPath = ret;\n    }\n    VIR_FREE(nodes);\n    return nodeSize;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfGetRWDisksPathsFromLibvirtXML(const char *filePath,\n                                                 char ***rwDisksPath)\n{\n    int result = -1;\n    size_t i = 0;\n    char **ret = NULL;\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr xPathContext = NULL;\n    xmlNodePtr *nodes = NULL;\n    int nodeSize = 0;\n    *rwDisksPath = NULL;\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"filePath is null\"));\n        goto cleanup;\n    }\n    xml = virXMLParse(filePath, NULL, NULL);\n    if (xml == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to parse the xml\"));\n        goto cleanup;\n    }\n\n    if (!(xPathContext = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    xPathContext->node = xmlDocGetRootElement(xml);\n    if ((nodeSize = virXPathNodeSet(\"/domainsnapshot/disks/disk\",\n                                    xPathContext, &nodes)) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(ret, nodeSize) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nodeSize; i++) {\n        xmlNodePtr node = nodes[i];\n        xPathContext->node = node;\n        xmlNodePtr sourceNode = virXPathNode(\"./source\", xPathContext);\n        if (sourceNode)\n            ret[i] = virXMLPropString(sourceNode, \"file\");\n    }\n    result = 0;\n\n cleanup:\n    xmlFreeDoc(xml);\n    xmlXPathFreeContext(xPathContext);\n    if (result < 0) {\n        virStringListFree(ret);\n        nodeSize = -1;\n    } else {\n        *rwDisksPath = ret;\n    }\n    VIR_FREE(nodes);\n    return nodeSize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to remove Fake Disks\")"
          ],
          "line": 4642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfRemoveFakeDisks",
          "args": [
            "snapshotMachineDesc"
          ],
          "line": 4641
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfRemoveFakeDisks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "1432-1475",
          "snippet": "int\nvirVBoxSnapshotConfRemoveFakeDisks(virVBoxSnapshotConfMachinePtr machine)\n{\n    int ret = -1;\n    size_t i = 0;\n    size_t j = 0;\n    size_t tempSize = 0;\n    size_t diskSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *tempList = NULL;\n    virVBoxSnapshotConfHardDiskPtr *diskList = NULL;\n\n    if (VIR_ALLOC_N(diskList, 0) < 0)\n        return -1;\n\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        tempSize = virVBoxSnapshotConfAllChildren(machine->mediaRegistry->disks[i], &tempList);\n        if (VIR_EXPAND_N(diskList, diskSize, tempSize) < 0)\n            goto cleanup;\n\n        for (j = 0; j < tempSize; j++)\n            diskList[diskSize - tempSize + j] = tempList[j];\n\n        VIR_FREE(tempList);\n    }\n\n    for (i = 0; i < diskSize; i++) {\n        if (strstr(diskList[i]->location, \"fake\") != NULL) {\n            if (virVBoxSnapshotConfRemoveHardDisk(machine->mediaRegistry, diskList[i]->uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to remove hard disk %s from media registry\"),\n                               diskList[i]->location);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(diskList);\n    VIR_FREE(tempList);\n\n    return ret;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nint\nvirVBoxSnapshotConfRemoveFakeDisks(virVBoxSnapshotConfMachinePtr machine)\n{\n    int ret = -1;\n    size_t i = 0;\n    size_t j = 0;\n    size_t tempSize = 0;\n    size_t diskSize = 0;\n    virVBoxSnapshotConfHardDiskPtr *tempList = NULL;\n    virVBoxSnapshotConfHardDiskPtr *diskList = NULL;\n\n    if (VIR_ALLOC_N(diskList, 0) < 0)\n        return -1;\n\n    for (i = 0; i < machine->mediaRegistry->ndisks; i++) {\n        tempSize = virVBoxSnapshotConfAllChildren(machine->mediaRegistry->disks[i], &tempList);\n        if (VIR_EXPAND_N(diskList, diskSize, tempSize) < 0)\n            goto cleanup;\n\n        for (j = 0; j < tempSize; j++)\n            diskList[diskSize - tempSize + j] = tempList[j];\n\n        VIR_FREE(tempList);\n    }\n\n    for (i = 0; i < diskSize; i++) {\n        if (strstr(diskList[i]->location, \"fake\") != NULL) {\n            if (virVBoxSnapshotConfRemoveHardDisk(machine->mediaRegistry, diskList[i]->uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to remove hard disk %s from media registry\"),\n                               diskList[i]->location);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(diskList);\n    VIR_FREE(tempList);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "currentSnapshotXmlFilePath"
          ],
          "line": 4632
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot create a vboxSnapshotXmlPtr\")"
          ],
          "line": 4625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVBoxSnapshotConfLoadVboxFile",
          "args": [
            "settingsFilePath_Utf8",
            "machineLocationPath"
          ],
          "line": 4623
        },
        "resolved": true,
        "details": {
          "function_name": "virVBoxSnapshotConfLoadVboxFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_snapshot_conf.c",
          "lines": "580-739",
          "snippet": "virVBoxSnapshotConfMachinePtr\nvirVBoxSnapshotConfLoadVboxFile(const char *filePath,\n                                const char *machineLocation)\n{\n    int ret = -1;\n    virVBoxSnapshotConfMachinePtr machineDescription = NULL;\n    xmlDocPtr xml = NULL;\n    xmlNodePtr machineNode = NULL;\n    xmlNodePtr cur = NULL;\n    xmlXPathContextPtr xPathContext = NULL;\n    char *currentStateModifiedString = NULL;\n\n    char **searchResultTab = NULL;\n    ssize_t searchResultSize = 0;\n    char *currentSnapshotAttribute = NULL;\n\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Filepath is Null\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC(machineDescription) < 0)\n        goto cleanup;\n\n    xml = virXMLParse(filePath, NULL, NULL);\n    if (xml == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to parse the xml\"));\n        goto cleanup;\n    }\n    if (!(xPathContext = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    if (xmlXPathRegisterNs(xPathContext,\n                           BAD_CAST \"vbox\",\n                           BAD_CAST \"http://www.innotek.de/VirtualBox-settings\") < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Failed to register xml namespace \"\n                         \"'http://www.innotek.de/VirtualBox-settings'\"));\n        goto cleanup;\n    }\n\n    /* Retrieve MachineNode */\n    cur = xmlDocGetRootElement(xml);\n    xPathContext->node = cur;\n    machineNode = virXPathNode(\"./vbox:Machine\", xPathContext);\n    if (machineNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <VirtualBox> <Machine> node\"));\n        goto cleanup;\n    }\n\n    machineDescription->uuid = virXMLPropString(machineNode, \"uuid\");\n    if (machineDescription->uuid == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    machineDescription->name = virXMLPropString(machineNode, \"name\");\n    if (machineDescription->name == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'name' attribute\"));\n        goto cleanup;\n    }\n\n    currentSnapshotAttribute = virXMLPropString(machineNode, \"currentSnapshot\");\n    if (currentSnapshotAttribute != NULL) {\n        /* we use virStringSearch because the uuid is between brackets */\n        searchResultSize = virStringSearch(currentSnapshotAttribute,\n                                           VBOX_UUID_REGEX,\n                                           1,\n                                           &searchResultTab);\n        if (searchResultSize != 1) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Cannot parse <Machine> 'currentSnapshot' attribute\"));\n            goto cleanup;\n        }\n        machineDescription->currentSnapshot = g_strdup(searchResultTab[0]);\n    }\n\n    machineDescription->snapshotFolder = virXMLPropString(machineNode, \"snapshotFolder\");\n    if (machineDescription->snapshotFolder == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'snapshotFolder' attribute\"));\n        goto cleanup;\n    }\n\n    currentStateModifiedString = virXMLPropString(machineNode, \"currentStateModified\");\n    if (currentStateModifiedString != NULL && STREQ(currentStateModifiedString, \"true\")) {\n        machineDescription->currentStateModified = 1;\n    } else {\n        machineDescription->currentStateModified = 0;\n    }\n    machineDescription->lastStateChange = virXMLPropString(machineNode, \"lastStateChange\");\n    if (machineDescription->lastStateChange == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'lastStateChange' attribute\"));\n        goto cleanup;\n    }\n\n    xPathContext->node = machineNode;\n    cur = virXPathNode(\"./vbox:Hardware\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <Hardware> node\"));\n        goto cleanup;\n    }\n    machineDescription->hardware = virXMLNodeToString(xml, cur);\n\n    cur = virXPathNode(\"./vbox:ExtraData\", xPathContext);\n    if (cur)\n        machineDescription->extraData = virXMLNodeToString(xml, cur);\n\n    cur = virXPathNode(\"./vbox:StorageControllers\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <StorageControllers> node\"));\n        goto cleanup;\n    }\n    machineDescription->storageController = virXMLNodeToString(xml, cur);\n\n    /* retrieve mediaRegistry */\n    cur = virXPathNode(\"./vbox:MediaRegistry\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <MediaRegistry> node\"));\n        goto cleanup;\n    }\n    machineDescription->mediaRegistry = virVBoxSnapshotConfRetrieveMediaRegistry(cur, xPathContext, machineLocation);\n    if (machineDescription->mediaRegistry == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to create media registry\"));\n        goto cleanup;\n    }\n\n    /* retrieve snapshot */\n    xPathContext->node = machineNode;\n    cur = virXPathNode(\"./vbox:Snapshot\", xPathContext);\n    if (cur != NULL) {\n        machineDescription->snapshot = virVBoxSnapshotConfRetrieveSnapshot(cur, xPathContext);\n        if (!machineDescription->snapshot)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    xmlXPathFreeContext(xPathContext);\n    xmlFreeDoc(xml);\n\n    VIR_FREE(currentStateModifiedString);\n    VIR_FREE(currentSnapshotAttribute);\n    virStringListFree(searchResultTab);\n    if (ret < 0) {\n        virVBoxSnapshotConfMachineFree(machineDescription);\n        machineDescription = NULL;\n    }\n    return machineDescription;\n}",
          "includes": [
            "#include <libxml/xpathInternals.h>",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <libxml/xpathInternals.h>\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"vbox_snapshot_conf.h\"\n#include <config.h>\n\nvirVBoxSnapshotConfMachinePtr\nvirVBoxSnapshotConfLoadVboxFile(const char *filePath,\n                                const char *machineLocation)\n{\n    int ret = -1;\n    virVBoxSnapshotConfMachinePtr machineDescription = NULL;\n    xmlDocPtr xml = NULL;\n    xmlNodePtr machineNode = NULL;\n    xmlNodePtr cur = NULL;\n    xmlXPathContextPtr xPathContext = NULL;\n    char *currentStateModifiedString = NULL;\n\n    char **searchResultTab = NULL;\n    ssize_t searchResultSize = 0;\n    char *currentSnapshotAttribute = NULL;\n\n    if (filePath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Filepath is Null\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC(machineDescription) < 0)\n        goto cleanup;\n\n    xml = virXMLParse(filePath, NULL, NULL);\n    if (xml == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to parse the xml\"));\n        goto cleanup;\n    }\n    if (!(xPathContext = virXMLXPathContextNew(xml)))\n        goto cleanup;\n\n    if (xmlXPathRegisterNs(xPathContext,\n                           BAD_CAST \"vbox\",\n                           BAD_CAST \"http://www.innotek.de/VirtualBox-settings\") < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Failed to register xml namespace \"\n                         \"'http://www.innotek.de/VirtualBox-settings'\"));\n        goto cleanup;\n    }\n\n    /* Retrieve MachineNode */\n    cur = xmlDocGetRootElement(xml);\n    xPathContext->node = cur;\n    machineNode = virXPathNode(\"./vbox:Machine\", xPathContext);\n    if (machineNode == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <VirtualBox> <Machine> node\"));\n        goto cleanup;\n    }\n\n    machineDescription->uuid = virXMLPropString(machineNode, \"uuid\");\n    if (machineDescription->uuid == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'uuid' attribute\"));\n        goto cleanup;\n    }\n    machineDescription->name = virXMLPropString(machineNode, \"name\");\n    if (machineDescription->name == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'name' attribute\"));\n        goto cleanup;\n    }\n\n    currentSnapshotAttribute = virXMLPropString(machineNode, \"currentSnapshot\");\n    if (currentSnapshotAttribute != NULL) {\n        /* we use virStringSearch because the uuid is between brackets */\n        searchResultSize = virStringSearch(currentSnapshotAttribute,\n                                           VBOX_UUID_REGEX,\n                                           1,\n                                           &searchResultTab);\n        if (searchResultSize != 1) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Cannot parse <Machine> 'currentSnapshot' attribute\"));\n            goto cleanup;\n        }\n        machineDescription->currentSnapshot = g_strdup(searchResultTab[0]);\n    }\n\n    machineDescription->snapshotFolder = virXMLPropString(machineNode, \"snapshotFolder\");\n    if (machineDescription->snapshotFolder == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'snapshotFolder' attribute\"));\n        goto cleanup;\n    }\n\n    currentStateModifiedString = virXMLPropString(machineNode, \"currentStateModified\");\n    if (currentStateModifiedString != NULL && STREQ(currentStateModifiedString, \"true\")) {\n        machineDescription->currentStateModified = 1;\n    } else {\n        machineDescription->currentStateModified = 0;\n    }\n    machineDescription->lastStateChange = virXMLPropString(machineNode, \"lastStateChange\");\n    if (machineDescription->lastStateChange == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> 'lastStateChange' attribute\"));\n        goto cleanup;\n    }\n\n    xPathContext->node = machineNode;\n    cur = virXPathNode(\"./vbox:Hardware\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <Hardware> node\"));\n        goto cleanup;\n    }\n    machineDescription->hardware = virXMLNodeToString(xml, cur);\n\n    cur = virXPathNode(\"./vbox:ExtraData\", xPathContext);\n    if (cur)\n        machineDescription->extraData = virXMLNodeToString(xml, cur);\n\n    cur = virXPathNode(\"./vbox:StorageControllers\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <StorageControllers> node\"));\n        goto cleanup;\n    }\n    machineDescription->storageController = virXMLNodeToString(xml, cur);\n\n    /* retrieve mediaRegistry */\n    cur = virXPathNode(\"./vbox:MediaRegistry\", xPathContext);\n    if (cur == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Cannot parse <Machine> <MediaRegistry> node\"));\n        goto cleanup;\n    }\n    machineDescription->mediaRegistry = virVBoxSnapshotConfRetrieveMediaRegistry(cur, xPathContext, machineLocation);\n    if (machineDescription->mediaRegistry == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"Unable to create media registry\"));\n        goto cleanup;\n    }\n\n    /* retrieve snapshot */\n    xPathContext->node = machineNode;\n    cur = virXPathNode(\"./vbox:Snapshot\", xPathContext);\n    if (cur != NULL) {\n        machineDescription->snapshot = virVBoxSnapshotConfRetrieveSnapshot(cur, xPathContext);\n        if (!machineDescription->snapshot)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    xmlXPathFreeContext(xPathContext);\n    xmlFreeDoc(xml);\n\n    VIR_FREE(currentStateModifiedString);\n    VIR_FREE(currentSnapshotAttribute);\n    virStringListFree(searchResultTab);\n    if (ret < 0) {\n        virVBoxSnapshotConfMachineFree(machineDescription);\n        machineDescription = NULL;\n    }\n    return machineDescription;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get the machine location path\")"
          ],
          "line": 4617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "machineNameUtf16",
            "&machineName"
          ],
          "line": 4612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot get machine name\")"
          ],
          "line": 4608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetName",
          "args": [
            "machine",
            "&machineNameUtf16"
          ],
          "line": 4606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "settingsFilePath",
            "&settingsFilePath_Utf8"
          ],
          "line": 4603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot get settings file path\")"
          ],
          "line": 4599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetSettingsFilePath",
          "args": [
            "machine",
            "&settingsFilePath"
          ],
          "line": 4597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SaveSettings",
          "args": [
            "machine"
          ],
          "line": 4595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&domiid",
            "&machine"
          ],
          "line": 4592
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"This function may not work in current version\""
          ],
          "line": 4590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxSnapshotRedefine(virDomainPtr dom,\n                     virDomainSnapshotDefPtr def,\n                     bool isCurrent)\n{\n    /*\n     * If your snapshot has a parent,\n     * it will only be redefined if you have already\n     * redefined the parent.\n     *\n     * The general algorithm of this function is below :\n     * First of all, we are going to create our vboxSnapshotXmlMachinePtr struct from\n     * the machine settings path.\n     * Then, if the machine current snapshot xml file is saved in the machine location,\n     * it means that this snapshot was previously modified by us and has fake disks.\n     * Fake disks are added when the flag VIR_DOMAIN_SNAPSHOT_CREATE_CURRENT was not set\n     * yet, in order to not corrupt read-only disks. The first thing to do is to remove those\n     * disks and restore the read-write disks, if any, in the vboxSnapshotXmlMachinePtr struct.\n     * We also delete the current snapshot xml file.\n     *\n     * After that, we are going to register the snapshot read-only disks that we want to redefine,\n     * if they are not in the media registry struct.\n     *\n     * The next step is to unregister the machine and close all disks.\n     *\n     * Then, we check if the flag VIR_DOMAIN_SNAPSHOT_CREATE_REDEFINE has already been set.\n     * If this flag was set, we just add read-write disks to the media registry\n     * struct. Otherwise, we save the snapshot xml file into the machine location in order\n     * to recover the read-write disks during the next redefine and we create differential disks\n     * from the snapshot read-only disks and add them to the media registry struct.\n     *\n     * Finally, we register the machine with the new virtualbox description file.\n     */\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    nsresult rc;\n    PRUnichar *settingsFilePath = NULL;\n    char *settingsFilePath_Utf8 = NULL;\n    virVBoxSnapshotConfMachinePtr snapshotMachineDesc = NULL;\n    char *currentSnapshotXmlFilePath = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    char *machineName = NULL;\n    char **realReadWriteDisksPath = NULL;\n    int realReadWriteDisksPathSize = 0;\n    char **realReadOnlyDisksPath = NULL;\n    int realReadOnlyDisksPathSize = 0;\n    virVBoxSnapshotConfSnapshotPtr newSnapshotPtr = NULL;\n    unsigned char snapshotUuid[VIR_UUID_BUFLEN];\n    virVBoxSnapshotConfHardDiskPtr *hardDiskToOpen = NULL;\n    size_t hardDiskToOpenSize = 0;\n    virVBoxSnapshotConfHardDiskPtr newHardDisk = NULL;\n    char **searchResultTab = NULL;\n    ssize_t resultSize = 0;\n    int it = 0;\n    int jt = 0;\n    PRUint32 aMediaSize = 0;\n    IMedium **aMedia = NULL;\n    char *machineLocationPath = NULL;\n    char *nameTmpUse = NULL;\n    bool snapshotFileExists = false;\n    bool needToChangeStorageController = false;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    rc = gVBoxAPI.UIMachine.SaveSettings(machine);\n    /* It may failed when the machine is not mutable. */\n    rc = gVBoxAPI.UIMachine.GetSettingsFilePath(machine, &settingsFilePath);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get settings file path\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(settingsFilePath, &settingsFilePath_Utf8);\n\n    /* Getting the machine name to retrieve the machine location path. */\n    rc = gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot get machine name\"));\n        goto cleanup;\n    }\n    VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineName);\n\n    nameTmpUse = g_strdup_printf(\"%s.vbox\", machineName);\n    machineLocationPath = virStringReplace(settingsFilePath_Utf8, nameTmpUse, \"\");\n    if (machineLocationPath == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get the machine location path\"));\n        goto cleanup;\n    }\n\n    /* We create the xml struct with the settings file path. */\n    snapshotMachineDesc = virVBoxSnapshotConfLoadVboxFile(settingsFilePath_Utf8, machineLocationPath);\n    if (snapshotMachineDesc == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"cannot create a vboxSnapshotXmlPtr\"));\n        goto cleanup;\n    }\n    if (snapshotMachineDesc->currentSnapshot != NULL) {\n        currentSnapshotXmlFilePath = g_strdup_printf(\"%s%s.xml\",\n                                                     machineLocationPath, snapshotMachineDesc->currentSnapshot);\n        snapshotFileExists = virFileExists(currentSnapshotXmlFilePath);\n    }\n\n    if (snapshotFileExists) {\n        /*\n         * We have created fake disks, so we have to remove them and replace them with\n         * the read-write disks if there are any. The fake disks will be closed during\n         * the machine unregistration.\n         */\n        if (virVBoxSnapshotConfRemoveFakeDisks(snapshotMachineDesc) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to remove Fake Disks\"));\n            goto cleanup;\n        }\n        realReadWriteDisksPathSize = virVBoxSnapshotConfGetRWDisksPathsFromLibvirtXML(currentSnapshotXmlFilePath,\n                                                             &realReadWriteDisksPath);\n        realReadOnlyDisksPathSize = virVBoxSnapshotConfGetRODisksPathsFromLibvirtXML(currentSnapshotXmlFilePath,\n                                                                         &realReadOnlyDisksPath);\n        /* The read-only disk number is necessarily greater or equal to the\n         * read-write disk number */\n        if (realReadOnlyDisksPathSize < realReadWriteDisksPathSize) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"The read only disk number must be greater or equal to the \"\n                           \" read write disk number\"));\n            goto cleanup;\n        }\n        for (it = 0; it < realReadWriteDisksPathSize; it++) {\n            virVBoxSnapshotConfHardDiskPtr readWriteDisk = NULL;\n            PRUnichar *locationUtf = NULL;\n            IMedium *readWriteMedium = NULL;\n            char *uuid = NULL;\n            PRUnichar *formatUtf = NULL;\n            char *format = NULL;\n            const char *parentUuid = NULL;\n            vboxIID iid;\n\n            VBOX_IID_INITIALIZE(&iid);\n            VBOX_UTF8_TO_UTF16(realReadWriteDisksPath[it], &locationUtf);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &readWriteMedium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                VBOX_UTF16_FREE(locationUtf);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf);\n\n            rc = gVBoxAPI.UIMedium.GetId(readWriteMedium, &iid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get the read write medium id\"));\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n            vboxIIDUnalloc(&iid);\n\n            rc = gVBoxAPI.UIMedium.GetFormat(readWriteMedium, &formatUtf);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get the read write medium format\"));\n                goto cleanup;\n            }\n            VBOX_UTF16_TO_UTF8(formatUtf, &format);\n            VBOX_UTF16_FREE(formatUtf);\n\n            if (VIR_ALLOC(readWriteDisk) < 0) {\n                VIR_FREE(formatUtf);\n                goto cleanup;\n            }\n\n            readWriteDisk->format = format;\n            readWriteDisk->uuid = uuid;\n            readWriteDisk->location = realReadWriteDisksPath[it];\n            /*\n             * We get the current snapshot's read-only disk uuid in order to add the\n             * read-write disk to the media registry as its child. The read-only disk\n             * is already in the media registry because it is the fake disk's parent.\n             */\n            parentUuid = virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc,\n                                                                   realReadOnlyDisksPath[it]);\n            if (parentUuid == NULL) {\n                VIR_FREE(readWriteDisk);\n                goto cleanup;\n            }\n\n            if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(readWriteDisk,\n                                           snapshotMachineDesc->mediaRegistry,\n                                           parentUuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to add hard disk to media Registry\"));\n                VIR_FREE(readWriteDisk);\n                goto cleanup;\n            }\n            rc = gVBoxAPI.UIMedium.Close(readWriteMedium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n        /*\n         * Now we have done this swap, we remove the snapshot xml file from the\n         * current machine location.\n         */\n        if (unlink(currentSnapshotXmlFilePath) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to delete file %s\"), currentSnapshotXmlFilePath);\n            goto cleanup;\n        }\n    }\n    /*\n     * Before unregistering the machine, while all disks are still open, ensure that all\n     * read-only disks are in the redefined snapshot's media registry (the disks need to\n     * be open to query their uuid).\n     */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        int diskInMediaRegistry = 0;\n        IMedium *readOnlyMedium = NULL;\n        PRUnichar *locationUtf = NULL;\n        char *uuid = NULL;\n        PRUnichar *formatUtf = NULL;\n        char *format = NULL;\n        char *parentUuid = NULL;\n        virVBoxSnapshotConfHardDiskPtr readOnlyDisk = NULL;\n        vboxIID iid, parentiid;\n\n        VBOX_IID_INITIALIZE(&iid);\n        VBOX_IID_INITIALIZE(&parentiid);\n        diskInMediaRegistry = virVBoxSnapshotConfDiskIsInMediaRegistry(snapshotMachineDesc,\n                                                        def->parent.dom->disks[it]->src->path);\n        if (diskInMediaRegistry == -1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to know if disk is in media registry\"));\n            goto cleanup;\n        }\n        if (diskInMediaRegistry == 1) /* Nothing to do. */\n            continue;\n        /* The read only disk is not in the media registry */\n\n        VBOX_UTF8_TO_UTF16(def->parent.dom->disks[it]->src->path, &locationUtf);\n        rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                              locationUtf,\n                                              DeviceType_HardDisk,\n                                              AccessMode_ReadWrite,\n                                              &readOnlyMedium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to open HardDisk, rc=%08x\"),\n                           (unsigned)rc);\n            VBOX_UTF16_FREE(locationUtf);\n            goto cleanup;\n        }\n        VBOX_UTF16_FREE(locationUtf);\n\n        rc = gVBoxAPI.UIMedium.GetId(readOnlyMedium, &iid);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get hard disk id\"));\n            goto cleanup;\n        }\n        gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n        vboxIIDUnalloc(&iid);\n\n        rc = gVBoxAPI.UIMedium.GetFormat(readOnlyMedium, &formatUtf);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get hard disk format\"));\n            VIR_FREE(uuid);\n            goto cleanup;\n        }\n        VBOX_UTF16_TO_UTF8(formatUtf, &format);\n        VBOX_UTF16_FREE(formatUtf);\n\n        /* This disk is already in the media registry */\n        IMedium *parentReadOnlyMedium = NULL;\n        rc = gVBoxAPI.UIMedium.GetParent(readOnlyMedium, &parentReadOnlyMedium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get parent hard disk\"));\n            VIR_FREE(uuid);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMedium.GetId(parentReadOnlyMedium, &parentiid);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to get hard disk id, rc=%08x\"),\n                           (unsigned)rc);\n            VIR_FREE(uuid);\n            goto cleanup;\n        }\n        gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n        vboxIIDUnalloc(&parentiid);\n\n        rc = gVBoxAPI.UIMedium.Close(readOnlyMedium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unable to close HardDisk, rc=%08x\"),\n                           (unsigned)rc);\n            VIR_FREE(uuid);\n            VIR_FREE(parentUuid);\n            goto cleanup;\n        }\n\n        if (VIR_ALLOC(readOnlyDisk) < 0) {\n            VIR_FREE(uuid);\n            VIR_FREE(parentUuid);\n            goto cleanup;\n        }\n\n        readOnlyDisk->format = format;\n        readOnlyDisk->uuid = uuid;\n        readOnlyDisk->location = g_strdup(def->parent.dom->disks[it]->src->path);\n\n        if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(readOnlyDisk, snapshotMachineDesc->mediaRegistry,\n                                       parentUuid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to add hard disk to media registry\"));\n            VIR_FREE(readOnlyDisk);\n            goto cleanup;\n        }\n    }\n\n    /* Now, we can unregister the machine */\n    rc = gVBoxAPI.UIMachine.Unregister(machine,\n                                       CleanupMode_DetachAllReturnHardDisksOnly,\n                                       &aMediaSize,\n                                       &aMedia);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to unregister machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n    VBOX_RELEASE(machine);\n\n    /*\n     * Unregister the machine, and then close all disks returned by the unregister method.\n     * Some close operations will fail because some disks that need to be closed will not\n     * be returned by virtualbox. We will close them just after. We have to use this\n     * solution because it is the only way to delete fake disks.\n     */\n    for (it = 0; it < aMediaSize; it++) {\n        IMedium *medium = aMedia[it];\n        if (medium) {\n            PRUnichar *locationUtf16 = NULL;\n            char *locationUtf8 = NULL;\n            rc = gVBoxAPI.UIMedium.GetLocation(medium, &locationUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get medium location\"));\n                goto cleanup;\n            }\n            VBOX_UTF16_TO_UTF8(locationUtf16, &locationUtf8);\n            VBOX_UTF16_FREE(locationUtf16);\n            if (strstr(locationUtf8, \"fake\") != NULL) {\n                /* we delete the fake disk because we don't need it anymore */\n                IProgress *progress = NULL;\n                resultCodeUnion resultCode;\n                rc = gVBoxAPI.UIMedium.DeleteStorage(medium, &progress);\n                if (NS_FAILED(rc)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to delete medium, rc=%08x\"),\n                                   (unsigned)rc);\n                    VIR_FREE(locationUtf8);\n                    goto cleanup;\n                }\n                gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n                gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n                if (RC_FAILED(resultCode)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Error while closing medium, rc=%08x\"),\n                                   resultCode.uResultCode);\n                    VIR_FREE(locationUtf8);\n                    goto cleanup;\n                }\n                VBOX_RELEASE(progress);\n            } else {\n                /*\n                 * This a comment from vboxmanage code in the handleUnregisterVM\n                 * function in VBoxManageMisc.cpp :\n                 * Note that the IMachine::Unregister method will return the medium\n                 * reference in a sane order, which means that closing will normally\n                 * succeed, unless there is still another machine which uses the\n                 * medium. No harm done if we ignore the error.\n                 */\n                ignore_value(gVBoxAPI.UIMedium.Close(medium));\n            }\n            VBOX_UTF8_FREE(locationUtf8);\n        }\n    }\n    /* Close all disks that failed to close normally. */\n    for (it = 0; it < snapshotMachineDesc->mediaRegistry->ndisks; it++) {\n        if (vboxCloseDisksRecursively(dom, snapshotMachineDesc->mediaRegistry->disks[it]->location) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to close recursively all disks\"));\n            goto cleanup;\n        }\n    }\n    /* Here, all disks are closed or deleted */\n\n    /* We are now going to create and fill the Snapshot xml struct */\n    if (VIR_ALLOC(newSnapshotPtr) < 0)\n        goto cleanup;\n\n    if (virUUIDGenerate(snapshotUuid) < 0)\n        goto cleanup;\n\n    char uuidtmp[VIR_UUID_STRING_BUFLEN];\n    virUUIDFormat(snapshotUuid, uuidtmp);\n    newSnapshotPtr->uuid = g_strdup(uuidtmp);\n\n    VIR_DEBUG(\"New snapshot UUID: %s\", newSnapshotPtr->uuid);\n    newSnapshotPtr->name = g_strdup(def->parent.name);\n\n    newSnapshotPtr->timeStamp = virTimeStringThen(def->parent.creationTime * 1000);\n\n    newSnapshotPtr->description = g_strdup(def->parent.description);\n\n    newSnapshotPtr->hardware = g_strdup(snapshotMachineDesc->hardware);\n\n    newSnapshotPtr->storageController = g_strdup(snapshotMachineDesc->storageController);\n\n    /* We get the parent disk uuid from the parent disk location\n     * to correctly fill the storage controller. */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        char *location = NULL;\n        const char *uuidReplacing = NULL;\n        char *tmp = NULL;\n\n        location = def->parent.dom->disks[it]->src->path;\n        if (!location)\n            goto cleanup;\n        /* Replacing the uuid */\n        uuidReplacing = virVBoxSnapshotConfHardDiskUuidByLocation(snapshotMachineDesc, location);\n        if (uuidReplacing == NULL)\n            goto cleanup;\n\n        resultSize = virStringSearch(newSnapshotPtr->storageController,\n                                     VBOX_UUID_REGEX,\n                                     it + 1,\n                                     &searchResultTab);\n        if (resultSize != it + 1)\n            goto cleanup;\n\n        tmp = virStringReplace(newSnapshotPtr->storageController,\n                               searchResultTab[it],\n                               uuidReplacing);\n        virStringListFree(searchResultTab);\n        searchResultTab = NULL;\n        VIR_FREE(newSnapshotPtr->storageController);\n        if (!tmp)\n            goto cleanup;\n        newSnapshotPtr->storageController = g_strdup(tmp);\n\n        VIR_FREE(tmp);\n    }\n    if (virVBoxSnapshotConfAddSnapshotToXmlMachine(newSnapshotPtr, snapshotMachineDesc, def->parent.parent_name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to add the snapshot to the machine description\"));\n        goto cleanup;\n    }\n    /*\n     * We change the current snapshot only if there is no current snapshot or if the\n     * snapshotFile exists, otherwise, it means that the correct current snapshot is\n     * already set.\n     */\n\n    if (snapshotMachineDesc->currentSnapshot == NULL || snapshotFileExists) {\n        snapshotMachineDesc->currentSnapshot = newSnapshotPtr->uuid;\n        needToChangeStorageController = true;\n    }\n\n    /*\n     * Open the snapshot's read-write disk's full ancestry to allow opening the\n     * read-write disk itself.\n     */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        char *location = NULL;\n\n        location = def->parent.dom->disks[it]->src->path;\n        if (!location)\n            goto cleanup;\n\n        hardDiskToOpenSize = virVBoxSnapshotConfDiskListToOpen(snapshotMachineDesc,\n                                                   &hardDiskToOpen, location);\n        for (jt = hardDiskToOpenSize -1; jt >= 0; jt--) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            VBOX_UTF8_TO_UTF16(hardDiskToOpen[jt]->location, &locationUtf16);\n\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf16,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &medium);\n            VBOX_UTF16_FREE(locationUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n    }\n    if (isCurrent || !needToChangeStorageController) {\n        /* We don't create a differential hard disk because either the current snapshot\n         * has already been defined or the snapshot to redefine is the current snapshot.\n         * If the snapshot to redefine is the current snapshot, we add read-write disks in\n         * the machine storage controllers.\n         */\n        for (it = 0; it < def->ndisks; it++) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            virVBoxSnapshotConfHardDiskPtr disk = NULL;\n            PRUnichar *formatUtf16 = NULL;\n            char *format = NULL;\n            char *uuid = NULL;\n            IMedium *parentDisk = NULL;\n            char *parentUuid = NULL;\n            vboxIID iid, parentiid;\n\n            VBOX_IID_INITIALIZE(&iid);\n            VBOX_IID_INITIALIZE(&parentiid);\n            VBOX_UTF8_TO_UTF16(def->disks[it].src->path, &locationUtf16);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                 locationUtf16,\n                                                 DeviceType_HardDisk,\n                                                 AccessMode_ReadWrite,\n                                                 &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf16);\n\n            if (VIR_ALLOC(disk) < 0)\n                goto cleanup;\n\n            rc = gVBoxAPI.UIMedium.GetFormat(medium, &formatUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get disk format\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n\n            VBOX_UTF16_TO_UTF8(formatUtf16, &format);\n            disk->format = format;\n            VBOX_UTF16_FREE(formatUtf16);\n\n            disk->location = g_strdup(def->disks[it].src->path);\n\n            rc = gVBoxAPI.UIMedium.GetId(medium, &iid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get disk uuid\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n            disk->uuid = uuid;\n            vboxIIDUnalloc(&iid);\n\n            rc = gVBoxAPI.UIMedium.GetParent(medium, &parentDisk);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get disk parent\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n\n            gVBoxAPI.UIMedium.GetId(parentDisk, &parentiid);\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n            vboxIIDUnalloc(&parentiid);\n            if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(disk,\n                                           snapshotMachineDesc->mediaRegistry,\n                                           parentUuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to add hard disk to the media registry\"));\n                VIR_FREE(disk);\n                goto cleanup;\n            }\n\n            if (needToChangeStorageController) {\n                /* We need to append this disk in the storage controller */\n                char *tmp = NULL;\n                resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                             VBOX_UUID_REGEX,\n                                             it + 1,\n                                             &searchResultTab);\n                if (resultSize != it + 1) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Unable to find UUID %s\"), searchResultTab[it]);\n                    goto cleanup;\n                }\n\n                tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                       searchResultTab[it],\n                                       disk->uuid);\n                VIR_FREE(snapshotMachineDesc->storageController);\n                if (!tmp)\n                    goto cleanup;\n                snapshotMachineDesc->storageController = g_strdup(tmp);\n\n                VIR_FREE(tmp);\n            }\n            /* Close disk */\n            rc = gVBoxAPI.UIMedium.Close(medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n    } else {\n        /* Create a \"fake\" disk to avoid corrupting children snapshot disks. */\n        for (it = 0; it < def->parent.dom->ndisks; it++) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            char *parentUuid = NULL;\n            IMedium *newMedium = NULL;\n            PRUnichar *formatUtf16 = NULL;\n            PRUnichar *newLocation = NULL;\n            char *newLocationUtf8 = NULL;\n            resultCodeUnion resultCode;\n            char *uuid = NULL;\n            char *format = NULL;\n            char *tmp = NULL;\n            vboxIID iid, parentiid;\n\n            VBOX_IID_INITIALIZE(&iid);\n            VBOX_IID_INITIALIZE(&parentiid);\n            VBOX_UTF8_TO_UTF16(def->parent.dom->disks[it]->src->path, &locationUtf16);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf16,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                VBOX_UTF16_FREE(locationUtf16);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf16);\n\n            rc = gVBoxAPI.UIMedium.GetId(medium, &parentiid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to get hardDisk Id, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &parentiid, &parentUuid);\n            vboxIIDUnalloc(&parentiid);\n            VBOX_UTF8_TO_UTF16(\"VDI\", &formatUtf16);\n\n            newLocationUtf8 = g_strdup_printf(\"%sfakedisk-%d.vdi\",\n                                              machineLocationPath, it);\n            VBOX_UTF8_TO_UTF16(newLocationUtf8, &newLocation);\n            rc = gVBoxAPI.UIVirtualBox.CreateHardDisk(data->vboxObj,\n                                                      formatUtf16,\n                                                      newLocation,\n                                                      &newMedium);\n            VBOX_UTF16_FREE(newLocation);\n            VBOX_UTF16_FREE(formatUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to create HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n\n            IProgress *progress = NULL;\n            PRUint32 tab[1];\n            tab[0] = MediumVariant_Diff;\n            gVBoxAPI.UIMedium.CreateDiffStorage(medium, newMedium, 1, tab, &progress);\n\n            gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n            gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n            if (RC_FAILED(resultCode)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Error while creating diff storage, rc=%08x\"),\n                               resultCode.uResultCode);\n                goto cleanup;\n            }\n            VBOX_RELEASE(progress);\n            /*\n             * The differential newHardDisk is created, we add it to the\n             * media registry and the machine storage controllers.\n             */\n\n            if (VIR_ALLOC(newHardDisk) < 0)\n                goto cleanup;\n\n            rc = gVBoxAPI.UIMedium.GetId(newMedium, &iid);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to get medium uuid, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            gVBoxAPI.UIID.vboxIIDToUtf8(data, &iid, &uuid);\n            newHardDisk->uuid = uuid;\n            vboxIIDUnalloc(&iid);\n\n            newHardDisk->location = g_strdup(newLocationUtf8);\n\n            rc = gVBoxAPI.UIMedium.GetFormat(newMedium, &formatUtf16);\n            VBOX_UTF16_TO_UTF8(formatUtf16, &format);\n            newHardDisk->format = format;\n            VBOX_UTF16_FREE(formatUtf16);\n\n            if (virVBoxSnapshotConfAddHardDiskToMediaRegistry(newHardDisk,\n                                           snapshotMachineDesc->mediaRegistry,\n                                           parentUuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to add hard disk to the media registry\"));\n                goto cleanup;\n            }\n            newHardDisk = NULL;  /* Consumed by above */\n            /* Adding the fake disk to the machine storage controllers */\n\n            resultSize = virStringSearch(snapshotMachineDesc->storageController,\n                                         VBOX_UUID_REGEX,\n                                         it + 1,\n                                         &searchResultTab);\n            if (resultSize != it + 1) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to find UUID %s\"), searchResultTab[it]);\n                goto cleanup;\n            }\n\n            tmp = virStringReplace(snapshotMachineDesc->storageController,\n                                   searchResultTab[it],\n                                   uuid);\n            VIR_FREE(snapshotMachineDesc->storageController);\n            if (!tmp)\n                goto cleanup;\n            snapshotMachineDesc->storageController = g_strdup(tmp);\n\n            VIR_FREE(tmp);\n            /* Closing the \"fake\" disk */\n            rc = gVBoxAPI.UIMedium.Close(newMedium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close the new medium, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n        }\n        /*\n         * We save the snapshot xml file to retrieve the real read-write disk during the\n         * next define. This file is saved as \"'machineLocation'/snapshot-'uuid'.xml\"\n         */\n        VIR_FREE(currentSnapshotXmlFilePath);\n        currentSnapshotXmlFilePath = g_strdup_printf(\"%s%s.xml\",\n                                                     machineLocationPath, snapshotMachineDesc->currentSnapshot);\n        char *snapshotContent = virDomainSnapshotDefFormat(NULL, def,\n                                                           data->xmlopt,\n                                                           VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE);\n        if (snapshotContent == NULL) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unable to get snapshot content\"));\n            goto cleanup;\n        }\n        if (virFileWriteStr(currentSnapshotXmlFilePath, snapshotContent, 0644) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to save new snapshot xml file\"));\n            goto cleanup;\n        }\n        VIR_FREE(snapshotContent);\n    }\n    /*\n     * All the snapshot structure manipulation is done, we close the disks we have\n     * previously opened.\n     */\n    for (it = 0; it < def->parent.dom->ndisks; it++) {\n        char *location = def->parent.dom->disks[it]->src->path;\n        if (!location)\n            goto cleanup;\n\n        hardDiskToOpenSize = virVBoxSnapshotConfDiskListToOpen(snapshotMachineDesc,\n                                                   &hardDiskToOpen, location);\n        for (jt = 0; jt < hardDiskToOpenSize; jt++) {\n            IMedium *medium = NULL;\n            PRUnichar *locationUtf16 = NULL;\n            VBOX_UTF8_TO_UTF16(hardDiskToOpen[jt]->location, &locationUtf16);\n            rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                  locationUtf16,\n                                                  DeviceType_HardDisk,\n                                                  AccessMode_ReadWrite,\n                                                  &medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to open HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            rc = gVBoxAPI.UIMedium.Close(medium);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to close HardDisk, rc=%08x\"),\n                               (unsigned)rc);\n                goto cleanup;\n            }\n            VBOX_UTF16_FREE(locationUtf16);\n        }\n    }\n\n    /* Now, we rewrite the 'machineName'.vbox file to redefine the machine. */\n    if (virVBoxSnapshotConfSaveVboxFile(snapshotMachineDesc, settingsFilePath_Utf8) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to serialize the machine description\"));\n        goto cleanup;\n    }\n    rc = gVBoxAPI.UIVirtualBox.OpenMachine(data->vboxObj,\n                                           settingsFilePath,\n                                           &machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to open Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIVirtualBox.RegisterMachine(data->vboxObj, machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to register Machine, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VBOX_RELEASE(machine);\n    VBOX_UTF16_FREE(settingsFilePath);\n    VBOX_UTF8_FREE(settingsFilePath_Utf8);\n    VIR_FREE(snapshotMachineDesc);\n    VIR_FREE(currentSnapshotXmlFilePath);\n    VBOX_UTF16_FREE(machineNameUtf16);\n    VBOX_UTF8_FREE(machineName);\n    virStringListFree(realReadOnlyDisksPath);\n    virStringListFree(realReadWriteDisksPath);\n    virStringListFree(searchResultTab);\n    virVboxSnapshotConfHardDiskFree(newHardDisk);\n    VIR_FREE(hardDiskToOpen);\n    VIR_FREE(newSnapshotPtr);\n    VIR_FREE(machineLocationPath);\n    VIR_FREE(nameTmpUse);\n    return ret;\n}"
  },
  {
    "function_name": "vboxCloseDisksRecursively",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "4452-4520",
    "snippet": "static int vboxCloseDisksRecursively(virDomainPtr dom, char *location)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    nsresult rc;\n    size_t i = 0;\n    PRUnichar *locationUtf = NULL;\n    IMedium *medium = NULL;\n    IMedium **children = NULL;\n    PRUint32 childrenSize = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    VBOX_UTF8_TO_UTF16(location, &locationUtf);\n    rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                          locationUtf,\n                                          DeviceType_HardDisk,\n                                          AccessMode_ReadWrite,\n                                          &medium);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to open HardDisk, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n    rc = gVBoxAPI.UIMedium.GetChildren(medium, &childrenSize, &children);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get disk children\"));\n        goto cleanup;\n    }\n    for (i = 0; i < childrenSize; i++) {\n        IMedium *childMedium = children[i];\n        if (childMedium) {\n            PRUnichar *childLocationUtf = NULL;\n            char *childLocation = NULL;\n            rc = gVBoxAPI.UIMedium.GetLocation(childMedium, &childLocationUtf);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get childMedium location\"));\n                goto cleanup;\n            }\n            VBOX_UTF16_TO_UTF8(childLocationUtf, &childLocation);\n            VBOX_UTF16_FREE(childLocationUtf);\n            if (vboxCloseDisksRecursively(dom, childLocation) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to close disk children\"));\n                goto cleanup;\n            }\n            VIR_FREE(childLocation);\n        }\n    }\n    rc = gVBoxAPI.UIMedium.Close(medium);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to close HardDisk, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VBOX_UTF16_FREE(locationUtf);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "locationUtf"
          ],
          "line": 4518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to close HardDisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 4510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to close HardDisk, rc=%08x\""
          ],
          "line": 4511
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.Close",
          "args": [
            "medium"
          ],
          "line": 4508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "childLocation"
          ],
          "line": 4505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to close disk children\")"
          ],
          "line": 4501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxCloseDisksRecursively",
          "args": [
            "dom",
            "childLocation"
          ],
          "line": 4500
        },
        "resolved": true,
        "details": {
          "function_name": "vboxCloseDisksRecursively",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "4452-4520",
          "snippet": "static int vboxCloseDisksRecursively(virDomainPtr dom, char *location)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    nsresult rc;\n    size_t i = 0;\n    PRUnichar *locationUtf = NULL;\n    IMedium *medium = NULL;\n    IMedium **children = NULL;\n    PRUint32 childrenSize = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    VBOX_UTF8_TO_UTF16(location, &locationUtf);\n    rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                          locationUtf,\n                                          DeviceType_HardDisk,\n                                          AccessMode_ReadWrite,\n                                          &medium);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to open HardDisk, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n    rc = gVBoxAPI.UIMedium.GetChildren(medium, &childrenSize, &children);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get disk children\"));\n        goto cleanup;\n    }\n    for (i = 0; i < childrenSize; i++) {\n        IMedium *childMedium = children[i];\n        if (childMedium) {\n            PRUnichar *childLocationUtf = NULL;\n            char *childLocation = NULL;\n            rc = gVBoxAPI.UIMedium.GetLocation(childMedium, &childLocationUtf);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get childMedium location\"));\n                goto cleanup;\n            }\n            VBOX_UTF16_TO_UTF8(childLocationUtf, &childLocation);\n            VBOX_UTF16_FREE(childLocationUtf);\n            if (vboxCloseDisksRecursively(dom, childLocation) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to close disk children\"));\n                goto cleanup;\n            }\n            VIR_FREE(childLocation);\n        }\n    }\n    rc = gVBoxAPI.UIMedium.Close(medium);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to close HardDisk, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VBOX_UTF16_FREE(locationUtf);\n    return ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "childLocationUtf"
          ],
          "line": 4499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "childLocationUtf",
            "&childLocation"
          ],
          "line": 4498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get childMedium location\")"
          ],
          "line": 4494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetLocation",
          "args": [
            "childMedium",
            "&childLocationUtf"
          ],
          "line": 4492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to get disk children\")"
          ],
          "line": 4483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetChildren",
          "args": [
            "medium",
            "&childrenSize",
            "&children"
          ],
          "line": 4481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to open HardDisk, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.OpenMedium",
          "args": [
            "data->vboxObj",
            "locationUtf",
            "DeviceType_HardDisk",
            "AccessMode_ReadWrite",
            "&medium"
          ],
          "line": 4470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "location",
            "&locationUtf"
          ],
          "line": 4469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"This function may not work in current version\""
          ],
          "line": 4467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxCloseDisksRecursively(virDomainPtr dom, char *location)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    nsresult rc;\n    size_t i = 0;\n    PRUnichar *locationUtf = NULL;\n    IMedium *medium = NULL;\n    IMedium **children = NULL;\n    PRUint32 childrenSize = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!gVBoxAPI.vboxSnapshotRedefine)\n        VIR_WARN(\"This function may not work in current version\");\n\n    VBOX_UTF8_TO_UTF16(location, &locationUtf);\n    rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                          locationUtf,\n                                          DeviceType_HardDisk,\n                                          AccessMode_ReadWrite,\n                                          &medium);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to open HardDisk, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n    rc = gVBoxAPI.UIMedium.GetChildren(medium, &childrenSize, &children);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to get disk children\"));\n        goto cleanup;\n    }\n    for (i = 0; i < childrenSize; i++) {\n        IMedium *childMedium = children[i];\n        if (childMedium) {\n            PRUnichar *childLocationUtf = NULL;\n            char *childLocation = NULL;\n            rc = gVBoxAPI.UIMedium.GetLocation(childMedium, &childLocationUtf);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to get childMedium location\"));\n                goto cleanup;\n            }\n            VBOX_UTF16_TO_UTF8(childLocationUtf, &childLocation);\n            VBOX_UTF16_FREE(childLocationUtf);\n            if (vboxCloseDisksRecursively(dom, childLocation) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Unable to close disk children\"));\n                goto cleanup;\n            }\n            VIR_FREE(childLocation);\n        }\n    }\n    rc = gVBoxAPI.UIMedium.Close(medium);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to close HardDisk, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VBOX_UTF16_FREE(locationUtf);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainDetachDeviceFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "4444-4450",
    "snippet": "static int vboxDomainDetachDeviceFlags(virDomainPtr dom, const char *xml,\n                                       unsigned int flags)\n{\n    virCheckFlags(VIR_DOMAIN_AFFECT_LIVE, -1);\n\n    return vboxDomainDetachDevice(dom, xml);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxDomainDetachDevice",
          "args": [
            "dom",
            "xml"
          ],
          "line": 4449
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainDetachDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "4356-4442",
          "snippet": "static int vboxDomainDetachDevice(virDomainPtr dom, const char *xml)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 state;\n    virDomainDefPtr def = NULL;\n    virDomainDeviceDefPtr dev = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    if (!(def = virDomainDefNew()))\n        return ret;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    dev = virDomainDeviceDefParse(xml, def, data->xmlopt, NULL,\n                                  VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                  VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n    if (dev == NULL)\n        goto cleanup;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state) ||\n        gVBoxAPI.machineStateChecker.Paused(state)) {\n        rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    } else {\n        rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    }\n\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n    if (NS_SUCCEEDED(rc) && machine) {\n        /* ret = -VIR_ERR_ARGUMENT_UNSUPPORTED means the current device don't support hotplug. */\n        ret = -VIR_ERR_ARGUMENT_UNSUPPORTED;\n        if (dev->type == VIR_DOMAIN_DEVICE_HOSTDEV) {\n            if (dev->data.hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS) {\n                if (dev->data.hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n                }\n            }\n        } else if (dev->type == VIR_DOMAIN_DEVICE_FS &&\n                   dev->data.fs->type == VIR_DOMAIN_FS_TYPE_MOUNT) {\n            PRUnichar *nameUtf16;\n\n            VBOX_UTF8_TO_UTF16(dev->data.fs->dst, &nameUtf16);\n\n            rc = gVBoxAPI.UIMachine.RemoveSharedFolder(machine, nameUtf16);\n\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not detach shared folder '%s', rc=%08x\"),\n                               dev->data.fs->dst, (unsigned)rc);\n            } else {\n                ret = 0;\n            }\n\n            VBOX_UTF16_FREE(nameUtf16);\n        }\n        gVBoxAPI.UIMachine.SaveSettings(machine);\n        VBOX_RELEASE(machine);\n\n        if (ret == -VIR_ERR_ARGUMENT_UNSUPPORTED) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, _(\"Unsupported device type %d\"), dev->type);\n            ret = -1;\n        }\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    vboxIIDUnalloc(&iid);\n    virDomainDefFree(def);\n    virDomainDeviceDefFree(dev);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainDetachDevice(virDomainPtr dom, const char *xml)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 state;\n    virDomainDefPtr def = NULL;\n    virDomainDeviceDefPtr dev = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    if (!(def = virDomainDefNew()))\n        return ret;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    dev = virDomainDeviceDefParse(xml, def, data->xmlopt, NULL,\n                                  VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                  VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n    if (dev == NULL)\n        goto cleanup;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state) ||\n        gVBoxAPI.machineStateChecker.Paused(state)) {\n        rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    } else {\n        rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    }\n\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n    if (NS_SUCCEEDED(rc) && machine) {\n        /* ret = -VIR_ERR_ARGUMENT_UNSUPPORTED means the current device don't support hotplug. */\n        ret = -VIR_ERR_ARGUMENT_UNSUPPORTED;\n        if (dev->type == VIR_DOMAIN_DEVICE_HOSTDEV) {\n            if (dev->data.hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS) {\n                if (dev->data.hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n                }\n            }\n        } else if (dev->type == VIR_DOMAIN_DEVICE_FS &&\n                   dev->data.fs->type == VIR_DOMAIN_FS_TYPE_MOUNT) {\n            PRUnichar *nameUtf16;\n\n            VBOX_UTF8_TO_UTF16(dev->data.fs->dst, &nameUtf16);\n\n            rc = gVBoxAPI.UIMachine.RemoveSharedFolder(machine, nameUtf16);\n\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not detach shared folder '%s', rc=%08x\"),\n                               dev->data.fs->dst, (unsigned)rc);\n            } else {\n                ret = 0;\n            }\n\n            VBOX_UTF16_FREE(nameUtf16);\n        }\n        gVBoxAPI.UIMachine.SaveSettings(machine);\n        VBOX_RELEASE(machine);\n\n        if (ret == -VIR_ERR_ARGUMENT_UNSUPPORTED) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, _(\"Unsupported device type %d\"), dev->type);\n            ret = -1;\n        }\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    vboxIIDUnalloc(&iid);\n    virDomainDefFree(def);\n    virDomainDeviceDefFree(dev);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_AFFECT_LIVE",
            "-1"
          ],
          "line": 4447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxDomainDetachDeviceFlags(virDomainPtr dom, const char *xml,\n                                       unsigned int flags)\n{\n    virCheckFlags(VIR_DOMAIN_AFFECT_LIVE, -1);\n\n    return vboxDomainDetachDevice(dom, xml);\n}"
  },
  {
    "function_name": "vboxDomainDetachDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "4356-4442",
    "snippet": "static int vboxDomainDetachDevice(virDomainPtr dom, const char *xml)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 state;\n    virDomainDefPtr def = NULL;\n    virDomainDeviceDefPtr dev = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    if (!(def = virDomainDefNew()))\n        return ret;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    dev = virDomainDeviceDefParse(xml, def, data->xmlopt, NULL,\n                                  VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                  VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n    if (dev == NULL)\n        goto cleanup;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state) ||\n        gVBoxAPI.machineStateChecker.Paused(state)) {\n        rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    } else {\n        rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    }\n\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n    if (NS_SUCCEEDED(rc) && machine) {\n        /* ret = -VIR_ERR_ARGUMENT_UNSUPPORTED means the current device don't support hotplug. */\n        ret = -VIR_ERR_ARGUMENT_UNSUPPORTED;\n        if (dev->type == VIR_DOMAIN_DEVICE_HOSTDEV) {\n            if (dev->data.hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS) {\n                if (dev->data.hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n                }\n            }\n        } else if (dev->type == VIR_DOMAIN_DEVICE_FS &&\n                   dev->data.fs->type == VIR_DOMAIN_FS_TYPE_MOUNT) {\n            PRUnichar *nameUtf16;\n\n            VBOX_UTF8_TO_UTF16(dev->data.fs->dst, &nameUtf16);\n\n            rc = gVBoxAPI.UIMachine.RemoveSharedFolder(machine, nameUtf16);\n\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not detach shared folder '%s', rc=%08x\"),\n                               dev->data.fs->dst, (unsigned)rc);\n            } else {\n                ret = 0;\n            }\n\n            VBOX_UTF16_FREE(nameUtf16);\n        }\n        gVBoxAPI.UIMachine.SaveSettings(machine);\n        VBOX_RELEASE(machine);\n\n        if (ret == -VIR_ERR_ARGUMENT_UNSUPPORTED) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, _(\"Unsupported device type %d\"), dev->type);\n            ret = -1;\n        }\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    vboxIIDUnalloc(&iid);\n    virDomainDefFree(def);\n    virDomainDeviceDefFree(dev);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDeviceDefFree",
          "args": [
            "dev"
          ],
          "line": 4440
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3062-3146",
          "snippet": "void virDomainDeviceDefFree(virDomainDeviceDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch ((virDomainDeviceType) def->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        virDomainDiskDefFree(def->data.disk);\n        break;\n    case VIR_DOMAIN_DEVICE_LEASE:\n        virDomainLeaseDefFree(def->data.lease);\n        break;\n    case VIR_DOMAIN_DEVICE_NET:\n        virDomainNetDefFree(def->data.net);\n        break;\n    case VIR_DOMAIN_DEVICE_INPUT:\n        virDomainInputDefFree(def->data.input);\n        break;\n    case VIR_DOMAIN_DEVICE_SOUND:\n        virDomainSoundDefFree(def->data.sound);\n        break;\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        virDomainVideoDefFree(def->data.video);\n        break;\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n        virDomainHostdevDefFree(def->data.hostdev);\n        break;\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        virDomainWatchdogDefFree(def->data.watchdog);\n        break;\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n        virDomainControllerDefFree(def->data.controller);\n        break;\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n        virDomainGraphicsDefFree(def->data.graphics);\n        break;\n    case VIR_DOMAIN_DEVICE_HUB:\n        virDomainHubDefFree(def->data.hub);\n        break;\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n        virDomainRedirdevDefFree(def->data.redirdev);\n        break;\n    case VIR_DOMAIN_DEVICE_RNG:\n        virDomainRNGDefFree(def->data.rng);\n        break;\n    case VIR_DOMAIN_DEVICE_CHR:\n        virDomainChrDefFree(def->data.chr);\n        break;\n    case VIR_DOMAIN_DEVICE_FS:\n        virDomainFSDefFree(def->data.fs);\n        break;\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        virDomainSmartcardDefFree(def->data.smartcard);\n        break;\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        virDomainMemballoonDefFree(def->data.memballoon);\n        break;\n    case VIR_DOMAIN_DEVICE_NVRAM:\n        virDomainNVRAMDefFree(def->data.nvram);\n        break;\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        virDomainShmemDefFree(def->data.shmem);\n        break;\n    case VIR_DOMAIN_DEVICE_TPM:\n        virDomainTPMDefFree(def->data.tpm);\n        break;\n    case VIR_DOMAIN_DEVICE_PANIC:\n        virDomainPanicDefFree(def->data.panic);\n        break;\n    case VIR_DOMAIN_DEVICE_MEMORY:\n        virDomainMemoryDefFree(def->data.memory);\n        break;\n    case VIR_DOMAIN_DEVICE_IOMMU:\n        VIR_FREE(def->data.iommu);\n        break;\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        virDomainVsockDefFree(def->data.vsock);\n        break;\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        break;\n    }\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch ((virDomainDeviceType) def->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        virDomainDiskDefFree(def->data.disk);\n        break;\n    case VIR_DOMAIN_DEVICE_LEASE:\n        virDomainLeaseDefFree(def->data.lease);\n        break;\n    case VIR_DOMAIN_DEVICE_NET:\n        virDomainNetDefFree(def->data.net);\n        break;\n    case VIR_DOMAIN_DEVICE_INPUT:\n        virDomainInputDefFree(def->data.input);\n        break;\n    case VIR_DOMAIN_DEVICE_SOUND:\n        virDomainSoundDefFree(def->data.sound);\n        break;\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        virDomainVideoDefFree(def->data.video);\n        break;\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n        virDomainHostdevDefFree(def->data.hostdev);\n        break;\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        virDomainWatchdogDefFree(def->data.watchdog);\n        break;\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n        virDomainControllerDefFree(def->data.controller);\n        break;\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n        virDomainGraphicsDefFree(def->data.graphics);\n        break;\n    case VIR_DOMAIN_DEVICE_HUB:\n        virDomainHubDefFree(def->data.hub);\n        break;\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n        virDomainRedirdevDefFree(def->data.redirdev);\n        break;\n    case VIR_DOMAIN_DEVICE_RNG:\n        virDomainRNGDefFree(def->data.rng);\n        break;\n    case VIR_DOMAIN_DEVICE_CHR:\n        virDomainChrDefFree(def->data.chr);\n        break;\n    case VIR_DOMAIN_DEVICE_FS:\n        virDomainFSDefFree(def->data.fs);\n        break;\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        virDomainSmartcardDefFree(def->data.smartcard);\n        break;\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        virDomainMemballoonDefFree(def->data.memballoon);\n        break;\n    case VIR_DOMAIN_DEVICE_NVRAM:\n        virDomainNVRAMDefFree(def->data.nvram);\n        break;\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        virDomainShmemDefFree(def->data.shmem);\n        break;\n    case VIR_DOMAIN_DEVICE_TPM:\n        virDomainTPMDefFree(def->data.tpm);\n        break;\n    case VIR_DOMAIN_DEVICE_PANIC:\n        virDomainPanicDefFree(def->data.panic);\n        break;\n    case VIR_DOMAIN_DEVICE_MEMORY:\n        virDomainMemoryDefFree(def->data.memory);\n        break;\n    case VIR_DOMAIN_DEVICE_IOMMU:\n        VIR_FREE(def->data.iommu);\n        break;\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        virDomainVsockDefFree(def->data.vsock);\n        break;\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        break;\n    }\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 4439
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 4438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 4435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "_(\"Unsupported device type %d\")",
            "dev->type"
          ],
          "line": 4431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported device type %d\""
          ],
          "line": 4431
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 4428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SaveSettings",
          "args": [
            "machine"
          ],
          "line": 4427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "nameUtf16"
          ],
          "line": 4425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not detach shared folder '%s', rc=%08x\")",
            "dev->data.fs->dst",
            "(unsigned)rc"
          ],
          "line": 4418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.RemoveSharedFolder",
          "args": [
            "machine",
            "nameUtf16"
          ],
          "line": 4415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "dev->data.fs->dst",
            "&nameUtf16"
          ],
          "line": 4413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_SUCCEEDED",
          "args": [
            "rc"
          ],
          "line": 4401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetMachine",
          "args": [
            "data->vboxSession",
            "&machine"
          ],
          "line": 4400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Open",
          "args": [
            "data",
            "&iid",
            "machine"
          ],
          "line": 4394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.OpenExisting",
          "args": [
            "data",
            "&iid",
            "machine"
          ],
          "line": 4392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Paused",
          "args": [
            "state"
          ],
          "line": 4391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Running",
          "args": [
            "state"
          ],
          "line": 4390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 4388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 4382
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDeviceDefParse",
          "args": [
            "xml",
            "def",
            "data->xmlopt",
            "NULL",
            "VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                  VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE"
          ],
          "line": 4376
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceDefParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "16792-16961",
          "snippet": "virDomainDeviceDefPtr\nvirDomainDeviceDefParse(const char *xmlStr,\n                        const virDomainDef *def,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    g_autoptr(xmlDoc) xml = NULL;\n    xmlNodePtr node;\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autoptr(virDomainDeviceDef) dev = NULL;\n\n    if (!(xml = virXMLParseStringCtxt(xmlStr, _(\"(device_definition)\"), &ctxt)))\n        return NULL;\n\n    node = ctxt->node;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    if ((dev->type = virDomainDeviceTypeFromString((const char *) node->name)) < 0) {\n        /* Some crazy mapping of serial, parallel, console and channel to\n         * VIR_DOMAIN_DEVICE_CHR. */\n        if (virXMLNodeNameEqual(node, \"channel\") ||\n            virXMLNodeNameEqual(node, \"console\") ||\n            virXMLNodeNameEqual(node, \"parallel\") ||\n            virXMLNodeNameEqual(node, \"serial\")) {\n            dev->type = VIR_DOMAIN_DEVICE_CHR;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown device type '%s'\"),\n                           node->name);\n            return NULL;\n        }\n    }\n\n    switch ((virDomainDeviceType) dev->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        if (!(dev->data.disk = virDomainDiskDefParseXML(xmlopt, node, ctxt,\n                                                        flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_LEASE:\n        if (!(dev->data.lease = virDomainLeaseDefParseXML(node)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_FS:\n        if (!(dev->data.fs = virDomainFSDefParseXML(xmlopt, node, ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_NET:\n        if (!(dev->data.net = virDomainNetDefParseXML(xmlopt, node, ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_INPUT:\n        if (!(dev->data.input = virDomainInputDefParseXML(xmlopt, def, node,\n                                                          ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_SOUND:\n        if (!(dev->data.sound = virDomainSoundDefParseXML(xmlopt, node,\n                                                          ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        if (!(dev->data.watchdog = virDomainWatchdogDefParseXML(xmlopt,\n                                                                node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        if (!(dev->data.video = virDomainVideoDefParseXML(xmlopt, node,\n                                                          ctxt, def, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n        if (!(dev->data.hostdev = virDomainHostdevDefParseXML(xmlopt, node,\n                                                              ctxt,\n                                                              flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n        if (!(dev->data.controller = virDomainControllerDefParseXML(xmlopt, node,\n                                                                    ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n        if (!(dev->data.graphics = virDomainGraphicsDefParseXML(xmlopt, node,\n                                                                ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_HUB:\n        if (!(dev->data.hub = virDomainHubDefParseXML(xmlopt, node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n        if (!(dev->data.redirdev = virDomainRedirdevDefParseXML(xmlopt, node,\n                                                                ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_RNG:\n        if (!(dev->data.rng = virDomainRNGDefParseXML(xmlopt, node,\n                                                      ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_CHR:\n        if (!(dev->data.chr = virDomainChrDefParseXML(xmlopt,\n                                                      ctxt,\n                                                      node,\n                                                      flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        if (!(dev->data.smartcard = virDomainSmartcardDefParseXML(xmlopt, node,\n                                                                  ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        if (!(dev->data.memballoon = virDomainMemballoonDefParseXML(xmlopt,\n                                                                    node,\n                                                                    ctxt,\n                                                                    flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_NVRAM:\n        if (!(dev->data.nvram = virDomainNVRAMDefParseXML(xmlopt, node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        if (!(dev->data.shmem = virDomainShmemDefParseXML(xmlopt, node,\n                                                          ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_TPM:\n        if (!(dev->data.tpm = virDomainTPMDefParseXML(xmlopt, node, ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_PANIC:\n        if (!(dev->data.panic = virDomainPanicDefParseXML(xmlopt, node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_MEMORY:\n        if (!(dev->data.memory = virDomainMemoryDefParseXML(xmlopt, node,\n                                                            ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_IOMMU:\n        if (!(dev->data.iommu = virDomainIOMMUDefParseXML(node, ctxt)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        if (!(dev->data.vsock = virDomainVsockDefParseXML(xmlopt, node, ctxt,\n                                                          flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_NONE:\n    case VIR_DOMAIN_DEVICE_LAST:\n        break;\n    }\n\n    /* callback to fill driver specific device aspects */\n    if (virDomainDeviceDefPostParseOne(dev, def, flags,\n                                       xmlopt, parseOpaque) < 0)\n        return NULL;\n\n    /* validate the configuration */\n    if (virDomainDeviceDefValidate(dev, def, flags, xmlopt) < 0)\n        return NULL;\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDeviceDefPtr\nvirDomainDeviceDefParse(const char *xmlStr,\n                        const virDomainDef *def,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    g_autoptr(xmlDoc) xml = NULL;\n    xmlNodePtr node;\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autoptr(virDomainDeviceDef) dev = NULL;\n\n    if (!(xml = virXMLParseStringCtxt(xmlStr, _(\"(device_definition)\"), &ctxt)))\n        return NULL;\n\n    node = ctxt->node;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    if ((dev->type = virDomainDeviceTypeFromString((const char *) node->name)) < 0) {\n        /* Some crazy mapping of serial, parallel, console and channel to\n         * VIR_DOMAIN_DEVICE_CHR. */\n        if (virXMLNodeNameEqual(node, \"channel\") ||\n            virXMLNodeNameEqual(node, \"console\") ||\n            virXMLNodeNameEqual(node, \"parallel\") ||\n            virXMLNodeNameEqual(node, \"serial\")) {\n            dev->type = VIR_DOMAIN_DEVICE_CHR;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown device type '%s'\"),\n                           node->name);\n            return NULL;\n        }\n    }\n\n    switch ((virDomainDeviceType) dev->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        if (!(dev->data.disk = virDomainDiskDefParseXML(xmlopt, node, ctxt,\n                                                        flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_LEASE:\n        if (!(dev->data.lease = virDomainLeaseDefParseXML(node)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_FS:\n        if (!(dev->data.fs = virDomainFSDefParseXML(xmlopt, node, ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_NET:\n        if (!(dev->data.net = virDomainNetDefParseXML(xmlopt, node, ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_INPUT:\n        if (!(dev->data.input = virDomainInputDefParseXML(xmlopt, def, node,\n                                                          ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_SOUND:\n        if (!(dev->data.sound = virDomainSoundDefParseXML(xmlopt, node,\n                                                          ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        if (!(dev->data.watchdog = virDomainWatchdogDefParseXML(xmlopt,\n                                                                node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        if (!(dev->data.video = virDomainVideoDefParseXML(xmlopt, node,\n                                                          ctxt, def, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n        if (!(dev->data.hostdev = virDomainHostdevDefParseXML(xmlopt, node,\n                                                              ctxt,\n                                                              flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n        if (!(dev->data.controller = virDomainControllerDefParseXML(xmlopt, node,\n                                                                    ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n        if (!(dev->data.graphics = virDomainGraphicsDefParseXML(xmlopt, node,\n                                                                ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_HUB:\n        if (!(dev->data.hub = virDomainHubDefParseXML(xmlopt, node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n        if (!(dev->data.redirdev = virDomainRedirdevDefParseXML(xmlopt, node,\n                                                                ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_RNG:\n        if (!(dev->data.rng = virDomainRNGDefParseXML(xmlopt, node,\n                                                      ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_CHR:\n        if (!(dev->data.chr = virDomainChrDefParseXML(xmlopt,\n                                                      ctxt,\n                                                      node,\n                                                      flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        if (!(dev->data.smartcard = virDomainSmartcardDefParseXML(xmlopt, node,\n                                                                  ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        if (!(dev->data.memballoon = virDomainMemballoonDefParseXML(xmlopt,\n                                                                    node,\n                                                                    ctxt,\n                                                                    flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_NVRAM:\n        if (!(dev->data.nvram = virDomainNVRAMDefParseXML(xmlopt, node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        if (!(dev->data.shmem = virDomainShmemDefParseXML(xmlopt, node,\n                                                          ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_TPM:\n        if (!(dev->data.tpm = virDomainTPMDefParseXML(xmlopt, node, ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_PANIC:\n        if (!(dev->data.panic = virDomainPanicDefParseXML(xmlopt, node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_MEMORY:\n        if (!(dev->data.memory = virDomainMemoryDefParseXML(xmlopt, node,\n                                                            ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_IOMMU:\n        if (!(dev->data.iommu = virDomainIOMMUDefParseXML(node, ctxt)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        if (!(dev->data.vsock = virDomainVsockDefParseXML(xmlopt, node, ctxt,\n                                                          flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_NONE:\n    case VIR_DOMAIN_DEVICE_LAST:\n        break;\n    }\n\n    /* callback to fill driver specific device aspects */\n    if (virDomainDeviceDefPostParseOne(dev, def, flags,\n                                       xmlopt, parseOpaque) < 0)\n        return NULL;\n\n    /* validate the configuration */\n    if (virDomainDeviceDefValidate(dev, def, flags, xmlopt) < 0)\n        return NULL;\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefNew",
          "args": [],
          "line": 4371
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3574-3594",
          "snippet": "virDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 4370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainDetachDevice(virDomainPtr dom, const char *xml)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 state;\n    virDomainDefPtr def = NULL;\n    virDomainDeviceDefPtr dev = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    if (!(def = virDomainDefNew()))\n        return ret;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    dev = virDomainDeviceDefParse(xml, def, data->xmlopt, NULL,\n                                  VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                  VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n    if (dev == NULL)\n        goto cleanup;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state) ||\n        gVBoxAPI.machineStateChecker.Paused(state)) {\n        rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    } else {\n        rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    }\n\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n    if (NS_SUCCEEDED(rc) && machine) {\n        /* ret = -VIR_ERR_ARGUMENT_UNSUPPORTED means the current device don't support hotplug. */\n        ret = -VIR_ERR_ARGUMENT_UNSUPPORTED;\n        if (dev->type == VIR_DOMAIN_DEVICE_HOSTDEV) {\n            if (dev->data.hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS) {\n                if (dev->data.hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB) {\n                }\n            }\n        } else if (dev->type == VIR_DOMAIN_DEVICE_FS &&\n                   dev->data.fs->type == VIR_DOMAIN_FS_TYPE_MOUNT) {\n            PRUnichar *nameUtf16;\n\n            VBOX_UTF8_TO_UTF16(dev->data.fs->dst, &nameUtf16);\n\n            rc = gVBoxAPI.UIMachine.RemoveSharedFolder(machine, nameUtf16);\n\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not detach shared folder '%s', rc=%08x\"),\n                               dev->data.fs->dst, (unsigned)rc);\n            } else {\n                ret = 0;\n            }\n\n            VBOX_UTF16_FREE(nameUtf16);\n        }\n        gVBoxAPI.UIMachine.SaveSettings(machine);\n        VBOX_RELEASE(machine);\n\n        if (ret == -VIR_ERR_ARGUMENT_UNSUPPORTED) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, _(\"Unsupported device type %d\"), dev->type);\n            ret = -1;\n        }\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    vboxIIDUnalloc(&iid);\n    virDomainDefFree(def);\n    virDomainDeviceDefFree(dev);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainUpdateDeviceFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "4340-4354",
    "snippet": "static int vboxDomainUpdateDeviceFlags(virDomainPtr dom, const char *xml,\n                                       unsigned int flags)\n{\n    virCheckFlags(VIR_DOMAIN_AFFECT_CURRENT |\n                  VIR_DOMAIN_AFFECT_LIVE |\n                  VIR_DOMAIN_AFFECT_CONFIG, -1);\n\n    if (flags & VIR_DOMAIN_AFFECT_CONFIG) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"cannot modify the persistent configuration of a domain\"));\n        return -1;\n    }\n\n    return vboxDomainAttachDeviceImpl(dom, xml, 1);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxDomainAttachDeviceImpl",
          "args": [
            "dom",
            "xml",
            "1"
          ],
          "line": 4353
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainAttachDeviceImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "4235-4325",
          "snippet": "static int vboxDomainAttachDeviceImpl(virDomainPtr dom,\n                                      const char *xml,\n                                      int mediaChangeOnly G_GNUC_UNUSED)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 state;\n    virDomainDefPtr def = NULL;\n    virDomainDeviceDefPtr dev = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    if (!(def = virDomainDefNew()))\n        return ret;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    dev = virDomainDeviceDefParse(xml, def, data->xmlopt, NULL,\n                                  VIR_DOMAIN_DEF_PARSE_INACTIVE);\n    if (dev == NULL)\n        goto cleanup;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state) ||\n        gVBoxAPI.machineStateChecker.Paused(state)) {\n        rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    } else {\n        rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    }\n\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n\n    if (NS_SUCCEEDED(rc) && machine) {\n        /* ret = -VIR_ERR_ARGUMENT_UNSUPPORTED means the current device don't support hotplug. */\n        ret = -VIR_ERR_ARGUMENT_UNSUPPORTED;\n        if (dev->type == VIR_DOMAIN_DEVICE_FS &&\n            dev->data.fs->type == VIR_DOMAIN_FS_TYPE_MOUNT) {\n            PRUnichar *nameUtf16;\n            PRUnichar *hostPathUtf16;\n            PRBool writable;\n\n            VBOX_UTF8_TO_UTF16(dev->data.fs->dst, &nameUtf16);\n            VBOX_UTF8_TO_UTF16(dev->data.fs->src->path, &hostPathUtf16);\n            writable = !dev->data.fs->readonly;\n\n            rc = gVBoxAPI.UIMachine.CreateSharedFolder(machine, nameUtf16, hostPathUtf16,\n                                                       writable, PR_FALSE);\n\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not attach shared folder '%s', rc=%08x\"),\n                               dev->data.fs->dst, (unsigned)rc);\n                ret = -1;\n            } else {\n                ret = 0;\n            }\n\n            VBOX_UTF16_FREE(nameUtf16);\n            VBOX_UTF16_FREE(hostPathUtf16);\n        }\n        gVBoxAPI.UIMachine.SaveSettings(machine);\n        VBOX_RELEASE(machine);\n\n        if (ret == -VIR_ERR_ARGUMENT_UNSUPPORTED) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, _(\"Unsupported device type %d\"), dev->type);\n            ret = -1;\n        }\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    vboxIIDUnalloc(&iid);\n    virDomainDefFree(def);\n    virDomainDeviceDefFree(dev);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainAttachDeviceImpl(virDomainPtr dom,\n                                      const char *xml,\n                                      int mediaChangeOnly G_GNUC_UNUSED)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 state;\n    virDomainDefPtr def = NULL;\n    virDomainDeviceDefPtr dev = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    if (!(def = virDomainDefNew()))\n        return ret;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    dev = virDomainDeviceDefParse(xml, def, data->xmlopt, NULL,\n                                  VIR_DOMAIN_DEF_PARSE_INACTIVE);\n    if (dev == NULL)\n        goto cleanup;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state) ||\n        gVBoxAPI.machineStateChecker.Paused(state)) {\n        rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    } else {\n        rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    }\n\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n\n    if (NS_SUCCEEDED(rc) && machine) {\n        /* ret = -VIR_ERR_ARGUMENT_UNSUPPORTED means the current device don't support hotplug. */\n        ret = -VIR_ERR_ARGUMENT_UNSUPPORTED;\n        if (dev->type == VIR_DOMAIN_DEVICE_FS &&\n            dev->data.fs->type == VIR_DOMAIN_FS_TYPE_MOUNT) {\n            PRUnichar *nameUtf16;\n            PRUnichar *hostPathUtf16;\n            PRBool writable;\n\n            VBOX_UTF8_TO_UTF16(dev->data.fs->dst, &nameUtf16);\n            VBOX_UTF8_TO_UTF16(dev->data.fs->src->path, &hostPathUtf16);\n            writable = !dev->data.fs->readonly;\n\n            rc = gVBoxAPI.UIMachine.CreateSharedFolder(machine, nameUtf16, hostPathUtf16,\n                                                       writable, PR_FALSE);\n\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not attach shared folder '%s', rc=%08x\"),\n                               dev->data.fs->dst, (unsigned)rc);\n                ret = -1;\n            } else {\n                ret = 0;\n            }\n\n            VBOX_UTF16_FREE(nameUtf16);\n            VBOX_UTF16_FREE(hostPathUtf16);\n        }\n        gVBoxAPI.UIMachine.SaveSettings(machine);\n        VBOX_RELEASE(machine);\n\n        if (ret == -VIR_ERR_ARGUMENT_UNSUPPORTED) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, _(\"Unsupported device type %d\"), dev->type);\n            ret = -1;\n        }\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    vboxIIDUnalloc(&iid);\n    virDomainDefFree(def);\n    virDomainDeviceDefFree(dev);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"cannot modify the persistent configuration of a domain\")"
          ],
          "line": 4348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot modify the persistent configuration of a domain\""
          ],
          "line": 4349
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_AFFECT_CURRENT |\n                  VIR_DOMAIN_AFFECT_LIVE |\n                  VIR_DOMAIN_AFFECT_CONFIG",
            "-1"
          ],
          "line": 4343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxDomainUpdateDeviceFlags(virDomainPtr dom, const char *xml,\n                                       unsigned int flags)\n{\n    virCheckFlags(VIR_DOMAIN_AFFECT_CURRENT |\n                  VIR_DOMAIN_AFFECT_LIVE |\n                  VIR_DOMAIN_AFFECT_CONFIG, -1);\n\n    if (flags & VIR_DOMAIN_AFFECT_CONFIG) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"cannot modify the persistent configuration of a domain\"));\n        return -1;\n    }\n\n    return vboxDomainAttachDeviceImpl(dom, xml, 1);\n}"
  },
  {
    "function_name": "vboxDomainAttachDeviceFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "4332-4338",
    "snippet": "static int vboxDomainAttachDeviceFlags(virDomainPtr dom, const char *xml,\n                                       unsigned int flags)\n{\n    virCheckFlags(VIR_DOMAIN_AFFECT_LIVE, -1);\n\n    return vboxDomainAttachDeviceImpl(dom, xml, 0);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxDomainAttachDeviceImpl",
          "args": [
            "dom",
            "xml",
            "0"
          ],
          "line": 4337
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainAttachDeviceImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "4235-4325",
          "snippet": "static int vboxDomainAttachDeviceImpl(virDomainPtr dom,\n                                      const char *xml,\n                                      int mediaChangeOnly G_GNUC_UNUSED)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 state;\n    virDomainDefPtr def = NULL;\n    virDomainDeviceDefPtr dev = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    if (!(def = virDomainDefNew()))\n        return ret;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    dev = virDomainDeviceDefParse(xml, def, data->xmlopt, NULL,\n                                  VIR_DOMAIN_DEF_PARSE_INACTIVE);\n    if (dev == NULL)\n        goto cleanup;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state) ||\n        gVBoxAPI.machineStateChecker.Paused(state)) {\n        rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    } else {\n        rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    }\n\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n\n    if (NS_SUCCEEDED(rc) && machine) {\n        /* ret = -VIR_ERR_ARGUMENT_UNSUPPORTED means the current device don't support hotplug. */\n        ret = -VIR_ERR_ARGUMENT_UNSUPPORTED;\n        if (dev->type == VIR_DOMAIN_DEVICE_FS &&\n            dev->data.fs->type == VIR_DOMAIN_FS_TYPE_MOUNT) {\n            PRUnichar *nameUtf16;\n            PRUnichar *hostPathUtf16;\n            PRBool writable;\n\n            VBOX_UTF8_TO_UTF16(dev->data.fs->dst, &nameUtf16);\n            VBOX_UTF8_TO_UTF16(dev->data.fs->src->path, &hostPathUtf16);\n            writable = !dev->data.fs->readonly;\n\n            rc = gVBoxAPI.UIMachine.CreateSharedFolder(machine, nameUtf16, hostPathUtf16,\n                                                       writable, PR_FALSE);\n\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not attach shared folder '%s', rc=%08x\"),\n                               dev->data.fs->dst, (unsigned)rc);\n                ret = -1;\n            } else {\n                ret = 0;\n            }\n\n            VBOX_UTF16_FREE(nameUtf16);\n            VBOX_UTF16_FREE(hostPathUtf16);\n        }\n        gVBoxAPI.UIMachine.SaveSettings(machine);\n        VBOX_RELEASE(machine);\n\n        if (ret == -VIR_ERR_ARGUMENT_UNSUPPORTED) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, _(\"Unsupported device type %d\"), dev->type);\n            ret = -1;\n        }\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    vboxIIDUnalloc(&iid);\n    virDomainDefFree(def);\n    virDomainDeviceDefFree(dev);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainAttachDeviceImpl(virDomainPtr dom,\n                                      const char *xml,\n                                      int mediaChangeOnly G_GNUC_UNUSED)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 state;\n    virDomainDefPtr def = NULL;\n    virDomainDeviceDefPtr dev = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    if (!(def = virDomainDefNew()))\n        return ret;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    dev = virDomainDeviceDefParse(xml, def, data->xmlopt, NULL,\n                                  VIR_DOMAIN_DEF_PARSE_INACTIVE);\n    if (dev == NULL)\n        goto cleanup;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state) ||\n        gVBoxAPI.machineStateChecker.Paused(state)) {\n        rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    } else {\n        rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    }\n\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n\n    if (NS_SUCCEEDED(rc) && machine) {\n        /* ret = -VIR_ERR_ARGUMENT_UNSUPPORTED means the current device don't support hotplug. */\n        ret = -VIR_ERR_ARGUMENT_UNSUPPORTED;\n        if (dev->type == VIR_DOMAIN_DEVICE_FS &&\n            dev->data.fs->type == VIR_DOMAIN_FS_TYPE_MOUNT) {\n            PRUnichar *nameUtf16;\n            PRUnichar *hostPathUtf16;\n            PRBool writable;\n\n            VBOX_UTF8_TO_UTF16(dev->data.fs->dst, &nameUtf16);\n            VBOX_UTF8_TO_UTF16(dev->data.fs->src->path, &hostPathUtf16);\n            writable = !dev->data.fs->readonly;\n\n            rc = gVBoxAPI.UIMachine.CreateSharedFolder(machine, nameUtf16, hostPathUtf16,\n                                                       writable, PR_FALSE);\n\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not attach shared folder '%s', rc=%08x\"),\n                               dev->data.fs->dst, (unsigned)rc);\n                ret = -1;\n            } else {\n                ret = 0;\n            }\n\n            VBOX_UTF16_FREE(nameUtf16);\n            VBOX_UTF16_FREE(hostPathUtf16);\n        }\n        gVBoxAPI.UIMachine.SaveSettings(machine);\n        VBOX_RELEASE(machine);\n\n        if (ret == -VIR_ERR_ARGUMENT_UNSUPPORTED) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, _(\"Unsupported device type %d\"), dev->type);\n            ret = -1;\n        }\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    vboxIIDUnalloc(&iid);\n    virDomainDefFree(def);\n    virDomainDeviceDefFree(dev);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_AFFECT_LIVE",
            "-1"
          ],
          "line": 4335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxDomainAttachDeviceFlags(virDomainPtr dom, const char *xml,\n                                       unsigned int flags)\n{\n    virCheckFlags(VIR_DOMAIN_AFFECT_LIVE, -1);\n\n    return vboxDomainAttachDeviceImpl(dom, xml, 0);\n}"
  },
  {
    "function_name": "vboxDomainAttachDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "4327-4330",
    "snippet": "static int vboxDomainAttachDevice(virDomainPtr dom, const char *xml)\n{\n    return vboxDomainAttachDeviceImpl(dom, xml, 0);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxDomainAttachDeviceImpl",
          "args": [
            "dom",
            "xml",
            "0"
          ],
          "line": 4329
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainAttachDeviceImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "4235-4325",
          "snippet": "static int vboxDomainAttachDeviceImpl(virDomainPtr dom,\n                                      const char *xml,\n                                      int mediaChangeOnly G_GNUC_UNUSED)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 state;\n    virDomainDefPtr def = NULL;\n    virDomainDeviceDefPtr dev = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    if (!(def = virDomainDefNew()))\n        return ret;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    dev = virDomainDeviceDefParse(xml, def, data->xmlopt, NULL,\n                                  VIR_DOMAIN_DEF_PARSE_INACTIVE);\n    if (dev == NULL)\n        goto cleanup;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state) ||\n        gVBoxAPI.machineStateChecker.Paused(state)) {\n        rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    } else {\n        rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    }\n\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n\n    if (NS_SUCCEEDED(rc) && machine) {\n        /* ret = -VIR_ERR_ARGUMENT_UNSUPPORTED means the current device don't support hotplug. */\n        ret = -VIR_ERR_ARGUMENT_UNSUPPORTED;\n        if (dev->type == VIR_DOMAIN_DEVICE_FS &&\n            dev->data.fs->type == VIR_DOMAIN_FS_TYPE_MOUNT) {\n            PRUnichar *nameUtf16;\n            PRUnichar *hostPathUtf16;\n            PRBool writable;\n\n            VBOX_UTF8_TO_UTF16(dev->data.fs->dst, &nameUtf16);\n            VBOX_UTF8_TO_UTF16(dev->data.fs->src->path, &hostPathUtf16);\n            writable = !dev->data.fs->readonly;\n\n            rc = gVBoxAPI.UIMachine.CreateSharedFolder(machine, nameUtf16, hostPathUtf16,\n                                                       writable, PR_FALSE);\n\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not attach shared folder '%s', rc=%08x\"),\n                               dev->data.fs->dst, (unsigned)rc);\n                ret = -1;\n            } else {\n                ret = 0;\n            }\n\n            VBOX_UTF16_FREE(nameUtf16);\n            VBOX_UTF16_FREE(hostPathUtf16);\n        }\n        gVBoxAPI.UIMachine.SaveSettings(machine);\n        VBOX_RELEASE(machine);\n\n        if (ret == -VIR_ERR_ARGUMENT_UNSUPPORTED) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, _(\"Unsupported device type %d\"), dev->type);\n            ret = -1;\n        }\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    vboxIIDUnalloc(&iid);\n    virDomainDefFree(def);\n    virDomainDeviceDefFree(dev);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainAttachDeviceImpl(virDomainPtr dom,\n                                      const char *xml,\n                                      int mediaChangeOnly G_GNUC_UNUSED)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 state;\n    virDomainDefPtr def = NULL;\n    virDomainDeviceDefPtr dev = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    if (!(def = virDomainDefNew()))\n        return ret;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    dev = virDomainDeviceDefParse(xml, def, data->xmlopt, NULL,\n                                  VIR_DOMAIN_DEF_PARSE_INACTIVE);\n    if (dev == NULL)\n        goto cleanup;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state) ||\n        gVBoxAPI.machineStateChecker.Paused(state)) {\n        rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    } else {\n        rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    }\n\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n\n    if (NS_SUCCEEDED(rc) && machine) {\n        /* ret = -VIR_ERR_ARGUMENT_UNSUPPORTED means the current device don't support hotplug. */\n        ret = -VIR_ERR_ARGUMENT_UNSUPPORTED;\n        if (dev->type == VIR_DOMAIN_DEVICE_FS &&\n            dev->data.fs->type == VIR_DOMAIN_FS_TYPE_MOUNT) {\n            PRUnichar *nameUtf16;\n            PRUnichar *hostPathUtf16;\n            PRBool writable;\n\n            VBOX_UTF8_TO_UTF16(dev->data.fs->dst, &nameUtf16);\n            VBOX_UTF8_TO_UTF16(dev->data.fs->src->path, &hostPathUtf16);\n            writable = !dev->data.fs->readonly;\n\n            rc = gVBoxAPI.UIMachine.CreateSharedFolder(machine, nameUtf16, hostPathUtf16,\n                                                       writable, PR_FALSE);\n\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not attach shared folder '%s', rc=%08x\"),\n                               dev->data.fs->dst, (unsigned)rc);\n                ret = -1;\n            } else {\n                ret = 0;\n            }\n\n            VBOX_UTF16_FREE(nameUtf16);\n            VBOX_UTF16_FREE(hostPathUtf16);\n        }\n        gVBoxAPI.UIMachine.SaveSettings(machine);\n        VBOX_RELEASE(machine);\n\n        if (ret == -VIR_ERR_ARGUMENT_UNSUPPORTED) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, _(\"Unsupported device type %d\"), dev->type);\n            ret = -1;\n        }\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    vboxIIDUnalloc(&iid);\n    virDomainDefFree(def);\n    virDomainDeviceDefFree(dev);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxDomainAttachDevice(virDomainPtr dom, const char *xml)\n{\n    return vboxDomainAttachDeviceImpl(dom, xml, 0);\n}"
  },
  {
    "function_name": "vboxDomainAttachDeviceImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "4235-4325",
    "snippet": "static int vboxDomainAttachDeviceImpl(virDomainPtr dom,\n                                      const char *xml,\n                                      int mediaChangeOnly G_GNUC_UNUSED)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 state;\n    virDomainDefPtr def = NULL;\n    virDomainDeviceDefPtr dev = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    if (!(def = virDomainDefNew()))\n        return ret;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    dev = virDomainDeviceDefParse(xml, def, data->xmlopt, NULL,\n                                  VIR_DOMAIN_DEF_PARSE_INACTIVE);\n    if (dev == NULL)\n        goto cleanup;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state) ||\n        gVBoxAPI.machineStateChecker.Paused(state)) {\n        rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    } else {\n        rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    }\n\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n\n    if (NS_SUCCEEDED(rc) && machine) {\n        /* ret = -VIR_ERR_ARGUMENT_UNSUPPORTED means the current device don't support hotplug. */\n        ret = -VIR_ERR_ARGUMENT_UNSUPPORTED;\n        if (dev->type == VIR_DOMAIN_DEVICE_FS &&\n            dev->data.fs->type == VIR_DOMAIN_FS_TYPE_MOUNT) {\n            PRUnichar *nameUtf16;\n            PRUnichar *hostPathUtf16;\n            PRBool writable;\n\n            VBOX_UTF8_TO_UTF16(dev->data.fs->dst, &nameUtf16);\n            VBOX_UTF8_TO_UTF16(dev->data.fs->src->path, &hostPathUtf16);\n            writable = !dev->data.fs->readonly;\n\n            rc = gVBoxAPI.UIMachine.CreateSharedFolder(machine, nameUtf16, hostPathUtf16,\n                                                       writable, PR_FALSE);\n\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not attach shared folder '%s', rc=%08x\"),\n                               dev->data.fs->dst, (unsigned)rc);\n                ret = -1;\n            } else {\n                ret = 0;\n            }\n\n            VBOX_UTF16_FREE(nameUtf16);\n            VBOX_UTF16_FREE(hostPathUtf16);\n        }\n        gVBoxAPI.UIMachine.SaveSettings(machine);\n        VBOX_RELEASE(machine);\n\n        if (ret == -VIR_ERR_ARGUMENT_UNSUPPORTED) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, _(\"Unsupported device type %d\"), dev->type);\n            ret = -1;\n        }\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    vboxIIDUnalloc(&iid);\n    virDomainDefFree(def);\n    virDomainDeviceDefFree(dev);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDeviceDefFree",
          "args": [
            "dev"
          ],
          "line": 4323
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3062-3146",
          "snippet": "void virDomainDeviceDefFree(virDomainDeviceDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch ((virDomainDeviceType) def->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        virDomainDiskDefFree(def->data.disk);\n        break;\n    case VIR_DOMAIN_DEVICE_LEASE:\n        virDomainLeaseDefFree(def->data.lease);\n        break;\n    case VIR_DOMAIN_DEVICE_NET:\n        virDomainNetDefFree(def->data.net);\n        break;\n    case VIR_DOMAIN_DEVICE_INPUT:\n        virDomainInputDefFree(def->data.input);\n        break;\n    case VIR_DOMAIN_DEVICE_SOUND:\n        virDomainSoundDefFree(def->data.sound);\n        break;\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        virDomainVideoDefFree(def->data.video);\n        break;\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n        virDomainHostdevDefFree(def->data.hostdev);\n        break;\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        virDomainWatchdogDefFree(def->data.watchdog);\n        break;\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n        virDomainControllerDefFree(def->data.controller);\n        break;\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n        virDomainGraphicsDefFree(def->data.graphics);\n        break;\n    case VIR_DOMAIN_DEVICE_HUB:\n        virDomainHubDefFree(def->data.hub);\n        break;\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n        virDomainRedirdevDefFree(def->data.redirdev);\n        break;\n    case VIR_DOMAIN_DEVICE_RNG:\n        virDomainRNGDefFree(def->data.rng);\n        break;\n    case VIR_DOMAIN_DEVICE_CHR:\n        virDomainChrDefFree(def->data.chr);\n        break;\n    case VIR_DOMAIN_DEVICE_FS:\n        virDomainFSDefFree(def->data.fs);\n        break;\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        virDomainSmartcardDefFree(def->data.smartcard);\n        break;\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        virDomainMemballoonDefFree(def->data.memballoon);\n        break;\n    case VIR_DOMAIN_DEVICE_NVRAM:\n        virDomainNVRAMDefFree(def->data.nvram);\n        break;\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        virDomainShmemDefFree(def->data.shmem);\n        break;\n    case VIR_DOMAIN_DEVICE_TPM:\n        virDomainTPMDefFree(def->data.tpm);\n        break;\n    case VIR_DOMAIN_DEVICE_PANIC:\n        virDomainPanicDefFree(def->data.panic);\n        break;\n    case VIR_DOMAIN_DEVICE_MEMORY:\n        virDomainMemoryDefFree(def->data.memory);\n        break;\n    case VIR_DOMAIN_DEVICE_IOMMU:\n        VIR_FREE(def->data.iommu);\n        break;\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        virDomainVsockDefFree(def->data.vsock);\n        break;\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        break;\n    }\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def)\n{\n    if (!def)\n        return;\n\n    switch ((virDomainDeviceType) def->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        virDomainDiskDefFree(def->data.disk);\n        break;\n    case VIR_DOMAIN_DEVICE_LEASE:\n        virDomainLeaseDefFree(def->data.lease);\n        break;\n    case VIR_DOMAIN_DEVICE_NET:\n        virDomainNetDefFree(def->data.net);\n        break;\n    case VIR_DOMAIN_DEVICE_INPUT:\n        virDomainInputDefFree(def->data.input);\n        break;\n    case VIR_DOMAIN_DEVICE_SOUND:\n        virDomainSoundDefFree(def->data.sound);\n        break;\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        virDomainVideoDefFree(def->data.video);\n        break;\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n        virDomainHostdevDefFree(def->data.hostdev);\n        break;\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        virDomainWatchdogDefFree(def->data.watchdog);\n        break;\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n        virDomainControllerDefFree(def->data.controller);\n        break;\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n        virDomainGraphicsDefFree(def->data.graphics);\n        break;\n    case VIR_DOMAIN_DEVICE_HUB:\n        virDomainHubDefFree(def->data.hub);\n        break;\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n        virDomainRedirdevDefFree(def->data.redirdev);\n        break;\n    case VIR_DOMAIN_DEVICE_RNG:\n        virDomainRNGDefFree(def->data.rng);\n        break;\n    case VIR_DOMAIN_DEVICE_CHR:\n        virDomainChrDefFree(def->data.chr);\n        break;\n    case VIR_DOMAIN_DEVICE_FS:\n        virDomainFSDefFree(def->data.fs);\n        break;\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        virDomainSmartcardDefFree(def->data.smartcard);\n        break;\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        virDomainMemballoonDefFree(def->data.memballoon);\n        break;\n    case VIR_DOMAIN_DEVICE_NVRAM:\n        virDomainNVRAMDefFree(def->data.nvram);\n        break;\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        virDomainShmemDefFree(def->data.shmem);\n        break;\n    case VIR_DOMAIN_DEVICE_TPM:\n        virDomainTPMDefFree(def->data.tpm);\n        break;\n    case VIR_DOMAIN_DEVICE_PANIC:\n        virDomainPanicDefFree(def->data.panic);\n        break;\n    case VIR_DOMAIN_DEVICE_MEMORY:\n        virDomainMemoryDefFree(def->data.memory);\n        break;\n    case VIR_DOMAIN_DEVICE_IOMMU:\n        VIR_FREE(def->data.iommu);\n        break;\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        virDomainVsockDefFree(def->data.vsock);\n        break;\n    case VIR_DOMAIN_DEVICE_LAST:\n    case VIR_DOMAIN_DEVICE_NONE:\n        break;\n    }\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 4322
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 4321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 4318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "_(\"Unsupported device type %d\")",
            "dev->type"
          ],
          "line": 4314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported device type %d\""
          ],
          "line": 4314
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 4311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SaveSettings",
          "args": [
            "machine"
          ],
          "line": 4310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "hostPathUtf16"
          ],
          "line": 4308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "nameUtf16"
          ],
          "line": 4307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not attach shared folder '%s', rc=%08x\")",
            "dev->data.fs->dst",
            "(unsigned)rc"
          ],
          "line": 4299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.CreateSharedFolder",
          "args": [
            "machine",
            "nameUtf16",
            "hostPathUtf16",
            "writable",
            "PR_FALSE"
          ],
          "line": 4295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "dev->data.fs->src->path",
            "&hostPathUtf16"
          ],
          "line": 4292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "dev->data.fs->dst",
            "&nameUtf16"
          ],
          "line": 4291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_SUCCEEDED",
          "args": [
            "rc"
          ],
          "line": 4282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetMachine",
          "args": [
            "data->vboxSession",
            "&machine"
          ],
          "line": 4280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Open",
          "args": [
            "data",
            "&iid",
            "machine"
          ],
          "line": 4274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.OpenExisting",
          "args": [
            "data",
            "&iid",
            "machine"
          ],
          "line": 4272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Paused",
          "args": [
            "state"
          ],
          "line": 4271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Running",
          "args": [
            "state"
          ],
          "line": 4270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 4268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 4262
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDeviceDefParse",
          "args": [
            "xml",
            "def",
            "data->xmlopt",
            "NULL",
            "VIR_DOMAIN_DEF_PARSE_INACTIVE"
          ],
          "line": 4257
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceDefParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "16792-16961",
          "snippet": "virDomainDeviceDefPtr\nvirDomainDeviceDefParse(const char *xmlStr,\n                        const virDomainDef *def,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    g_autoptr(xmlDoc) xml = NULL;\n    xmlNodePtr node;\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autoptr(virDomainDeviceDef) dev = NULL;\n\n    if (!(xml = virXMLParseStringCtxt(xmlStr, _(\"(device_definition)\"), &ctxt)))\n        return NULL;\n\n    node = ctxt->node;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    if ((dev->type = virDomainDeviceTypeFromString((const char *) node->name)) < 0) {\n        /* Some crazy mapping of serial, parallel, console and channel to\n         * VIR_DOMAIN_DEVICE_CHR. */\n        if (virXMLNodeNameEqual(node, \"channel\") ||\n            virXMLNodeNameEqual(node, \"console\") ||\n            virXMLNodeNameEqual(node, \"parallel\") ||\n            virXMLNodeNameEqual(node, \"serial\")) {\n            dev->type = VIR_DOMAIN_DEVICE_CHR;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown device type '%s'\"),\n                           node->name);\n            return NULL;\n        }\n    }\n\n    switch ((virDomainDeviceType) dev->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        if (!(dev->data.disk = virDomainDiskDefParseXML(xmlopt, node, ctxt,\n                                                        flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_LEASE:\n        if (!(dev->data.lease = virDomainLeaseDefParseXML(node)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_FS:\n        if (!(dev->data.fs = virDomainFSDefParseXML(xmlopt, node, ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_NET:\n        if (!(dev->data.net = virDomainNetDefParseXML(xmlopt, node, ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_INPUT:\n        if (!(dev->data.input = virDomainInputDefParseXML(xmlopt, def, node,\n                                                          ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_SOUND:\n        if (!(dev->data.sound = virDomainSoundDefParseXML(xmlopt, node,\n                                                          ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        if (!(dev->data.watchdog = virDomainWatchdogDefParseXML(xmlopt,\n                                                                node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        if (!(dev->data.video = virDomainVideoDefParseXML(xmlopt, node,\n                                                          ctxt, def, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n        if (!(dev->data.hostdev = virDomainHostdevDefParseXML(xmlopt, node,\n                                                              ctxt,\n                                                              flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n        if (!(dev->data.controller = virDomainControllerDefParseXML(xmlopt, node,\n                                                                    ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n        if (!(dev->data.graphics = virDomainGraphicsDefParseXML(xmlopt, node,\n                                                                ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_HUB:\n        if (!(dev->data.hub = virDomainHubDefParseXML(xmlopt, node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n        if (!(dev->data.redirdev = virDomainRedirdevDefParseXML(xmlopt, node,\n                                                                ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_RNG:\n        if (!(dev->data.rng = virDomainRNGDefParseXML(xmlopt, node,\n                                                      ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_CHR:\n        if (!(dev->data.chr = virDomainChrDefParseXML(xmlopt,\n                                                      ctxt,\n                                                      node,\n                                                      flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        if (!(dev->data.smartcard = virDomainSmartcardDefParseXML(xmlopt, node,\n                                                                  ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        if (!(dev->data.memballoon = virDomainMemballoonDefParseXML(xmlopt,\n                                                                    node,\n                                                                    ctxt,\n                                                                    flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_NVRAM:\n        if (!(dev->data.nvram = virDomainNVRAMDefParseXML(xmlopt, node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        if (!(dev->data.shmem = virDomainShmemDefParseXML(xmlopt, node,\n                                                          ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_TPM:\n        if (!(dev->data.tpm = virDomainTPMDefParseXML(xmlopt, node, ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_PANIC:\n        if (!(dev->data.panic = virDomainPanicDefParseXML(xmlopt, node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_MEMORY:\n        if (!(dev->data.memory = virDomainMemoryDefParseXML(xmlopt, node,\n                                                            ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_IOMMU:\n        if (!(dev->data.iommu = virDomainIOMMUDefParseXML(node, ctxt)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        if (!(dev->data.vsock = virDomainVsockDefParseXML(xmlopt, node, ctxt,\n                                                          flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_NONE:\n    case VIR_DOMAIN_DEVICE_LAST:\n        break;\n    }\n\n    /* callback to fill driver specific device aspects */\n    if (virDomainDeviceDefPostParseOne(dev, def, flags,\n                                       xmlopt, parseOpaque) < 0)\n        return NULL;\n\n    /* validate the configuration */\n    if (virDomainDeviceDefValidate(dev, def, flags, xmlopt) < 0)\n        return NULL;\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDeviceDefPtr\nvirDomainDeviceDefParse(const char *xmlStr,\n                        const virDomainDef *def,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    g_autoptr(xmlDoc) xml = NULL;\n    xmlNodePtr node;\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autoptr(virDomainDeviceDef) dev = NULL;\n\n    if (!(xml = virXMLParseStringCtxt(xmlStr, _(\"(device_definition)\"), &ctxt)))\n        return NULL;\n\n    node = ctxt->node;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    if ((dev->type = virDomainDeviceTypeFromString((const char *) node->name)) < 0) {\n        /* Some crazy mapping of serial, parallel, console and channel to\n         * VIR_DOMAIN_DEVICE_CHR. */\n        if (virXMLNodeNameEqual(node, \"channel\") ||\n            virXMLNodeNameEqual(node, \"console\") ||\n            virXMLNodeNameEqual(node, \"parallel\") ||\n            virXMLNodeNameEqual(node, \"serial\")) {\n            dev->type = VIR_DOMAIN_DEVICE_CHR;\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown device type '%s'\"),\n                           node->name);\n            return NULL;\n        }\n    }\n\n    switch ((virDomainDeviceType) dev->type) {\n    case VIR_DOMAIN_DEVICE_DISK:\n        if (!(dev->data.disk = virDomainDiskDefParseXML(xmlopt, node, ctxt,\n                                                        flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_LEASE:\n        if (!(dev->data.lease = virDomainLeaseDefParseXML(node)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_FS:\n        if (!(dev->data.fs = virDomainFSDefParseXML(xmlopt, node, ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_NET:\n        if (!(dev->data.net = virDomainNetDefParseXML(xmlopt, node, ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_INPUT:\n        if (!(dev->data.input = virDomainInputDefParseXML(xmlopt, def, node,\n                                                          ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_SOUND:\n        if (!(dev->data.sound = virDomainSoundDefParseXML(xmlopt, node,\n                                                          ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_WATCHDOG:\n        if (!(dev->data.watchdog = virDomainWatchdogDefParseXML(xmlopt,\n                                                                node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_VIDEO:\n        if (!(dev->data.video = virDomainVideoDefParseXML(xmlopt, node,\n                                                          ctxt, def, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_HOSTDEV:\n        if (!(dev->data.hostdev = virDomainHostdevDefParseXML(xmlopt, node,\n                                                              ctxt,\n                                                              flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_CONTROLLER:\n        if (!(dev->data.controller = virDomainControllerDefParseXML(xmlopt, node,\n                                                                    ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_GRAPHICS:\n        if (!(dev->data.graphics = virDomainGraphicsDefParseXML(xmlopt, node,\n                                                                ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_HUB:\n        if (!(dev->data.hub = virDomainHubDefParseXML(xmlopt, node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_REDIRDEV:\n        if (!(dev->data.redirdev = virDomainRedirdevDefParseXML(xmlopt, node,\n                                                                ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_RNG:\n        if (!(dev->data.rng = virDomainRNGDefParseXML(xmlopt, node,\n                                                      ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_CHR:\n        if (!(dev->data.chr = virDomainChrDefParseXML(xmlopt,\n                                                      ctxt,\n                                                      node,\n                                                      flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_SMARTCARD:\n        if (!(dev->data.smartcard = virDomainSmartcardDefParseXML(xmlopt, node,\n                                                                  ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_MEMBALLOON:\n        if (!(dev->data.memballoon = virDomainMemballoonDefParseXML(xmlopt,\n                                                                    node,\n                                                                    ctxt,\n                                                                    flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_NVRAM:\n        if (!(dev->data.nvram = virDomainNVRAMDefParseXML(xmlopt, node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_SHMEM:\n        if (!(dev->data.shmem = virDomainShmemDefParseXML(xmlopt, node,\n                                                          ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_TPM:\n        if (!(dev->data.tpm = virDomainTPMDefParseXML(xmlopt, node, ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_PANIC:\n        if (!(dev->data.panic = virDomainPanicDefParseXML(xmlopt, node, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_MEMORY:\n        if (!(dev->data.memory = virDomainMemoryDefParseXML(xmlopt, node,\n                                                            ctxt, flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_IOMMU:\n        if (!(dev->data.iommu = virDomainIOMMUDefParseXML(node, ctxt)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_VSOCK:\n        if (!(dev->data.vsock = virDomainVsockDefParseXML(xmlopt, node, ctxt,\n                                                          flags)))\n            return NULL;\n        break;\n    case VIR_DOMAIN_DEVICE_NONE:\n    case VIR_DOMAIN_DEVICE_LAST:\n        break;\n    }\n\n    /* callback to fill driver specific device aspects */\n    if (virDomainDeviceDefPostParseOne(dev, def, flags,\n                                       xmlopt, parseOpaque) < 0)\n        return NULL;\n\n    /* validate the configuration */\n    if (virDomainDeviceDefValidate(dev, def, flags, xmlopt) < 0)\n        return NULL;\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefNew",
          "args": [],
          "line": 4252
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3574-3594",
          "snippet": "virDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 4251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainAttachDeviceImpl(virDomainPtr dom,\n                                      const char *xml,\n                                      int mediaChangeOnly G_GNUC_UNUSED)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 state;\n    virDomainDefPtr def = NULL;\n    virDomainDeviceDefPtr dev = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    if (!(def = virDomainDefNew()))\n        return ret;\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    dev = virDomainDeviceDefParse(xml, def, data->xmlopt, NULL,\n                                  VIR_DOMAIN_DEF_PARSE_INACTIVE);\n    if (dev == NULL)\n        goto cleanup;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state) ||\n        gVBoxAPI.machineStateChecker.Paused(state)) {\n        rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    } else {\n        rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    }\n\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n\n    if (NS_SUCCEEDED(rc) && machine) {\n        /* ret = -VIR_ERR_ARGUMENT_UNSUPPORTED means the current device don't support hotplug. */\n        ret = -VIR_ERR_ARGUMENT_UNSUPPORTED;\n        if (dev->type == VIR_DOMAIN_DEVICE_FS &&\n            dev->data.fs->type == VIR_DOMAIN_FS_TYPE_MOUNT) {\n            PRUnichar *nameUtf16;\n            PRUnichar *hostPathUtf16;\n            PRBool writable;\n\n            VBOX_UTF8_TO_UTF16(dev->data.fs->dst, &nameUtf16);\n            VBOX_UTF8_TO_UTF16(dev->data.fs->src->path, &hostPathUtf16);\n            writable = !dev->data.fs->readonly;\n\n            rc = gVBoxAPI.UIMachine.CreateSharedFolder(machine, nameUtf16, hostPathUtf16,\n                                                       writable, PR_FALSE);\n\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not attach shared folder '%s', rc=%08x\"),\n                               dev->data.fs->dst, (unsigned)rc);\n                ret = -1;\n            } else {\n                ret = 0;\n            }\n\n            VBOX_UTF16_FREE(nameUtf16);\n            VBOX_UTF16_FREE(hostPathUtf16);\n        }\n        gVBoxAPI.UIMachine.SaveSettings(machine);\n        VBOX_RELEASE(machine);\n\n        if (ret == -VIR_ERR_ARGUMENT_UNSUPPORTED) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, _(\"Unsupported device type %d\"), dev->type);\n            ret = -1;\n        }\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    vboxIIDUnalloc(&iid);\n    virDomainDefFree(def);\n    virDomainDeviceDefFree(dev);\n    return ret;\n}"
  },
  {
    "function_name": "vboxConnectNumOfDefinedDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "4192-4233",
    "snippet": "static int vboxConnectNumOfDefinedDomains(virConnectPtr conn)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    PRUint32 state;\n    nsresult rc;\n    size_t i;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj,\n                                      ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get number of Defined Domains, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n    for (i = 0; i < machines.count; ++i) {\n        PRBool isAccessible = PR_FALSE;\n        IMachine *machine = machines.items[i];\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (!isAccessible)\n            continue;\n\n        gVBoxAPI.UIMachine.GetState(machine, &state);\n        if (gVBoxAPI.machineStateChecker.Inactive(state))\n            ret++;\n    }\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&machines"
          ],
          "line": 4231
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Inactive",
          "args": [
            "state"
          ],
          "line": 4226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 4225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 4221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get number of Defined Domains, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 4207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not get number of Defined Domains, rc=%08x\""
          ],
          "line": 4208
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&machines",
            "data->vboxObj",
            "ARRAY_GET_MACHINES"
          ],
          "line": 4204
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxConnectNumOfDefinedDomains(virConnectPtr conn)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    PRUint32 state;\n    nsresult rc;\n    size_t i;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj,\n                                      ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get number of Defined Domains, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n    for (i = 0; i < machines.count; ++i) {\n        PRBool isAccessible = PR_FALSE;\n        IMachine *machine = machines.items[i];\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (!isAccessible)\n            continue;\n\n        gVBoxAPI.UIMachine.GetState(machine, &state);\n        if (gVBoxAPI.machineStateChecker.Inactive(state))\n            ret++;\n    }\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n    return ret;\n}"
  },
  {
    "function_name": "vboxConnectListDefinedDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "4136-4190",
    "snippet": "static int vboxConnectListDefinedDomains(virConnectPtr conn,\n                                         char ** const names, int maxnames)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    char *machineName = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    PRUint32 state;\n    nsresult rc;\n    size_t i, j;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj,\n                                      ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of Defined Domains, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    memset(names, 0, sizeof(names[i]) * maxnames);\n\n    ret = 0;\n    for (i = 0, j = 0; (i < machines.count) && (j < maxnames); i++) {\n        PRBool isAccessible = PR_FALSE;\n        IMachine *machine = machines.items[i];\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (!isAccessible)\n            continue;\n\n        gVBoxAPI.UIMachine.GetState(machine, &state);\n        if (!gVBoxAPI.machineStateChecker.Inactive(state))\n            continue;\n\n        gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n        VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineName);\n        names[j] = g_strdup(machineName);\n        VBOX_UTF16_FREE(machineNameUtf16);\n        VBOX_UTF8_FREE(machineName);\n        j++;\n        ret++;\n    }\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&machines"
          ],
          "line": 4188
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "machineName"
          ],
          "line": 4182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "machineNameUtf16"
          ],
          "line": 4181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "machineName"
          ],
          "line": 4180
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "machineNameUtf16",
            "&machineName"
          ],
          "line": 4179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetName",
          "args": [
            "machine",
            "&machineNameUtf16"
          ],
          "line": 4178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Inactive",
          "args": [
            "state"
          ],
          "line": 4175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 4174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 4170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "names",
            "0",
            "sizeof(names[i]) * maxnames"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get list of Defined Domains, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 4154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not get list of Defined Domains, rc=%08x\""
          ],
          "line": 4155
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 4153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&machines",
            "data->vboxObj",
            "ARRAY_GET_MACHINES"
          ],
          "line": 4151
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxConnectListDefinedDomains(virConnectPtr conn,\n                                         char ** const names, int maxnames)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    char *machineName = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    PRUint32 state;\n    nsresult rc;\n    size_t i, j;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj,\n                                      ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of Defined Domains, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    memset(names, 0, sizeof(names[i]) * maxnames);\n\n    ret = 0;\n    for (i = 0, j = 0; (i < machines.count) && (j < maxnames); i++) {\n        PRBool isAccessible = PR_FALSE;\n        IMachine *machine = machines.items[i];\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (!isAccessible)\n            continue;\n\n        gVBoxAPI.UIMachine.GetState(machine, &state);\n        if (!gVBoxAPI.machineStateChecker.Inactive(state))\n            continue;\n\n        gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n        VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineName);\n        names[j] = g_strdup(machineName);\n        VBOX_UTF16_FREE(machineNameUtf16);\n        VBOX_UTF8_FREE(machineName);\n        j++;\n        ret++;\n    }\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "3978-4134",
    "snippet": "static char *vboxDomainGetXMLDesc(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    virDomainDefPtr def = NULL;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRBool accessible = PR_FALSE;\n    size_t i = 0;\n    PRBool PAEEnabled = PR_FALSE;\n    PRBool ACPIEnabled = PR_FALSE;\n    PRBool IOAPICEnabled = PR_FALSE;\n    PRUint32 CPUCount = 0;\n    PRUint32 memorySize = 0;\n    PRUint32 networkAdapterCount = 0;\n    PRUint32 maxMemorySize = 4 * 1024;\n    PRUint32 maxBootPosition = 0;\n    PRUint32 serialPortCount = 0;\n    PRUint32 parallelPortCount = 0;\n    IBIOSSettings *bios = NULL;\n    PRUint32 chipsetType = ChipsetType_Null;\n    ISystemProperties *systemProperties = NULL;\n    char *ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(VIR_DOMAIN_XML_COMMON_FLAGS, NULL);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &accessible);\n    if (!accessible)\n        goto cleanup;\n\n    def->virtType = VIR_DOMAIN_VIRT_VBOX;\n    def->id = dom->id;\n    memcpy(def->uuid, dom->uuid, VIR_UUID_BUFLEN);\n    def->name = g_strdup(dom->name);\n\n    gVBoxAPI.UIMachine.GetMemorySize(machine, &memorySize);\n    def->mem.cur_balloon = memorySize * 1024;\n\n    if (gVBoxAPI.chipsetType)\n        gVBoxAPI.UIMachine.GetChipsetType(machine, &chipsetType);\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetMaxGuestRAM(systemProperties, &maxMemorySize);\n        gVBoxAPI.UISystemProperties.GetMaxBootPosition(systemProperties, &maxBootPosition);\n        gVBoxAPI.UISystemProperties.GetMaxNetworkAdapters(systemProperties, chipsetType, &networkAdapterCount);\n        gVBoxAPI.UISystemProperties.GetSerialPortCount(systemProperties, &serialPortCount);\n        gVBoxAPI.UISystemProperties.GetParallelPortCount(systemProperties, &parallelPortCount);\n        VBOX_RELEASE(systemProperties);\n        systemProperties = NULL;\n    }\n    /* Currently setting memory and maxMemory as same, cause\n     * the notation here seems to be inconsistent while\n     * reading and while dumping xml\n     */\n    /* def->mem.max_balloon = maxMemorySize * 1024; */\n    virDomainDefSetMemoryTotal(def, memorySize * 1024);\n\n    gVBoxAPI.UIMachine.GetCPUCount(machine, &CPUCount);\n    if (virDomainDefSetVcpusMax(def, CPUCount, data->xmlopt) < 0)\n        goto cleanup;\n\n    if (virDomainDefSetVcpus(def, CPUCount) < 0)\n        goto cleanup;\n\n    /* Skip cpumasklen, cpumask, onReboot, onPoweroff, onCrash */\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n    def->os.arch = virArchFromHost();\n\n    def->os.nBootDevs = 0;\n    for (i = 0; (i < VIR_DOMAIN_BOOT_LAST) && (i < maxBootPosition); i++) {\n        PRUint32 device = DeviceType_Null;\n\n        gVBoxAPI.UIMachine.GetBootOrder(machine, i+1, &device);\n\n        if (device == DeviceType_Floppy) {\n            def->os.bootDevs[i] = VIR_DOMAIN_BOOT_FLOPPY;\n            def->os.nBootDevs++;\n        } else if (device == DeviceType_DVD) {\n            def->os.bootDevs[i] = VIR_DOMAIN_BOOT_CDROM;\n            def->os.nBootDevs++;\n        } else if (device == DeviceType_HardDisk) {\n            def->os.bootDevs[i] = VIR_DOMAIN_BOOT_DISK;\n            def->os.nBootDevs++;\n        } else if (device == DeviceType_Network) {\n            def->os.bootDevs[i] = VIR_DOMAIN_BOOT_NET;\n            def->os.nBootDevs++;\n        } else if (device == DeviceType_USB) {\n            /* Not supported by libvirt yet */\n        } else if (device == DeviceType_SharedFolder) {\n            /* Not supported by libvirt yet */\n            /* Can VirtualBox really boot from a shared folder? */\n        }\n    }\n\n    gVBoxAPI.UIMachine.GetCPUProperty(machine, CPUPropertyType_PAE, &PAEEnabled);\n    if (PAEEnabled)\n        def->features[VIR_DOMAIN_FEATURE_PAE] = VIR_TRISTATE_SWITCH_ON;\n\n    gVBoxAPI.UIMachine.GetBIOSSettings(machine, &bios);\n    if (bios) {\n        gVBoxAPI.UIBIOSSettings.GetACPIEnabled(bios, &ACPIEnabled);\n        if (ACPIEnabled)\n            def->features[VIR_DOMAIN_FEATURE_ACPI] = VIR_TRISTATE_SWITCH_ON;\n\n        gVBoxAPI.UIBIOSSettings.GetIOAPICEnabled(bios, &IOAPICEnabled);\n        if (IOAPICEnabled)\n            def->features[VIR_DOMAIN_FEATURE_APIC] = VIR_TRISTATE_SWITCH_ON;\n\n        VBOX_RELEASE(bios);\n    }\n\n    /* Currently VirtualBox always uses locatime\n     * so locatime is always true here */\n    def->clock.offset = VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME;\n\n    if (vboxDumpVideo(def, data, machine) < 0)\n        goto cleanup;\n    if (vboxDumpDisplay(def, data, machine) < 0)\n        goto cleanup;\n    if (vboxDumpStorageControllers(def, machine) < 0)\n        goto cleanup;\n    if (vboxDumpDisks(def, data, machine) < 0)\n        goto cleanup;\n\n    if (vboxDumpSharedFolders(def, data, machine) < 0)\n        goto cleanup;\n    if (vboxDumpNetworks(def, data, machine, networkAdapterCount) < 0)\n        goto cleanup;\n    vboxDumpAudio(def, data, machine);\n\n    if (vboxDumpSerial(def, data, machine, serialPortCount) < 0)\n        goto cleanup;\n    if (vboxDumpParallel(def, data, machine, parallelPortCount) < 0)\n        goto cleanup;\n\n    /* dump USB devices/filters if active */\n    vboxHostDeviceGetXMLDesc(data, def, machine);\n\n    ret = virDomainDefFormat(def, data->xmlopt,\n                             virDomainDefFormatConvertXMLFlags(flags));\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    virDomainDefFree(def);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 4132
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 4131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 4130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefFormat",
          "args": [
            "def",
            "data->xmlopt",
            "virDomainDefFormatConvertXMLFlags(flags)"
          ],
          "line": 4126
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29496-29508",
          "snippet": "char *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)\n\nchar *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormatConvertXMLFlags",
          "args": [
            "flags"
          ],
          "line": 4127
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormatConvertXMLFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29481-29493",
          "snippet": "unsigned int virDomainDefFormatConvertXMLFlags(unsigned int flags)\n{\n    unsigned int formatFlags = 0;\n\n    if (flags & VIR_DOMAIN_XML_SECURE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_SECURE;\n    if (flags & VIR_DOMAIN_XML_INACTIVE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_INACTIVE;\n    if (flags & VIR_DOMAIN_XML_MIGRATABLE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_MIGRATABLE;\n\n    return formatFlags;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int virDomainDefFormatConvertXMLFlags(unsigned int flags)\n{\n    unsigned int formatFlags = 0;\n\n    if (flags & VIR_DOMAIN_XML_SECURE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_SECURE;\n    if (flags & VIR_DOMAIN_XML_INACTIVE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_INACTIVE;\n    if (flags & VIR_DOMAIN_XML_MIGRATABLE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_MIGRATABLE;\n\n    return formatFlags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxHostDeviceGetXMLDesc",
          "args": [
            "data",
            "def",
            "machine"
          ],
          "line": 4124
        },
        "resolved": true,
        "details": {
          "function_name": "vboxHostDeviceGetXMLDesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "2946-3050",
          "snippet": "static void\nvboxHostDeviceGetXMLDesc(vboxDriverPtr data, virDomainDefPtr def, IMachine *machine)\n{\n    IUSBCommon *USBCommon = NULL;\n    PRBool enabled = PR_FALSE;\n    vboxArray deviceFilters = VBOX_ARRAY_INITIALIZER;\n    size_t i;\n    PRUint32 USBFilterCount = 0;\n\n    def->nhostdevs = 0;\n\n    gVBoxAPI.UIMachine.GetUSBCommon(machine, &USBCommon);\n    if (!USBCommon)\n        return;\n\n    gVBoxAPI.UIUSBCommon.GetEnabled(USBCommon, &enabled);\n    if (!enabled)\n        goto release_controller;\n\n    gVBoxAPI.UArray.vboxArrayGet(&deviceFilters, USBCommon,\n                                 gVBoxAPI.UArray.handleUSBGetDeviceFilters(USBCommon));\n\n    if (deviceFilters.count <= 0)\n        goto release_filters;\n\n    /* check if the filters are active and then only\n     * alloc mem and set def->nhostdevs\n     */\n\n    for (i = 0; i < deviceFilters.count; i++) {\n        PRBool active = PR_FALSE;\n        IUSBDeviceFilter *deviceFilter = deviceFilters.items[i];\n\n        gVBoxAPI.UIUSBDeviceFilter.GetActive(deviceFilter, &active);\n        if (active)\n            def->nhostdevs++;\n    }\n\n    if (def->nhostdevs == 0)\n        goto release_filters;\n\n    /* Alloc mem needed for the filters now */\n    if (VIR_ALLOC_N(def->hostdevs, def->nhostdevs) < 0)\n        goto release_filters;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        def->hostdevs[i] = virDomainHostdevDefNew();\n        if (!def->hostdevs[i])\n            goto release_hostdevs;\n    }\n\n    for (i = 0; i < deviceFilters.count; i++) {\n        PRBool active = PR_FALSE;\n        IUSBDeviceFilter *deviceFilter = deviceFilters.items[i];\n        PRUnichar *vendorIdUtf16 = NULL;\n        char *vendorIdUtf8 = NULL;\n        unsigned vendorId = 0;\n        PRUnichar *productIdUtf16 = NULL;\n        char *productIdUtf8 = NULL;\n        unsigned productId = 0;\n        char *endptr = NULL;\n\n        gVBoxAPI.UIUSBDeviceFilter.GetActive(deviceFilter, &active);\n        if (!active)\n            continue;\n\n        def->hostdevs[USBFilterCount]->mode =\n            VIR_DOMAIN_HOSTDEV_MODE_SUBSYS;\n        def->hostdevs[USBFilterCount]->source.subsys.type =\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB;\n\n        gVBoxAPI.UIUSBDeviceFilter.GetVendorId(deviceFilter, &vendorIdUtf16);\n        gVBoxAPI.UIUSBDeviceFilter.GetProductId(deviceFilter, &productIdUtf16);\n\n        VBOX_UTF16_TO_UTF8(vendorIdUtf16, &vendorIdUtf8);\n        VBOX_UTF16_TO_UTF8(productIdUtf16, &productIdUtf8);\n\n        ignore_value(virStrToLong_ui(vendorIdUtf8, &endptr, 16, &vendorId));\n        ignore_value(virStrToLong_ui(productIdUtf8, &endptr, 16, &productId));\n\n        def->hostdevs[USBFilterCount]->source.subsys.u.usb.vendor = vendorId;\n        def->hostdevs[USBFilterCount]->source.subsys.u.usb.product = productId;\n\n        VBOX_UTF16_FREE(vendorIdUtf16);\n        VBOX_UTF8_FREE(vendorIdUtf8);\n\n        VBOX_UTF16_FREE(productIdUtf16);\n        VBOX_UTF8_FREE(productIdUtf8);\n\n        USBFilterCount++;\n    }\n\n release_filters:\n    gVBoxAPI.UArray.vboxArrayRelease(&deviceFilters);\n release_controller:\n    VBOX_RELEASE(USBCommon);\n    return;\n\n release_hostdevs:\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    goto release_filters;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxHostDeviceGetXMLDesc(vboxDriverPtr data, virDomainDefPtr def, IMachine *machine)\n{\n    IUSBCommon *USBCommon = NULL;\n    PRBool enabled = PR_FALSE;\n    vboxArray deviceFilters = VBOX_ARRAY_INITIALIZER;\n    size_t i;\n    PRUint32 USBFilterCount = 0;\n\n    def->nhostdevs = 0;\n\n    gVBoxAPI.UIMachine.GetUSBCommon(machine, &USBCommon);\n    if (!USBCommon)\n        return;\n\n    gVBoxAPI.UIUSBCommon.GetEnabled(USBCommon, &enabled);\n    if (!enabled)\n        goto release_controller;\n\n    gVBoxAPI.UArray.vboxArrayGet(&deviceFilters, USBCommon,\n                                 gVBoxAPI.UArray.handleUSBGetDeviceFilters(USBCommon));\n\n    if (deviceFilters.count <= 0)\n        goto release_filters;\n\n    /* check if the filters are active and then only\n     * alloc mem and set def->nhostdevs\n     */\n\n    for (i = 0; i < deviceFilters.count; i++) {\n        PRBool active = PR_FALSE;\n        IUSBDeviceFilter *deviceFilter = deviceFilters.items[i];\n\n        gVBoxAPI.UIUSBDeviceFilter.GetActive(deviceFilter, &active);\n        if (active)\n            def->nhostdevs++;\n    }\n\n    if (def->nhostdevs == 0)\n        goto release_filters;\n\n    /* Alloc mem needed for the filters now */\n    if (VIR_ALLOC_N(def->hostdevs, def->nhostdevs) < 0)\n        goto release_filters;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        def->hostdevs[i] = virDomainHostdevDefNew();\n        if (!def->hostdevs[i])\n            goto release_hostdevs;\n    }\n\n    for (i = 0; i < deviceFilters.count; i++) {\n        PRBool active = PR_FALSE;\n        IUSBDeviceFilter *deviceFilter = deviceFilters.items[i];\n        PRUnichar *vendorIdUtf16 = NULL;\n        char *vendorIdUtf8 = NULL;\n        unsigned vendorId = 0;\n        PRUnichar *productIdUtf16 = NULL;\n        char *productIdUtf8 = NULL;\n        unsigned productId = 0;\n        char *endptr = NULL;\n\n        gVBoxAPI.UIUSBDeviceFilter.GetActive(deviceFilter, &active);\n        if (!active)\n            continue;\n\n        def->hostdevs[USBFilterCount]->mode =\n            VIR_DOMAIN_HOSTDEV_MODE_SUBSYS;\n        def->hostdevs[USBFilterCount]->source.subsys.type =\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB;\n\n        gVBoxAPI.UIUSBDeviceFilter.GetVendorId(deviceFilter, &vendorIdUtf16);\n        gVBoxAPI.UIUSBDeviceFilter.GetProductId(deviceFilter, &productIdUtf16);\n\n        VBOX_UTF16_TO_UTF8(vendorIdUtf16, &vendorIdUtf8);\n        VBOX_UTF16_TO_UTF8(productIdUtf16, &productIdUtf8);\n\n        ignore_value(virStrToLong_ui(vendorIdUtf8, &endptr, 16, &vendorId));\n        ignore_value(virStrToLong_ui(productIdUtf8, &endptr, 16, &productId));\n\n        def->hostdevs[USBFilterCount]->source.subsys.u.usb.vendor = vendorId;\n        def->hostdevs[USBFilterCount]->source.subsys.u.usb.product = productId;\n\n        VBOX_UTF16_FREE(vendorIdUtf16);\n        VBOX_UTF8_FREE(vendorIdUtf8);\n\n        VBOX_UTF16_FREE(productIdUtf16);\n        VBOX_UTF8_FREE(productIdUtf8);\n\n        USBFilterCount++;\n    }\n\n release_filters:\n    gVBoxAPI.UArray.vboxArrayRelease(&deviceFilters);\n release_controller:\n    VBOX_RELEASE(USBCommon);\n    return;\n\n release_hostdevs:\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    goto release_filters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDumpParallel",
          "args": [
            "def",
            "data",
            "machine",
            "parallelPortCount"
          ],
          "line": 4120
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDumpParallel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "3897-3976",
          "snippet": "static int\nvboxDumpParallel(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine, PRUint32 parallelPortCount)\n{\n    PRUint32 parallelPortIncCount = 0;\n    size_t i = 0;\n    /* dump parallel ports if active */\n    def->nparallels = 0;\n    /* Get which parallel ports are enabled/active */\n    for (i = 0; i < parallelPortCount; i++) {\n        IParallelPort *parallelPort = NULL;\n\n        gVBoxAPI.UIMachine.GetParallelPort(machine, i, &parallelPort);\n        if (parallelPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UIParallelPort.GetEnabled(parallelPort, &enabled);\n            if (enabled)\n                def->nparallels++;\n\n            VBOX_RELEASE(parallelPort);\n        }\n    }\n\n    /* Allocate memory for the parallel ports which are enabled */\n    if (def->nparallels > 0) {\n        if (VIR_ALLOC_N(def->parallels, def->nparallels) < 0)\n            return -1;\n\n        for (i = 0; i < def->nparallels; i++) {\n            def->parallels[i] = virDomainChrDefNew(NULL);\n            if (!def->parallels[i])\n                return -1;\n        }\n    }\n\n    /* Now get the details about the parallel ports here */\n    for (i = 0;\n         parallelPortIncCount < def->nparallels &&\n             i < parallelPortCount;\n         i++) {\n        IParallelPort *parallelPort = NULL;\n\n        gVBoxAPI.UIMachine.GetParallelPort(machine, i, &parallelPort);\n        if (parallelPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UIParallelPort.GetEnabled(parallelPort, &enabled);\n            if (enabled) {\n                PRUint32 IOBase = 0;\n                PRUint32 IRQ = 0;\n                PRUnichar *pathUtf16 = NULL;\n                char *path = NULL;\n\n                gVBoxAPI.UIParallelPort.GetIRQ(parallelPort, &IRQ);\n                gVBoxAPI.UIParallelPort.GetIOBase(parallelPort, &IOBase);\n                if ((IRQ == 7) && (IOBase == 888)) {\n                    def->parallels[parallelPortIncCount]->target.port = 0;\n                } else if ((IRQ == 5) && (IOBase == 632)) {\n                    def->parallels[parallelPortIncCount]->target.port = 1;\n                }\n\n                def->parallels[parallelPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n                def->parallels[parallelPortIncCount]->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_PARALLEL;\n\n                gVBoxAPI.UIParallelPort.GetPath(parallelPort, &pathUtf16);\n\n                VBOX_UTF16_TO_UTF8(pathUtf16, &path);\n                def->parallels[parallelPortIncCount]->source->data.file.path = g_strdup(path);\n\n                parallelPortIncCount++;\n\n                VBOX_UTF16_FREE(pathUtf16);\n                VBOX_UTF8_FREE(path);\n            }\n\n            VBOX_RELEASE(parallelPort);\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpParallel(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine, PRUint32 parallelPortCount)\n{\n    PRUint32 parallelPortIncCount = 0;\n    size_t i = 0;\n    /* dump parallel ports if active */\n    def->nparallels = 0;\n    /* Get which parallel ports are enabled/active */\n    for (i = 0; i < parallelPortCount; i++) {\n        IParallelPort *parallelPort = NULL;\n\n        gVBoxAPI.UIMachine.GetParallelPort(machine, i, &parallelPort);\n        if (parallelPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UIParallelPort.GetEnabled(parallelPort, &enabled);\n            if (enabled)\n                def->nparallels++;\n\n            VBOX_RELEASE(parallelPort);\n        }\n    }\n\n    /* Allocate memory for the parallel ports which are enabled */\n    if (def->nparallels > 0) {\n        if (VIR_ALLOC_N(def->parallels, def->nparallels) < 0)\n            return -1;\n\n        for (i = 0; i < def->nparallels; i++) {\n            def->parallels[i] = virDomainChrDefNew(NULL);\n            if (!def->parallels[i])\n                return -1;\n        }\n    }\n\n    /* Now get the details about the parallel ports here */\n    for (i = 0;\n         parallelPortIncCount < def->nparallels &&\n             i < parallelPortCount;\n         i++) {\n        IParallelPort *parallelPort = NULL;\n\n        gVBoxAPI.UIMachine.GetParallelPort(machine, i, &parallelPort);\n        if (parallelPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UIParallelPort.GetEnabled(parallelPort, &enabled);\n            if (enabled) {\n                PRUint32 IOBase = 0;\n                PRUint32 IRQ = 0;\n                PRUnichar *pathUtf16 = NULL;\n                char *path = NULL;\n\n                gVBoxAPI.UIParallelPort.GetIRQ(parallelPort, &IRQ);\n                gVBoxAPI.UIParallelPort.GetIOBase(parallelPort, &IOBase);\n                if ((IRQ == 7) && (IOBase == 888)) {\n                    def->parallels[parallelPortIncCount]->target.port = 0;\n                } else if ((IRQ == 5) && (IOBase == 632)) {\n                    def->parallels[parallelPortIncCount]->target.port = 1;\n                }\n\n                def->parallels[parallelPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n                def->parallels[parallelPortIncCount]->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_PARALLEL;\n\n                gVBoxAPI.UIParallelPort.GetPath(parallelPort, &pathUtf16);\n\n                VBOX_UTF16_TO_UTF8(pathUtf16, &path);\n                def->parallels[parallelPortIncCount]->source->data.file.path = g_strdup(path);\n\n                parallelPortIncCount++;\n\n                VBOX_UTF16_FREE(pathUtf16);\n                VBOX_UTF8_FREE(path);\n            }\n\n            VBOX_RELEASE(parallelPort);\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDumpSerial",
          "args": [
            "def",
            "data",
            "machine",
            "serialPortCount"
          ],
          "line": 4118
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDumpSerial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "3802-3895",
          "snippet": "static int\nvboxDumpSerial(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine, PRUint32 serialPortCount)\n{\n    PRUint32 serialPortIncCount = 0;\n    size_t i = 0;\n    /* dump serial port if active */\n    def->nserials = 0;\n    /* Get which serial ports are enabled/active */\n    for (i = 0; i < serialPortCount; i++) {\n        ISerialPort *serialPort = NULL;\n\n        gVBoxAPI.UIMachine.GetSerialPort(machine, i, &serialPort);\n        if (serialPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UISerialPort.GetEnabled(serialPort, &enabled);\n            if (enabled)\n                def->nserials++;\n\n            VBOX_RELEASE(serialPort);\n        }\n    }\n\n    /* Allocate memory for the serial ports which are enabled */\n    if (def->nserials > 0) {\n        if (VIR_ALLOC_N(def->serials, def->nserials) < 0)\n            return -1;\n\n        for (i = 0; i < def->nserials; i++) {\n            def->serials[i] = virDomainChrDefNew(NULL);\n            if (!def->serials[i])\n                return -1;\n        }\n    }\n\n    /* Now get the details about the serial ports here */\n    for (i = 0;\n         serialPortIncCount < def->nserials && i < serialPortCount;\n         i++) {\n        ISerialPort *serialPort = NULL;\n\n        gVBoxAPI.UIMachine.GetSerialPort(machine, i, &serialPort);\n        if (serialPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UISerialPort.GetEnabled(serialPort, &enabled);\n            if (enabled) {\n                PRUint32 hostMode = PortMode_Disconnected;\n                PRUint32 IOBase = 0;\n                PRUint32 IRQ = 0;\n                PRUnichar *pathUtf16 = NULL;\n                char *path = NULL;\n\n                gVBoxAPI.UISerialPort.GetHostMode(serialPort, &hostMode);\n                if (hostMode == PortMode_HostPipe) {\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_PIPE;\n                } else if (hostMode == PortMode_HostDevice) {\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n                } else if (gVBoxAPI.APIVersion >= 2002051 &&\n                           hostMode == PortMode_RawFile) {\n                    /* PortMode RawFile is used for vbox 3.0 or later */\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n                } else {\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_NULL;\n                }\n\n                def->serials[serialPortIncCount]->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n\n                gVBoxAPI.UISerialPort.GetIRQ(serialPort, &IRQ);\n                gVBoxAPI.UISerialPort.GetIOBase(serialPort, &IOBase);\n                if ((IRQ == 4) && (IOBase == 1016)) {\n                    def->serials[serialPortIncCount]->target.port = 0;\n                } else if ((IRQ == 3) && (IOBase == 760)) {\n                    def->serials[serialPortIncCount]->target.port = 1;\n                }\n\n                gVBoxAPI.UISerialPort.GetPath(serialPort, &pathUtf16);\n\n                if (pathUtf16) {\n                    VBOX_UTF16_TO_UTF8(pathUtf16, &path);\n                    def->serials[serialPortIncCount]->source->data.file.path = g_strdup(path);\n                }\n\n                serialPortIncCount++;\n\n                VBOX_UTF16_FREE(pathUtf16);\n                VBOX_UTF8_FREE(path);\n            }\n\n            VBOX_RELEASE(serialPort);\n        }\n    }\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpSerial(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine, PRUint32 serialPortCount)\n{\n    PRUint32 serialPortIncCount = 0;\n    size_t i = 0;\n    /* dump serial port if active */\n    def->nserials = 0;\n    /* Get which serial ports are enabled/active */\n    for (i = 0; i < serialPortCount; i++) {\n        ISerialPort *serialPort = NULL;\n\n        gVBoxAPI.UIMachine.GetSerialPort(machine, i, &serialPort);\n        if (serialPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UISerialPort.GetEnabled(serialPort, &enabled);\n            if (enabled)\n                def->nserials++;\n\n            VBOX_RELEASE(serialPort);\n        }\n    }\n\n    /* Allocate memory for the serial ports which are enabled */\n    if (def->nserials > 0) {\n        if (VIR_ALLOC_N(def->serials, def->nserials) < 0)\n            return -1;\n\n        for (i = 0; i < def->nserials; i++) {\n            def->serials[i] = virDomainChrDefNew(NULL);\n            if (!def->serials[i])\n                return -1;\n        }\n    }\n\n    /* Now get the details about the serial ports here */\n    for (i = 0;\n         serialPortIncCount < def->nserials && i < serialPortCount;\n         i++) {\n        ISerialPort *serialPort = NULL;\n\n        gVBoxAPI.UIMachine.GetSerialPort(machine, i, &serialPort);\n        if (serialPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UISerialPort.GetEnabled(serialPort, &enabled);\n            if (enabled) {\n                PRUint32 hostMode = PortMode_Disconnected;\n                PRUint32 IOBase = 0;\n                PRUint32 IRQ = 0;\n                PRUnichar *pathUtf16 = NULL;\n                char *path = NULL;\n\n                gVBoxAPI.UISerialPort.GetHostMode(serialPort, &hostMode);\n                if (hostMode == PortMode_HostPipe) {\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_PIPE;\n                } else if (hostMode == PortMode_HostDevice) {\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n                } else if (gVBoxAPI.APIVersion >= 2002051 &&\n                           hostMode == PortMode_RawFile) {\n                    /* PortMode RawFile is used for vbox 3.0 or later */\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n                } else {\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_NULL;\n                }\n\n                def->serials[serialPortIncCount]->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n\n                gVBoxAPI.UISerialPort.GetIRQ(serialPort, &IRQ);\n                gVBoxAPI.UISerialPort.GetIOBase(serialPort, &IOBase);\n                if ((IRQ == 4) && (IOBase == 1016)) {\n                    def->serials[serialPortIncCount]->target.port = 0;\n                } else if ((IRQ == 3) && (IOBase == 760)) {\n                    def->serials[serialPortIncCount]->target.port = 1;\n                }\n\n                gVBoxAPI.UISerialPort.GetPath(serialPort, &pathUtf16);\n\n                if (pathUtf16) {\n                    VBOX_UTF16_TO_UTF8(pathUtf16, &path);\n                    def->serials[serialPortIncCount]->source->data.file.path = g_strdup(path);\n                }\n\n                serialPortIncCount++;\n\n                VBOX_UTF16_FREE(pathUtf16);\n                VBOX_UTF8_FREE(path);\n            }\n\n            VBOX_RELEASE(serialPort);\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDumpAudio",
          "args": [
            "def",
            "data",
            "machine"
          ],
          "line": 4116
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDumpAudio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "3762-3800",
          "snippet": "static void\nvboxDumpAudio(virDomainDefPtr def, vboxDriverPtr data G_GNUC_UNUSED,\n              IMachine *machine)\n{\n    /* dump sound card if active */\n\n    /* Set def->nsounds to one as VirtualBox currently supports\n     * only one sound card\n     */\n    IAudioAdapter *audioAdapter = NULL;\n\n    gVBoxAPI.UIMachine.GetAudioAdapter(machine, &audioAdapter);\n    if (audioAdapter) {\n        PRBool enabled = PR_FALSE;\n\n        gVBoxAPI.UIAudioAdapter.GetEnabled(audioAdapter, &enabled);\n        if (enabled) {\n            PRUint32 audioController = AudioControllerType_AC97;\n\n            def->nsounds = 1;\n            if (VIR_ALLOC_N(def->sounds, def->nsounds) >= 0) {\n                if (VIR_ALLOC(def->sounds[0]) >= 0) {\n                    gVBoxAPI.UIAudioAdapter.GetAudioController(audioAdapter, &audioController);\n                    if (audioController == AudioControllerType_SB16) {\n                        def->sounds[0]->model = VIR_DOMAIN_SOUND_MODEL_SB16;\n                    } else if (audioController == AudioControllerType_AC97) {\n                        def->sounds[0]->model = VIR_DOMAIN_SOUND_MODEL_AC97;\n                    }\n                } else {\n                    VIR_FREE(def->sounds);\n                    def->nsounds = 0;\n                }\n            } else {\n                def->nsounds = 0;\n            }\n        }\n        VBOX_RELEASE(audioAdapter);\n    }\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxDumpAudio(virDomainDefPtr def, vboxDriverPtr data G_GNUC_UNUSED,\n              IMachine *machine)\n{\n    /* dump sound card if active */\n\n    /* Set def->nsounds to one as VirtualBox currently supports\n     * only one sound card\n     */\n    IAudioAdapter *audioAdapter = NULL;\n\n    gVBoxAPI.UIMachine.GetAudioAdapter(machine, &audioAdapter);\n    if (audioAdapter) {\n        PRBool enabled = PR_FALSE;\n\n        gVBoxAPI.UIAudioAdapter.GetEnabled(audioAdapter, &enabled);\n        if (enabled) {\n            PRUint32 audioController = AudioControllerType_AC97;\n\n            def->nsounds = 1;\n            if (VIR_ALLOC_N(def->sounds, def->nsounds) >= 0) {\n                if (VIR_ALLOC(def->sounds[0]) >= 0) {\n                    gVBoxAPI.UIAudioAdapter.GetAudioController(audioAdapter, &audioController);\n                    if (audioController == AudioControllerType_SB16) {\n                        def->sounds[0]->model = VIR_DOMAIN_SOUND_MODEL_SB16;\n                    } else if (audioController == AudioControllerType_AC97) {\n                        def->sounds[0]->model = VIR_DOMAIN_SOUND_MODEL_AC97;\n                    }\n                } else {\n                    VIR_FREE(def->sounds);\n                    def->nsounds = 0;\n                }\n            } else {\n                def->nsounds = 0;\n            }\n        }\n        VBOX_RELEASE(audioAdapter);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDumpNetworks",
          "args": [
            "def",
            "data",
            "machine",
            "networkAdapterCount"
          ],
          "line": 4114
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDumpNetworks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "3734-3760",
          "snippet": "static int\nvboxDumpNetworks(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine, PRUint32 networkAdapterCount)\n{\n    size_t i = 0;\n\n    for (i = 0; i < networkAdapterCount; i++) {\n        INetworkAdapter *adapter = NULL;\n        virDomainNetDefPtr net = NULL;\n        PRBool enabled = PR_FALSE;\n\n        gVBoxAPI.UIMachine.GetNetworkAdapter(machine, i, &adapter);\n        if (adapter)\n            gVBoxAPI.UINetworkAdapter.GetEnabled(adapter, &enabled);\n\n        if (enabled) {\n            net = vboxDumpNetwork(data, adapter);\n            if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0) {\n                VBOX_RELEASE(adapter);\n                return -1;\n            }\n        }\n\n        VBOX_RELEASE(adapter);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpNetworks(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine, PRUint32 networkAdapterCount)\n{\n    size_t i = 0;\n\n    for (i = 0; i < networkAdapterCount; i++) {\n        INetworkAdapter *adapter = NULL;\n        virDomainNetDefPtr net = NULL;\n        PRBool enabled = PR_FALSE;\n\n        gVBoxAPI.UIMachine.GetNetworkAdapter(machine, i, &adapter);\n        if (adapter)\n            gVBoxAPI.UINetworkAdapter.GetEnabled(adapter, &enabled);\n\n        if (enabled) {\n            net = vboxDumpNetwork(data, adapter);\n            if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0) {\n                VBOX_RELEASE(adapter);\n                return -1;\n            }\n        }\n\n        VBOX_RELEASE(adapter);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDumpSharedFolders",
          "args": [
            "def",
            "data",
            "machine"
          ],
          "line": 4112
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDumpSharedFolders",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "3578-3635",
          "snippet": "static int\nvboxDumpSharedFolders(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    vboxArray sharedFolders = VBOX_ARRAY_INITIALIZER;\n    size_t i = 0;\n    int ret = -1;\n\n    def->nfss = 0;\n\n    gVBoxAPI.UArray.vboxArrayGet(&sharedFolders, machine,\n                                 gVBoxAPI.UArray.handleMachineGetSharedFolders(machine));\n\n    if (sharedFolders.count <= 0) {\n        if (sharedFolders.count == 0)\n            ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->fss, sharedFolders.count) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sharedFolders.count; i++) {\n        ISharedFolder *sharedFolder = sharedFolders.items[i];\n        PRUnichar *nameUtf16 = NULL;\n        char *name = NULL;\n        PRUnichar *hostPathUtf16 = NULL;\n        char *hostPath = NULL;\n        PRBool writable = PR_FALSE;\n\n        if (VIR_ALLOC(def->fss[i]) < 0)\n            goto cleanup;\n\n        def->fss[i]->type = VIR_DOMAIN_FS_TYPE_MOUNT;\n\n        gVBoxAPI.UISharedFolder.GetHostPath(sharedFolder, &hostPathUtf16);\n        VBOX_UTF16_TO_UTF8(hostPathUtf16, &hostPath);\n        def->fss[i]->src->path = g_strdup(hostPath);\n        VBOX_UTF8_FREE(hostPath);\n        VBOX_UTF16_FREE(hostPathUtf16);\n\n        gVBoxAPI.UISharedFolder.GetName(sharedFolder, &nameUtf16);\n        VBOX_UTF16_TO_UTF8(nameUtf16, &name);\n        def->fss[i]->dst = g_strdup(name);\n        VBOX_UTF8_FREE(name);\n        VBOX_UTF16_FREE(nameUtf16);\n\n        gVBoxAPI.UISharedFolder.GetWritable(sharedFolder, &writable);\n        def->fss[i]->readonly = !writable;\n\n        ++def->nfss;\n    }\n\n    ret = 0;\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&sharedFolders);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpSharedFolders(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    vboxArray sharedFolders = VBOX_ARRAY_INITIALIZER;\n    size_t i = 0;\n    int ret = -1;\n\n    def->nfss = 0;\n\n    gVBoxAPI.UArray.vboxArrayGet(&sharedFolders, machine,\n                                 gVBoxAPI.UArray.handleMachineGetSharedFolders(machine));\n\n    if (sharedFolders.count <= 0) {\n        if (sharedFolders.count == 0)\n            ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->fss, sharedFolders.count) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sharedFolders.count; i++) {\n        ISharedFolder *sharedFolder = sharedFolders.items[i];\n        PRUnichar *nameUtf16 = NULL;\n        char *name = NULL;\n        PRUnichar *hostPathUtf16 = NULL;\n        char *hostPath = NULL;\n        PRBool writable = PR_FALSE;\n\n        if (VIR_ALLOC(def->fss[i]) < 0)\n            goto cleanup;\n\n        def->fss[i]->type = VIR_DOMAIN_FS_TYPE_MOUNT;\n\n        gVBoxAPI.UISharedFolder.GetHostPath(sharedFolder, &hostPathUtf16);\n        VBOX_UTF16_TO_UTF8(hostPathUtf16, &hostPath);\n        def->fss[i]->src->path = g_strdup(hostPath);\n        VBOX_UTF8_FREE(hostPath);\n        VBOX_UTF16_FREE(hostPathUtf16);\n\n        gVBoxAPI.UISharedFolder.GetName(sharedFolder, &nameUtf16);\n        VBOX_UTF16_TO_UTF8(nameUtf16, &name);\n        def->fss[i]->dst = g_strdup(name);\n        VBOX_UTF8_FREE(name);\n        VBOX_UTF16_FREE(nameUtf16);\n\n        gVBoxAPI.UISharedFolder.GetWritable(sharedFolder, &writable);\n        def->fss[i]->readonly = !writable;\n\n        ++def->nfss;\n    }\n\n    ret = 0;\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&sharedFolders);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDumpDisks",
          "args": [
            "def",
            "data",
            "machine"
          ],
          "line": 4109
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDumpDisks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "3162-3421",
          "snippet": "static int\nvboxDumpDisks(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    vboxArray mediumAttachments = VBOX_ARRAY_INITIALIZER;\n    int ret = -1;\n    IMediumAttachment *mediumAttachment = NULL;\n    IMedium *medium = NULL;\n    IStorageController *controller = NULL;\n    PRUnichar *controllerName = NULL, *mediumLocUtf16 = NULL;\n    PRUint32 deviceType, storageBus;\n    PRInt32 devicePort, deviceSlot;\n    PRBool readOnly;\n    nsresult rc;\n    virDomainDiskDefPtr disk = NULL;\n    virDomainControllerDefPtr ctrl = NULL;\n    char *mediumLocUtf8 = NULL;\n    size_t sdCount = 0, i, j;\n\n    def->ndisks = 0;\n    gVBoxAPI.UArray.vboxArrayGet(&mediumAttachments, machine,\n                 gVBoxAPI.UArray.handleMachineGetMediumAttachments(machine));\n\n    /* get the number of attachments */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        mediumAttachment = mediumAttachments.items[i];\n        if (!mediumAttachment)\n            continue;\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(mediumAttachment, &medium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get IMedium, rc=%08x\"), rc);\n            goto cleanup;\n        }\n\n        def->ndisks++;\n        VBOX_RELEASE(medium);\n    }\n\n    /* Allocate mem, if fails return error */\n    if (VIR_ALLOC_N(def->disks, def->ndisks) < 0)\n        goto cleanup;\n\n    for (i = 0; i < def->ndisks; i++) {\n        disk = virDomainDiskDefNew(NULL);\n        if (!disk)\n            goto cleanup;\n\n        def->disks[i] = disk;\n    }\n\n    /* get the attachment details here */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        mediumAttachment = mediumAttachments.items[i];\n        controller = NULL;\n        controllerName = NULL;\n        deviceType = DeviceType_Null;\n        storageBus = StorageBus_Null;\n        readOnly = PR_FALSE;\n        medium = NULL;\n        mediumLocUtf16 = NULL;\n        mediumLocUtf8 = NULL;\n        devicePort = 0;\n        deviceSlot = 0;\n        disk = def->disks[i];\n\n        if (!mediumAttachment)\n            continue;\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(mediumAttachment, &medium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get IMedium, rc=%08x\"), rc);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetController(mediumAttachment,\n                                                       &controllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get storage controller name, rc=%08x\"),\n                           rc);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMachine.GetStorageControllerByName(machine,\n                                                           controllerName,\n                                                           &controller);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get storage controller by name, rc=%08x\"),\n                           rc);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetType(mediumAttachment, &deviceType);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get device type, rc=%08x\"), rc);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetPort(mediumAttachment, &devicePort);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get device port, rc=%08x\"), rc);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetDevice(mediumAttachment, &deviceSlot);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get device slot, rc=%08x\"), rc);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIStorageController.GetBus(controller, &storageBus);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get storage controller bus, rc=%08x\"),\n                           rc);\n            goto cleanup;\n        }\n\n        if (medium) {\n            rc = gVBoxAPI.UIMedium.GetLocation(medium, &mediumLocUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not get medium storage location, rc=%08x\"),\n                               rc);\n                goto cleanup;\n            }\n\n            VBOX_UTF16_TO_UTF8(mediumLocUtf16, &mediumLocUtf8);\n\n            if (virDomainDiskSetSource(disk, mediumLocUtf8) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not set disk source\"));\n                goto cleanup;\n            }\n\n            rc = gVBoxAPI.UIMedium.GetReadOnly(medium, &readOnly);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not get read only state, rc=%08x\"), rc);\n                goto cleanup;\n            }\n        }\n\n        disk->dst = vboxGenerateMediumName(storageBus, devicePort, deviceSlot,\n                                           sdCount);\n\n        if (!disk->dst) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not generate medium name for the disk \"\n                             \"at: port:%d, slot:%d\"), devicePort, deviceSlot);\n            goto cleanup;\n        }\n\n        disk->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        disk->info.addr.drive.bus = 0;\n        disk->info.addr.drive.unit = devicePort;\n\n        switch ((enum StorageBus) storageBus) {\n        case StorageBus_IDE:\n            disk->bus = VIR_DOMAIN_DISK_BUS_IDE;\n            disk->info.addr.drive.bus = devicePort; /* primary, secondary */\n            disk->info.addr.drive.unit = deviceSlot; /* master, slave */\n\n            break;\n        case StorageBus_SATA:\n            disk->bus = VIR_DOMAIN_DISK_BUS_SATA;\n            sdCount++;\n\n            break;\n        case StorageBus_SCSI:\n        case StorageBus_SAS:\n            disk->bus = VIR_DOMAIN_DISK_BUS_SCSI;\n            sdCount++;\n\n            /* In vbox, if there's a disk attached to SAS controller, there will\n             * be libvirt SCSI controller present with model \"lsi1068\", and we\n             * need to find its index\n             */\n            for (j = 0; j < def->ncontrollers; j++) {\n                ctrl = def->controllers[j];\n\n                if (ctrl->type != VIR_DOMAIN_CONTROLLER_TYPE_SCSI)\n                    continue;\n\n                if (storageBus == StorageBus_SAS &&\n                    ctrl->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068) {\n                    disk->info.addr.drive.controller = ctrl->idx;\n                    break;\n                }\n\n                if (storageBus == StorageBus_SCSI &&\n                    ctrl->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068) {\n                    disk->info.addr.drive.controller = ctrl->idx;\n                    break;\n                }\n            }\n\n            break;\n        case StorageBus_Floppy:\n            disk->bus = VIR_DOMAIN_DISK_BUS_FDC;\n\n            break;\n        case StorageBus_Null:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unsupported null storage bus\"));\n            goto cleanup;\n        }\n\n        switch ((enum DeviceType) deviceType) {\n        case DeviceType_HardDisk:\n            disk->device = VIR_DOMAIN_DISK_DEVICE_DISK;\n\n            break;\n        case DeviceType_Floppy:\n            disk->device = VIR_DOMAIN_DISK_DEVICE_FLOPPY;\n\n            break;\n        case DeviceType_DVD:\n            disk->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n\n            break;\n        case DeviceType_Network:\n        case DeviceType_USB:\n        case DeviceType_SharedFolder:\n        case DeviceType_Null:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unsupported vbox device type: %d\"), deviceType);\n            goto cleanup;\n        }\n\n        if (readOnly == PR_TRUE)\n            disk->src->readonly = true;\n\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n\n        VBOX_UTF16_FREE(controllerName);\n        VBOX_UTF8_FREE(mediumLocUtf8);\n        VBOX_UTF16_FREE(mediumLocUtf16);\n        VBOX_RELEASE(medium);\n        VBOX_RELEASE(controller);\n    }\n\n    ret = 0;\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&mediumAttachments);\n\n    if (ret < 0) {\n        VBOX_UTF16_FREE(controllerName);\n        VBOX_UTF8_FREE(mediumLocUtf8);\n        VBOX_UTF16_FREE(mediumLocUtf16);\n        VBOX_RELEASE(medium);\n        VBOX_RELEASE(controller);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpDisks(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    vboxArray mediumAttachments = VBOX_ARRAY_INITIALIZER;\n    int ret = -1;\n    IMediumAttachment *mediumAttachment = NULL;\n    IMedium *medium = NULL;\n    IStorageController *controller = NULL;\n    PRUnichar *controllerName = NULL, *mediumLocUtf16 = NULL;\n    PRUint32 deviceType, storageBus;\n    PRInt32 devicePort, deviceSlot;\n    PRBool readOnly;\n    nsresult rc;\n    virDomainDiskDefPtr disk = NULL;\n    virDomainControllerDefPtr ctrl = NULL;\n    char *mediumLocUtf8 = NULL;\n    size_t sdCount = 0, i, j;\n\n    def->ndisks = 0;\n    gVBoxAPI.UArray.vboxArrayGet(&mediumAttachments, machine,\n                 gVBoxAPI.UArray.handleMachineGetMediumAttachments(machine));\n\n    /* get the number of attachments */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        mediumAttachment = mediumAttachments.items[i];\n        if (!mediumAttachment)\n            continue;\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(mediumAttachment, &medium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get IMedium, rc=%08x\"), rc);\n            goto cleanup;\n        }\n\n        def->ndisks++;\n        VBOX_RELEASE(medium);\n    }\n\n    /* Allocate mem, if fails return error */\n    if (VIR_ALLOC_N(def->disks, def->ndisks) < 0)\n        goto cleanup;\n\n    for (i = 0; i < def->ndisks; i++) {\n        disk = virDomainDiskDefNew(NULL);\n        if (!disk)\n            goto cleanup;\n\n        def->disks[i] = disk;\n    }\n\n    /* get the attachment details here */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        mediumAttachment = mediumAttachments.items[i];\n        controller = NULL;\n        controllerName = NULL;\n        deviceType = DeviceType_Null;\n        storageBus = StorageBus_Null;\n        readOnly = PR_FALSE;\n        medium = NULL;\n        mediumLocUtf16 = NULL;\n        mediumLocUtf8 = NULL;\n        devicePort = 0;\n        deviceSlot = 0;\n        disk = def->disks[i];\n\n        if (!mediumAttachment)\n            continue;\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(mediumAttachment, &medium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get IMedium, rc=%08x\"), rc);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetController(mediumAttachment,\n                                                       &controllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get storage controller name, rc=%08x\"),\n                           rc);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMachine.GetStorageControllerByName(machine,\n                                                           controllerName,\n                                                           &controller);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get storage controller by name, rc=%08x\"),\n                           rc);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetType(mediumAttachment, &deviceType);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get device type, rc=%08x\"), rc);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetPort(mediumAttachment, &devicePort);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get device port, rc=%08x\"), rc);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetDevice(mediumAttachment, &deviceSlot);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get device slot, rc=%08x\"), rc);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIStorageController.GetBus(controller, &storageBus);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get storage controller bus, rc=%08x\"),\n                           rc);\n            goto cleanup;\n        }\n\n        if (medium) {\n            rc = gVBoxAPI.UIMedium.GetLocation(medium, &mediumLocUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not get medium storage location, rc=%08x\"),\n                               rc);\n                goto cleanup;\n            }\n\n            VBOX_UTF16_TO_UTF8(mediumLocUtf16, &mediumLocUtf8);\n\n            if (virDomainDiskSetSource(disk, mediumLocUtf8) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not set disk source\"));\n                goto cleanup;\n            }\n\n            rc = gVBoxAPI.UIMedium.GetReadOnly(medium, &readOnly);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not get read only state, rc=%08x\"), rc);\n                goto cleanup;\n            }\n        }\n\n        disk->dst = vboxGenerateMediumName(storageBus, devicePort, deviceSlot,\n                                           sdCount);\n\n        if (!disk->dst) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not generate medium name for the disk \"\n                             \"at: port:%d, slot:%d\"), devicePort, deviceSlot);\n            goto cleanup;\n        }\n\n        disk->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        disk->info.addr.drive.bus = 0;\n        disk->info.addr.drive.unit = devicePort;\n\n        switch ((enum StorageBus) storageBus) {\n        case StorageBus_IDE:\n            disk->bus = VIR_DOMAIN_DISK_BUS_IDE;\n            disk->info.addr.drive.bus = devicePort; /* primary, secondary */\n            disk->info.addr.drive.unit = deviceSlot; /* master, slave */\n\n            break;\n        case StorageBus_SATA:\n            disk->bus = VIR_DOMAIN_DISK_BUS_SATA;\n            sdCount++;\n\n            break;\n        case StorageBus_SCSI:\n        case StorageBus_SAS:\n            disk->bus = VIR_DOMAIN_DISK_BUS_SCSI;\n            sdCount++;\n\n            /* In vbox, if there's a disk attached to SAS controller, there will\n             * be libvirt SCSI controller present with model \"lsi1068\", and we\n             * need to find its index\n             */\n            for (j = 0; j < def->ncontrollers; j++) {\n                ctrl = def->controllers[j];\n\n                if (ctrl->type != VIR_DOMAIN_CONTROLLER_TYPE_SCSI)\n                    continue;\n\n                if (storageBus == StorageBus_SAS &&\n                    ctrl->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068) {\n                    disk->info.addr.drive.controller = ctrl->idx;\n                    break;\n                }\n\n                if (storageBus == StorageBus_SCSI &&\n                    ctrl->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068) {\n                    disk->info.addr.drive.controller = ctrl->idx;\n                    break;\n                }\n            }\n\n            break;\n        case StorageBus_Floppy:\n            disk->bus = VIR_DOMAIN_DISK_BUS_FDC;\n\n            break;\n        case StorageBus_Null:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unsupported null storage bus\"));\n            goto cleanup;\n        }\n\n        switch ((enum DeviceType) deviceType) {\n        case DeviceType_HardDisk:\n            disk->device = VIR_DOMAIN_DISK_DEVICE_DISK;\n\n            break;\n        case DeviceType_Floppy:\n            disk->device = VIR_DOMAIN_DISK_DEVICE_FLOPPY;\n\n            break;\n        case DeviceType_DVD:\n            disk->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n\n            break;\n        case DeviceType_Network:\n        case DeviceType_USB:\n        case DeviceType_SharedFolder:\n        case DeviceType_Null:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unsupported vbox device type: %d\"), deviceType);\n            goto cleanup;\n        }\n\n        if (readOnly == PR_TRUE)\n            disk->src->readonly = true;\n\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n\n        VBOX_UTF16_FREE(controllerName);\n        VBOX_UTF8_FREE(mediumLocUtf8);\n        VBOX_UTF16_FREE(mediumLocUtf16);\n        VBOX_RELEASE(medium);\n        VBOX_RELEASE(controller);\n    }\n\n    ret = 0;\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&mediumAttachments);\n\n    if (ret < 0) {\n        VBOX_UTF16_FREE(controllerName);\n        VBOX_UTF8_FREE(mediumLocUtf8);\n        VBOX_UTF16_FREE(mediumLocUtf16);\n        VBOX_RELEASE(medium);\n        VBOX_RELEASE(controller);\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDumpStorageControllers",
          "args": [
            "def",
            "machine"
          ],
          "line": 4107
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDumpStorageControllers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "3053-3159",
          "snippet": "static int\nvboxDumpStorageControllers(virDomainDefPtr def, IMachine *machine)\n{\n    vboxArray storageControllers = VBOX_ARRAY_INITIALIZER;\n    IStorageController *controller = NULL;\n    PRUint32 storageBus = StorageBus_Null;\n    PRUint32 controllerType = StorageControllerType_Null;\n    virDomainControllerDefPtr cont = NULL;\n    size_t i = 0;\n    int model = -1, ret = -1;\n    virDomainControllerType type = VIR_DOMAIN_CONTROLLER_TYPE_LAST;\n\n    gVBoxAPI.UArray.vboxArrayGet(&storageControllers, machine,\n                 gVBoxAPI.UArray.handleMachineGetStorageControllers(machine));\n\n    for (i = 0; i < storageControllers.count; i++) {\n        controller = storageControllers.items[i];\n        storageBus = StorageBus_Null;\n        controllerType = StorageControllerType_Null;\n        type = VIR_DOMAIN_CONTROLLER_TYPE_LAST;\n        model = -1;\n\n        if (!controller)\n            continue;\n\n        gVBoxAPI.UIStorageController.GetBus(controller, &storageBus);\n        gVBoxAPI.UIStorageController.GetControllerType(controller,\n                                                       &controllerType);\n\n        /* vbox controller model => libvirt controller model */\n        switch ((enum StorageControllerType) controllerType) {\n        case StorageControllerType_PIIX3:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX3;\n\n            break;\n        case StorageControllerType_PIIX4:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX4;\n\n            break;\n        case StorageControllerType_ICH6:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_IDE_ICH6;\n\n            break;\n        case StorageControllerType_BusLogic:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC;\n\n            break;\n        case StorageControllerType_LsiLogic:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC;\n\n            break;\n        case StorageControllerType_LsiLogicSas:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068;\n\n            break;\n        case StorageControllerType_IntelAhci:\n        case StorageControllerType_I82078:\n        case StorageControllerType_Null:\n            model = -1;\n\n            break;\n        }\n\n        /* vbox controller bus => libvirt controller type */\n        switch ((enum StorageBus) storageBus) {\n        case StorageBus_IDE:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_IDE;\n\n            break;\n        case StorageBus_SCSI:\n        case StorageBus_SAS:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_SCSI;\n\n            break;\n        case StorageBus_SATA:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_SATA;\n\n            break;\n        case StorageBus_Floppy:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_FDC;\n\n            break;\n        case StorageBus_Null:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unsupported null storage bus\"));\n\n            goto cleanup;\n        }\n\n        if (type != VIR_DOMAIN_CONTROLLER_TYPE_LAST) {\n            cont = virDomainDefAddController(def, type, -1, model);\n            if (!cont) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to add %s controller type definition\"),\n                               virDomainControllerTypeToString(type));\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&storageControllers);\n\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpStorageControllers(virDomainDefPtr def, IMachine *machine)\n{\n    vboxArray storageControllers = VBOX_ARRAY_INITIALIZER;\n    IStorageController *controller = NULL;\n    PRUint32 storageBus = StorageBus_Null;\n    PRUint32 controllerType = StorageControllerType_Null;\n    virDomainControllerDefPtr cont = NULL;\n    size_t i = 0;\n    int model = -1, ret = -1;\n    virDomainControllerType type = VIR_DOMAIN_CONTROLLER_TYPE_LAST;\n\n    gVBoxAPI.UArray.vboxArrayGet(&storageControllers, machine,\n                 gVBoxAPI.UArray.handleMachineGetStorageControllers(machine));\n\n    for (i = 0; i < storageControllers.count; i++) {\n        controller = storageControllers.items[i];\n        storageBus = StorageBus_Null;\n        controllerType = StorageControllerType_Null;\n        type = VIR_DOMAIN_CONTROLLER_TYPE_LAST;\n        model = -1;\n\n        if (!controller)\n            continue;\n\n        gVBoxAPI.UIStorageController.GetBus(controller, &storageBus);\n        gVBoxAPI.UIStorageController.GetControllerType(controller,\n                                                       &controllerType);\n\n        /* vbox controller model => libvirt controller model */\n        switch ((enum StorageControllerType) controllerType) {\n        case StorageControllerType_PIIX3:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX3;\n\n            break;\n        case StorageControllerType_PIIX4:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX4;\n\n            break;\n        case StorageControllerType_ICH6:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_IDE_ICH6;\n\n            break;\n        case StorageControllerType_BusLogic:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC;\n\n            break;\n        case StorageControllerType_LsiLogic:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC;\n\n            break;\n        case StorageControllerType_LsiLogicSas:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068;\n\n            break;\n        case StorageControllerType_IntelAhci:\n        case StorageControllerType_I82078:\n        case StorageControllerType_Null:\n            model = -1;\n\n            break;\n        }\n\n        /* vbox controller bus => libvirt controller type */\n        switch ((enum StorageBus) storageBus) {\n        case StorageBus_IDE:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_IDE;\n\n            break;\n        case StorageBus_SCSI:\n        case StorageBus_SAS:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_SCSI;\n\n            break;\n        case StorageBus_SATA:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_SATA;\n\n            break;\n        case StorageBus_Floppy:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_FDC;\n\n            break;\n        case StorageBus_Null:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unsupported null storage bus\"));\n\n            goto cleanup;\n        }\n\n        if (type != VIR_DOMAIN_CONTROLLER_TYPE_LAST) {\n            cont = virDomainDefAddController(def, type, -1, model);\n            if (!cont) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to add %s controller type definition\"),\n                               virDomainControllerTypeToString(type));\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&storageControllers);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDumpDisplay",
          "args": [
            "def",
            "data",
            "machine"
          ],
          "line": 4105
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDumpDisplay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "3460-3576",
          "snippet": "static int\nvboxDumpDisplay(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    /* dump display options vrdp/gui/sdl */\n    PRUnichar *keyUtf16 = NULL;\n    PRUnichar *valueTypeUtf16 = NULL;\n    char *valueTypeUtf8 = NULL;\n    char *netAddressUtf8 = NULL;\n    IVRDEServer *VRDEServer = NULL;\n    PRBool VRDxEnabled = PR_FALSE;\n    virDomainGraphicsDefPtr graphics = NULL;\n    int ret = -1;\n\n    def->ngraphics = 0;\n\n    VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyUtf16);\n    gVBoxAPI.UIMachine.GetExtraData(machine, keyUtf16, &valueTypeUtf16);\n    VBOX_UTF16_FREE(keyUtf16);\n\n    if (valueTypeUtf16) {\n        VBOX_UTF16_TO_UTF8(valueTypeUtf16, &valueTypeUtf8);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n    }\n\n    if (STREQ_NULLABLE(valueTypeUtf8, \"sdl\") ||\n        STREQ_NULLABLE(valueTypeUtf8, \"gui\")) {\n        PRUnichar *valueDisplayUtf16 = NULL;\n        char *valueDisplayUtf8 = NULL;\n\n        if (VIR_ALLOC(graphics) < 0)\n            goto cleanup;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyUtf16);\n        gVBoxAPI.UIMachine.GetExtraData(machine, keyUtf16, &valueDisplayUtf16);\n        VBOX_UTF16_FREE(keyUtf16);\n\n        if (valueDisplayUtf16) {\n            VBOX_UTF16_TO_UTF8(valueDisplayUtf16, &valueDisplayUtf8);\n            VBOX_UTF16_FREE(valueDisplayUtf16);\n\n            if (STREQ(valueDisplayUtf8, \"\"))\n                VBOX_UTF8_FREE(valueDisplayUtf8);\n        }\n\n        if (STREQ_NULLABLE(valueTypeUtf8, \"sdl\")) {\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SDL;\n            graphics->data.sdl.display = valueDisplayUtf8;\n            valueDisplayUtf8 = NULL;\n        }\n\n        if (STREQ_NULLABLE(valueTypeUtf8, \"gui\")) {\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP;\n            graphics->data.desktop.display = valueDisplayUtf8;\n            valueDisplayUtf8 = NULL;\n        }\n        VBOX_UTF8_FREE(valueDisplayUtf8);\n    } else if (STRNEQ_NULLABLE(valueTypeUtf8, \"vrdp\")) {\n        if (VIR_ALLOC(graphics) < 0)\n            goto cleanup;\n\n        graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP;\n        graphics->data.desktop.display = g_strdup(getenv(\"DISPLAY\"));\n    }\n\n    if (graphics &&\n        VIR_APPEND_ELEMENT(def->graphics, def->ngraphics, graphics) < 0)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetVRDEServer(machine, &VRDEServer);\n    if (VRDEServer)\n        gVBoxAPI.UIVRDEServer.GetEnabled(VRDEServer, &VRDxEnabled);\n\n    if (VRDxEnabled) {\n        PRUnichar *netAddressUtf16 = NULL;\n        PRBool allowMultiConnection = PR_FALSE;\n        PRBool reuseSingleConnection = PR_FALSE;\n\n        if (VIR_ALLOC(graphics) < 0)\n            goto cleanup;\n\n        gVBoxAPI.UIVRDEServer.GetPorts(data, VRDEServer, machine, graphics);\n\n        graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_RDP;\n\n        gVBoxAPI.UIVRDEServer.GetNetAddress(data, VRDEServer, &netAddressUtf16);\n        if (netAddressUtf16) {\n            VBOX_UTF16_TO_UTF8(netAddressUtf16, &netAddressUtf8);\n            VBOX_UTF16_FREE(netAddressUtf16);\n        }\n\n        if (netAddressUtf8 && STREQ(netAddressUtf8, \"\"))\n            VBOX_UTF8_FREE(netAddressUtf8);\n\n        if (virDomainGraphicsListenAppendAddress(graphics, netAddressUtf8) < 0)\n            goto cleanup;\n\n        gVBoxAPI.UIVRDEServer.GetAllowMultiConnection(VRDEServer, &allowMultiConnection);\n        if (allowMultiConnection)\n            graphics->data.rdp.multiUser = true;\n\n        gVBoxAPI.UIVRDEServer.GetReuseSingleConnection(VRDEServer, &reuseSingleConnection);\n        if (reuseSingleConnection)\n            graphics->data.rdp.replaceUser = true;\n\n        if (VIR_APPEND_ELEMENT(def->graphics, def->ngraphics, graphics) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(VRDEServer);\n    VBOX_UTF8_FREE(valueTypeUtf8);\n    VBOX_UTF8_FREE(netAddressUtf8);\n    virDomainGraphicsDefFree(graphics);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpDisplay(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    /* dump display options vrdp/gui/sdl */\n    PRUnichar *keyUtf16 = NULL;\n    PRUnichar *valueTypeUtf16 = NULL;\n    char *valueTypeUtf8 = NULL;\n    char *netAddressUtf8 = NULL;\n    IVRDEServer *VRDEServer = NULL;\n    PRBool VRDxEnabled = PR_FALSE;\n    virDomainGraphicsDefPtr graphics = NULL;\n    int ret = -1;\n\n    def->ngraphics = 0;\n\n    VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyUtf16);\n    gVBoxAPI.UIMachine.GetExtraData(machine, keyUtf16, &valueTypeUtf16);\n    VBOX_UTF16_FREE(keyUtf16);\n\n    if (valueTypeUtf16) {\n        VBOX_UTF16_TO_UTF8(valueTypeUtf16, &valueTypeUtf8);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n    }\n\n    if (STREQ_NULLABLE(valueTypeUtf8, \"sdl\") ||\n        STREQ_NULLABLE(valueTypeUtf8, \"gui\")) {\n        PRUnichar *valueDisplayUtf16 = NULL;\n        char *valueDisplayUtf8 = NULL;\n\n        if (VIR_ALLOC(graphics) < 0)\n            goto cleanup;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyUtf16);\n        gVBoxAPI.UIMachine.GetExtraData(machine, keyUtf16, &valueDisplayUtf16);\n        VBOX_UTF16_FREE(keyUtf16);\n\n        if (valueDisplayUtf16) {\n            VBOX_UTF16_TO_UTF8(valueDisplayUtf16, &valueDisplayUtf8);\n            VBOX_UTF16_FREE(valueDisplayUtf16);\n\n            if (STREQ(valueDisplayUtf8, \"\"))\n                VBOX_UTF8_FREE(valueDisplayUtf8);\n        }\n\n        if (STREQ_NULLABLE(valueTypeUtf8, \"sdl\")) {\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SDL;\n            graphics->data.sdl.display = valueDisplayUtf8;\n            valueDisplayUtf8 = NULL;\n        }\n\n        if (STREQ_NULLABLE(valueTypeUtf8, \"gui\")) {\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP;\n            graphics->data.desktop.display = valueDisplayUtf8;\n            valueDisplayUtf8 = NULL;\n        }\n        VBOX_UTF8_FREE(valueDisplayUtf8);\n    } else if (STRNEQ_NULLABLE(valueTypeUtf8, \"vrdp\")) {\n        if (VIR_ALLOC(graphics) < 0)\n            goto cleanup;\n\n        graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP;\n        graphics->data.desktop.display = g_strdup(getenv(\"DISPLAY\"));\n    }\n\n    if (graphics &&\n        VIR_APPEND_ELEMENT(def->graphics, def->ngraphics, graphics) < 0)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetVRDEServer(machine, &VRDEServer);\n    if (VRDEServer)\n        gVBoxAPI.UIVRDEServer.GetEnabled(VRDEServer, &VRDxEnabled);\n\n    if (VRDxEnabled) {\n        PRUnichar *netAddressUtf16 = NULL;\n        PRBool allowMultiConnection = PR_FALSE;\n        PRBool reuseSingleConnection = PR_FALSE;\n\n        if (VIR_ALLOC(graphics) < 0)\n            goto cleanup;\n\n        gVBoxAPI.UIVRDEServer.GetPorts(data, VRDEServer, machine, graphics);\n\n        graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_RDP;\n\n        gVBoxAPI.UIVRDEServer.GetNetAddress(data, VRDEServer, &netAddressUtf16);\n        if (netAddressUtf16) {\n            VBOX_UTF16_TO_UTF8(netAddressUtf16, &netAddressUtf8);\n            VBOX_UTF16_FREE(netAddressUtf16);\n        }\n\n        if (netAddressUtf8 && STREQ(netAddressUtf8, \"\"))\n            VBOX_UTF8_FREE(netAddressUtf8);\n\n        if (virDomainGraphicsListenAppendAddress(graphics, netAddressUtf8) < 0)\n            goto cleanup;\n\n        gVBoxAPI.UIVRDEServer.GetAllowMultiConnection(VRDEServer, &allowMultiConnection);\n        if (allowMultiConnection)\n            graphics->data.rdp.multiUser = true;\n\n        gVBoxAPI.UIVRDEServer.GetReuseSingleConnection(VRDEServer, &reuseSingleConnection);\n        if (reuseSingleConnection)\n            graphics->data.rdp.replaceUser = true;\n\n        if (VIR_APPEND_ELEMENT(def->graphics, def->ngraphics, graphics) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(VRDEServer);\n    VBOX_UTF8_FREE(valueTypeUtf8);\n    VBOX_UTF8_FREE(netAddressUtf8);\n    virDomainGraphicsDefFree(graphics);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDumpVideo",
          "args": [
            "def",
            "data",
            "machine"
          ],
          "line": 4103
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDumpVideo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "3423-3458",
          "snippet": "static int\nvboxDumpVideo(virDomainDefPtr def, vboxDriverPtr data G_GNUC_UNUSED,\n              IMachine *machine)\n{\n    /* dump video options vram/2d/3d/directx/etc. */\n    /* the default is: vram is 8MB, One monitor, 3dAccel Off */\n    PRUint32 VRAMSize = 8;\n    PRUint32 monitorCount = 1;\n    PRBool accelerate3DEnabled = PR_FALSE;\n    PRBool accelerate2DEnabled = PR_FALSE;\n\n    /* Currently supports only one graphics card */\n    if (VIR_ALLOC_N(def->videos, 1) < 0)\n        return -1;\n    def->nvideos = 1;\n\n    if (VIR_ALLOC(def->videos[0]) < 0)\n        return -1;\n\n    gVBoxAPI.UIMachine.GetVRAMSize(machine, &VRAMSize);\n    gVBoxAPI.UIMachine.GetMonitorCount(machine, &monitorCount);\n    gVBoxAPI.UIMachine.GetAccelerate3DEnabled(machine, &accelerate3DEnabled);\n    gVBoxAPI.UIMachine.GetAccelerate2DVideoEnabled(machine, &accelerate2DEnabled);\n\n    def->videos[0]->type = VIR_DOMAIN_VIDEO_TYPE_VBOX;\n    def->videos[0]->vram = VRAMSize * 1024;\n    def->videos[0]->heads = monitorCount;\n    if (VIR_ALLOC(def->videos[0]->accel) < 0)\n        return -1;\n    def->videos[0]->accel->accel3d = accelerate3DEnabled ?\n        VIR_TRISTATE_BOOL_YES : VIR_TRISTATE_BOOL_NO;\n    def->videos[0]->accel->accel2d = accelerate2DEnabled ?\n        VIR_TRISTATE_BOOL_YES : VIR_TRISTATE_BOOL_NO;\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpVideo(virDomainDefPtr def, vboxDriverPtr data G_GNUC_UNUSED,\n              IMachine *machine)\n{\n    /* dump video options vram/2d/3d/directx/etc. */\n    /* the default is: vram is 8MB, One monitor, 3dAccel Off */\n    PRUint32 VRAMSize = 8;\n    PRUint32 monitorCount = 1;\n    PRBool accelerate3DEnabled = PR_FALSE;\n    PRBool accelerate2DEnabled = PR_FALSE;\n\n    /* Currently supports only one graphics card */\n    if (VIR_ALLOC_N(def->videos, 1) < 0)\n        return -1;\n    def->nvideos = 1;\n\n    if (VIR_ALLOC(def->videos[0]) < 0)\n        return -1;\n\n    gVBoxAPI.UIMachine.GetVRAMSize(machine, &VRAMSize);\n    gVBoxAPI.UIMachine.GetMonitorCount(machine, &monitorCount);\n    gVBoxAPI.UIMachine.GetAccelerate3DEnabled(machine, &accelerate3DEnabled);\n    gVBoxAPI.UIMachine.GetAccelerate2DVideoEnabled(machine, &accelerate2DEnabled);\n\n    def->videos[0]->type = VIR_DOMAIN_VIDEO_TYPE_VBOX;\n    def->videos[0]->vram = VRAMSize * 1024;\n    def->videos[0]->heads = monitorCount;\n    if (VIR_ALLOC(def->videos[0]->accel) < 0)\n        return -1;\n    def->videos[0]->accel->accel3d = accelerate3DEnabled ?\n        VIR_TRISTATE_BOOL_YES : VIR_TRISTATE_BOOL_NO;\n    def->videos[0]->accel->accel2d = accelerate2DEnabled ?\n        VIR_TRISTATE_BOOL_YES : VIR_TRISTATE_BOOL_NO;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "bios"
          ],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIBIOSSettings.GetIOAPICEnabled",
          "args": [
            "bios",
            "&IOAPICEnabled"
          ],
          "line": 4092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIBIOSSettings.GetACPIEnabled",
          "args": [
            "bios",
            "&ACPIEnabled"
          ],
          "line": 4088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetBIOSSettings",
          "args": [
            "machine",
            "&bios"
          ],
          "line": 4086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetCPUProperty",
          "args": [
            "machine",
            "CPUPropertyType_PAE",
            "&PAEEnabled"
          ],
          "line": 4082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetBootOrder",
          "args": [
            "machine",
            "i+1",
            "&device"
          ],
          "line": 4060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchFromHost",
          "args": [],
          "line": 4054
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "206-235",
          "snippet": "virArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nvirArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetVcpus",
          "args": [
            "def",
            "CPUCount"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1889-1909",
          "snippet": "int\nvirDomainDefSetVcpus(virDomainDefPtr def,\n                     unsigned int vcpus)\n{\n    size_t i;\n\n    if (vcpus > def->maxvcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"maximum vCPU count must not be less than current \"\n                         \"vCPU count\"));\n        return -1;\n    }\n\n    for (i = 0; i < vcpus; i++)\n        def->vcpus[i]->online = true;\n\n    for (i = vcpus; i < def->maxvcpus; i++)\n        def->vcpus[i]->online = false;\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSetVcpus(virDomainDefPtr def,\n                     unsigned int vcpus)\n{\n    size_t i;\n\n    if (vcpus > def->maxvcpus) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"maximum vCPU count must not be less than current \"\n                         \"vCPU count\"));\n        return -1;\n    }\n\n    for (i = 0; i < vcpus; i++)\n        def->vcpus[i]->online = true;\n\n    for (i = vcpus; i < def->maxvcpus; i++)\n        def->vcpus[i]->online = false;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSetVcpusMax",
          "args": [
            "def",
            "CPUCount",
            "data->xmlopt"
          ],
          "line": 4045
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetVcpusMax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1838-1865",
          "snippet": "int\nvirDomainDefSetVcpusMax(virDomainDefPtr def,\n                        unsigned int maxvcpus,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    size_t oldmax = def->maxvcpus;\n    size_t i;\n\n    if (def->maxvcpus == maxvcpus)\n        return 0;\n\n    if (def->maxvcpus < maxvcpus) {\n        if (VIR_EXPAND_N(def->vcpus, def->maxvcpus, maxvcpus - def->maxvcpus) < 0)\n            return -1;\n\n        for (i = oldmax; i < def->maxvcpus; i++) {\n            if (!(def->vcpus[i] = virDomainVcpuDefNew(xmlopt)))\n                return -1;\n        }\n    } else {\n        for (i = maxvcpus; i < def->maxvcpus; i++)\n            virDomainVcpuDefFree(def->vcpus[i]);\n\n        VIR_SHRINK_N(def->vcpus, def->maxvcpus, def->maxvcpus - maxvcpus);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSetVcpusMax(virDomainDefPtr def,\n                        unsigned int maxvcpus,\n                        virDomainXMLOptionPtr xmlopt)\n{\n    size_t oldmax = def->maxvcpus;\n    size_t i;\n\n    if (def->maxvcpus == maxvcpus)\n        return 0;\n\n    if (def->maxvcpus < maxvcpus) {\n        if (VIR_EXPAND_N(def->vcpus, def->maxvcpus, maxvcpus - def->maxvcpus) < 0)\n            return -1;\n\n        for (i = oldmax; i < def->maxvcpus; i++) {\n            if (!(def->vcpus[i] = virDomainVcpuDefNew(xmlopt)))\n                return -1;\n        }\n    } else {\n        for (i = maxvcpus; i < def->maxvcpus; i++)\n            virDomainVcpuDefFree(def->vcpus[i]);\n\n        VIR_SHRINK_N(def->vcpus, def->maxvcpus, def->maxvcpus - maxvcpus);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetCPUCount",
          "args": [
            "machine",
            "&CPUCount"
          ],
          "line": 4044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefSetMemoryTotal",
          "args": [
            "def",
            "memorySize * 1024"
          ],
          "line": 4042
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSetMemoryTotal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10931-10936",
          "snippet": "void\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDefSetMemoryTotal(virDomainDefPtr def,\n                           unsigned long long size)\n{\n    def->mem.total_memory = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "systemProperties"
          ],
          "line": 4034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISystemProperties.GetParallelPortCount",
          "args": [
            "systemProperties",
            "&parallelPortCount"
          ],
          "line": 4033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISystemProperties.GetSerialPortCount",
          "args": [
            "systemProperties",
            "&serialPortCount"
          ],
          "line": 4032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISystemProperties.GetMaxNetworkAdapters",
          "args": [
            "systemProperties",
            "chipsetType",
            "&networkAdapterCount"
          ],
          "line": 4031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISystemProperties.GetMaxBootPosition",
          "args": [
            "systemProperties",
            "&maxBootPosition"
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISystemProperties.GetMaxGuestRAM",
          "args": [
            "systemProperties",
            "&maxMemorySize"
          ],
          "line": 4029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetSystemProperties",
          "args": [
            "data->vboxObj",
            "&systemProperties"
          ],
          "line": 4027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetChipsetType",
          "args": [
            "machine",
            "&chipsetType"
          ],
          "line": 4025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetMemorySize",
          "args": [
            "machine",
            "&memorySize"
          ],
          "line": 4021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "dom->name"
          ],
          "line": 4019
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "def->uuid",
            "dom->uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 4018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&accessible"
          ],
          "line": 4012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefNew",
          "args": [],
          "line": 4009
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3574-3594",
          "snippet": "virDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefNew(void)\n{\n    virDomainDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->numa = virDomainNumaNew()))\n        goto error;\n\n    ret->mem.hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.soft_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n    ret->mem.swap_hard_limit = VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n\n    return ret;\n\n error:\n    virDomainDefFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 4006
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_XML_COMMON_FLAGS",
            "NULL"
          ],
          "line": 4004
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic char *vboxDomainGetXMLDesc(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    virDomainDefPtr def = NULL;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRBool accessible = PR_FALSE;\n    size_t i = 0;\n    PRBool PAEEnabled = PR_FALSE;\n    PRBool ACPIEnabled = PR_FALSE;\n    PRBool IOAPICEnabled = PR_FALSE;\n    PRUint32 CPUCount = 0;\n    PRUint32 memorySize = 0;\n    PRUint32 networkAdapterCount = 0;\n    PRUint32 maxMemorySize = 4 * 1024;\n    PRUint32 maxBootPosition = 0;\n    PRUint32 serialPortCount = 0;\n    PRUint32 parallelPortCount = 0;\n    IBIOSSettings *bios = NULL;\n    PRUint32 chipsetType = ChipsetType_Null;\n    ISystemProperties *systemProperties = NULL;\n    char *ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(VIR_DOMAIN_XML_COMMON_FLAGS, NULL);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &accessible);\n    if (!accessible)\n        goto cleanup;\n\n    def->virtType = VIR_DOMAIN_VIRT_VBOX;\n    def->id = dom->id;\n    memcpy(def->uuid, dom->uuid, VIR_UUID_BUFLEN);\n    def->name = g_strdup(dom->name);\n\n    gVBoxAPI.UIMachine.GetMemorySize(machine, &memorySize);\n    def->mem.cur_balloon = memorySize * 1024;\n\n    if (gVBoxAPI.chipsetType)\n        gVBoxAPI.UIMachine.GetChipsetType(machine, &chipsetType);\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetMaxGuestRAM(systemProperties, &maxMemorySize);\n        gVBoxAPI.UISystemProperties.GetMaxBootPosition(systemProperties, &maxBootPosition);\n        gVBoxAPI.UISystemProperties.GetMaxNetworkAdapters(systemProperties, chipsetType, &networkAdapterCount);\n        gVBoxAPI.UISystemProperties.GetSerialPortCount(systemProperties, &serialPortCount);\n        gVBoxAPI.UISystemProperties.GetParallelPortCount(systemProperties, &parallelPortCount);\n        VBOX_RELEASE(systemProperties);\n        systemProperties = NULL;\n    }\n    /* Currently setting memory and maxMemory as same, cause\n     * the notation here seems to be inconsistent while\n     * reading and while dumping xml\n     */\n    /* def->mem.max_balloon = maxMemorySize * 1024; */\n    virDomainDefSetMemoryTotal(def, memorySize * 1024);\n\n    gVBoxAPI.UIMachine.GetCPUCount(machine, &CPUCount);\n    if (virDomainDefSetVcpusMax(def, CPUCount, data->xmlopt) < 0)\n        goto cleanup;\n\n    if (virDomainDefSetVcpus(def, CPUCount) < 0)\n        goto cleanup;\n\n    /* Skip cpumasklen, cpumask, onReboot, onPoweroff, onCrash */\n\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n    def->os.arch = virArchFromHost();\n\n    def->os.nBootDevs = 0;\n    for (i = 0; (i < VIR_DOMAIN_BOOT_LAST) && (i < maxBootPosition); i++) {\n        PRUint32 device = DeviceType_Null;\n\n        gVBoxAPI.UIMachine.GetBootOrder(machine, i+1, &device);\n\n        if (device == DeviceType_Floppy) {\n            def->os.bootDevs[i] = VIR_DOMAIN_BOOT_FLOPPY;\n            def->os.nBootDevs++;\n        } else if (device == DeviceType_DVD) {\n            def->os.bootDevs[i] = VIR_DOMAIN_BOOT_CDROM;\n            def->os.nBootDevs++;\n        } else if (device == DeviceType_HardDisk) {\n            def->os.bootDevs[i] = VIR_DOMAIN_BOOT_DISK;\n            def->os.nBootDevs++;\n        } else if (device == DeviceType_Network) {\n            def->os.bootDevs[i] = VIR_DOMAIN_BOOT_NET;\n            def->os.nBootDevs++;\n        } else if (device == DeviceType_USB) {\n            /* Not supported by libvirt yet */\n        } else if (device == DeviceType_SharedFolder) {\n            /* Not supported by libvirt yet */\n            /* Can VirtualBox really boot from a shared folder? */\n        }\n    }\n\n    gVBoxAPI.UIMachine.GetCPUProperty(machine, CPUPropertyType_PAE, &PAEEnabled);\n    if (PAEEnabled)\n        def->features[VIR_DOMAIN_FEATURE_PAE] = VIR_TRISTATE_SWITCH_ON;\n\n    gVBoxAPI.UIMachine.GetBIOSSettings(machine, &bios);\n    if (bios) {\n        gVBoxAPI.UIBIOSSettings.GetACPIEnabled(bios, &ACPIEnabled);\n        if (ACPIEnabled)\n            def->features[VIR_DOMAIN_FEATURE_ACPI] = VIR_TRISTATE_SWITCH_ON;\n\n        gVBoxAPI.UIBIOSSettings.GetIOAPICEnabled(bios, &IOAPICEnabled);\n        if (IOAPICEnabled)\n            def->features[VIR_DOMAIN_FEATURE_APIC] = VIR_TRISTATE_SWITCH_ON;\n\n        VBOX_RELEASE(bios);\n    }\n\n    /* Currently VirtualBox always uses locatime\n     * so locatime is always true here */\n    def->clock.offset = VIR_DOMAIN_CLOCK_OFFSET_LOCALTIME;\n\n    if (vboxDumpVideo(def, data, machine) < 0)\n        goto cleanup;\n    if (vboxDumpDisplay(def, data, machine) < 0)\n        goto cleanup;\n    if (vboxDumpStorageControllers(def, machine) < 0)\n        goto cleanup;\n    if (vboxDumpDisks(def, data, machine) < 0)\n        goto cleanup;\n\n    if (vboxDumpSharedFolders(def, data, machine) < 0)\n        goto cleanup;\n    if (vboxDumpNetworks(def, data, machine, networkAdapterCount) < 0)\n        goto cleanup;\n    vboxDumpAudio(def, data, machine);\n\n    if (vboxDumpSerial(def, data, machine, serialPortCount) < 0)\n        goto cleanup;\n    if (vboxDumpParallel(def, data, machine, parallelPortCount) < 0)\n        goto cleanup;\n\n    /* dump USB devices/filters if active */\n    vboxHostDeviceGetXMLDesc(data, def, machine);\n\n    ret = virDomainDefFormat(def, data->xmlopt,\n                             virDomainDefFormatConvertXMLFlags(flags));\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    virDomainDefFree(def);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDumpParallel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "3897-3976",
    "snippet": "static int\nvboxDumpParallel(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine, PRUint32 parallelPortCount)\n{\n    PRUint32 parallelPortIncCount = 0;\n    size_t i = 0;\n    /* dump parallel ports if active */\n    def->nparallels = 0;\n    /* Get which parallel ports are enabled/active */\n    for (i = 0; i < parallelPortCount; i++) {\n        IParallelPort *parallelPort = NULL;\n\n        gVBoxAPI.UIMachine.GetParallelPort(machine, i, &parallelPort);\n        if (parallelPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UIParallelPort.GetEnabled(parallelPort, &enabled);\n            if (enabled)\n                def->nparallels++;\n\n            VBOX_RELEASE(parallelPort);\n        }\n    }\n\n    /* Allocate memory for the parallel ports which are enabled */\n    if (def->nparallels > 0) {\n        if (VIR_ALLOC_N(def->parallels, def->nparallels) < 0)\n            return -1;\n\n        for (i = 0; i < def->nparallels; i++) {\n            def->parallels[i] = virDomainChrDefNew(NULL);\n            if (!def->parallels[i])\n                return -1;\n        }\n    }\n\n    /* Now get the details about the parallel ports here */\n    for (i = 0;\n         parallelPortIncCount < def->nparallels &&\n             i < parallelPortCount;\n         i++) {\n        IParallelPort *parallelPort = NULL;\n\n        gVBoxAPI.UIMachine.GetParallelPort(machine, i, &parallelPort);\n        if (parallelPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UIParallelPort.GetEnabled(parallelPort, &enabled);\n            if (enabled) {\n                PRUint32 IOBase = 0;\n                PRUint32 IRQ = 0;\n                PRUnichar *pathUtf16 = NULL;\n                char *path = NULL;\n\n                gVBoxAPI.UIParallelPort.GetIRQ(parallelPort, &IRQ);\n                gVBoxAPI.UIParallelPort.GetIOBase(parallelPort, &IOBase);\n                if ((IRQ == 7) && (IOBase == 888)) {\n                    def->parallels[parallelPortIncCount]->target.port = 0;\n                } else if ((IRQ == 5) && (IOBase == 632)) {\n                    def->parallels[parallelPortIncCount]->target.port = 1;\n                }\n\n                def->parallels[parallelPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n                def->parallels[parallelPortIncCount]->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_PARALLEL;\n\n                gVBoxAPI.UIParallelPort.GetPath(parallelPort, &pathUtf16);\n\n                VBOX_UTF16_TO_UTF8(pathUtf16, &path);\n                def->parallels[parallelPortIncCount]->source->data.file.path = g_strdup(path);\n\n                parallelPortIncCount++;\n\n                VBOX_UTF16_FREE(pathUtf16);\n                VBOX_UTF8_FREE(path);\n            }\n\n            VBOX_RELEASE(parallelPort);\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "parallelPort"
          ],
          "line": 3972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "path"
          ],
          "line": 3969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "pathUtf16"
          ],
          "line": 3968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "path"
          ],
          "line": 3964
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "pathUtf16",
            "&path"
          ],
          "line": 3963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIParallelPort.GetPath",
          "args": [
            "parallelPort",
            "&pathUtf16"
          ],
          "line": 3961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIParallelPort.GetIOBase",
          "args": [
            "parallelPort",
            "&IOBase"
          ],
          "line": 3951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIParallelPort.GetIRQ",
          "args": [
            "parallelPort",
            "&IRQ"
          ],
          "line": 3950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIParallelPort.GetEnabled",
          "args": [
            "parallelPort",
            "&enabled"
          ],
          "line": 3943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetParallelPort",
          "args": [
            "machine",
            "i",
            "&parallelPort"
          ],
          "line": 3939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrDefNew",
          "args": [
            "NULL"
          ],
          "line": 3926
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "13232-13246",
          "snippet": "virDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->parallels",
            "def->nparallels"
          ],
          "line": 3922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "parallelPort"
          ],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIParallelPort.GetEnabled",
          "args": [
            "parallelPort",
            "&enabled"
          ],
          "line": 3912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetParallelPort",
          "args": [
            "machine",
            "i",
            "&parallelPort"
          ],
          "line": 3908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpParallel(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine, PRUint32 parallelPortCount)\n{\n    PRUint32 parallelPortIncCount = 0;\n    size_t i = 0;\n    /* dump parallel ports if active */\n    def->nparallels = 0;\n    /* Get which parallel ports are enabled/active */\n    for (i = 0; i < parallelPortCount; i++) {\n        IParallelPort *parallelPort = NULL;\n\n        gVBoxAPI.UIMachine.GetParallelPort(machine, i, &parallelPort);\n        if (parallelPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UIParallelPort.GetEnabled(parallelPort, &enabled);\n            if (enabled)\n                def->nparallels++;\n\n            VBOX_RELEASE(parallelPort);\n        }\n    }\n\n    /* Allocate memory for the parallel ports which are enabled */\n    if (def->nparallels > 0) {\n        if (VIR_ALLOC_N(def->parallels, def->nparallels) < 0)\n            return -1;\n\n        for (i = 0; i < def->nparallels; i++) {\n            def->parallels[i] = virDomainChrDefNew(NULL);\n            if (!def->parallels[i])\n                return -1;\n        }\n    }\n\n    /* Now get the details about the parallel ports here */\n    for (i = 0;\n         parallelPortIncCount < def->nparallels &&\n             i < parallelPortCount;\n         i++) {\n        IParallelPort *parallelPort = NULL;\n\n        gVBoxAPI.UIMachine.GetParallelPort(machine, i, &parallelPort);\n        if (parallelPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UIParallelPort.GetEnabled(parallelPort, &enabled);\n            if (enabled) {\n                PRUint32 IOBase = 0;\n                PRUint32 IRQ = 0;\n                PRUnichar *pathUtf16 = NULL;\n                char *path = NULL;\n\n                gVBoxAPI.UIParallelPort.GetIRQ(parallelPort, &IRQ);\n                gVBoxAPI.UIParallelPort.GetIOBase(parallelPort, &IOBase);\n                if ((IRQ == 7) && (IOBase == 888)) {\n                    def->parallels[parallelPortIncCount]->target.port = 0;\n                } else if ((IRQ == 5) && (IOBase == 632)) {\n                    def->parallels[parallelPortIncCount]->target.port = 1;\n                }\n\n                def->parallels[parallelPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n                def->parallels[parallelPortIncCount]->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_PARALLEL;\n\n                gVBoxAPI.UIParallelPort.GetPath(parallelPort, &pathUtf16);\n\n                VBOX_UTF16_TO_UTF8(pathUtf16, &path);\n                def->parallels[parallelPortIncCount]->source->data.file.path = g_strdup(path);\n\n                parallelPortIncCount++;\n\n                VBOX_UTF16_FREE(pathUtf16);\n                VBOX_UTF8_FREE(path);\n            }\n\n            VBOX_RELEASE(parallelPort);\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "vboxDumpSerial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "3802-3895",
    "snippet": "static int\nvboxDumpSerial(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine, PRUint32 serialPortCount)\n{\n    PRUint32 serialPortIncCount = 0;\n    size_t i = 0;\n    /* dump serial port if active */\n    def->nserials = 0;\n    /* Get which serial ports are enabled/active */\n    for (i = 0; i < serialPortCount; i++) {\n        ISerialPort *serialPort = NULL;\n\n        gVBoxAPI.UIMachine.GetSerialPort(machine, i, &serialPort);\n        if (serialPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UISerialPort.GetEnabled(serialPort, &enabled);\n            if (enabled)\n                def->nserials++;\n\n            VBOX_RELEASE(serialPort);\n        }\n    }\n\n    /* Allocate memory for the serial ports which are enabled */\n    if (def->nserials > 0) {\n        if (VIR_ALLOC_N(def->serials, def->nserials) < 0)\n            return -1;\n\n        for (i = 0; i < def->nserials; i++) {\n            def->serials[i] = virDomainChrDefNew(NULL);\n            if (!def->serials[i])\n                return -1;\n        }\n    }\n\n    /* Now get the details about the serial ports here */\n    for (i = 0;\n         serialPortIncCount < def->nserials && i < serialPortCount;\n         i++) {\n        ISerialPort *serialPort = NULL;\n\n        gVBoxAPI.UIMachine.GetSerialPort(machine, i, &serialPort);\n        if (serialPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UISerialPort.GetEnabled(serialPort, &enabled);\n            if (enabled) {\n                PRUint32 hostMode = PortMode_Disconnected;\n                PRUint32 IOBase = 0;\n                PRUint32 IRQ = 0;\n                PRUnichar *pathUtf16 = NULL;\n                char *path = NULL;\n\n                gVBoxAPI.UISerialPort.GetHostMode(serialPort, &hostMode);\n                if (hostMode == PortMode_HostPipe) {\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_PIPE;\n                } else if (hostMode == PortMode_HostDevice) {\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n                } else if (gVBoxAPI.APIVersion >= 2002051 &&\n                           hostMode == PortMode_RawFile) {\n                    /* PortMode RawFile is used for vbox 3.0 or later */\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n                } else {\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_NULL;\n                }\n\n                def->serials[serialPortIncCount]->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n\n                gVBoxAPI.UISerialPort.GetIRQ(serialPort, &IRQ);\n                gVBoxAPI.UISerialPort.GetIOBase(serialPort, &IOBase);\n                if ((IRQ == 4) && (IOBase == 1016)) {\n                    def->serials[serialPortIncCount]->target.port = 0;\n                } else if ((IRQ == 3) && (IOBase == 760)) {\n                    def->serials[serialPortIncCount]->target.port = 1;\n                }\n\n                gVBoxAPI.UISerialPort.GetPath(serialPort, &pathUtf16);\n\n                if (pathUtf16) {\n                    VBOX_UTF16_TO_UTF8(pathUtf16, &path);\n                    def->serials[serialPortIncCount]->source->data.file.path = g_strdup(path);\n                }\n\n                serialPortIncCount++;\n\n                VBOX_UTF16_FREE(pathUtf16);\n                VBOX_UTF8_FREE(path);\n            }\n\n            VBOX_RELEASE(serialPort);\n        }\n    }\n    return 0;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "serialPort"
          ],
          "line": 3891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "path"
          ],
          "line": 3888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "pathUtf16"
          ],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "path"
          ],
          "line": 3882
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "pathUtf16",
            "&path"
          ],
          "line": 3881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.GetPath",
          "args": [
            "serialPort",
            "&pathUtf16"
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.GetIOBase",
          "args": [
            "serialPort",
            "&IOBase"
          ],
          "line": 3871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.GetIRQ",
          "args": [
            "serialPort",
            "&IRQ"
          ],
          "line": 3870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.GetHostMode",
          "args": [
            "serialPort",
            "&hostMode"
          ],
          "line": 3855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.GetEnabled",
          "args": [
            "serialPort",
            "&enabled"
          ],
          "line": 3847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetSerialPort",
          "args": [
            "machine",
            "i",
            "&serialPort"
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainChrDefNew",
          "args": [
            "NULL"
          ],
          "line": 3831
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "13232-13246",
          "snippet": "virDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainChrDefPtr\nvirDomainChrDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainChrDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    def->target.port = -1;\n\n    if (!(def->source = virDomainChrSourceDefNew(xmlopt)))\n        VIR_FREE(def);\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->serials",
            "def->nserials"
          ],
          "line": 3827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "serialPort"
          ],
          "line": 3821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.GetEnabled",
          "args": [
            "serialPort",
            "&enabled"
          ],
          "line": 3817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetSerialPort",
          "args": [
            "machine",
            "i",
            "&serialPort"
          ],
          "line": 3813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpSerial(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine, PRUint32 serialPortCount)\n{\n    PRUint32 serialPortIncCount = 0;\n    size_t i = 0;\n    /* dump serial port if active */\n    def->nserials = 0;\n    /* Get which serial ports are enabled/active */\n    for (i = 0; i < serialPortCount; i++) {\n        ISerialPort *serialPort = NULL;\n\n        gVBoxAPI.UIMachine.GetSerialPort(machine, i, &serialPort);\n        if (serialPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UISerialPort.GetEnabled(serialPort, &enabled);\n            if (enabled)\n                def->nserials++;\n\n            VBOX_RELEASE(serialPort);\n        }\n    }\n\n    /* Allocate memory for the serial ports which are enabled */\n    if (def->nserials > 0) {\n        if (VIR_ALLOC_N(def->serials, def->nserials) < 0)\n            return -1;\n\n        for (i = 0; i < def->nserials; i++) {\n            def->serials[i] = virDomainChrDefNew(NULL);\n            if (!def->serials[i])\n                return -1;\n        }\n    }\n\n    /* Now get the details about the serial ports here */\n    for (i = 0;\n         serialPortIncCount < def->nserials && i < serialPortCount;\n         i++) {\n        ISerialPort *serialPort = NULL;\n\n        gVBoxAPI.UIMachine.GetSerialPort(machine, i, &serialPort);\n        if (serialPort) {\n            PRBool enabled = PR_FALSE;\n\n            gVBoxAPI.UISerialPort.GetEnabled(serialPort, &enabled);\n            if (enabled) {\n                PRUint32 hostMode = PortMode_Disconnected;\n                PRUint32 IOBase = 0;\n                PRUint32 IRQ = 0;\n                PRUnichar *pathUtf16 = NULL;\n                char *path = NULL;\n\n                gVBoxAPI.UISerialPort.GetHostMode(serialPort, &hostMode);\n                if (hostMode == PortMode_HostPipe) {\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_PIPE;\n                } else if (hostMode == PortMode_HostDevice) {\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_DEV;\n                } else if (gVBoxAPI.APIVersion >= 2002051 &&\n                           hostMode == PortMode_RawFile) {\n                    /* PortMode RawFile is used for vbox 3.0 or later */\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_FILE;\n                } else {\n                    def->serials[serialPortIncCount]->source->type = VIR_DOMAIN_CHR_TYPE_NULL;\n                }\n\n                def->serials[serialPortIncCount]->deviceType = VIR_DOMAIN_CHR_DEVICE_TYPE_SERIAL;\n\n                gVBoxAPI.UISerialPort.GetIRQ(serialPort, &IRQ);\n                gVBoxAPI.UISerialPort.GetIOBase(serialPort, &IOBase);\n                if ((IRQ == 4) && (IOBase == 1016)) {\n                    def->serials[serialPortIncCount]->target.port = 0;\n                } else if ((IRQ == 3) && (IOBase == 760)) {\n                    def->serials[serialPortIncCount]->target.port = 1;\n                }\n\n                gVBoxAPI.UISerialPort.GetPath(serialPort, &pathUtf16);\n\n                if (pathUtf16) {\n                    VBOX_UTF16_TO_UTF8(pathUtf16, &path);\n                    def->serials[serialPortIncCount]->source->data.file.path = g_strdup(path);\n                }\n\n                serialPortIncCount++;\n\n                VBOX_UTF16_FREE(pathUtf16);\n                VBOX_UTF8_FREE(path);\n            }\n\n            VBOX_RELEASE(serialPort);\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "vboxDumpAudio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "3762-3800",
    "snippet": "static void\nvboxDumpAudio(virDomainDefPtr def, vboxDriverPtr data G_GNUC_UNUSED,\n              IMachine *machine)\n{\n    /* dump sound card if active */\n\n    /* Set def->nsounds to one as VirtualBox currently supports\n     * only one sound card\n     */\n    IAudioAdapter *audioAdapter = NULL;\n\n    gVBoxAPI.UIMachine.GetAudioAdapter(machine, &audioAdapter);\n    if (audioAdapter) {\n        PRBool enabled = PR_FALSE;\n\n        gVBoxAPI.UIAudioAdapter.GetEnabled(audioAdapter, &enabled);\n        if (enabled) {\n            PRUint32 audioController = AudioControllerType_AC97;\n\n            def->nsounds = 1;\n            if (VIR_ALLOC_N(def->sounds, def->nsounds) >= 0) {\n                if (VIR_ALLOC(def->sounds[0]) >= 0) {\n                    gVBoxAPI.UIAudioAdapter.GetAudioController(audioAdapter, &audioController);\n                    if (audioController == AudioControllerType_SB16) {\n                        def->sounds[0]->model = VIR_DOMAIN_SOUND_MODEL_SB16;\n                    } else if (audioController == AudioControllerType_AC97) {\n                        def->sounds[0]->model = VIR_DOMAIN_SOUND_MODEL_AC97;\n                    }\n                } else {\n                    VIR_FREE(def->sounds);\n                    def->nsounds = 0;\n                }\n            } else {\n                def->nsounds = 0;\n            }\n        }\n        VBOX_RELEASE(audioAdapter);\n    }\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "audioAdapter"
          ],
          "line": 3798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->sounds"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIAudioAdapter.GetAudioController",
          "args": [
            "audioAdapter",
            "&audioController"
          ],
          "line": 3784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def->sounds[0]"
          ],
          "line": 3783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->sounds",
            "def->nsounds"
          ],
          "line": 3782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIAudioAdapter.GetEnabled",
          "args": [
            "audioAdapter",
            "&enabled"
          ],
          "line": 3777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAudioAdapter",
          "args": [
            "machine",
            "&audioAdapter"
          ],
          "line": 3773
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxDumpAudio(virDomainDefPtr def, vboxDriverPtr data G_GNUC_UNUSED,\n              IMachine *machine)\n{\n    /* dump sound card if active */\n\n    /* Set def->nsounds to one as VirtualBox currently supports\n     * only one sound card\n     */\n    IAudioAdapter *audioAdapter = NULL;\n\n    gVBoxAPI.UIMachine.GetAudioAdapter(machine, &audioAdapter);\n    if (audioAdapter) {\n        PRBool enabled = PR_FALSE;\n\n        gVBoxAPI.UIAudioAdapter.GetEnabled(audioAdapter, &enabled);\n        if (enabled) {\n            PRUint32 audioController = AudioControllerType_AC97;\n\n            def->nsounds = 1;\n            if (VIR_ALLOC_N(def->sounds, def->nsounds) >= 0) {\n                if (VIR_ALLOC(def->sounds[0]) >= 0) {\n                    gVBoxAPI.UIAudioAdapter.GetAudioController(audioAdapter, &audioController);\n                    if (audioController == AudioControllerType_SB16) {\n                        def->sounds[0]->model = VIR_DOMAIN_SOUND_MODEL_SB16;\n                    } else if (audioController == AudioControllerType_AC97) {\n                        def->sounds[0]->model = VIR_DOMAIN_SOUND_MODEL_AC97;\n                    }\n                } else {\n                    VIR_FREE(def->sounds);\n                    def->nsounds = 0;\n                }\n            } else {\n                def->nsounds = 0;\n            }\n        }\n        VBOX_RELEASE(audioAdapter);\n    }\n}"
  },
  {
    "function_name": "vboxDumpNetworks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "3734-3760",
    "snippet": "static int\nvboxDumpNetworks(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine, PRUint32 networkAdapterCount)\n{\n    size_t i = 0;\n\n    for (i = 0; i < networkAdapterCount; i++) {\n        INetworkAdapter *adapter = NULL;\n        virDomainNetDefPtr net = NULL;\n        PRBool enabled = PR_FALSE;\n\n        gVBoxAPI.UIMachine.GetNetworkAdapter(machine, i, &adapter);\n        if (adapter)\n            gVBoxAPI.UINetworkAdapter.GetEnabled(adapter, &enabled);\n\n        if (enabled) {\n            net = vboxDumpNetwork(data, adapter);\n            if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0) {\n                VBOX_RELEASE(adapter);\n                return -1;\n            }\n        }\n\n        VBOX_RELEASE(adapter);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "adapter"
          ],
          "line": 3756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "adapter"
          ],
          "line": 3751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->nets",
            "def->nnets",
            "net"
          ],
          "line": 3750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxDumpNetwork",
          "args": [
            "data",
            "adapter"
          ],
          "line": 3749
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDumpNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "3637-3732",
          "snippet": "static virDomainNetDefPtr\nvboxDumpNetwork(vboxDriverPtr data, INetworkAdapter *adapter)\n{\n    PRUint32 attachmentType = NetworkAttachmentType_Null;\n    PRUint32 adapterType = NetworkAdapterType_Null;\n    PRUnichar *utf16 = NULL;\n    char *utf8 = NULL;\n    virDomainNetDefPtr net = NULL;\n\n    if (!(net = virDomainNetDefNew(data->xmlopt)))\n        return NULL;\n\n    gVBoxAPI.UINetworkAdapter.GetAttachmentType(adapter, &attachmentType);\n\n    switch (attachmentType) {\n    case NetworkAttachmentType_NAT:\n        net->type = VIR_DOMAIN_NET_TYPE_USER;\n        break;\n\n    case NetworkAttachmentType_Bridged:\n        net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n\n        gVBoxAPI.UINetworkAdapter.GetBridgedInterface(adapter, &utf16);\n\n        VBOX_UTF16_TO_UTF8(utf16, &utf8);\n        net->data.bridge.brname = g_steal_pointer(&utf8);\n        VBOX_UTF16_FREE(utf16);\n        break;\n\n    case NetworkAttachmentType_Internal:\n        net->type = VIR_DOMAIN_NET_TYPE_INTERNAL;\n\n        gVBoxAPI.UINetworkAdapter.GetInternalNetwork(adapter, &utf16);\n\n        VBOX_UTF16_TO_UTF8(utf16, &utf8);\n        net->data.internal.name = g_steal_pointer(&utf8);\n        VBOX_UTF16_FREE(utf16);\n        break;\n\n    case NetworkAttachmentType_HostOnly:\n        net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n\n        gVBoxAPI.UINetworkAdapter.GetHostOnlyInterface(adapter, &utf16);\n\n        VBOX_UTF16_TO_UTF8(utf16, &utf8);\n        net->data.network.name = g_steal_pointer(&utf8);\n        VBOX_UTF16_FREE(utf16);\n        break;\n\n    default:\n        /* default to user type i.e. NAT in VirtualBox if this\n         * dump is ever used to create a machine.\n         */\n        net->type = VIR_DOMAIN_NET_TYPE_USER;\n    }\n\n    gVBoxAPI.UINetworkAdapter.GetAdapterType(adapter, &adapterType);\n    switch (adapterType) {\n    case NetworkAdapterType_Am79C970A:\n        net->model = VIR_DOMAIN_NET_MODEL_AM79C970A;\n        break;\n    case NetworkAdapterType_Am79C973:\n        net->model = VIR_DOMAIN_NET_MODEL_AM79C973;\n        break;\n    case NetworkAdapterType_I82540EM:\n        net->model = VIR_DOMAIN_NET_MODEL_82540EM;\n        break;\n    case NetworkAdapterType_I82545EM:\n        net->model = VIR_DOMAIN_NET_MODEL_82545EM;\n        break;\n    case NetworkAdapterType_I82543GC:\n        net->model = VIR_DOMAIN_NET_MODEL_82543GC;\n        break;\n    case NetworkAdapterType_Virtio:\n        /* Only vbox 3.1 and later support NetworkAdapterType_Virto */\n        if (gVBoxAPI.APIVersion >= 3000051)\n            net->model = VIR_DOMAIN_NET_MODEL_VIRTIO;\n        break;\n    }\n\n    gVBoxAPI.UINetworkAdapter.GetMACAddress(adapter, &utf16);\n    VBOX_UTF16_TO_UTF8(utf16, &utf8);\n    VBOX_UTF16_FREE(utf16);\n\n    if (virMacAddrParseHex(utf8, &net->mac) < 0) {\n        VBOX_UTF8_FREE(utf8);\n        goto error;\n    }\n\n    VBOX_UTF8_FREE(utf8);\n    return net;\n\n error:\n    virDomainNetDefFree(net);\n    return NULL;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virDomainNetDefPtr\nvboxDumpNetwork(vboxDriverPtr data, INetworkAdapter *adapter)\n{\n    PRUint32 attachmentType = NetworkAttachmentType_Null;\n    PRUint32 adapterType = NetworkAdapterType_Null;\n    PRUnichar *utf16 = NULL;\n    char *utf8 = NULL;\n    virDomainNetDefPtr net = NULL;\n\n    if (!(net = virDomainNetDefNew(data->xmlopt)))\n        return NULL;\n\n    gVBoxAPI.UINetworkAdapter.GetAttachmentType(adapter, &attachmentType);\n\n    switch (attachmentType) {\n    case NetworkAttachmentType_NAT:\n        net->type = VIR_DOMAIN_NET_TYPE_USER;\n        break;\n\n    case NetworkAttachmentType_Bridged:\n        net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n\n        gVBoxAPI.UINetworkAdapter.GetBridgedInterface(adapter, &utf16);\n\n        VBOX_UTF16_TO_UTF8(utf16, &utf8);\n        net->data.bridge.brname = g_steal_pointer(&utf8);\n        VBOX_UTF16_FREE(utf16);\n        break;\n\n    case NetworkAttachmentType_Internal:\n        net->type = VIR_DOMAIN_NET_TYPE_INTERNAL;\n\n        gVBoxAPI.UINetworkAdapter.GetInternalNetwork(adapter, &utf16);\n\n        VBOX_UTF16_TO_UTF8(utf16, &utf8);\n        net->data.internal.name = g_steal_pointer(&utf8);\n        VBOX_UTF16_FREE(utf16);\n        break;\n\n    case NetworkAttachmentType_HostOnly:\n        net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n\n        gVBoxAPI.UINetworkAdapter.GetHostOnlyInterface(adapter, &utf16);\n\n        VBOX_UTF16_TO_UTF8(utf16, &utf8);\n        net->data.network.name = g_steal_pointer(&utf8);\n        VBOX_UTF16_FREE(utf16);\n        break;\n\n    default:\n        /* default to user type i.e. NAT in VirtualBox if this\n         * dump is ever used to create a machine.\n         */\n        net->type = VIR_DOMAIN_NET_TYPE_USER;\n    }\n\n    gVBoxAPI.UINetworkAdapter.GetAdapterType(adapter, &adapterType);\n    switch (adapterType) {\n    case NetworkAdapterType_Am79C970A:\n        net->model = VIR_DOMAIN_NET_MODEL_AM79C970A;\n        break;\n    case NetworkAdapterType_Am79C973:\n        net->model = VIR_DOMAIN_NET_MODEL_AM79C973;\n        break;\n    case NetworkAdapterType_I82540EM:\n        net->model = VIR_DOMAIN_NET_MODEL_82540EM;\n        break;\n    case NetworkAdapterType_I82545EM:\n        net->model = VIR_DOMAIN_NET_MODEL_82545EM;\n        break;\n    case NetworkAdapterType_I82543GC:\n        net->model = VIR_DOMAIN_NET_MODEL_82543GC;\n        break;\n    case NetworkAdapterType_Virtio:\n        /* Only vbox 3.1 and later support NetworkAdapterType_Virto */\n        if (gVBoxAPI.APIVersion >= 3000051)\n            net->model = VIR_DOMAIN_NET_MODEL_VIRTIO;\n        break;\n    }\n\n    gVBoxAPI.UINetworkAdapter.GetMACAddress(adapter, &utf16);\n    VBOX_UTF16_TO_UTF8(utf16, &utf8);\n    VBOX_UTF16_FREE(utf16);\n\n    if (virMacAddrParseHex(utf8, &net->mac) < 0) {\n        VBOX_UTF8_FREE(utf8);\n        goto error;\n    }\n\n    VBOX_UTF8_FREE(utf8);\n    return net;\n\n error:\n    virDomainNetDefFree(net);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.GetEnabled",
          "args": [
            "adapter",
            "&enabled"
          ],
          "line": 3746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetNetworkAdapter",
          "args": [
            "machine",
            "i",
            "&adapter"
          ],
          "line": 3744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpNetworks(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine, PRUint32 networkAdapterCount)\n{\n    size_t i = 0;\n\n    for (i = 0; i < networkAdapterCount; i++) {\n        INetworkAdapter *adapter = NULL;\n        virDomainNetDefPtr net = NULL;\n        PRBool enabled = PR_FALSE;\n\n        gVBoxAPI.UIMachine.GetNetworkAdapter(machine, i, &adapter);\n        if (adapter)\n            gVBoxAPI.UINetworkAdapter.GetEnabled(adapter, &enabled);\n\n        if (enabled) {\n            net = vboxDumpNetwork(data, adapter);\n            if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0) {\n                VBOX_RELEASE(adapter);\n                return -1;\n            }\n        }\n\n        VBOX_RELEASE(adapter);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vboxDumpNetwork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "3637-3732",
    "snippet": "static virDomainNetDefPtr\nvboxDumpNetwork(vboxDriverPtr data, INetworkAdapter *adapter)\n{\n    PRUint32 attachmentType = NetworkAttachmentType_Null;\n    PRUint32 adapterType = NetworkAdapterType_Null;\n    PRUnichar *utf16 = NULL;\n    char *utf8 = NULL;\n    virDomainNetDefPtr net = NULL;\n\n    if (!(net = virDomainNetDefNew(data->xmlopt)))\n        return NULL;\n\n    gVBoxAPI.UINetworkAdapter.GetAttachmentType(adapter, &attachmentType);\n\n    switch (attachmentType) {\n    case NetworkAttachmentType_NAT:\n        net->type = VIR_DOMAIN_NET_TYPE_USER;\n        break;\n\n    case NetworkAttachmentType_Bridged:\n        net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n\n        gVBoxAPI.UINetworkAdapter.GetBridgedInterface(adapter, &utf16);\n\n        VBOX_UTF16_TO_UTF8(utf16, &utf8);\n        net->data.bridge.brname = g_steal_pointer(&utf8);\n        VBOX_UTF16_FREE(utf16);\n        break;\n\n    case NetworkAttachmentType_Internal:\n        net->type = VIR_DOMAIN_NET_TYPE_INTERNAL;\n\n        gVBoxAPI.UINetworkAdapter.GetInternalNetwork(adapter, &utf16);\n\n        VBOX_UTF16_TO_UTF8(utf16, &utf8);\n        net->data.internal.name = g_steal_pointer(&utf8);\n        VBOX_UTF16_FREE(utf16);\n        break;\n\n    case NetworkAttachmentType_HostOnly:\n        net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n\n        gVBoxAPI.UINetworkAdapter.GetHostOnlyInterface(adapter, &utf16);\n\n        VBOX_UTF16_TO_UTF8(utf16, &utf8);\n        net->data.network.name = g_steal_pointer(&utf8);\n        VBOX_UTF16_FREE(utf16);\n        break;\n\n    default:\n        /* default to user type i.e. NAT in VirtualBox if this\n         * dump is ever used to create a machine.\n         */\n        net->type = VIR_DOMAIN_NET_TYPE_USER;\n    }\n\n    gVBoxAPI.UINetworkAdapter.GetAdapterType(adapter, &adapterType);\n    switch (adapterType) {\n    case NetworkAdapterType_Am79C970A:\n        net->model = VIR_DOMAIN_NET_MODEL_AM79C970A;\n        break;\n    case NetworkAdapterType_Am79C973:\n        net->model = VIR_DOMAIN_NET_MODEL_AM79C973;\n        break;\n    case NetworkAdapterType_I82540EM:\n        net->model = VIR_DOMAIN_NET_MODEL_82540EM;\n        break;\n    case NetworkAdapterType_I82545EM:\n        net->model = VIR_DOMAIN_NET_MODEL_82545EM;\n        break;\n    case NetworkAdapterType_I82543GC:\n        net->model = VIR_DOMAIN_NET_MODEL_82543GC;\n        break;\n    case NetworkAdapterType_Virtio:\n        /* Only vbox 3.1 and later support NetworkAdapterType_Virto */\n        if (gVBoxAPI.APIVersion >= 3000051)\n            net->model = VIR_DOMAIN_NET_MODEL_VIRTIO;\n        break;\n    }\n\n    gVBoxAPI.UINetworkAdapter.GetMACAddress(adapter, &utf16);\n    VBOX_UTF16_TO_UTF8(utf16, &utf8);\n    VBOX_UTF16_FREE(utf16);\n\n    if (virMacAddrParseHex(utf8, &net->mac) < 0) {\n        VBOX_UTF8_FREE(utf8);\n        goto error;\n    }\n\n    VBOX_UTF8_FREE(utf8);\n    return net;\n\n error:\n    virDomainNetDefFree(net);\n    return NULL;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainNetDefFree",
          "args": [
            "net"
          ],
          "line": 3730
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2481-2489",
          "snippet": "void\nvirDomainNetDefFree(virDomainNetDefPtr def)\n{\n    if (!def)\n        return;\n    virDomainNetDefClear(def);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainNetDefFree(virDomainNetDefPtr def)\n{\n    if (!def)\n        return;\n    virDomainNetDefClear(def);\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "utf8"
          ],
          "line": 3726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "utf8"
          ],
          "line": 3722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrParseHex",
          "args": [
            "utf8",
            "&net->mac"
          ],
          "line": 3721
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "205-218",
          "snippet": "int\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nint\nvirMacAddrParseHex(const char *str, virMacAddrPtr addr)\n{\n    size_t i;\n\n    if (strspn(str, \"0123456789abcdefABCDEF\") != VIR_MAC_HEXLEN ||\n        str[VIR_MAC_HEXLEN])\n        return -1;\n\n    for (i = 0; i < VIR_MAC_BUFLEN; i++)\n        addr->addr[i] = (g_ascii_xdigit_value(str[2 * i]) << 4 |\n                         g_ascii_xdigit_value(str[2 * i + 1]));\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "utf16"
          ],
          "line": 3719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "utf16",
            "&utf8"
          ],
          "line": 3718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.GetMACAddress",
          "args": [
            "adapter",
            "&utf16"
          ],
          "line": 3717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.GetAdapterType",
          "args": [
            "adapter",
            "&adapterType"
          ],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "utf16"
          ],
          "line": 3683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&utf8"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "utf16",
            "&utf8"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.GetHostOnlyInterface",
          "args": [
            "adapter",
            "&utf16"
          ],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "utf16"
          ],
          "line": 3673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&utf8"
          ],
          "line": 3672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "utf16",
            "&utf8"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.GetInternalNetwork",
          "args": [
            "adapter",
            "&utf16"
          ],
          "line": 3669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "utf16"
          ],
          "line": 3663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&utf8"
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "utf16",
            "&utf8"
          ],
          "line": 3661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.GetBridgedInterface",
          "args": [
            "adapter",
            "&utf16"
          ],
          "line": 3659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.GetAttachmentType",
          "args": [
            "adapter",
            "&attachmentType"
          ],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetDefNew",
          "args": [
            "data->xmlopt"
          ],
          "line": 3646
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "14783-14798",
          "snippet": "virDomainNetDefPtr\nvirDomainNetDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainNetDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (xmlopt && xmlopt->privateData.networkNew &&\n        !(def->privateData = xmlopt->privateData.networkNew())) {\n        virDomainNetDefFree(def);\n        def = NULL;\n    }\n\n    return def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainNetDefPtr\nvirDomainNetDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainNetDefPtr def = NULL;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (xmlopt && xmlopt->privateData.networkNew &&\n        !(def->privateData = xmlopt->privateData.networkNew())) {\n        virDomainNetDefFree(def);\n        def = NULL;\n    }\n\n    return def;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virDomainNetDefPtr\nvboxDumpNetwork(vboxDriverPtr data, INetworkAdapter *adapter)\n{\n    PRUint32 attachmentType = NetworkAttachmentType_Null;\n    PRUint32 adapterType = NetworkAdapterType_Null;\n    PRUnichar *utf16 = NULL;\n    char *utf8 = NULL;\n    virDomainNetDefPtr net = NULL;\n\n    if (!(net = virDomainNetDefNew(data->xmlopt)))\n        return NULL;\n\n    gVBoxAPI.UINetworkAdapter.GetAttachmentType(adapter, &attachmentType);\n\n    switch (attachmentType) {\n    case NetworkAttachmentType_NAT:\n        net->type = VIR_DOMAIN_NET_TYPE_USER;\n        break;\n\n    case NetworkAttachmentType_Bridged:\n        net->type = VIR_DOMAIN_NET_TYPE_BRIDGE;\n\n        gVBoxAPI.UINetworkAdapter.GetBridgedInterface(adapter, &utf16);\n\n        VBOX_UTF16_TO_UTF8(utf16, &utf8);\n        net->data.bridge.brname = g_steal_pointer(&utf8);\n        VBOX_UTF16_FREE(utf16);\n        break;\n\n    case NetworkAttachmentType_Internal:\n        net->type = VIR_DOMAIN_NET_TYPE_INTERNAL;\n\n        gVBoxAPI.UINetworkAdapter.GetInternalNetwork(adapter, &utf16);\n\n        VBOX_UTF16_TO_UTF8(utf16, &utf8);\n        net->data.internal.name = g_steal_pointer(&utf8);\n        VBOX_UTF16_FREE(utf16);\n        break;\n\n    case NetworkAttachmentType_HostOnly:\n        net->type = VIR_DOMAIN_NET_TYPE_NETWORK;\n\n        gVBoxAPI.UINetworkAdapter.GetHostOnlyInterface(adapter, &utf16);\n\n        VBOX_UTF16_TO_UTF8(utf16, &utf8);\n        net->data.network.name = g_steal_pointer(&utf8);\n        VBOX_UTF16_FREE(utf16);\n        break;\n\n    default:\n        /* default to user type i.e. NAT in VirtualBox if this\n         * dump is ever used to create a machine.\n         */\n        net->type = VIR_DOMAIN_NET_TYPE_USER;\n    }\n\n    gVBoxAPI.UINetworkAdapter.GetAdapterType(adapter, &adapterType);\n    switch (adapterType) {\n    case NetworkAdapterType_Am79C970A:\n        net->model = VIR_DOMAIN_NET_MODEL_AM79C970A;\n        break;\n    case NetworkAdapterType_Am79C973:\n        net->model = VIR_DOMAIN_NET_MODEL_AM79C973;\n        break;\n    case NetworkAdapterType_I82540EM:\n        net->model = VIR_DOMAIN_NET_MODEL_82540EM;\n        break;\n    case NetworkAdapterType_I82545EM:\n        net->model = VIR_DOMAIN_NET_MODEL_82545EM;\n        break;\n    case NetworkAdapterType_I82543GC:\n        net->model = VIR_DOMAIN_NET_MODEL_82543GC;\n        break;\n    case NetworkAdapterType_Virtio:\n        /* Only vbox 3.1 and later support NetworkAdapterType_Virto */\n        if (gVBoxAPI.APIVersion >= 3000051)\n            net->model = VIR_DOMAIN_NET_MODEL_VIRTIO;\n        break;\n    }\n\n    gVBoxAPI.UINetworkAdapter.GetMACAddress(adapter, &utf16);\n    VBOX_UTF16_TO_UTF8(utf16, &utf8);\n    VBOX_UTF16_FREE(utf16);\n\n    if (virMacAddrParseHex(utf8, &net->mac) < 0) {\n        VBOX_UTF8_FREE(utf8);\n        goto error;\n    }\n\n    VBOX_UTF8_FREE(utf8);\n    return net;\n\n error:\n    virDomainNetDefFree(net);\n    return NULL;\n}"
  },
  {
    "function_name": "vboxDumpSharedFolders",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "3578-3635",
    "snippet": "static int\nvboxDumpSharedFolders(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    vboxArray sharedFolders = VBOX_ARRAY_INITIALIZER;\n    size_t i = 0;\n    int ret = -1;\n\n    def->nfss = 0;\n\n    gVBoxAPI.UArray.vboxArrayGet(&sharedFolders, machine,\n                                 gVBoxAPI.UArray.handleMachineGetSharedFolders(machine));\n\n    if (sharedFolders.count <= 0) {\n        if (sharedFolders.count == 0)\n            ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->fss, sharedFolders.count) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sharedFolders.count; i++) {\n        ISharedFolder *sharedFolder = sharedFolders.items[i];\n        PRUnichar *nameUtf16 = NULL;\n        char *name = NULL;\n        PRUnichar *hostPathUtf16 = NULL;\n        char *hostPath = NULL;\n        PRBool writable = PR_FALSE;\n\n        if (VIR_ALLOC(def->fss[i]) < 0)\n            goto cleanup;\n\n        def->fss[i]->type = VIR_DOMAIN_FS_TYPE_MOUNT;\n\n        gVBoxAPI.UISharedFolder.GetHostPath(sharedFolder, &hostPathUtf16);\n        VBOX_UTF16_TO_UTF8(hostPathUtf16, &hostPath);\n        def->fss[i]->src->path = g_strdup(hostPath);\n        VBOX_UTF8_FREE(hostPath);\n        VBOX_UTF16_FREE(hostPathUtf16);\n\n        gVBoxAPI.UISharedFolder.GetName(sharedFolder, &nameUtf16);\n        VBOX_UTF16_TO_UTF8(nameUtf16, &name);\n        def->fss[i]->dst = g_strdup(name);\n        VBOX_UTF8_FREE(name);\n        VBOX_UTF16_FREE(nameUtf16);\n\n        gVBoxAPI.UISharedFolder.GetWritable(sharedFolder, &writable);\n        def->fss[i]->readonly = !writable;\n\n        ++def->nfss;\n    }\n\n    ret = 0;\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&sharedFolders);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&sharedFolders"
          ],
          "line": 3633
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISharedFolder.GetWritable",
          "args": [
            "sharedFolder",
            "&writable"
          ],
          "line": 3624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "nameUtf16"
          ],
          "line": 3622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "name"
          ],
          "line": 3621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "name"
          ],
          "line": 3620
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "nameUtf16",
            "&name"
          ],
          "line": 3619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISharedFolder.GetName",
          "args": [
            "sharedFolder",
            "&nameUtf16"
          ],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "hostPathUtf16"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "hostPath"
          ],
          "line": 3615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "hostPathUtf16",
            "&hostPath"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISharedFolder.GetHostPath",
          "args": [
            "sharedFolder",
            "&hostPathUtf16"
          ],
          "line": 3612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def->fss[i]"
          ],
          "line": 3607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->fss",
            "sharedFolders.count"
          ],
          "line": 3596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&sharedFolders",
            "machine",
            "gVBoxAPI.UArray.handleMachineGetSharedFolders(machine)"
          ],
          "line": 3587
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleMachineGetSharedFolders",
          "args": [
            "machine"
          ],
          "line": 3588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpSharedFolders(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    vboxArray sharedFolders = VBOX_ARRAY_INITIALIZER;\n    size_t i = 0;\n    int ret = -1;\n\n    def->nfss = 0;\n\n    gVBoxAPI.UArray.vboxArrayGet(&sharedFolders, machine,\n                                 gVBoxAPI.UArray.handleMachineGetSharedFolders(machine));\n\n    if (sharedFolders.count <= 0) {\n        if (sharedFolders.count == 0)\n            ret = 0;\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(def->fss, sharedFolders.count) < 0)\n        goto cleanup;\n\n    for (i = 0; i < sharedFolders.count; i++) {\n        ISharedFolder *sharedFolder = sharedFolders.items[i];\n        PRUnichar *nameUtf16 = NULL;\n        char *name = NULL;\n        PRUnichar *hostPathUtf16 = NULL;\n        char *hostPath = NULL;\n        PRBool writable = PR_FALSE;\n\n        if (VIR_ALLOC(def->fss[i]) < 0)\n            goto cleanup;\n\n        def->fss[i]->type = VIR_DOMAIN_FS_TYPE_MOUNT;\n\n        gVBoxAPI.UISharedFolder.GetHostPath(sharedFolder, &hostPathUtf16);\n        VBOX_UTF16_TO_UTF8(hostPathUtf16, &hostPath);\n        def->fss[i]->src->path = g_strdup(hostPath);\n        VBOX_UTF8_FREE(hostPath);\n        VBOX_UTF16_FREE(hostPathUtf16);\n\n        gVBoxAPI.UISharedFolder.GetName(sharedFolder, &nameUtf16);\n        VBOX_UTF16_TO_UTF8(nameUtf16, &name);\n        def->fss[i]->dst = g_strdup(name);\n        VBOX_UTF8_FREE(name);\n        VBOX_UTF16_FREE(nameUtf16);\n\n        gVBoxAPI.UISharedFolder.GetWritable(sharedFolder, &writable);\n        def->fss[i]->readonly = !writable;\n\n        ++def->nfss;\n    }\n\n    ret = 0;\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&sharedFolders);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDumpDisplay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "3460-3576",
    "snippet": "static int\nvboxDumpDisplay(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    /* dump display options vrdp/gui/sdl */\n    PRUnichar *keyUtf16 = NULL;\n    PRUnichar *valueTypeUtf16 = NULL;\n    char *valueTypeUtf8 = NULL;\n    char *netAddressUtf8 = NULL;\n    IVRDEServer *VRDEServer = NULL;\n    PRBool VRDxEnabled = PR_FALSE;\n    virDomainGraphicsDefPtr graphics = NULL;\n    int ret = -1;\n\n    def->ngraphics = 0;\n\n    VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyUtf16);\n    gVBoxAPI.UIMachine.GetExtraData(machine, keyUtf16, &valueTypeUtf16);\n    VBOX_UTF16_FREE(keyUtf16);\n\n    if (valueTypeUtf16) {\n        VBOX_UTF16_TO_UTF8(valueTypeUtf16, &valueTypeUtf8);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n    }\n\n    if (STREQ_NULLABLE(valueTypeUtf8, \"sdl\") ||\n        STREQ_NULLABLE(valueTypeUtf8, \"gui\")) {\n        PRUnichar *valueDisplayUtf16 = NULL;\n        char *valueDisplayUtf8 = NULL;\n\n        if (VIR_ALLOC(graphics) < 0)\n            goto cleanup;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyUtf16);\n        gVBoxAPI.UIMachine.GetExtraData(machine, keyUtf16, &valueDisplayUtf16);\n        VBOX_UTF16_FREE(keyUtf16);\n\n        if (valueDisplayUtf16) {\n            VBOX_UTF16_TO_UTF8(valueDisplayUtf16, &valueDisplayUtf8);\n            VBOX_UTF16_FREE(valueDisplayUtf16);\n\n            if (STREQ(valueDisplayUtf8, \"\"))\n                VBOX_UTF8_FREE(valueDisplayUtf8);\n        }\n\n        if (STREQ_NULLABLE(valueTypeUtf8, \"sdl\")) {\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SDL;\n            graphics->data.sdl.display = valueDisplayUtf8;\n            valueDisplayUtf8 = NULL;\n        }\n\n        if (STREQ_NULLABLE(valueTypeUtf8, \"gui\")) {\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP;\n            graphics->data.desktop.display = valueDisplayUtf8;\n            valueDisplayUtf8 = NULL;\n        }\n        VBOX_UTF8_FREE(valueDisplayUtf8);\n    } else if (STRNEQ_NULLABLE(valueTypeUtf8, \"vrdp\")) {\n        if (VIR_ALLOC(graphics) < 0)\n            goto cleanup;\n\n        graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP;\n        graphics->data.desktop.display = g_strdup(getenv(\"DISPLAY\"));\n    }\n\n    if (graphics &&\n        VIR_APPEND_ELEMENT(def->graphics, def->ngraphics, graphics) < 0)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetVRDEServer(machine, &VRDEServer);\n    if (VRDEServer)\n        gVBoxAPI.UIVRDEServer.GetEnabled(VRDEServer, &VRDxEnabled);\n\n    if (VRDxEnabled) {\n        PRUnichar *netAddressUtf16 = NULL;\n        PRBool allowMultiConnection = PR_FALSE;\n        PRBool reuseSingleConnection = PR_FALSE;\n\n        if (VIR_ALLOC(graphics) < 0)\n            goto cleanup;\n\n        gVBoxAPI.UIVRDEServer.GetPorts(data, VRDEServer, machine, graphics);\n\n        graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_RDP;\n\n        gVBoxAPI.UIVRDEServer.GetNetAddress(data, VRDEServer, &netAddressUtf16);\n        if (netAddressUtf16) {\n            VBOX_UTF16_TO_UTF8(netAddressUtf16, &netAddressUtf8);\n            VBOX_UTF16_FREE(netAddressUtf16);\n        }\n\n        if (netAddressUtf8 && STREQ(netAddressUtf8, \"\"))\n            VBOX_UTF8_FREE(netAddressUtf8);\n\n        if (virDomainGraphicsListenAppendAddress(graphics, netAddressUtf8) < 0)\n            goto cleanup;\n\n        gVBoxAPI.UIVRDEServer.GetAllowMultiConnection(VRDEServer, &allowMultiConnection);\n        if (allowMultiConnection)\n            graphics->data.rdp.multiUser = true;\n\n        gVBoxAPI.UIVRDEServer.GetReuseSingleConnection(VRDEServer, &reuseSingleConnection);\n        if (reuseSingleConnection)\n            graphics->data.rdp.replaceUser = true;\n\n        if (VIR_APPEND_ELEMENT(def->graphics, def->ngraphics, graphics) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(VRDEServer);\n    VBOX_UTF8_FREE(valueTypeUtf8);\n    VBOX_UTF8_FREE(netAddressUtf8);\n    virDomainGraphicsDefFree(graphics);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainGraphicsDefFree",
          "args": [
            "graphics"
          ],
          "line": 3574
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1719-1764",
          "snippet": "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    switch (def->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        VIR_FREE(def->data.vnc.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.vnc.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n        VIR_FREE(def->data.sdl.display);\n        VIR_FREE(def->data.sdl.xauth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n        VIR_FREE(def->data.desktop.display);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        VIR_FREE(def->data.spice.rendernode);\n        VIR_FREE(def->data.spice.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.spice.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        VIR_FREE(def->data.egl_headless.rendernode);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    for (i = 0; i < def->nListens; i++)\n        virDomainGraphicsListenDefClear(&def->listens[i]);\n    VIR_FREE(def->listens);\n\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    switch (def->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        VIR_FREE(def->data.vnc.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.vnc.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n        VIR_FREE(def->data.sdl.display);\n        VIR_FREE(def->data.sdl.xauth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n        VIR_FREE(def->data.desktop.display);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        VIR_FREE(def->data.spice.rendernode);\n        VIR_FREE(def->data.spice.keymap);\n        virDomainGraphicsAuthDefClear(&def->data.spice.auth);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        VIR_FREE(def->data.egl_headless.rendernode);\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    for (i = 0; i < def->nListens; i++)\n        virDomainGraphicsListenDefClear(&def->listens[i]);\n    VIR_FREE(def->listens);\n\n    virObjectUnref(def->privateData);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "netAddressUtf8"
          ],
          "line": 3573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "valueTypeUtf8"
          ],
          "line": 3572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "VRDEServer"
          ],
          "line": 3571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->graphics",
            "def->ngraphics",
            "graphics"
          ],
          "line": 3564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVRDEServer.GetReuseSingleConnection",
          "args": [
            "VRDEServer",
            "&reuseSingleConnection"
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVRDEServer.GetAllowMultiConnection",
          "args": [
            "VRDEServer",
            "&allowMultiConnection"
          ],
          "line": 3556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsListenAppendAddress",
          "args": [
            "graphics",
            "netAddressUtf8"
          ],
          "line": 3553
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsListenAppendAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30367-30386",
          "snippet": "int\nvirDomainGraphicsListenAppendAddress(virDomainGraphicsDefPtr def,\n                                     const char *address)\n{\n    virDomainGraphicsListenDef glisten;\n\n    memset(&glisten, 0, sizeof(glisten));\n\n    glisten.type = VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS;\n\n    glisten.address = g_strdup(address);\n\n    if (VIR_APPEND_ELEMENT_COPY(def->listens, def->nListens, glisten) < 0)\n        goto error;\n\n    return 0;\n error:\n    VIR_FREE(glisten.address);\n    return -1;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainGraphicsListenAppendAddress(virDomainGraphicsDefPtr def,\n                                     const char *address)\n{\n    virDomainGraphicsListenDef glisten;\n\n    memset(&glisten, 0, sizeof(glisten));\n\n    glisten.type = VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS;\n\n    glisten.address = g_strdup(address);\n\n    if (VIR_APPEND_ELEMENT_COPY(def->listens, def->nListens, glisten) < 0)\n        goto error;\n\n    return 0;\n error:\n    VIR_FREE(glisten.address);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "netAddressUtf8"
          ],
          "line": 3551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "netAddressUtf8",
            "\"\""
          ],
          "line": 3550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "netAddressUtf16"
          ],
          "line": 3547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "netAddressUtf16",
            "&netAddressUtf8"
          ],
          "line": 3546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVRDEServer.GetNetAddress",
          "args": [
            "data",
            "VRDEServer",
            "&netAddressUtf16"
          ],
          "line": 3544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVRDEServer.GetPorts",
          "args": [
            "data",
            "VRDEServer",
            "machine",
            "graphics"
          ],
          "line": 3540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "graphics"
          ],
          "line": 3537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVRDEServer.GetEnabled",
          "args": [
            "VRDEServer",
            "&VRDxEnabled"
          ],
          "line": 3530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetVRDEServer",
          "args": [
            "machine",
            "&VRDEServer"
          ],
          "line": 3528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "def->graphics",
            "def->ngraphics",
            "graphics"
          ],
          "line": 3525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "getenv(\"DISPLAY\")"
          ],
          "line": 3521
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"DISPLAY\""
          ],
          "line": 3521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "graphics"
          ],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "valueTypeUtf8",
            "\"vrdp\""
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "valueDisplayUtf8"
          ],
          "line": 3515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "valueTypeUtf8",
            "\"gui\""
          ],
          "line": 3510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "valueTypeUtf8",
            "\"sdl\""
          ],
          "line": 3504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "valueDisplayUtf8"
          ],
          "line": 3501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "valueDisplayUtf8",
            "\"\""
          ],
          "line": 3500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "valueDisplayUtf16"
          ],
          "line": 3498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "valueDisplayUtf16",
            "&valueDisplayUtf8"
          ],
          "line": 3497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "keyUtf16"
          ],
          "line": 3494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetExtraData",
          "args": [
            "machine",
            "keyUtf16",
            "&valueDisplayUtf16"
          ],
          "line": 3493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"FRONTEND/Display\"",
            "&keyUtf16"
          ],
          "line": 3492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "graphics"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "valueTypeUtf8",
            "\"gui\""
          ],
          "line": 3485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "valueTypeUtf8",
            "\"sdl\""
          ],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "valueTypeUtf16"
          ],
          "line": 3481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "valueTypeUtf16",
            "&valueTypeUtf8"
          ],
          "line": 3480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "keyUtf16"
          ],
          "line": 3477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetExtraData",
          "args": [
            "machine",
            "keyUtf16",
            "&valueTypeUtf16"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"FRONTEND/Type\"",
            "&keyUtf16"
          ],
          "line": 3475
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpDisplay(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    /* dump display options vrdp/gui/sdl */\n    PRUnichar *keyUtf16 = NULL;\n    PRUnichar *valueTypeUtf16 = NULL;\n    char *valueTypeUtf8 = NULL;\n    char *netAddressUtf8 = NULL;\n    IVRDEServer *VRDEServer = NULL;\n    PRBool VRDxEnabled = PR_FALSE;\n    virDomainGraphicsDefPtr graphics = NULL;\n    int ret = -1;\n\n    def->ngraphics = 0;\n\n    VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyUtf16);\n    gVBoxAPI.UIMachine.GetExtraData(machine, keyUtf16, &valueTypeUtf16);\n    VBOX_UTF16_FREE(keyUtf16);\n\n    if (valueTypeUtf16) {\n        VBOX_UTF16_TO_UTF8(valueTypeUtf16, &valueTypeUtf8);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n    }\n\n    if (STREQ_NULLABLE(valueTypeUtf8, \"sdl\") ||\n        STREQ_NULLABLE(valueTypeUtf8, \"gui\")) {\n        PRUnichar *valueDisplayUtf16 = NULL;\n        char *valueDisplayUtf8 = NULL;\n\n        if (VIR_ALLOC(graphics) < 0)\n            goto cleanup;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyUtf16);\n        gVBoxAPI.UIMachine.GetExtraData(machine, keyUtf16, &valueDisplayUtf16);\n        VBOX_UTF16_FREE(keyUtf16);\n\n        if (valueDisplayUtf16) {\n            VBOX_UTF16_TO_UTF8(valueDisplayUtf16, &valueDisplayUtf8);\n            VBOX_UTF16_FREE(valueDisplayUtf16);\n\n            if (STREQ(valueDisplayUtf8, \"\"))\n                VBOX_UTF8_FREE(valueDisplayUtf8);\n        }\n\n        if (STREQ_NULLABLE(valueTypeUtf8, \"sdl\")) {\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_SDL;\n            graphics->data.sdl.display = valueDisplayUtf8;\n            valueDisplayUtf8 = NULL;\n        }\n\n        if (STREQ_NULLABLE(valueTypeUtf8, \"gui\")) {\n            graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP;\n            graphics->data.desktop.display = valueDisplayUtf8;\n            valueDisplayUtf8 = NULL;\n        }\n        VBOX_UTF8_FREE(valueDisplayUtf8);\n    } else if (STRNEQ_NULLABLE(valueTypeUtf8, \"vrdp\")) {\n        if (VIR_ALLOC(graphics) < 0)\n            goto cleanup;\n\n        graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP;\n        graphics->data.desktop.display = g_strdup(getenv(\"DISPLAY\"));\n    }\n\n    if (graphics &&\n        VIR_APPEND_ELEMENT(def->graphics, def->ngraphics, graphics) < 0)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetVRDEServer(machine, &VRDEServer);\n    if (VRDEServer)\n        gVBoxAPI.UIVRDEServer.GetEnabled(VRDEServer, &VRDxEnabled);\n\n    if (VRDxEnabled) {\n        PRUnichar *netAddressUtf16 = NULL;\n        PRBool allowMultiConnection = PR_FALSE;\n        PRBool reuseSingleConnection = PR_FALSE;\n\n        if (VIR_ALLOC(graphics) < 0)\n            goto cleanup;\n\n        gVBoxAPI.UIVRDEServer.GetPorts(data, VRDEServer, machine, graphics);\n\n        graphics->type = VIR_DOMAIN_GRAPHICS_TYPE_RDP;\n\n        gVBoxAPI.UIVRDEServer.GetNetAddress(data, VRDEServer, &netAddressUtf16);\n        if (netAddressUtf16) {\n            VBOX_UTF16_TO_UTF8(netAddressUtf16, &netAddressUtf8);\n            VBOX_UTF16_FREE(netAddressUtf16);\n        }\n\n        if (netAddressUtf8 && STREQ(netAddressUtf8, \"\"))\n            VBOX_UTF8_FREE(netAddressUtf8);\n\n        if (virDomainGraphicsListenAppendAddress(graphics, netAddressUtf8) < 0)\n            goto cleanup;\n\n        gVBoxAPI.UIVRDEServer.GetAllowMultiConnection(VRDEServer, &allowMultiConnection);\n        if (allowMultiConnection)\n            graphics->data.rdp.multiUser = true;\n\n        gVBoxAPI.UIVRDEServer.GetReuseSingleConnection(VRDEServer, &reuseSingleConnection);\n        if (reuseSingleConnection)\n            graphics->data.rdp.replaceUser = true;\n\n        if (VIR_APPEND_ELEMENT(def->graphics, def->ngraphics, graphics) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(VRDEServer);\n    VBOX_UTF8_FREE(valueTypeUtf8);\n    VBOX_UTF8_FREE(netAddressUtf8);\n    virDomainGraphicsDefFree(graphics);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDumpVideo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "3423-3458",
    "snippet": "static int\nvboxDumpVideo(virDomainDefPtr def, vboxDriverPtr data G_GNUC_UNUSED,\n              IMachine *machine)\n{\n    /* dump video options vram/2d/3d/directx/etc. */\n    /* the default is: vram is 8MB, One monitor, 3dAccel Off */\n    PRUint32 VRAMSize = 8;\n    PRUint32 monitorCount = 1;\n    PRBool accelerate3DEnabled = PR_FALSE;\n    PRBool accelerate2DEnabled = PR_FALSE;\n\n    /* Currently supports only one graphics card */\n    if (VIR_ALLOC_N(def->videos, 1) < 0)\n        return -1;\n    def->nvideos = 1;\n\n    if (VIR_ALLOC(def->videos[0]) < 0)\n        return -1;\n\n    gVBoxAPI.UIMachine.GetVRAMSize(machine, &VRAMSize);\n    gVBoxAPI.UIMachine.GetMonitorCount(machine, &monitorCount);\n    gVBoxAPI.UIMachine.GetAccelerate3DEnabled(machine, &accelerate3DEnabled);\n    gVBoxAPI.UIMachine.GetAccelerate2DVideoEnabled(machine, &accelerate2DEnabled);\n\n    def->videos[0]->type = VIR_DOMAIN_VIDEO_TYPE_VBOX;\n    def->videos[0]->vram = VRAMSize * 1024;\n    def->videos[0]->heads = monitorCount;\n    if (VIR_ALLOC(def->videos[0]->accel) < 0)\n        return -1;\n    def->videos[0]->accel->accel3d = accelerate3DEnabled ?\n        VIR_TRISTATE_BOOL_YES : VIR_TRISTATE_BOOL_NO;\n    def->videos[0]->accel->accel2d = accelerate2DEnabled ?\n        VIR_TRISTATE_BOOL_YES : VIR_TRISTATE_BOOL_NO;\n\n    return 0;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def->videos[0]->accel"
          ],
          "line": 3450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccelerate2DVideoEnabled",
          "args": [
            "machine",
            "&accelerate2DEnabled"
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccelerate3DEnabled",
          "args": [
            "machine",
            "&accelerate3DEnabled"
          ],
          "line": 3444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetMonitorCount",
          "args": [
            "machine",
            "&monitorCount"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetVRAMSize",
          "args": [
            "machine",
            "&VRAMSize"
          ],
          "line": 3442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "def->videos[0]"
          ],
          "line": 3439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->videos",
            "1"
          ],
          "line": 3435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpVideo(virDomainDefPtr def, vboxDriverPtr data G_GNUC_UNUSED,\n              IMachine *machine)\n{\n    /* dump video options vram/2d/3d/directx/etc. */\n    /* the default is: vram is 8MB, One monitor, 3dAccel Off */\n    PRUint32 VRAMSize = 8;\n    PRUint32 monitorCount = 1;\n    PRBool accelerate3DEnabled = PR_FALSE;\n    PRBool accelerate2DEnabled = PR_FALSE;\n\n    /* Currently supports only one graphics card */\n    if (VIR_ALLOC_N(def->videos, 1) < 0)\n        return -1;\n    def->nvideos = 1;\n\n    if (VIR_ALLOC(def->videos[0]) < 0)\n        return -1;\n\n    gVBoxAPI.UIMachine.GetVRAMSize(machine, &VRAMSize);\n    gVBoxAPI.UIMachine.GetMonitorCount(machine, &monitorCount);\n    gVBoxAPI.UIMachine.GetAccelerate3DEnabled(machine, &accelerate3DEnabled);\n    gVBoxAPI.UIMachine.GetAccelerate2DVideoEnabled(machine, &accelerate2DEnabled);\n\n    def->videos[0]->type = VIR_DOMAIN_VIDEO_TYPE_VBOX;\n    def->videos[0]->vram = VRAMSize * 1024;\n    def->videos[0]->heads = monitorCount;\n    if (VIR_ALLOC(def->videos[0]->accel) < 0)\n        return -1;\n    def->videos[0]->accel->accel3d = accelerate3DEnabled ?\n        VIR_TRISTATE_BOOL_YES : VIR_TRISTATE_BOOL_NO;\n    def->videos[0]->accel->accel2d = accelerate2DEnabled ?\n        VIR_TRISTATE_BOOL_YES : VIR_TRISTATE_BOOL_NO;\n\n    return 0;\n}"
  },
  {
    "function_name": "vboxDumpDisks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "3162-3421",
    "snippet": "static int\nvboxDumpDisks(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    vboxArray mediumAttachments = VBOX_ARRAY_INITIALIZER;\n    int ret = -1;\n    IMediumAttachment *mediumAttachment = NULL;\n    IMedium *medium = NULL;\n    IStorageController *controller = NULL;\n    PRUnichar *controllerName = NULL, *mediumLocUtf16 = NULL;\n    PRUint32 deviceType, storageBus;\n    PRInt32 devicePort, deviceSlot;\n    PRBool readOnly;\n    nsresult rc;\n    virDomainDiskDefPtr disk = NULL;\n    virDomainControllerDefPtr ctrl = NULL;\n    char *mediumLocUtf8 = NULL;\n    size_t sdCount = 0, i, j;\n\n    def->ndisks = 0;\n    gVBoxAPI.UArray.vboxArrayGet(&mediumAttachments, machine,\n                 gVBoxAPI.UArray.handleMachineGetMediumAttachments(machine));\n\n    /* get the number of attachments */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        mediumAttachment = mediumAttachments.items[i];\n        if (!mediumAttachment)\n            continue;\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(mediumAttachment, &medium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get IMedium, rc=%08x\"), rc);\n            goto cleanup;\n        }\n\n        def->ndisks++;\n        VBOX_RELEASE(medium);\n    }\n\n    /* Allocate mem, if fails return error */\n    if (VIR_ALLOC_N(def->disks, def->ndisks) < 0)\n        goto cleanup;\n\n    for (i = 0; i < def->ndisks; i++) {\n        disk = virDomainDiskDefNew(NULL);\n        if (!disk)\n            goto cleanup;\n\n        def->disks[i] = disk;\n    }\n\n    /* get the attachment details here */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        mediumAttachment = mediumAttachments.items[i];\n        controller = NULL;\n        controllerName = NULL;\n        deviceType = DeviceType_Null;\n        storageBus = StorageBus_Null;\n        readOnly = PR_FALSE;\n        medium = NULL;\n        mediumLocUtf16 = NULL;\n        mediumLocUtf8 = NULL;\n        devicePort = 0;\n        deviceSlot = 0;\n        disk = def->disks[i];\n\n        if (!mediumAttachment)\n            continue;\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(mediumAttachment, &medium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get IMedium, rc=%08x\"), rc);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetController(mediumAttachment,\n                                                       &controllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get storage controller name, rc=%08x\"),\n                           rc);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMachine.GetStorageControllerByName(machine,\n                                                           controllerName,\n                                                           &controller);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get storage controller by name, rc=%08x\"),\n                           rc);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetType(mediumAttachment, &deviceType);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get device type, rc=%08x\"), rc);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetPort(mediumAttachment, &devicePort);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get device port, rc=%08x\"), rc);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetDevice(mediumAttachment, &deviceSlot);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get device slot, rc=%08x\"), rc);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIStorageController.GetBus(controller, &storageBus);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get storage controller bus, rc=%08x\"),\n                           rc);\n            goto cleanup;\n        }\n\n        if (medium) {\n            rc = gVBoxAPI.UIMedium.GetLocation(medium, &mediumLocUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not get medium storage location, rc=%08x\"),\n                               rc);\n                goto cleanup;\n            }\n\n            VBOX_UTF16_TO_UTF8(mediumLocUtf16, &mediumLocUtf8);\n\n            if (virDomainDiskSetSource(disk, mediumLocUtf8) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not set disk source\"));\n                goto cleanup;\n            }\n\n            rc = gVBoxAPI.UIMedium.GetReadOnly(medium, &readOnly);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not get read only state, rc=%08x\"), rc);\n                goto cleanup;\n            }\n        }\n\n        disk->dst = vboxGenerateMediumName(storageBus, devicePort, deviceSlot,\n                                           sdCount);\n\n        if (!disk->dst) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not generate medium name for the disk \"\n                             \"at: port:%d, slot:%d\"), devicePort, deviceSlot);\n            goto cleanup;\n        }\n\n        disk->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        disk->info.addr.drive.bus = 0;\n        disk->info.addr.drive.unit = devicePort;\n\n        switch ((enum StorageBus) storageBus) {\n        case StorageBus_IDE:\n            disk->bus = VIR_DOMAIN_DISK_BUS_IDE;\n            disk->info.addr.drive.bus = devicePort; /* primary, secondary */\n            disk->info.addr.drive.unit = deviceSlot; /* master, slave */\n\n            break;\n        case StorageBus_SATA:\n            disk->bus = VIR_DOMAIN_DISK_BUS_SATA;\n            sdCount++;\n\n            break;\n        case StorageBus_SCSI:\n        case StorageBus_SAS:\n            disk->bus = VIR_DOMAIN_DISK_BUS_SCSI;\n            sdCount++;\n\n            /* In vbox, if there's a disk attached to SAS controller, there will\n             * be libvirt SCSI controller present with model \"lsi1068\", and we\n             * need to find its index\n             */\n            for (j = 0; j < def->ncontrollers; j++) {\n                ctrl = def->controllers[j];\n\n                if (ctrl->type != VIR_DOMAIN_CONTROLLER_TYPE_SCSI)\n                    continue;\n\n                if (storageBus == StorageBus_SAS &&\n                    ctrl->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068) {\n                    disk->info.addr.drive.controller = ctrl->idx;\n                    break;\n                }\n\n                if (storageBus == StorageBus_SCSI &&\n                    ctrl->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068) {\n                    disk->info.addr.drive.controller = ctrl->idx;\n                    break;\n                }\n            }\n\n            break;\n        case StorageBus_Floppy:\n            disk->bus = VIR_DOMAIN_DISK_BUS_FDC;\n\n            break;\n        case StorageBus_Null:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unsupported null storage bus\"));\n            goto cleanup;\n        }\n\n        switch ((enum DeviceType) deviceType) {\n        case DeviceType_HardDisk:\n            disk->device = VIR_DOMAIN_DISK_DEVICE_DISK;\n\n            break;\n        case DeviceType_Floppy:\n            disk->device = VIR_DOMAIN_DISK_DEVICE_FLOPPY;\n\n            break;\n        case DeviceType_DVD:\n            disk->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n\n            break;\n        case DeviceType_Network:\n        case DeviceType_USB:\n        case DeviceType_SharedFolder:\n        case DeviceType_Null:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unsupported vbox device type: %d\"), deviceType);\n            goto cleanup;\n        }\n\n        if (readOnly == PR_TRUE)\n            disk->src->readonly = true;\n\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n\n        VBOX_UTF16_FREE(controllerName);\n        VBOX_UTF8_FREE(mediumLocUtf8);\n        VBOX_UTF16_FREE(mediumLocUtf16);\n        VBOX_RELEASE(medium);\n        VBOX_RELEASE(controller);\n    }\n\n    ret = 0;\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&mediumAttachments);\n\n    if (ret < 0) {\n        VBOX_UTF16_FREE(controllerName);\n        VBOX_UTF8_FREE(mediumLocUtf8);\n        VBOX_UTF16_FREE(mediumLocUtf16);\n        VBOX_RELEASE(medium);\n        VBOX_RELEASE(controller);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "controller"
          ],
          "line": 3417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "medium"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "mediumLocUtf16"
          ],
          "line": 3415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "mediumLocUtf8"
          ],
          "line": 3414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "controllerName"
          ],
          "line": 3413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&mediumAttachments"
          ],
          "line": 3410
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "controller"
          ],
          "line": 3404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "medium"
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "mediumLocUtf16"
          ],
          "line": 3402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "mediumLocUtf8"
          ],
          "line": 3401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "controllerName"
          ],
          "line": 3400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskSetType",
          "args": [
            "disk",
            "VIR_STORAGE_TYPE_FILE"
          ],
          "line": 3398
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2148-2152",
          "snippet": "void\nvirDomainDiskSetType(virDomainDiskDefPtr def, int type)\n{\n    def->src->type = type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainDiskSetType(virDomainDiskDefPtr def, int type)\n{\n    def->src->type = type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unsupported vbox device type: %d\")",
            "deviceType"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported vbox device type: %d\""
          ],
          "line": 3391
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unsupported null storage bus\")"
          ],
          "line": 3368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not generate medium name for the disk \"\n                             \"at: port:%d, slot:%d\")",
            "devicePort",
            "deviceSlot"
          ],
          "line": 3312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxGenerateMediumName",
          "args": [
            "storageBus",
            "devicePort",
            "deviceSlot",
            "sdCount"
          ],
          "line": 3308
        },
        "resolved": true,
        "details": {
          "function_name": "vboxGenerateMediumName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "299-335",
          "snippet": "static char *\nvboxGenerateMediumName(PRUint32 storageBus,\n                       PRInt32 devicePort,\n                       PRInt32 deviceSlot,\n                       size_t sdCount)\n{\n    const char *prefix = NULL;\n    char *name = NULL;\n    int total = 0;\n\n    switch ((enum StorageBus) storageBus) {\n    case StorageBus_IDE:\n        prefix = \"hd\";\n        total = devicePort * 2 + deviceSlot;\n\n        break;\n    case StorageBus_SATA:\n    case StorageBus_SCSI:\n    case StorageBus_SAS:\n        prefix = \"sd\";\n        total = sdCount;\n\n        break;\n    case StorageBus_Floppy:\n        total = deviceSlot;\n        prefix = \"fd\";\n\n        break;\n    case StorageBus_Null:\n\n        return NULL;\n    }\n\n    name = virIndexToDiskName(total, prefix);\n\n    return name;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nvboxGenerateMediumName(PRUint32 storageBus,\n                       PRInt32 devicePort,\n                       PRInt32 deviceSlot,\n                       size_t sdCount)\n{\n    const char *prefix = NULL;\n    char *name = NULL;\n    int total = 0;\n\n    switch ((enum StorageBus) storageBus) {\n    case StorageBus_IDE:\n        prefix = \"hd\";\n        total = devicePort * 2 + deviceSlot;\n\n        break;\n    case StorageBus_SATA:\n    case StorageBus_SCSI:\n    case StorageBus_SAS:\n        prefix = \"sd\";\n        total = sdCount;\n\n        break;\n    case StorageBus_Floppy:\n        total = deviceSlot;\n        prefix = \"fd\";\n\n        break;\n    case StorageBus_Null:\n\n        return NULL;\n    }\n\n    name = virIndexToDiskName(total, prefix);\n\n    return name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get read only state, rc=%08x\")",
            "rc"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 3301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetReadOnly",
          "args": [
            "medium",
            "&readOnly"
          ],
          "line": 3300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not set disk source\")"
          ],
          "line": 3295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskSetSource",
          "args": [
            "disk",
            "mediumLocUtf8"
          ],
          "line": 3294
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2162-2169",
          "snippet": "int\nvirDomainDiskSetSource(virDomainDiskDefPtr def, const char *src)\n{\n    char *tmp = g_strdup(src);\n    g_free(def->src->path);\n    def->src->path = tmp;\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskSetSource(virDomainDiskDefPtr def, const char *src)\n{\n    char *tmp = g_strdup(src);\n    g_free(def->src->path);\n    def->src->path = tmp;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "mediumLocUtf16",
            "&mediumLocUtf8"
          ],
          "line": 3292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get medium storage location, rc=%08x\")",
            "rc"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 3285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetLocation",
          "args": [
            "medium",
            "&mediumLocUtf16"
          ],
          "line": 3284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get storage controller bus, rc=%08x\")",
            "rc"
          ],
          "line": 3277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 3276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIStorageController.GetBus",
          "args": [
            "controller",
            "&storageBus"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get device slot, rc=%08x\")",
            "rc"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetDevice",
          "args": [
            "mediumAttachment",
            "&deviceSlot"
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get device port, rc=%08x\")",
            "rc"
          ],
          "line": 3265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 3264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetPort",
          "args": [
            "mediumAttachment",
            "&devicePort"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get device type, rc=%08x\")",
            "rc"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 3258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetType",
          "args": [
            "mediumAttachment",
            "&deviceType"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get storage controller by name, rc=%08x\")",
            "rc"
          ],
          "line": 3251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetStorageControllerByName",
          "args": [
            "machine",
            "controllerName",
            "&controller"
          ],
          "line": 3247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to get storage controller name, rc=%08x\")",
            "rc"
          ],
          "line": 3241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 3240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetController",
          "args": [
            "mediumAttachment",
            "&controllerName"
          ],
          "line": 3238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get IMedium, rc=%08x\")",
            "rc"
          ],
          "line": 3233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 3232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetMedium",
          "args": [
            "mediumAttachment",
            "&medium"
          ],
          "line": 3231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskDefNew",
          "args": [
            "NULL"
          ],
          "line": 3206
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2093-2114",
          "snippet": "virDomainDiskDefPtr\nvirDomainDiskDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDiskDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto error;\n\n    if (xmlopt &&\n        xmlopt->privateData.diskNew &&\n        !(ret->privateData = xmlopt->privateData.diskNew()))\n        goto error;\n\n    return ret;\n\n error:\n    virDomainDiskDefFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDiskDefPtr\nvirDomainDiskDefNew(virDomainXMLOptionPtr xmlopt)\n{\n    virDomainDiskDefPtr ret;\n\n    if (VIR_ALLOC(ret) < 0)\n        return NULL;\n\n    if (!(ret->src = virStorageSourceNew()))\n        goto error;\n\n    if (xmlopt &&\n        xmlopt->privateData.diskNew &&\n        !(ret->privateData = xmlopt->privateData.diskNew()))\n        goto error;\n\n    return ret;\n\n error:\n    virDomainDiskDefFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->disks",
            "def->ndisks"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "medium"
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get IMedium, rc=%08x\")",
            "rc"
          ],
          "line": 3192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMediumAttachment.GetMedium",
          "args": [
            "mediumAttachment",
            "&medium"
          ],
          "line": 3190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&mediumAttachments",
            "machine",
            "gVBoxAPI.UArray.handleMachineGetMediumAttachments(machine)"
          ],
          "line": 3181
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleMachineGetMediumAttachments",
          "args": [
            "machine"
          ],
          "line": 3182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpDisks(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    vboxArray mediumAttachments = VBOX_ARRAY_INITIALIZER;\n    int ret = -1;\n    IMediumAttachment *mediumAttachment = NULL;\n    IMedium *medium = NULL;\n    IStorageController *controller = NULL;\n    PRUnichar *controllerName = NULL, *mediumLocUtf16 = NULL;\n    PRUint32 deviceType, storageBus;\n    PRInt32 devicePort, deviceSlot;\n    PRBool readOnly;\n    nsresult rc;\n    virDomainDiskDefPtr disk = NULL;\n    virDomainControllerDefPtr ctrl = NULL;\n    char *mediumLocUtf8 = NULL;\n    size_t sdCount = 0, i, j;\n\n    def->ndisks = 0;\n    gVBoxAPI.UArray.vboxArrayGet(&mediumAttachments, machine,\n                 gVBoxAPI.UArray.handleMachineGetMediumAttachments(machine));\n\n    /* get the number of attachments */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        mediumAttachment = mediumAttachments.items[i];\n        if (!mediumAttachment)\n            continue;\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(mediumAttachment, &medium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get IMedium, rc=%08x\"), rc);\n            goto cleanup;\n        }\n\n        def->ndisks++;\n        VBOX_RELEASE(medium);\n    }\n\n    /* Allocate mem, if fails return error */\n    if (VIR_ALLOC_N(def->disks, def->ndisks) < 0)\n        goto cleanup;\n\n    for (i = 0; i < def->ndisks; i++) {\n        disk = virDomainDiskDefNew(NULL);\n        if (!disk)\n            goto cleanup;\n\n        def->disks[i] = disk;\n    }\n\n    /* get the attachment details here */\n    for (i = 0; i < mediumAttachments.count; i++) {\n        mediumAttachment = mediumAttachments.items[i];\n        controller = NULL;\n        controllerName = NULL;\n        deviceType = DeviceType_Null;\n        storageBus = StorageBus_Null;\n        readOnly = PR_FALSE;\n        medium = NULL;\n        mediumLocUtf16 = NULL;\n        mediumLocUtf8 = NULL;\n        devicePort = 0;\n        deviceSlot = 0;\n        disk = def->disks[i];\n\n        if (!mediumAttachment)\n            continue;\n\n        rc = gVBoxAPI.UIMediumAttachment.GetMedium(mediumAttachment, &medium);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get IMedium, rc=%08x\"), rc);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetController(mediumAttachment,\n                                                       &controllerName);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get storage controller name, rc=%08x\"),\n                           rc);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMachine.GetStorageControllerByName(machine,\n                                                           controllerName,\n                                                           &controller);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get storage controller by name, rc=%08x\"),\n                           rc);\n            goto cleanup;\n        }\n\n        rc = gVBoxAPI.UIMediumAttachment.GetType(mediumAttachment, &deviceType);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get device type, rc=%08x\"), rc);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetPort(mediumAttachment, &devicePort);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get device port, rc=%08x\"), rc);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIMediumAttachment.GetDevice(mediumAttachment, &deviceSlot);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get device slot, rc=%08x\"), rc);\n            goto cleanup;\n        }\n        rc = gVBoxAPI.UIStorageController.GetBus(controller, &storageBus);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not get storage controller bus, rc=%08x\"),\n                           rc);\n            goto cleanup;\n        }\n\n        if (medium) {\n            rc = gVBoxAPI.UIMedium.GetLocation(medium, &mediumLocUtf16);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not get medium storage location, rc=%08x\"),\n                               rc);\n                goto cleanup;\n            }\n\n            VBOX_UTF16_TO_UTF8(mediumLocUtf16, &mediumLocUtf8);\n\n            if (virDomainDiskSetSource(disk, mediumLocUtf8) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not set disk source\"));\n                goto cleanup;\n            }\n\n            rc = gVBoxAPI.UIMedium.GetReadOnly(medium, &readOnly);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not get read only state, rc=%08x\"), rc);\n                goto cleanup;\n            }\n        }\n\n        disk->dst = vboxGenerateMediumName(storageBus, devicePort, deviceSlot,\n                                           sdCount);\n\n        if (!disk->dst) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not generate medium name for the disk \"\n                             \"at: port:%d, slot:%d\"), devicePort, deviceSlot);\n            goto cleanup;\n        }\n\n        disk->info.type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;\n        disk->info.addr.drive.bus = 0;\n        disk->info.addr.drive.unit = devicePort;\n\n        switch ((enum StorageBus) storageBus) {\n        case StorageBus_IDE:\n            disk->bus = VIR_DOMAIN_DISK_BUS_IDE;\n            disk->info.addr.drive.bus = devicePort; /* primary, secondary */\n            disk->info.addr.drive.unit = deviceSlot; /* master, slave */\n\n            break;\n        case StorageBus_SATA:\n            disk->bus = VIR_DOMAIN_DISK_BUS_SATA;\n            sdCount++;\n\n            break;\n        case StorageBus_SCSI:\n        case StorageBus_SAS:\n            disk->bus = VIR_DOMAIN_DISK_BUS_SCSI;\n            sdCount++;\n\n            /* In vbox, if there's a disk attached to SAS controller, there will\n             * be libvirt SCSI controller present with model \"lsi1068\", and we\n             * need to find its index\n             */\n            for (j = 0; j < def->ncontrollers; j++) {\n                ctrl = def->controllers[j];\n\n                if (ctrl->type != VIR_DOMAIN_CONTROLLER_TYPE_SCSI)\n                    continue;\n\n                if (storageBus == StorageBus_SAS &&\n                    ctrl->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068) {\n                    disk->info.addr.drive.controller = ctrl->idx;\n                    break;\n                }\n\n                if (storageBus == StorageBus_SCSI &&\n                    ctrl->model != VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068) {\n                    disk->info.addr.drive.controller = ctrl->idx;\n                    break;\n                }\n            }\n\n            break;\n        case StorageBus_Floppy:\n            disk->bus = VIR_DOMAIN_DISK_BUS_FDC;\n\n            break;\n        case StorageBus_Null:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unsupported null storage bus\"));\n            goto cleanup;\n        }\n\n        switch ((enum DeviceType) deviceType) {\n        case DeviceType_HardDisk:\n            disk->device = VIR_DOMAIN_DISK_DEVICE_DISK;\n\n            break;\n        case DeviceType_Floppy:\n            disk->device = VIR_DOMAIN_DISK_DEVICE_FLOPPY;\n\n            break;\n        case DeviceType_DVD:\n            disk->device = VIR_DOMAIN_DISK_DEVICE_CDROM;\n\n            break;\n        case DeviceType_Network:\n        case DeviceType_USB:\n        case DeviceType_SharedFolder:\n        case DeviceType_Null:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unsupported vbox device type: %d\"), deviceType);\n            goto cleanup;\n        }\n\n        if (readOnly == PR_TRUE)\n            disk->src->readonly = true;\n\n        virDomainDiskSetType(disk, VIR_STORAGE_TYPE_FILE);\n\n        VBOX_UTF16_FREE(controllerName);\n        VBOX_UTF8_FREE(mediumLocUtf8);\n        VBOX_UTF16_FREE(mediumLocUtf16);\n        VBOX_RELEASE(medium);\n        VBOX_RELEASE(controller);\n    }\n\n    ret = 0;\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&mediumAttachments);\n\n    if (ret < 0) {\n        VBOX_UTF16_FREE(controllerName);\n        VBOX_UTF8_FREE(mediumLocUtf8);\n        VBOX_UTF16_FREE(mediumLocUtf16);\n        VBOX_RELEASE(medium);\n        VBOX_RELEASE(controller);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxDumpStorageControllers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "3053-3159",
    "snippet": "static int\nvboxDumpStorageControllers(virDomainDefPtr def, IMachine *machine)\n{\n    vboxArray storageControllers = VBOX_ARRAY_INITIALIZER;\n    IStorageController *controller = NULL;\n    PRUint32 storageBus = StorageBus_Null;\n    PRUint32 controllerType = StorageControllerType_Null;\n    virDomainControllerDefPtr cont = NULL;\n    size_t i = 0;\n    int model = -1, ret = -1;\n    virDomainControllerType type = VIR_DOMAIN_CONTROLLER_TYPE_LAST;\n\n    gVBoxAPI.UArray.vboxArrayGet(&storageControllers, machine,\n                 gVBoxAPI.UArray.handleMachineGetStorageControllers(machine));\n\n    for (i = 0; i < storageControllers.count; i++) {\n        controller = storageControllers.items[i];\n        storageBus = StorageBus_Null;\n        controllerType = StorageControllerType_Null;\n        type = VIR_DOMAIN_CONTROLLER_TYPE_LAST;\n        model = -1;\n\n        if (!controller)\n            continue;\n\n        gVBoxAPI.UIStorageController.GetBus(controller, &storageBus);\n        gVBoxAPI.UIStorageController.GetControllerType(controller,\n                                                       &controllerType);\n\n        /* vbox controller model => libvirt controller model */\n        switch ((enum StorageControllerType) controllerType) {\n        case StorageControllerType_PIIX3:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX3;\n\n            break;\n        case StorageControllerType_PIIX4:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX4;\n\n            break;\n        case StorageControllerType_ICH6:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_IDE_ICH6;\n\n            break;\n        case StorageControllerType_BusLogic:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC;\n\n            break;\n        case StorageControllerType_LsiLogic:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC;\n\n            break;\n        case StorageControllerType_LsiLogicSas:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068;\n\n            break;\n        case StorageControllerType_IntelAhci:\n        case StorageControllerType_I82078:\n        case StorageControllerType_Null:\n            model = -1;\n\n            break;\n        }\n\n        /* vbox controller bus => libvirt controller type */\n        switch ((enum StorageBus) storageBus) {\n        case StorageBus_IDE:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_IDE;\n\n            break;\n        case StorageBus_SCSI:\n        case StorageBus_SAS:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_SCSI;\n\n            break;\n        case StorageBus_SATA:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_SATA;\n\n            break;\n        case StorageBus_Floppy:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_FDC;\n\n            break;\n        case StorageBus_Null:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unsupported null storage bus\"));\n\n            goto cleanup;\n        }\n\n        if (type != VIR_DOMAIN_CONTROLLER_TYPE_LAST) {\n            cont = virDomainDefAddController(def, type, -1, model);\n            if (!cont) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to add %s controller type definition\"),\n                               virDomainControllerTypeToString(type));\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&storageControllers);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&storageControllers"
          ],
          "line": 3156
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to add %s controller type definition\")",
            "virDomainControllerTypeToString(type)"
          ],
          "line": 3145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainControllerTypeToString",
          "args": [
            "type"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to add %s controller type definition\""
          ],
          "line": 3146
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefAddController",
          "args": [
            "def",
            "type",
            "-1",
            "model"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefAddController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "18932-18952",
          "snippet": "virDomainControllerDefPtr\nvirDomainDefAddController(virDomainDefPtr def, int type, int idx, int model)\n{\n    virDomainControllerDefPtr cont;\n\n    if (!(cont = virDomainControllerDefNew(type)))\n        return NULL;\n\n    if (idx < 0)\n        idx = virDomainControllerFindUnusedIndex(def, type);\n\n    cont->idx = idx;\n    cont->model = model;\n\n    if (VIR_APPEND_ELEMENT_COPY(def->controllers, def->ncontrollers, cont) < 0) {\n        VIR_FREE(cont);\n        return NULL;\n    }\n\n    return cont;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainControllerDefPtr\nvirDomainDefAddController(virDomainDefPtr def, int type, int idx, int model)\n{\n    virDomainControllerDefPtr cont;\n\n    if (!(cont = virDomainControllerDefNew(type)))\n        return NULL;\n\n    if (idx < 0)\n        idx = virDomainControllerFindUnusedIndex(def, type);\n\n    cont->idx = idx;\n    cont->model = model;\n\n    if (VIR_APPEND_ELEMENT_COPY(def->controllers, def->ncontrollers, cont) < 0) {\n        VIR_FREE(cont);\n        return NULL;\n    }\n\n    return cont;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unsupported null storage bus\")"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIStorageController.GetControllerType",
          "args": [
            "controller",
            "&controllerType"
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIStorageController.GetBus",
          "args": [
            "controller",
            "&storageBus"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&storageControllers",
            "machine",
            "gVBoxAPI.UArray.handleMachineGetStorageControllers(machine)"
          ],
          "line": 3065
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleMachineGetStorageControllers",
          "args": [
            "machine"
          ],
          "line": 3066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDumpStorageControllers(virDomainDefPtr def, IMachine *machine)\n{\n    vboxArray storageControllers = VBOX_ARRAY_INITIALIZER;\n    IStorageController *controller = NULL;\n    PRUint32 storageBus = StorageBus_Null;\n    PRUint32 controllerType = StorageControllerType_Null;\n    virDomainControllerDefPtr cont = NULL;\n    size_t i = 0;\n    int model = -1, ret = -1;\n    virDomainControllerType type = VIR_DOMAIN_CONTROLLER_TYPE_LAST;\n\n    gVBoxAPI.UArray.vboxArrayGet(&storageControllers, machine,\n                 gVBoxAPI.UArray.handleMachineGetStorageControllers(machine));\n\n    for (i = 0; i < storageControllers.count; i++) {\n        controller = storageControllers.items[i];\n        storageBus = StorageBus_Null;\n        controllerType = StorageControllerType_Null;\n        type = VIR_DOMAIN_CONTROLLER_TYPE_LAST;\n        model = -1;\n\n        if (!controller)\n            continue;\n\n        gVBoxAPI.UIStorageController.GetBus(controller, &storageBus);\n        gVBoxAPI.UIStorageController.GetControllerType(controller,\n                                                       &controllerType);\n\n        /* vbox controller model => libvirt controller model */\n        switch ((enum StorageControllerType) controllerType) {\n        case StorageControllerType_PIIX3:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX3;\n\n            break;\n        case StorageControllerType_PIIX4:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX4;\n\n            break;\n        case StorageControllerType_ICH6:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_IDE_ICH6;\n\n            break;\n        case StorageControllerType_BusLogic:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC;\n\n            break;\n        case StorageControllerType_LsiLogic:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC;\n\n            break;\n        case StorageControllerType_LsiLogicSas:\n            model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068;\n\n            break;\n        case StorageControllerType_IntelAhci:\n        case StorageControllerType_I82078:\n        case StorageControllerType_Null:\n            model = -1;\n\n            break;\n        }\n\n        /* vbox controller bus => libvirt controller type */\n        switch ((enum StorageBus) storageBus) {\n        case StorageBus_IDE:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_IDE;\n\n            break;\n        case StorageBus_SCSI:\n        case StorageBus_SAS:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_SCSI;\n\n            break;\n        case StorageBus_SATA:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_SATA;\n\n            break;\n        case StorageBus_Floppy:\n            type = VIR_DOMAIN_CONTROLLER_TYPE_FDC;\n\n            break;\n        case StorageBus_Null:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Unsupported null storage bus\"));\n\n            goto cleanup;\n        }\n\n        if (type != VIR_DOMAIN_CONTROLLER_TYPE_LAST) {\n            cont = virDomainDefAddController(def, type, -1, model);\n            if (!cont) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to add %s controller type definition\"),\n                               virDomainControllerTypeToString(type));\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&storageControllers);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxHostDeviceGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2946-3050",
    "snippet": "static void\nvboxHostDeviceGetXMLDesc(vboxDriverPtr data, virDomainDefPtr def, IMachine *machine)\n{\n    IUSBCommon *USBCommon = NULL;\n    PRBool enabled = PR_FALSE;\n    vboxArray deviceFilters = VBOX_ARRAY_INITIALIZER;\n    size_t i;\n    PRUint32 USBFilterCount = 0;\n\n    def->nhostdevs = 0;\n\n    gVBoxAPI.UIMachine.GetUSBCommon(machine, &USBCommon);\n    if (!USBCommon)\n        return;\n\n    gVBoxAPI.UIUSBCommon.GetEnabled(USBCommon, &enabled);\n    if (!enabled)\n        goto release_controller;\n\n    gVBoxAPI.UArray.vboxArrayGet(&deviceFilters, USBCommon,\n                                 gVBoxAPI.UArray.handleUSBGetDeviceFilters(USBCommon));\n\n    if (deviceFilters.count <= 0)\n        goto release_filters;\n\n    /* check if the filters are active and then only\n     * alloc mem and set def->nhostdevs\n     */\n\n    for (i = 0; i < deviceFilters.count; i++) {\n        PRBool active = PR_FALSE;\n        IUSBDeviceFilter *deviceFilter = deviceFilters.items[i];\n\n        gVBoxAPI.UIUSBDeviceFilter.GetActive(deviceFilter, &active);\n        if (active)\n            def->nhostdevs++;\n    }\n\n    if (def->nhostdevs == 0)\n        goto release_filters;\n\n    /* Alloc mem needed for the filters now */\n    if (VIR_ALLOC_N(def->hostdevs, def->nhostdevs) < 0)\n        goto release_filters;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        def->hostdevs[i] = virDomainHostdevDefNew();\n        if (!def->hostdevs[i])\n            goto release_hostdevs;\n    }\n\n    for (i = 0; i < deviceFilters.count; i++) {\n        PRBool active = PR_FALSE;\n        IUSBDeviceFilter *deviceFilter = deviceFilters.items[i];\n        PRUnichar *vendorIdUtf16 = NULL;\n        char *vendorIdUtf8 = NULL;\n        unsigned vendorId = 0;\n        PRUnichar *productIdUtf16 = NULL;\n        char *productIdUtf8 = NULL;\n        unsigned productId = 0;\n        char *endptr = NULL;\n\n        gVBoxAPI.UIUSBDeviceFilter.GetActive(deviceFilter, &active);\n        if (!active)\n            continue;\n\n        def->hostdevs[USBFilterCount]->mode =\n            VIR_DOMAIN_HOSTDEV_MODE_SUBSYS;\n        def->hostdevs[USBFilterCount]->source.subsys.type =\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB;\n\n        gVBoxAPI.UIUSBDeviceFilter.GetVendorId(deviceFilter, &vendorIdUtf16);\n        gVBoxAPI.UIUSBDeviceFilter.GetProductId(deviceFilter, &productIdUtf16);\n\n        VBOX_UTF16_TO_UTF8(vendorIdUtf16, &vendorIdUtf8);\n        VBOX_UTF16_TO_UTF8(productIdUtf16, &productIdUtf8);\n\n        ignore_value(virStrToLong_ui(vendorIdUtf8, &endptr, 16, &vendorId));\n        ignore_value(virStrToLong_ui(productIdUtf8, &endptr, 16, &productId));\n\n        def->hostdevs[USBFilterCount]->source.subsys.u.usb.vendor = vendorId;\n        def->hostdevs[USBFilterCount]->source.subsys.u.usb.product = productId;\n\n        VBOX_UTF16_FREE(vendorIdUtf16);\n        VBOX_UTF8_FREE(vendorIdUtf8);\n\n        VBOX_UTF16_FREE(productIdUtf16);\n        VBOX_UTF8_FREE(productIdUtf8);\n\n        USBFilterCount++;\n    }\n\n release_filters:\n    gVBoxAPI.UArray.vboxArrayRelease(&deviceFilters);\n release_controller:\n    VBOX_RELEASE(USBCommon);\n    return;\n\n release_hostdevs:\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    goto release_filters;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "def->hostdevs"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainHostdevDefFree",
          "args": [
            "def->hostdevs[i]"
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainHostdevDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3002-3015",
          "snippet": "void virDomainHostdevDefFree(virDomainHostdevDefPtr def)\n{\n    if (!def)\n        return;\n\n    /* free all subordinate objects */\n    virDomainHostdevDefClear(def);\n\n    /* If there is a parentnet device object, it will handle freeing\n     * the memory.\n     */\n    if (!def->parentnet)\n        VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def)\n{\n    if (!def)\n        return;\n\n    /* free all subordinate objects */\n    virDomainHostdevDefClear(def);\n\n    /* If there is a parentnet device object, it will handle freeing\n     * the memory.\n     */\n    if (!def->parentnet)\n        VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "USBCommon"
          ],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&deviceFilters"
          ],
          "line": 3039
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "productIdUtf8"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "productIdUtf16"
          ],
          "line": 3032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "vendorIdUtf8"
          ],
          "line": 3030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "vendorIdUtf16"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStrToLong_ui(productIdUtf8, &endptr, 16, &productId)"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "productIdUtf8",
            "&endptr",
            "16",
            "&productId"
          ],
          "line": 3024
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virStrToLong_ui(vendorIdUtf8, &endptr, 16, &vendorId)"
          ],
          "line": 3023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "productIdUtf16",
            "&productIdUtf8"
          ],
          "line": 3021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "vendorIdUtf16",
            "&vendorIdUtf8"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIUSBDeviceFilter.GetProductId",
          "args": [
            "deviceFilter",
            "&productIdUtf16"
          ],
          "line": 3018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIUSBDeviceFilter.GetVendorId",
          "args": [
            "deviceFilter",
            "&vendorIdUtf16"
          ],
          "line": 3017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIUSBDeviceFilter.GetActive",
          "args": [
            "deviceFilter",
            "&active"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainHostdevDefNew",
          "args": [],
          "line": 2992
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainHostdevDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2889-2906",
          "snippet": "virDomainHostdevDefPtr\nvirDomainHostdevDefNew(void)\n{\n    virDomainHostdevDefPtr def;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(def->info) < 0)\n        goto error;\n\n    return def;\n\n error:\n    VIR_FREE(def->info);\n    VIR_FREE(def);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainHostdevDefPtr\nvirDomainHostdevDefNew(void)\n{\n    virDomainHostdevDefPtr def;\n\n    if (VIR_ALLOC(def) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(def->info) < 0)\n        goto error;\n\n    return def;\n\n error:\n    VIR_FREE(def->info);\n    VIR_FREE(def);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "def->hostdevs",
            "def->nhostdevs"
          ],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIUSBDeviceFilter.GetActive",
          "args": [
            "deviceFilter",
            "&active"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&deviceFilters",
            "USBCommon",
            "gVBoxAPI.UArray.handleUSBGetDeviceFilters(USBCommon)"
          ],
          "line": 2965
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.handleUSBGetDeviceFilters",
          "args": [
            "USBCommon"
          ],
          "line": 2966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIUSBCommon.GetEnabled",
          "args": [
            "USBCommon",
            "&enabled"
          ],
          "line": 2961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetUSBCommon",
          "args": [
            "machine",
            "&USBCommon"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxHostDeviceGetXMLDesc(vboxDriverPtr data, virDomainDefPtr def, IMachine *machine)\n{\n    IUSBCommon *USBCommon = NULL;\n    PRBool enabled = PR_FALSE;\n    vboxArray deviceFilters = VBOX_ARRAY_INITIALIZER;\n    size_t i;\n    PRUint32 USBFilterCount = 0;\n\n    def->nhostdevs = 0;\n\n    gVBoxAPI.UIMachine.GetUSBCommon(machine, &USBCommon);\n    if (!USBCommon)\n        return;\n\n    gVBoxAPI.UIUSBCommon.GetEnabled(USBCommon, &enabled);\n    if (!enabled)\n        goto release_controller;\n\n    gVBoxAPI.UArray.vboxArrayGet(&deviceFilters, USBCommon,\n                                 gVBoxAPI.UArray.handleUSBGetDeviceFilters(USBCommon));\n\n    if (deviceFilters.count <= 0)\n        goto release_filters;\n\n    /* check if the filters are active and then only\n     * alloc mem and set def->nhostdevs\n     */\n\n    for (i = 0; i < deviceFilters.count; i++) {\n        PRBool active = PR_FALSE;\n        IUSBDeviceFilter *deviceFilter = deviceFilters.items[i];\n\n        gVBoxAPI.UIUSBDeviceFilter.GetActive(deviceFilter, &active);\n        if (active)\n            def->nhostdevs++;\n    }\n\n    if (def->nhostdevs == 0)\n        goto release_filters;\n\n    /* Alloc mem needed for the filters now */\n    if (VIR_ALLOC_N(def->hostdevs, def->nhostdevs) < 0)\n        goto release_filters;\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        def->hostdevs[i] = virDomainHostdevDefNew();\n        if (!def->hostdevs[i])\n            goto release_hostdevs;\n    }\n\n    for (i = 0; i < deviceFilters.count; i++) {\n        PRBool active = PR_FALSE;\n        IUSBDeviceFilter *deviceFilter = deviceFilters.items[i];\n        PRUnichar *vendorIdUtf16 = NULL;\n        char *vendorIdUtf8 = NULL;\n        unsigned vendorId = 0;\n        PRUnichar *productIdUtf16 = NULL;\n        char *productIdUtf8 = NULL;\n        unsigned productId = 0;\n        char *endptr = NULL;\n\n        gVBoxAPI.UIUSBDeviceFilter.GetActive(deviceFilter, &active);\n        if (!active)\n            continue;\n\n        def->hostdevs[USBFilterCount]->mode =\n            VIR_DOMAIN_HOSTDEV_MODE_SUBSYS;\n        def->hostdevs[USBFilterCount]->source.subsys.type =\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB;\n\n        gVBoxAPI.UIUSBDeviceFilter.GetVendorId(deviceFilter, &vendorIdUtf16);\n        gVBoxAPI.UIUSBDeviceFilter.GetProductId(deviceFilter, &productIdUtf16);\n\n        VBOX_UTF16_TO_UTF8(vendorIdUtf16, &vendorIdUtf8);\n        VBOX_UTF16_TO_UTF8(productIdUtf16, &productIdUtf8);\n\n        ignore_value(virStrToLong_ui(vendorIdUtf8, &endptr, 16, &vendorId));\n        ignore_value(virStrToLong_ui(productIdUtf8, &endptr, 16, &productId));\n\n        def->hostdevs[USBFilterCount]->source.subsys.u.usb.vendor = vendorId;\n        def->hostdevs[USBFilterCount]->source.subsys.u.usb.product = productId;\n\n        VBOX_UTF16_FREE(vendorIdUtf16);\n        VBOX_UTF8_FREE(vendorIdUtf8);\n\n        VBOX_UTF16_FREE(productIdUtf16);\n        VBOX_UTF8_FREE(productIdUtf8);\n\n        USBFilterCount++;\n    }\n\n release_filters:\n    gVBoxAPI.UArray.vboxArrayRelease(&deviceFilters);\n release_controller:\n    VBOX_RELEASE(USBCommon);\n    return;\n\n release_hostdevs:\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    goto release_filters;\n}"
  },
  {
    "function_name": "vboxDomainGetMaxVcpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2940-2944",
    "snippet": "static int vboxDomainGetMaxVcpus(virDomainPtr dom)\n{\n    return vboxDomainGetVcpusFlags(dom, (VIR_DOMAIN_AFFECT_LIVE |\n                                         VIR_DOMAIN_VCPU_MAXIMUM));\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxDomainGetVcpusFlags",
          "args": [
            "dom",
            "(VIR_DOMAIN_AFFECT_LIVE |\n                                         VIR_DOMAIN_VCPU_MAXIMUM)"
          ],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainGetVcpusFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "2908-2938",
          "snippet": "static int vboxDomainGetVcpusFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 maxCPUCount = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (flags != (VIR_DOMAIN_AFFECT_LIVE | VIR_DOMAIN_VCPU_MAXIMUM)) {\n        virReportError(VIR_ERR_INVALID_ARG, _(\"unsupported flags: (0x%x)\"), flags);\n        return -1;\n    }\n\n    /* Currently every domain supports the same number of max cpus\n     * as that supported by vbox and thus take it directly from\n     * the systemproperties.\n     */\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetMaxGuestCPUCount(systemProperties, &maxCPUCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    if (maxCPUCount > 0)\n        ret = maxCPUCount;\n\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainGetVcpusFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 maxCPUCount = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (flags != (VIR_DOMAIN_AFFECT_LIVE | VIR_DOMAIN_VCPU_MAXIMUM)) {\n        virReportError(VIR_ERR_INVALID_ARG, _(\"unsupported flags: (0x%x)\"), flags);\n        return -1;\n    }\n\n    /* Currently every domain supports the same number of max cpus\n     * as that supported by vbox and thus take it directly from\n     * the systemproperties.\n     */\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetMaxGuestCPUCount(systemProperties, &maxCPUCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    if (maxCPUCount > 0)\n        ret = maxCPUCount;\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxDomainGetMaxVcpus(virDomainPtr dom)\n{\n    return vboxDomainGetVcpusFlags(dom, (VIR_DOMAIN_AFFECT_LIVE |\n                                         VIR_DOMAIN_VCPU_MAXIMUM));\n}"
  },
  {
    "function_name": "vboxDomainGetVcpusFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2908-2938",
    "snippet": "static int vboxDomainGetVcpusFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 maxCPUCount = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (flags != (VIR_DOMAIN_AFFECT_LIVE | VIR_DOMAIN_VCPU_MAXIMUM)) {\n        virReportError(VIR_ERR_INVALID_ARG, _(\"unsupported flags: (0x%x)\"), flags);\n        return -1;\n    }\n\n    /* Currently every domain supports the same number of max cpus\n     * as that supported by vbox and thus take it directly from\n     * the systemproperties.\n     */\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetMaxGuestCPUCount(systemProperties, &maxCPUCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    if (maxCPUCount > 0)\n        ret = maxCPUCount;\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "systemProperties"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISystemProperties.GetMaxGuestCPUCount",
          "args": [
            "systemProperties",
            "&maxCPUCount"
          ],
          "line": 2930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetSystemProperties",
          "args": [
            "data->vboxObj",
            "&systemProperties"
          ],
          "line": 2928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"unsupported flags: (0x%x)\")",
            "flags"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported flags: (0x%x)\""
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainGetVcpusFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 maxCPUCount = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (flags != (VIR_DOMAIN_AFFECT_LIVE | VIR_DOMAIN_VCPU_MAXIMUM)) {\n        virReportError(VIR_ERR_INVALID_ARG, _(\"unsupported flags: (0x%x)\"), flags);\n        return -1;\n    }\n\n    /* Currently every domain supports the same number of max cpus\n     * as that supported by vbox and thus take it directly from\n     * the systemproperties.\n     */\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetMaxGuestCPUCount(systemProperties, &maxCPUCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    if (maxCPUCount > 0)\n        ret = maxCPUCount;\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSetVcpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2903-2906",
    "snippet": "static int vboxDomainSetVcpus(virDomainPtr dom, unsigned int nvcpus)\n{\n    return vboxDomainSetVcpusFlags(dom, nvcpus, VIR_DOMAIN_AFFECT_LIVE);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxDomainSetVcpusFlags",
          "args": [
            "dom",
            "nvcpus",
            "VIR_DOMAIN_AFFECT_LIVE"
          ],
          "line": 2905
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainSetVcpusFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "2853-2901",
          "snippet": "static int vboxDomainSetVcpusFlags(virDomainPtr dom, unsigned int nvcpus,\n                                   unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 CPUCount = nvcpus;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (flags != VIR_DOMAIN_AFFECT_LIVE) {\n        virReportError(VIR_ERR_INVALID_ARG, _(\"unsupported flags: (0x%x)\"), flags);\n        return -1;\n    }\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        return -1;\n\n    rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    if (NS_SUCCEEDED(rc)) {\n        gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n        if (machine) {\n            rc = gVBoxAPI.UIMachine.SetCPUCount(machine, CPUCount);\n            if (NS_SUCCEEDED(rc)) {\n                gVBoxAPI.UIMachine.SaveSettings(machine);\n                ret = 0;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not set the number of cpus of the domain \"\n                                 \"to: %u, rc=%08x\"),\n                               CPUCount, (unsigned)rc);\n            }\n            VBOX_RELEASE(machine);\n        } else {\n            virReportError(VIR_ERR_NO_DOMAIN,\n                           _(\"no domain with matching id %d\"), dom->id);\n        }\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"can't open session to the domain with id %d\"), dom->id);\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainSetVcpusFlags(virDomainPtr dom, unsigned int nvcpus,\n                                   unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 CPUCount = nvcpus;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (flags != VIR_DOMAIN_AFFECT_LIVE) {\n        virReportError(VIR_ERR_INVALID_ARG, _(\"unsupported flags: (0x%x)\"), flags);\n        return -1;\n    }\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        return -1;\n\n    rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    if (NS_SUCCEEDED(rc)) {\n        gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n        if (machine) {\n            rc = gVBoxAPI.UIMachine.SetCPUCount(machine, CPUCount);\n            if (NS_SUCCEEDED(rc)) {\n                gVBoxAPI.UIMachine.SaveSettings(machine);\n                ret = 0;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not set the number of cpus of the domain \"\n                                 \"to: %u, rc=%08x\"),\n                               CPUCount, (unsigned)rc);\n            }\n            VBOX_RELEASE(machine);\n        } else {\n            virReportError(VIR_ERR_NO_DOMAIN,\n                           _(\"no domain with matching id %d\"), dom->id);\n        }\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"can't open session to the domain with id %d\"), dom->id);\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxDomainSetVcpus(virDomainPtr dom, unsigned int nvcpus)\n{\n    return vboxDomainSetVcpusFlags(dom, nvcpus, VIR_DOMAIN_AFFECT_LIVE);\n}"
  },
  {
    "function_name": "vboxDomainSetVcpusFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2853-2901",
    "snippet": "static int vboxDomainSetVcpusFlags(virDomainPtr dom, unsigned int nvcpus,\n                                   unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 CPUCount = nvcpus;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (flags != VIR_DOMAIN_AFFECT_LIVE) {\n        virReportError(VIR_ERR_INVALID_ARG, _(\"unsupported flags: (0x%x)\"), flags);\n        return -1;\n    }\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        return -1;\n\n    rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    if (NS_SUCCEEDED(rc)) {\n        gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n        if (machine) {\n            rc = gVBoxAPI.UIMachine.SetCPUCount(machine, CPUCount);\n            if (NS_SUCCEEDED(rc)) {\n                gVBoxAPI.UIMachine.SaveSettings(machine);\n                ret = 0;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not set the number of cpus of the domain \"\n                                 \"to: %u, rc=%08x\"),\n                               CPUCount, (unsigned)rc);\n            }\n            VBOX_RELEASE(machine);\n        } else {\n            virReportError(VIR_ERR_NO_DOMAIN,\n                           _(\"no domain with matching id %d\"), dom->id);\n        }\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"can't open session to the domain with id %d\"), dom->id);\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 2899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"can't open session to the domain with id %d\")",
            "dom->id"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"can't open session to the domain with id %d\""
          ],
          "line": 2895
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"no domain with matching id %d\")",
            "dom->id"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 2888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not set the number of cpus of the domain \"\n                                 \"to: %u, rc=%08x\")",
            "CPUCount",
            "(unsigned)rc"
          ],
          "line": 2883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SaveSettings",
          "args": [
            "machine"
          ],
          "line": 2880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_SUCCEEDED",
          "args": [
            "rc"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetCPUCount",
          "args": [
            "machine",
            "CPUCount"
          ],
          "line": 2878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetMachine",
          "args": [
            "data->vboxSession",
            "&machine"
          ],
          "line": 2876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_SUCCEEDED",
          "args": [
            "rc"
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Open",
          "args": [
            "data",
            "&iid",
            "machine"
          ],
          "line": 2874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"unsupported flags: (0x%x)\")",
            "flags"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainSetVcpusFlags(virDomainPtr dom, unsigned int nvcpus,\n                                   unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 CPUCount = nvcpus;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (flags != VIR_DOMAIN_AFFECT_LIVE) {\n        virReportError(VIR_ERR_INVALID_ARG, _(\"unsupported flags: (0x%x)\"), flags);\n        return -1;\n    }\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        return -1;\n\n    rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    if (NS_SUCCEEDED(rc)) {\n        gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n        if (machine) {\n            rc = gVBoxAPI.UIMachine.SetCPUCount(machine, CPUCount);\n            if (NS_SUCCEEDED(rc)) {\n                gVBoxAPI.UIMachine.SaveSettings(machine);\n                ret = 0;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"could not set the number of cpus of the domain \"\n                                 \"to: %u, rc=%08x\"),\n                               CPUCount, (unsigned)rc);\n            }\n            VBOX_RELEASE(machine);\n        } else {\n            virReportError(VIR_ERR_NO_DOMAIN,\n                           _(\"no domain with matching id %d\"), dom->id);\n        }\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"can't open session to the domain with id %d\"), dom->id);\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainGetState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2822-2851",
    "snippet": "static int vboxDomainGetState(virDomainPtr dom, int *state,\n                              int *reason, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    PRUint32 mstate;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &mstate);\n\n    *state = gVBoxAPI.vboxConvertState(mstate);\n\n    if (reason)\n        *reason = 0;\n\n    ret = 0;\n\n cleanup:\n    vboxIIDUnalloc(&domiid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&domiid"
          ],
          "line": 2849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.vboxConvertState",
          "args": [
            "mstate"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&mstate"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&domiid",
            "&machine"
          ],
          "line": 2836
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainGetState(virDomainPtr dom, int *state,\n                              int *reason, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID domiid;\n    IMachine *machine = NULL;\n    PRUint32 mstate;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &domiid, &machine) < 0)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &mstate);\n\n    *state = gVBoxAPI.vboxConvertState(mstate);\n\n    if (reason)\n        *reason = 0;\n\n    ret = 0;\n\n cleanup:\n    vboxIIDUnalloc(&domiid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2740-2820",
    "snippet": "static int vboxDomainGetInfo(virDomainPtr dom, virDomainInfoPtr info)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    char *machineName = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    nsresult rc;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return -1;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return -1;\n    }\n\n    info->nrVirtCpu = 0;\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n        PRBool isAccessible = PR_FALSE;\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (!isAccessible)\n            continue;\n\n        gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n        VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineName);\n\n        if (STREQ(dom->name, machineName)) {\n            /* Get the Machine State (also match it with\n            * virDomainState). Get the Machine memory and\n            * for time being set max_balloon and cur_balloon to same\n            * Also since there is no direct way of checking\n            * the cputime required (one condition being the\n            * VM is remote), return zero for cputime. Get the\n            * number of CPU.\n            */\n            PRUint32 CPUCount = 0;\n            PRUint32 memorySize = 0;\n            PRUint32 state;\n            PRUint32 maxMemorySize = 4 * 1024;\n            ISystemProperties *systemProperties = NULL;\n\n            gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n            if (systemProperties) {\n                gVBoxAPI.UISystemProperties.GetMaxGuestRAM(systemProperties, &maxMemorySize);\n                VBOX_RELEASE(systemProperties);\n                systemProperties = NULL;\n            }\n\n            gVBoxAPI.UIMachine.GetCPUCount(machine, &CPUCount);\n            gVBoxAPI.UIMachine.GetMemorySize(machine, &memorySize);\n            gVBoxAPI.UIMachine.GetState(machine, &state);\n\n            info->cpuTime = 0;\n            info->nrVirtCpu = CPUCount;\n            info->memory = memorySize * 1024;\n            info->maxMem = maxMemorySize * 1024;\n            info->state = gVBoxAPI.vboxConvertState(state);\n\n            ret = 0;\n        }\n\n        VBOX_UTF8_FREE(machineName);\n        VBOX_COM_UNALLOC_MEM(machineNameUtf16);\n        if (info->nrVirtCpu)\n            break;\n\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&machines"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_COM_UNALLOC_MEM",
          "args": [
            "machineNameUtf16"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "machineName"
          ],
          "line": 2810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.vboxConvertState",
          "args": [
            "state"
          ],
          "line": 2805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetMemorySize",
          "args": [
            "machine",
            "&memorySize"
          ],
          "line": 2798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetCPUCount",
          "args": [
            "machine",
            "&CPUCount"
          ],
          "line": 2797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "systemProperties"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISystemProperties.GetMaxGuestRAM",
          "args": [
            "systemProperties",
            "&maxMemorySize"
          ],
          "line": 2792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetSystemProperties",
          "args": [
            "data->vboxObj",
            "&systemProperties"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dom->name",
            "machineName"
          ],
          "line": 2775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "machineNameUtf16",
            "&machineName"
          ],
          "line": 2773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetName",
          "args": [
            "machine",
            "&machineNameUtf16"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get list of machines, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not get list of machines, rc=%08x\""
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 2754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&machines",
            "data->vboxObj",
            "ARRAY_GET_MACHINES"
          ],
          "line": 2753
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainGetInfo(virDomainPtr dom, virDomainInfoPtr info)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    char *machineName = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    nsresult rc;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return -1;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return -1;\n    }\n\n    info->nrVirtCpu = 0;\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n        PRBool isAccessible = PR_FALSE;\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (!isAccessible)\n            continue;\n\n        gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n        VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineName);\n\n        if (STREQ(dom->name, machineName)) {\n            /* Get the Machine State (also match it with\n            * virDomainState). Get the Machine memory and\n            * for time being set max_balloon and cur_balloon to same\n            * Also since there is no direct way of checking\n            * the cputime required (one condition being the\n            * VM is remote), return zero for cputime. Get the\n            * number of CPU.\n            */\n            PRUint32 CPUCount = 0;\n            PRUint32 memorySize = 0;\n            PRUint32 state;\n            PRUint32 maxMemorySize = 4 * 1024;\n            ISystemProperties *systemProperties = NULL;\n\n            gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n            if (systemProperties) {\n                gVBoxAPI.UISystemProperties.GetMaxGuestRAM(systemProperties, &maxMemorySize);\n                VBOX_RELEASE(systemProperties);\n                systemProperties = NULL;\n            }\n\n            gVBoxAPI.UIMachine.GetCPUCount(machine, &CPUCount);\n            gVBoxAPI.UIMachine.GetMemorySize(machine, &memorySize);\n            gVBoxAPI.UIMachine.GetState(machine, &state);\n\n            info->cpuTime = 0;\n            info->nrVirtCpu = CPUCount;\n            info->memory = memorySize * 1024;\n            info->maxMem = maxMemorySize * 1024;\n            info->state = gVBoxAPI.vboxConvertState(state);\n\n            ret = 0;\n        }\n\n        VBOX_UTF8_FREE(machineName);\n        VBOX_COM_UNALLOC_MEM(machineNameUtf16);\n        if (info->nrVirtCpu)\n            break;\n\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSetMemory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2682-2738",
    "snippet": "static int vboxDomainSetMemory(virDomainPtr dom, unsigned long memory)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 state;\n    PRBool isAccessible = PR_FALSE;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (!gVBoxAPI.machineStateChecker.PoweredOff(state)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"memory size can't be changed unless domain is powered down\"));\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n    if (NS_SUCCEEDED(rc) && machine) {\n\n        rc = gVBoxAPI.UIMachine.SetMemorySize(machine,\n                                              VIR_DIV_UP(memory, 1024));\n        if (NS_SUCCEEDED(rc)) {\n            gVBoxAPI.UIMachine.SaveSettings(machine);\n            ret = 0;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not set the memory size of the \"\n                             \"domain to: %lu Kb, rc=%08x\"),\n                           memory, (unsigned)rc);\n        }\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 2732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not set the memory size of the \"\n                             \"domain to: %lu Kb, rc=%08x\")",
            "memory",
            "(unsigned)rc"
          ],
          "line": 2726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not set the memory size of the \"\n                             \"domain to: %lu Kb, rc=%08x\""
          ],
          "line": 2727
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SaveSettings",
          "args": [
            "machine"
          ],
          "line": 2723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_SUCCEEDED",
          "args": [
            "rc"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetMemorySize",
          "args": [
            "machine",
            "VIR_DIV_UP(memory, 1024)"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "memory",
            "1024"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_SUCCEEDED",
          "args": [
            "rc"
          ],
          "line": 2718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetMachine",
          "args": [
            "data->vboxSession",
            "&machine"
          ],
          "line": 2717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Open",
          "args": [
            "data",
            "&iid",
            "machine"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"memory size can't be changed unless domain is powered down\")"
          ],
          "line": 2708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.PoweredOff",
          "args": [
            "state"
          ],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 2701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 2695
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainSetMemory(virDomainPtr dom, unsigned long memory)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    PRUint32 state;\n    PRBool isAccessible = PR_FALSE;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (!gVBoxAPI.machineStateChecker.PoweredOff(state)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"memory size can't be changed unless domain is powered down\"));\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UISession.Open(data, &iid, machine);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n    if (NS_SUCCEEDED(rc) && machine) {\n\n        rc = gVBoxAPI.UIMachine.SetMemorySize(machine,\n                                              VIR_DIV_UP(memory, 1024));\n        if (NS_SUCCEEDED(rc)) {\n            gVBoxAPI.UIMachine.SaveSettings(machine);\n            ret = 0;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not set the memory size of the \"\n                             \"domain to: %lu Kb, rc=%08x\"),\n                           memory, (unsigned)rc);\n        }\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainGetOSType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2670-2680",
    "snippet": "static char *vboxDomainGetOSType(virDomainPtr dom G_GNUC_UNUSED) {\n    /* Returning \"hvm\" always as suggested on list, cause\n     * this functions seems to be badly named and it\n     * is supposed to pass the ABI name and not the domain\n     * operating system driver as I had imagined ;)\n     */\n    char *osType;\n\n    osType = g_strdup(\"hvm\");\n    return osType;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"hvm\""
          ],
          "line": 2678
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic char *vboxDomainGetOSType(virDomainPtr dom G_GNUC_UNUSED) {\n    /* Returning \"hvm\" always as suggested on list, cause\n     * this functions seems to be badly named and it\n     * is supposed to pass the ABI name and not the domain\n     * operating system driver as I had imagined ;)\n     */\n    char *osType;\n\n    osType = g_strdup(\"hvm\");\n    return osType;\n}"
  },
  {
    "function_name": "vboxDomainDestroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2665-2668",
    "snippet": "static int vboxDomainDestroy(virDomainPtr dom)\n{\n    return vboxDomainDestroyFlags(dom, 0);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxDomainDestroyFlags",
          "args": [
            "dom",
            "0"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainDestroyFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "2616-2663",
          "snippet": "static int vboxDomainDestroyFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    IConsole *console = NULL;\n    PRUint32 state;\n    PRBool isAccessible = PR_FALSE;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.PoweredOff(state)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine already powered down\"));\n        goto cleanup;\n    }\n\n    gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n    if (console) {\n        gVBoxAPI.UIConsole.PowerDown(console);\n        VBOX_RELEASE(console);\n        dom->id = -1;\n        ret = 0;\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainDestroyFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    IConsole *console = NULL;\n    PRUint32 state;\n    PRBool isAccessible = PR_FALSE;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.PoweredOff(state)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine already powered down\"));\n        goto cleanup;\n    }\n\n    gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n    if (console) {\n        gVBoxAPI.UIConsole.PowerDown(console);\n        VBOX_RELEASE(console);\n        dom->id = -1;\n        ret = 0;\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxDomainDestroy(virDomainPtr dom)\n{\n    return vboxDomainDestroyFlags(dom, 0);\n}"
  },
  {
    "function_name": "vboxDomainDestroyFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2616-2663",
    "snippet": "static int vboxDomainDestroyFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    IConsole *console = NULL;\n    PRUint32 state;\n    PRBool isAccessible = PR_FALSE;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.PoweredOff(state)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine already powered down\"));\n        goto cleanup;\n    }\n\n    gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n    if (console) {\n        gVBoxAPI.UIConsole.PowerDown(console);\n        VBOX_RELEASE(console);\n        dom->id = -1;\n        ret = 0;\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 2657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "console"
          ],
          "line": 2653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIConsole.PowerDown",
          "args": [
            "console"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetConsole",
          "args": [
            "data->vboxSession",
            "&console"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.OpenExisting",
          "args": [
            "data",
            "&iid",
            "machine"
          ],
          "line": 2649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"machine already powered down\")"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"machine already powered down\""
          ],
          "line": 2645
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.PoweredOff",
          "args": [
            "state"
          ],
          "line": 2643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 2637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 2631
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 2629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainDestroyFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    IConsole *console = NULL;\n    PRUint32 state;\n    PRBool isAccessible = PR_FALSE;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.PoweredOff(state)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine already powered down\"));\n        goto cleanup;\n    }\n\n    gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n    if (console) {\n        gVBoxAPI.UIConsole.PowerDown(console);\n        VBOX_RELEASE(console);\n        dom->id = -1;\n        ret = 0;\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainReboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2568-2614",
    "snippet": "static int vboxDomainReboot(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    IConsole *console = NULL;\n    PRUint32 state;\n    PRBool isAccessible = PR_FALSE;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state)) {\n        gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n        gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n        if (console) {\n            gVBoxAPI.UIConsole.Reset(console);\n            VBOX_RELEASE(console);\n            ret = 0;\n        }\n        gVBoxAPI.UISession.Close(data->vboxSession);\n    } else {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine not running, so can't reboot it\"));\n        goto cleanup;\n    }\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 2612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"machine not running, so can't reboot it\")"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"machine not running, so can't reboot it\""
          ],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "console"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIConsole.Reset",
          "args": [
            "console"
          ],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetConsole",
          "args": [
            "data->vboxSession",
            "&console"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.OpenExisting",
          "args": [
            "data",
            "&iid",
            "machine"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Running",
          "args": [
            "state"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 2593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 2589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainReboot(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    IConsole *console = NULL;\n    PRUint32 state;\n    PRBool isAccessible = PR_FALSE;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state)) {\n        gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n        gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n        if (console) {\n            gVBoxAPI.UIConsole.Reset(console);\n            VBOX_RELEASE(console);\n            ret = 0;\n        }\n        gVBoxAPI.UISession.Close(data->vboxSession);\n    } else {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine not running, so can't reboot it\"));\n        goto cleanup;\n    }\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainShutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2563-2566",
    "snippet": "static int vboxDomainShutdown(virDomainPtr dom)\n{\n    return vboxDomainShutdownFlags(dom, 0);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxDomainShutdownFlags",
          "args": [
            "dom",
            "0"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainShutdownFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "2511-2561",
          "snippet": "static int vboxDomainShutdownFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    IConsole *console = NULL;\n    PRUint32 state;\n    PRBool isAccessible = PR_FALSE;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Paused(state)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine paused, so can't power it down\"));\n        goto cleanup;\n    } else if (gVBoxAPI.machineStateChecker.PoweredOff(state)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine already powered down\"));\n        goto cleanup;\n    }\n\n    gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n    if (console) {\n        gVBoxAPI.UIConsole.PowerButton(console);\n        VBOX_RELEASE(console);\n        ret = 0;\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainShutdownFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    IConsole *console = NULL;\n    PRUint32 state;\n    PRBool isAccessible = PR_FALSE;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Paused(state)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine paused, so can't power it down\"));\n        goto cleanup;\n    } else if (gVBoxAPI.machineStateChecker.PoweredOff(state)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine already powered down\"));\n        goto cleanup;\n    }\n\n    gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n    if (console) {\n        gVBoxAPI.UIConsole.PowerButton(console);\n        VBOX_RELEASE(console);\n        ret = 0;\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxDomainShutdown(virDomainPtr dom)\n{\n    return vboxDomainShutdownFlags(dom, 0);\n}"
  },
  {
    "function_name": "vboxDomainShutdownFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2511-2561",
    "snippet": "static int vboxDomainShutdownFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    IConsole *console = NULL;\n    PRUint32 state;\n    PRBool isAccessible = PR_FALSE;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Paused(state)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine paused, so can't power it down\"));\n        goto cleanup;\n    } else if (gVBoxAPI.machineStateChecker.PoweredOff(state)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine already powered down\"));\n        goto cleanup;\n    }\n\n    gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n    if (console) {\n        gVBoxAPI.UIConsole.PowerButton(console);\n        VBOX_RELEASE(console);\n        ret = 0;\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "console"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIConsole.PowerButton",
          "args": [
            "console"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetConsole",
          "args": [
            "data->vboxSession",
            "&console"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.OpenExisting",
          "args": [
            "data",
            "&iid",
            "machine"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"machine already powered down\")"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"machine already powered down\""
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.PoweredOff",
          "args": [
            "state"
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"machine paused, so can't power it down\")"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Paused",
          "args": [
            "state"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainShutdownFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    IConsole *console = NULL;\n    PRUint32 state;\n    PRBool isAccessible = PR_FALSE;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virCheckFlags(0, -1);\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Paused(state)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine paused, so can't power it down\"));\n        goto cleanup;\n    } else if (gVBoxAPI.machineStateChecker.PoweredOff(state)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine already powered down\"));\n        goto cleanup;\n    }\n\n    gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n    if (console) {\n        gVBoxAPI.UIConsole.PowerButton(console);\n        VBOX_RELEASE(console);\n        ret = 0;\n    }\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainResume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2460-2509",
    "snippet": "static int vboxDomainResume(virDomainPtr dom)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    IConsole *console = NULL;\n    PRUint32 state;\n    PRBool isAccessible = PR_FALSE;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Paused(state)) {\n        /* resume the machine here */\n        gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n        gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n        if (console) {\n            gVBoxAPI.UIConsole.Resume(console);\n            VBOX_RELEASE(console);\n            ret = 0;\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"error while resuming the domain\"));\n            goto cleanup;\n        }\n        gVBoxAPI.UISession.Close(data->vboxSession);\n    } else {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine not paused, so can't resume it\"));\n        goto cleanup;\n    }\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"machine not paused, so can't resume it\")"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"machine not paused, so can't resume it\""
          ],
          "line": 2501
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"error while resuming the domain\")"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "console"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIConsole.Resume",
          "args": [
            "console"
          ],
          "line": 2490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetConsole",
          "args": [
            "data->vboxSession",
            "&console"
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.OpenExisting",
          "args": [
            "data",
            "&iid",
            "machine"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Paused",
          "args": [
            "state"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainResume(virDomainPtr dom)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    IConsole *console = NULL;\n    PRUint32 state;\n    PRBool isAccessible = PR_FALSE;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Paused(state)) {\n        /* resume the machine here */\n        gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n        gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n        if (console) {\n            gVBoxAPI.UIConsole.Resume(console);\n            VBOX_RELEASE(console);\n            ret = 0;\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"error while resuming the domain\"));\n            goto cleanup;\n        }\n        gVBoxAPI.UISession.Close(data->vboxSession);\n    } else {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine not paused, so can't resume it\"));\n        goto cleanup;\n    }\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainSuspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2409-2458",
    "snippet": "static int vboxDomainSuspend(virDomainPtr dom)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    IConsole *console = NULL;\n    PRBool isAccessible = PR_FALSE;\n    PRUint32 state;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state)) {\n        /* set state pause */\n        gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n        gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n        if (console) {\n            gVBoxAPI.UIConsole.Pause(console);\n            VBOX_RELEASE(console);\n            ret = 0;\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"error while suspending the domain\"));\n            goto cleanup;\n        }\n        gVBoxAPI.UISession.Close(data->vboxSession);\n    } else {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine not in running state to suspend it\"));\n        goto cleanup;\n    }\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"machine not in running state to suspend it\")"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"machine not in running state to suspend it\""
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"error while suspending the domain\")"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "console"
          ],
          "line": 2440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIConsole.Pause",
          "args": [
            "console"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetConsole",
          "args": [
            "data->vboxSession",
            "&console"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.OpenExisting",
          "args": [
            "data",
            "&iid",
            "machine"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Running",
          "args": [
            "state"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 2422
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainSuspend(virDomainPtr dom)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    IConsole *console = NULL;\n    PRBool isAccessible = PR_FALSE;\n    PRUint32 state;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    if (!machine)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n\n    if (gVBoxAPI.machineStateChecker.Running(state)) {\n        /* set state pause */\n        gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n        gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n        if (console) {\n            gVBoxAPI.UIConsole.Pause(console);\n            VBOX_RELEASE(console);\n            ret = 0;\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"error while suspending the domain\"));\n            goto cleanup;\n        }\n        gVBoxAPI.UISession.Close(data->vboxSession);\n    } else {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"machine not in running state to suspend it\"));\n        goto cleanup;\n    }\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainIsUpdated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2386-2407",
    "snippet": "static int vboxDomainIsUpdated(virDomainPtr dom)\n{\n    /* VBox domains never have a persistent state that differs from\n     * current state.  However, we do want to check for existence.  */\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 2398
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxDomainIsUpdated(virDomainPtr dom)\n{\n    /* VBox domains never have a persistent state that differs from\n     * current state.  However, we do want to check for existence.  */\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainIsPersistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2363-2384",
    "snippet": "static int vboxDomainIsPersistent(virDomainPtr dom)\n{\n    /* All domains are persistent.  However, we do want to check for\n     * existence. */\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    ret = 1;\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxDomainIsPersistent(virDomainPtr dom)\n{\n    /* All domains are persistent.  However, we do want to check for\n     * existence. */\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    ret = 1;\n\n cleanup:\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainIsActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2293-2361",
    "snippet": "static int vboxDomainIsActive(virDomainPtr dom)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    vboxIID iid;\n    char *machineNameUtf8 = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    size_t i;\n    bool matched = false;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return ret;\n    }\n\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n        PRBool isAccessible = PR_FALSE;\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (!isAccessible)\n            continue;\n\n        gVBoxAPI.UIMachine.GetId(machine, &iid);\n        if (NS_FAILED(rc))\n            continue;\n        vboxIIDToUUID(&iid, uuid);\n        vboxIIDUnalloc(&iid);\n\n        if (memcmp(dom->uuid, uuid, VIR_UUID_BUFLEN) == 0) {\n\n            PRUint32 state;\n\n            matched = true;\n\n            gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n            VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineNameUtf8);\n\n            gVBoxAPI.UIMachine.GetState(machine, &state);\n\n            if (gVBoxAPI.machineStateChecker.Online(state))\n                ret = 1;\n            else\n                ret = 0;\n        }\n\n        if (matched)\n            break;\n    }\n\n    /* Do the cleanup and take care you dont leak any memory */\n    VBOX_UTF8_FREE(machineNameUtf8);\n    VBOX_COM_UNALLOC_MEM(machineNameUtf16);\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&machines"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_COM_UNALLOC_MEM",
          "args": [
            "machineNameUtf16"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "machineNameUtf8"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Online",
          "args": [
            "state"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "machineNameUtf16",
            "&machineNameUtf8"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetName",
          "args": [
            "machine",
            "&machineNameUtf16"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dom->uuid",
            "uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDToUUID",
          "args": [
            "&iid",
            "uuid"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetId",
          "args": [
            "machine",
            "&iid"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get list of machines, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not get list of machines, rc=%08x\""
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&machines",
            "data->vboxObj",
            "ARRAY_GET_MACHINES"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainIsActive(virDomainPtr dom)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    vboxIID iid;\n    char *machineNameUtf8 = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    size_t i;\n    bool matched = false;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return ret;\n    }\n\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n        PRBool isAccessible = PR_FALSE;\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (!isAccessible)\n            continue;\n\n        gVBoxAPI.UIMachine.GetId(machine, &iid);\n        if (NS_FAILED(rc))\n            continue;\n        vboxIIDToUUID(&iid, uuid);\n        vboxIIDUnalloc(&iid);\n\n        if (memcmp(dom->uuid, uuid, VIR_UUID_BUFLEN) == 0) {\n\n            PRUint32 state;\n\n            matched = true;\n\n            gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n            VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineNameUtf8);\n\n            gVBoxAPI.UIMachine.GetState(machine, &state);\n\n            if (gVBoxAPI.machineStateChecker.Online(state))\n                ret = 1;\n            else\n                ret = 0;\n        }\n\n        if (matched)\n            break;\n    }\n\n    /* Do the cleanup and take care you dont leak any memory */\n    VBOX_UTF8_FREE(machineNameUtf8);\n    VBOX_COM_UNALLOC_MEM(machineNameUtf16);\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainCreateXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2265-2291",
    "snippet": "static virDomainPtr vboxDomainCreateXML(virConnectPtr conn, const char *xml,\n                                        unsigned int flags)\n{\n    /* VirtualBox currently doesn't have support for running\n     * virtual machines without actually defining them and thus\n     * for time being just define new machine and start it.\n     *\n     * TODO: After the appropriate API's are added in VirtualBox\n     * change this behaviour to the expected one.\n     */\n\n    virDomainPtr dom;\n\n    virCheckFlags(0, NULL);\n\n    dom = vboxDomainDefineXML(conn, xml);\n    if (dom == NULL)\n        return NULL;\n\n    if (vboxDomainCreate(dom) < 0) {\n        vboxDomainUndefineFlags(dom, 0);\n        virObjectUnref(dom);\n        return NULL;\n    }\n\n    return dom;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "dom"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDomainUndefineFlags",
          "args": [
            "dom",
            "0"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainUndefineFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "2008-2041",
          "snippet": "static int vboxDomainUndefineFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIID.vboxIIDInitialize(&iid);\n    /* No managed save, so we explicitly reject\n     * VIR_DOMAIN_UNDEFINE_MANAGED_SAVE.  No snapshot metadata for\n     * VBox, so we can trivially ignore that flag.  */\n    virCheckFlags(VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA, -1);\n    vboxIIDFromUUID(&iid, dom->uuid);\n    rc = gVBoxAPI.unregisterMachine(data, &iid, &machine);\n\n    DEBUGIID(\"UUID of machine being undefined\", &iid);\n\n    if (NS_SUCCEEDED(rc)) {\n        gVBoxAPI.deleteConfig(machine);\n        ret = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not delete the domain, rc=%08x\"), (unsigned)rc);\n    }\n\n    vboxIIDUnalloc(&iid);\n    VBOX_RELEASE(machine);\n\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainUndefineFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIID.vboxIIDInitialize(&iid);\n    /* No managed save, so we explicitly reject\n     * VIR_DOMAIN_UNDEFINE_MANAGED_SAVE.  No snapshot metadata for\n     * VBox, so we can trivially ignore that flag.  */\n    virCheckFlags(VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA, -1);\n    vboxIIDFromUUID(&iid, dom->uuid);\n    rc = gVBoxAPI.unregisterMachine(data, &iid, &machine);\n\n    DEBUGIID(\"UUID of machine being undefined\", &iid);\n\n    if (NS_SUCCEEDED(rc)) {\n        gVBoxAPI.deleteConfig(machine);\n        ret = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not delete the domain, rc=%08x\"), (unsigned)rc);\n    }\n\n    vboxIIDUnalloc(&iid);\n    VBOX_RELEASE(machine);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDomainCreate",
          "args": [
            "dom"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "2260-2263",
          "snippet": "static int vboxDomainCreate(virDomainPtr dom)\n{\n    return vboxDomainCreateWithFlags(dom, 0);\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxDomainCreate(virDomainPtr dom)\n{\n    return vboxDomainCreateWithFlags(dom, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDomainDefineXML",
          "args": [
            "conn",
            "xml"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainDefineXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "2002-2006",
          "snippet": "static virDomainPtr\nvboxDomainDefineXML(virConnectPtr conn, const char *xml)\n{\n    return vboxDomainDefineXMLFlags(conn, xml, 0);\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virDomainPtr\nvboxDomainDefineXML(virConnectPtr conn, const char *xml)\n{\n    return vboxDomainDefineXMLFlags(conn, xml, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virDomainPtr vboxDomainCreateXML(virConnectPtr conn, const char *xml,\n                                        unsigned int flags)\n{\n    /* VirtualBox currently doesn't have support for running\n     * virtual machines without actually defining them and thus\n     * for time being just define new machine and start it.\n     *\n     * TODO: After the appropriate API's are added in VirtualBox\n     * change this behaviour to the expected one.\n     */\n\n    virDomainPtr dom;\n\n    virCheckFlags(0, NULL);\n\n    dom = vboxDomainDefineXML(conn, xml);\n    if (dom == NULL)\n        return NULL;\n\n    if (vboxDomainCreate(dom) < 0) {\n        vboxDomainUndefineFlags(dom, 0);\n        virObjectUnref(dom);\n        return NULL;\n    }\n\n    return dom;\n}"
  },
  {
    "function_name": "vboxDomainCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2260-2263",
    "snippet": "static int vboxDomainCreate(virDomainPtr dom)\n{\n    return vboxDomainCreateWithFlags(dom, 0);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxDomainCreateWithFlags",
          "args": [
            "dom",
            "0"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainCreateWithFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "2189-2258",
          "snippet": "static int vboxDomainCreateWithFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    unsigned char uuid[VIR_UUID_BUFLEN] = {0};\n    nsresult rc;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return -1;\n\n    virCheckFlags(0, -1);\n\n    if (!dom->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Error while reading the domain name\"));\n        return -1;\n    }\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return -1;\n    }\n\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n        PRBool isAccessible = PR_FALSE;\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (isAccessible) {\n            vboxIID iid;\n\n            VBOX_IID_INITIALIZE(&iid);\n\n            rc = gVBoxAPI.UIMachine.GetId(machine, &iid);\n            if (NS_FAILED(rc))\n                continue;\n            vboxIIDToUUID(&iid, uuid);\n\n            if (memcmp(dom->uuid, uuid, VIR_UUID_BUFLEN) == 0) {\n                PRUint32 state;\n                gVBoxAPI.UIMachine.GetState(machine, &state);\n\n                if (gVBoxAPI.machineStateChecker.NotStart(state)) {\n                    ret = vboxStartMachine(dom, i, machine, &iid);\n                } else {\n                    virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                                   _(\"machine is not in \"\n                                     \"poweroff|saved|aborted state, so \"\n                                     \"couldn't start it\"));\n                    ret = -1;\n                }\n            }\n            vboxIIDUnalloc(&iid);\n            if (ret != -1)\n                break;\n        }\n    }\n\n    /* Do the cleanup and take care you dont leak any memory */\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainCreateWithFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    unsigned char uuid[VIR_UUID_BUFLEN] = {0};\n    nsresult rc;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return -1;\n\n    virCheckFlags(0, -1);\n\n    if (!dom->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Error while reading the domain name\"));\n        return -1;\n    }\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return -1;\n    }\n\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n        PRBool isAccessible = PR_FALSE;\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (isAccessible) {\n            vboxIID iid;\n\n            VBOX_IID_INITIALIZE(&iid);\n\n            rc = gVBoxAPI.UIMachine.GetId(machine, &iid);\n            if (NS_FAILED(rc))\n                continue;\n            vboxIIDToUUID(&iid, uuid);\n\n            if (memcmp(dom->uuid, uuid, VIR_UUID_BUFLEN) == 0) {\n                PRUint32 state;\n                gVBoxAPI.UIMachine.GetState(machine, &state);\n\n                if (gVBoxAPI.machineStateChecker.NotStart(state)) {\n                    ret = vboxStartMachine(dom, i, machine, &iid);\n                } else {\n                    virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                                   _(\"machine is not in \"\n                                     \"poweroff|saved|aborted state, so \"\n                                     \"couldn't start it\"));\n                    ret = -1;\n                }\n            }\n            vboxIIDUnalloc(&iid);\n            if (ret != -1)\n                break;\n        }\n    }\n\n    /* Do the cleanup and take care you dont leak any memory */\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxDomainCreate(virDomainPtr dom)\n{\n    return vboxDomainCreateWithFlags(dom, 0);\n}"
  },
  {
    "function_name": "vboxDomainCreateWithFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2189-2258",
    "snippet": "static int vboxDomainCreateWithFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    unsigned char uuid[VIR_UUID_BUFLEN] = {0};\n    nsresult rc;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return -1;\n\n    virCheckFlags(0, -1);\n\n    if (!dom->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Error while reading the domain name\"));\n        return -1;\n    }\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return -1;\n    }\n\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n        PRBool isAccessible = PR_FALSE;\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (isAccessible) {\n            vboxIID iid;\n\n            VBOX_IID_INITIALIZE(&iid);\n\n            rc = gVBoxAPI.UIMachine.GetId(machine, &iid);\n            if (NS_FAILED(rc))\n                continue;\n            vboxIIDToUUID(&iid, uuid);\n\n            if (memcmp(dom->uuid, uuid, VIR_UUID_BUFLEN) == 0) {\n                PRUint32 state;\n                gVBoxAPI.UIMachine.GetState(machine, &state);\n\n                if (gVBoxAPI.machineStateChecker.NotStart(state)) {\n                    ret = vboxStartMachine(dom, i, machine, &iid);\n                } else {\n                    virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                                   _(\"machine is not in \"\n                                     \"poweroff|saved|aborted state, so \"\n                                     \"couldn't start it\"));\n                    ret = -1;\n                }\n            }\n            vboxIIDUnalloc(&iid);\n            if (ret != -1)\n                break;\n        }\n    }\n\n    /* Do the cleanup and take care you dont leak any memory */\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&machines"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"machine is not in \"\n                                     \"poweroff|saved|aborted state, so \"\n                                     \"couldn't start it\")"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"machine is not in \"\n                                     \"poweroff|saved|aborted state, so \"\n                                     \"couldn't start it\""
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxStartMachine",
          "args": [
            "dom",
            "i",
            "machine",
            "&iid"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "vboxStartMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "2048-2187",
          "snippet": "static int\nvboxStartMachine(virDomainPtr dom, int maxDomID, IMachine *machine, vboxIID *iid)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    int vrdpPresent = 0;\n    int sdlPresent = 0;\n    int guiPresent = 0;\n    char *guiDisplay = NULL;\n    char *sdlDisplay = NULL;\n    PRUnichar *keyTypeUtf16 = NULL;\n    PRUnichar *valueTypeUtf16 = NULL;\n    char *valueTypeUtf8 = NULL;\n    PRUnichar *keyDislpayUtf16 = NULL;\n    PRUnichar *valueDisplayUtf16 = NULL;\n    char *valueDisplayUtf8 = NULL;\n    IProgress *progress = NULL;\n    PRUnichar *env = NULL;\n    PRUnichar *sessionType = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n    gVBoxAPI.UIMachine.GetExtraData(machine, keyTypeUtf16, &valueTypeUtf16);\n    VBOX_UTF16_FREE(keyTypeUtf16);\n\n    if (valueTypeUtf16) {\n        VBOX_UTF16_TO_UTF8(valueTypeUtf16, &valueTypeUtf8);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n        if (STREQ(valueTypeUtf8, \"sdl\") || STREQ(valueTypeUtf8, \"gui\")) {\n\n            VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyDislpayUtf16);\n            gVBoxAPI.UIMachine.GetExtraData(machine, keyDislpayUtf16,\n                                            &valueDisplayUtf16);\n            VBOX_UTF16_FREE(keyDislpayUtf16);\n\n            if (valueDisplayUtf16) {\n                VBOX_UTF16_TO_UTF8(valueDisplayUtf16, &valueDisplayUtf8);\n                VBOX_UTF16_FREE(valueDisplayUtf16);\n\n                if (strlen(valueDisplayUtf8) <= 0)\n                    VBOX_UTF8_FREE(valueDisplayUtf8);\n            }\n\n            if (STREQ(valueTypeUtf8, \"sdl\")) {\n                sdlPresent = 1;\n                sdlDisplay = g_strdup(valueDisplayUtf8);\n            }\n\n            if (STREQ(valueTypeUtf8, \"gui\")) {\n                guiPresent = 1;\n                guiDisplay = g_strdup(valueDisplayUtf8);\n            }\n        }\n\n        if (STREQ(valueTypeUtf8, \"vrdp\"))\n            vrdpPresent = 1;\n\n        if (!vrdpPresent && !sdlPresent && !guiPresent) {\n            /* if nothing is selected it means either the machine xml\n             * file is really old or some values are missing so fallback\n             */\n            guiPresent = 1;\n        }\n\n        VBOX_UTF8_FREE(valueTypeUtf8);\n\n    } else {\n        guiPresent = 1;\n    }\n    VBOX_UTF8_FREE(valueDisplayUtf8);\n\n    if (guiPresent) {\n        if (guiDisplay) {\n            char *displayutf8;\n            displayutf8 = g_strdup_printf(\"DISPLAY=%s\", guiDisplay);\n            VBOX_UTF8_TO_UTF16(displayutf8, &env);\n            VIR_FREE(displayutf8);\n            VIR_FREE(guiDisplay);\n        }\n\n        VBOX_UTF8_TO_UTF16(\"gui\", &sessionType);\n    }\n\n    if (sdlPresent) {\n        if (sdlDisplay) {\n            char *displayutf8;\n            displayutf8 = g_strdup_printf(\"DISPLAY=%s\", sdlDisplay);\n            VBOX_UTF8_TO_UTF16(displayutf8, &env);\n            VIR_FREE(displayutf8);\n            VIR_FREE(sdlDisplay);\n        }\n\n        VBOX_UTF8_TO_UTF16(\"sdl\", &sessionType);\n    }\n\n    if (vrdpPresent)\n        VBOX_UTF8_TO_UTF16(\"vrdp\", &sessionType);\n\n    rc = gVBoxAPI.UIMachine.LaunchVMProcess(data, machine, iid,\n                                            sessionType, env,\n                                            &progress);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"OpenRemoteSession/LaunchVMProcess failed, domain can't be started\"));\n        ret = -1;\n    } else {\n        PRBool completed = 0;\n        resultCodeUnion resultCode;\n\n        gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n        rc = gVBoxAPI.UIProgress.GetCompleted(progress, &completed);\n        if (NS_FAILED(rc)) {\n            /* error */\n            ret = -1;\n        }\n        gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n        if (RC_FAILED(resultCode)) {\n            /* error */\n            ret = -1;\n        } else {\n            /* all ok set the domid */\n            dom->id = maxDomID + 1;\n            ret = 0;\n        }\n    }\n\n    VBOX_RELEASE(progress);\n\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n    VBOX_UTF16_FREE(env);\n    VBOX_UTF16_FREE(sessionType);\n\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxStartMachine(virDomainPtr dom, int maxDomID, IMachine *machine, vboxIID *iid)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    int vrdpPresent = 0;\n    int sdlPresent = 0;\n    int guiPresent = 0;\n    char *guiDisplay = NULL;\n    char *sdlDisplay = NULL;\n    PRUnichar *keyTypeUtf16 = NULL;\n    PRUnichar *valueTypeUtf16 = NULL;\n    char *valueTypeUtf8 = NULL;\n    PRUnichar *keyDislpayUtf16 = NULL;\n    PRUnichar *valueDisplayUtf16 = NULL;\n    char *valueDisplayUtf8 = NULL;\n    IProgress *progress = NULL;\n    PRUnichar *env = NULL;\n    PRUnichar *sessionType = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n    gVBoxAPI.UIMachine.GetExtraData(machine, keyTypeUtf16, &valueTypeUtf16);\n    VBOX_UTF16_FREE(keyTypeUtf16);\n\n    if (valueTypeUtf16) {\n        VBOX_UTF16_TO_UTF8(valueTypeUtf16, &valueTypeUtf8);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n        if (STREQ(valueTypeUtf8, \"sdl\") || STREQ(valueTypeUtf8, \"gui\")) {\n\n            VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyDislpayUtf16);\n            gVBoxAPI.UIMachine.GetExtraData(machine, keyDislpayUtf16,\n                                            &valueDisplayUtf16);\n            VBOX_UTF16_FREE(keyDislpayUtf16);\n\n            if (valueDisplayUtf16) {\n                VBOX_UTF16_TO_UTF8(valueDisplayUtf16, &valueDisplayUtf8);\n                VBOX_UTF16_FREE(valueDisplayUtf16);\n\n                if (strlen(valueDisplayUtf8) <= 0)\n                    VBOX_UTF8_FREE(valueDisplayUtf8);\n            }\n\n            if (STREQ(valueTypeUtf8, \"sdl\")) {\n                sdlPresent = 1;\n                sdlDisplay = g_strdup(valueDisplayUtf8);\n            }\n\n            if (STREQ(valueTypeUtf8, \"gui\")) {\n                guiPresent = 1;\n                guiDisplay = g_strdup(valueDisplayUtf8);\n            }\n        }\n\n        if (STREQ(valueTypeUtf8, \"vrdp\"))\n            vrdpPresent = 1;\n\n        if (!vrdpPresent && !sdlPresent && !guiPresent) {\n            /* if nothing is selected it means either the machine xml\n             * file is really old or some values are missing so fallback\n             */\n            guiPresent = 1;\n        }\n\n        VBOX_UTF8_FREE(valueTypeUtf8);\n\n    } else {\n        guiPresent = 1;\n    }\n    VBOX_UTF8_FREE(valueDisplayUtf8);\n\n    if (guiPresent) {\n        if (guiDisplay) {\n            char *displayutf8;\n            displayutf8 = g_strdup_printf(\"DISPLAY=%s\", guiDisplay);\n            VBOX_UTF8_TO_UTF16(displayutf8, &env);\n            VIR_FREE(displayutf8);\n            VIR_FREE(guiDisplay);\n        }\n\n        VBOX_UTF8_TO_UTF16(\"gui\", &sessionType);\n    }\n\n    if (sdlPresent) {\n        if (sdlDisplay) {\n            char *displayutf8;\n            displayutf8 = g_strdup_printf(\"DISPLAY=%s\", sdlDisplay);\n            VBOX_UTF8_TO_UTF16(displayutf8, &env);\n            VIR_FREE(displayutf8);\n            VIR_FREE(sdlDisplay);\n        }\n\n        VBOX_UTF8_TO_UTF16(\"sdl\", &sessionType);\n    }\n\n    if (vrdpPresent)\n        VBOX_UTF8_TO_UTF16(\"vrdp\", &sessionType);\n\n    rc = gVBoxAPI.UIMachine.LaunchVMProcess(data, machine, iid,\n                                            sessionType, env,\n                                            &progress);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"OpenRemoteSession/LaunchVMProcess failed, domain can't be started\"));\n        ret = -1;\n    } else {\n        PRBool completed = 0;\n        resultCodeUnion resultCode;\n\n        gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n        rc = gVBoxAPI.UIProgress.GetCompleted(progress, &completed);\n        if (NS_FAILED(rc)) {\n            /* error */\n            ret = -1;\n        }\n        gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n        if (RC_FAILED(resultCode)) {\n            /* error */\n            ret = -1;\n        } else {\n            /* all ok set the domid */\n            dom->id = maxDomID + 1;\n            ret = 0;\n        }\n    }\n\n    VBOX_RELEASE(progress);\n\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n    VBOX_UTF16_FREE(env);\n    VBOX_UTF16_FREE(sessionType);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.NotStart",
          "args": [
            "state"
          ],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dom->uuid",
            "uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDToUUID",
          "args": [
            "&iid",
            "uuid"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetId",
          "args": [
            "machine",
            "&iid"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 2223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get list of machines, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&machines",
            "data->vboxObj",
            "ARRAY_GET_MACHINES"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Error while reading the domain name\")"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainCreateWithFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    unsigned char uuid[VIR_UUID_BUFLEN] = {0};\n    nsresult rc;\n    size_t i = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return -1;\n\n    virCheckFlags(0, -1);\n\n    if (!dom->name) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Error while reading the domain name\"));\n        return -1;\n    }\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return -1;\n    }\n\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n        PRBool isAccessible = PR_FALSE;\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (isAccessible) {\n            vboxIID iid;\n\n            VBOX_IID_INITIALIZE(&iid);\n\n            rc = gVBoxAPI.UIMachine.GetId(machine, &iid);\n            if (NS_FAILED(rc))\n                continue;\n            vboxIIDToUUID(&iid, uuid);\n\n            if (memcmp(dom->uuid, uuid, VIR_UUID_BUFLEN) == 0) {\n                PRUint32 state;\n                gVBoxAPI.UIMachine.GetState(machine, &state);\n\n                if (gVBoxAPI.machineStateChecker.NotStart(state)) {\n                    ret = vboxStartMachine(dom, i, machine, &iid);\n                } else {\n                    virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                                   _(\"machine is not in \"\n                                     \"poweroff|saved|aborted state, so \"\n                                     \"couldn't start it\"));\n                    ret = -1;\n                }\n            }\n            vboxIIDUnalloc(&iid);\n            if (ret != -1)\n                break;\n        }\n    }\n\n    /* Do the cleanup and take care you dont leak any memory */\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxStartMachine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2048-2187",
    "snippet": "static int\nvboxStartMachine(virDomainPtr dom, int maxDomID, IMachine *machine, vboxIID *iid)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    int vrdpPresent = 0;\n    int sdlPresent = 0;\n    int guiPresent = 0;\n    char *guiDisplay = NULL;\n    char *sdlDisplay = NULL;\n    PRUnichar *keyTypeUtf16 = NULL;\n    PRUnichar *valueTypeUtf16 = NULL;\n    char *valueTypeUtf8 = NULL;\n    PRUnichar *keyDislpayUtf16 = NULL;\n    PRUnichar *valueDisplayUtf16 = NULL;\n    char *valueDisplayUtf8 = NULL;\n    IProgress *progress = NULL;\n    PRUnichar *env = NULL;\n    PRUnichar *sessionType = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n    gVBoxAPI.UIMachine.GetExtraData(machine, keyTypeUtf16, &valueTypeUtf16);\n    VBOX_UTF16_FREE(keyTypeUtf16);\n\n    if (valueTypeUtf16) {\n        VBOX_UTF16_TO_UTF8(valueTypeUtf16, &valueTypeUtf8);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n        if (STREQ(valueTypeUtf8, \"sdl\") || STREQ(valueTypeUtf8, \"gui\")) {\n\n            VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyDislpayUtf16);\n            gVBoxAPI.UIMachine.GetExtraData(machine, keyDislpayUtf16,\n                                            &valueDisplayUtf16);\n            VBOX_UTF16_FREE(keyDislpayUtf16);\n\n            if (valueDisplayUtf16) {\n                VBOX_UTF16_TO_UTF8(valueDisplayUtf16, &valueDisplayUtf8);\n                VBOX_UTF16_FREE(valueDisplayUtf16);\n\n                if (strlen(valueDisplayUtf8) <= 0)\n                    VBOX_UTF8_FREE(valueDisplayUtf8);\n            }\n\n            if (STREQ(valueTypeUtf8, \"sdl\")) {\n                sdlPresent = 1;\n                sdlDisplay = g_strdup(valueDisplayUtf8);\n            }\n\n            if (STREQ(valueTypeUtf8, \"gui\")) {\n                guiPresent = 1;\n                guiDisplay = g_strdup(valueDisplayUtf8);\n            }\n        }\n\n        if (STREQ(valueTypeUtf8, \"vrdp\"))\n            vrdpPresent = 1;\n\n        if (!vrdpPresent && !sdlPresent && !guiPresent) {\n            /* if nothing is selected it means either the machine xml\n             * file is really old or some values are missing so fallback\n             */\n            guiPresent = 1;\n        }\n\n        VBOX_UTF8_FREE(valueTypeUtf8);\n\n    } else {\n        guiPresent = 1;\n    }\n    VBOX_UTF8_FREE(valueDisplayUtf8);\n\n    if (guiPresent) {\n        if (guiDisplay) {\n            char *displayutf8;\n            displayutf8 = g_strdup_printf(\"DISPLAY=%s\", guiDisplay);\n            VBOX_UTF8_TO_UTF16(displayutf8, &env);\n            VIR_FREE(displayutf8);\n            VIR_FREE(guiDisplay);\n        }\n\n        VBOX_UTF8_TO_UTF16(\"gui\", &sessionType);\n    }\n\n    if (sdlPresent) {\n        if (sdlDisplay) {\n            char *displayutf8;\n            displayutf8 = g_strdup_printf(\"DISPLAY=%s\", sdlDisplay);\n            VBOX_UTF8_TO_UTF16(displayutf8, &env);\n            VIR_FREE(displayutf8);\n            VIR_FREE(sdlDisplay);\n        }\n\n        VBOX_UTF8_TO_UTF16(\"sdl\", &sessionType);\n    }\n\n    if (vrdpPresent)\n        VBOX_UTF8_TO_UTF16(\"vrdp\", &sessionType);\n\n    rc = gVBoxAPI.UIMachine.LaunchVMProcess(data, machine, iid,\n                                            sessionType, env,\n                                            &progress);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"OpenRemoteSession/LaunchVMProcess failed, domain can't be started\"));\n        ret = -1;\n    } else {\n        PRBool completed = 0;\n        resultCodeUnion resultCode;\n\n        gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n        rc = gVBoxAPI.UIProgress.GetCompleted(progress, &completed);\n        if (NS_FAILED(rc)) {\n            /* error */\n            ret = -1;\n        }\n        gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n        if (RC_FAILED(resultCode)) {\n            /* error */\n            ret = -1;\n        } else {\n            /* all ok set the domid */\n            dom->id = maxDomID + 1;\n            ret = 0;\n        }\n    }\n\n    VBOX_RELEASE(progress);\n\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n    VBOX_UTF16_FREE(env);\n    VBOX_UTF16_FREE(sessionType);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "sessionType"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "env"
          ],
          "line": 2183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "progress"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RC_FAILED",
          "args": [
            "resultCode"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.GetResultCode",
          "args": [
            "progress",
            "&resultCode"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.GetCompleted",
          "args": [
            "progress",
            "&completed"
          ],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.WaitForCompletion",
          "args": [
            "progress",
            "-1"
          ],
          "line": 2162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"OpenRemoteSession/LaunchVMProcess failed, domain can't be started\")"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"OpenRemoteSession/LaunchVMProcess failed, domain can't be started\""
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.LaunchVMProcess",
          "args": [
            "data",
            "machine",
            "iid",
            "sessionType",
            "env",
            "&progress"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"vrdp\"",
            "&sessionType"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"sdl\"",
            "&sessionType"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sdlDisplay"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "displayutf8"
          ],
          "line": 2140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "displayutf8",
            "&env"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"DISPLAY=%s\"",
            "sdlDisplay"
          ],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"gui\"",
            "&sessionType"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "guiDisplay"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "displayutf8"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "displayutf8",
            "&env"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "valueDisplayUtf8"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "valueTypeUtf8"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "valueTypeUtf8",
            "\"vrdp\""
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "valueTypeUtf8",
            "\"gui\""
          ],
          "line": 2100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "valueTypeUtf8",
            "\"sdl\""
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "valueDisplayUtf8"
          ],
          "line": 2092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "valueDisplayUtf8"
          ],
          "line": 2091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "valueDisplayUtf16"
          ],
          "line": 2089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "valueDisplayUtf16",
            "&valueDisplayUtf8"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "keyDislpayUtf16"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetExtraData",
          "args": [
            "machine",
            "keyDislpayUtf16",
            "&valueDisplayUtf16"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"FRONTEND/Display\"",
            "&keyDislpayUtf16"
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "valueTypeUtf8",
            "\"gui\""
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "valueTypeUtf8",
            "\"sdl\""
          ],
          "line": 2080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "valueTypeUtf16"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "valueTypeUtf16",
            "&valueTypeUtf8"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "keyTypeUtf16"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetExtraData",
          "args": [
            "machine",
            "keyTypeUtf16",
            "&valueTypeUtf16"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"FRONTEND/Type\"",
            "&keyTypeUtf16"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxStartMachine(virDomainPtr dom, int maxDomID, IMachine *machine, vboxIID *iid)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    int vrdpPresent = 0;\n    int sdlPresent = 0;\n    int guiPresent = 0;\n    char *guiDisplay = NULL;\n    char *sdlDisplay = NULL;\n    PRUnichar *keyTypeUtf16 = NULL;\n    PRUnichar *valueTypeUtf16 = NULL;\n    char *valueTypeUtf8 = NULL;\n    PRUnichar *keyDislpayUtf16 = NULL;\n    PRUnichar *valueDisplayUtf16 = NULL;\n    char *valueDisplayUtf8 = NULL;\n    IProgress *progress = NULL;\n    PRUnichar *env = NULL;\n    PRUnichar *sessionType = NULL;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n    gVBoxAPI.UIMachine.GetExtraData(machine, keyTypeUtf16, &valueTypeUtf16);\n    VBOX_UTF16_FREE(keyTypeUtf16);\n\n    if (valueTypeUtf16) {\n        VBOX_UTF16_TO_UTF8(valueTypeUtf16, &valueTypeUtf8);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n        if (STREQ(valueTypeUtf8, \"sdl\") || STREQ(valueTypeUtf8, \"gui\")) {\n\n            VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyDislpayUtf16);\n            gVBoxAPI.UIMachine.GetExtraData(machine, keyDislpayUtf16,\n                                            &valueDisplayUtf16);\n            VBOX_UTF16_FREE(keyDislpayUtf16);\n\n            if (valueDisplayUtf16) {\n                VBOX_UTF16_TO_UTF8(valueDisplayUtf16, &valueDisplayUtf8);\n                VBOX_UTF16_FREE(valueDisplayUtf16);\n\n                if (strlen(valueDisplayUtf8) <= 0)\n                    VBOX_UTF8_FREE(valueDisplayUtf8);\n            }\n\n            if (STREQ(valueTypeUtf8, \"sdl\")) {\n                sdlPresent = 1;\n                sdlDisplay = g_strdup(valueDisplayUtf8);\n            }\n\n            if (STREQ(valueTypeUtf8, \"gui\")) {\n                guiPresent = 1;\n                guiDisplay = g_strdup(valueDisplayUtf8);\n            }\n        }\n\n        if (STREQ(valueTypeUtf8, \"vrdp\"))\n            vrdpPresent = 1;\n\n        if (!vrdpPresent && !sdlPresent && !guiPresent) {\n            /* if nothing is selected it means either the machine xml\n             * file is really old or some values are missing so fallback\n             */\n            guiPresent = 1;\n        }\n\n        VBOX_UTF8_FREE(valueTypeUtf8);\n\n    } else {\n        guiPresent = 1;\n    }\n    VBOX_UTF8_FREE(valueDisplayUtf8);\n\n    if (guiPresent) {\n        if (guiDisplay) {\n            char *displayutf8;\n            displayutf8 = g_strdup_printf(\"DISPLAY=%s\", guiDisplay);\n            VBOX_UTF8_TO_UTF16(displayutf8, &env);\n            VIR_FREE(displayutf8);\n            VIR_FREE(guiDisplay);\n        }\n\n        VBOX_UTF8_TO_UTF16(\"gui\", &sessionType);\n    }\n\n    if (sdlPresent) {\n        if (sdlDisplay) {\n            char *displayutf8;\n            displayutf8 = g_strdup_printf(\"DISPLAY=%s\", sdlDisplay);\n            VBOX_UTF8_TO_UTF16(displayutf8, &env);\n            VIR_FREE(displayutf8);\n            VIR_FREE(sdlDisplay);\n        }\n\n        VBOX_UTF8_TO_UTF16(\"sdl\", &sessionType);\n    }\n\n    if (vrdpPresent)\n        VBOX_UTF8_TO_UTF16(\"vrdp\", &sessionType);\n\n    rc = gVBoxAPI.UIMachine.LaunchVMProcess(data, machine, iid,\n                                            sessionType, env,\n                                            &progress);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"OpenRemoteSession/LaunchVMProcess failed, domain can't be started\"));\n        ret = -1;\n    } else {\n        PRBool completed = 0;\n        resultCodeUnion resultCode;\n\n        gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n        rc = gVBoxAPI.UIProgress.GetCompleted(progress, &completed);\n        if (NS_FAILED(rc)) {\n            /* error */\n            ret = -1;\n        }\n        gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n        if (RC_FAILED(resultCode)) {\n            /* error */\n            ret = -1;\n        } else {\n            /* all ok set the domid */\n            dom->id = maxDomID + 1;\n            ret = 0;\n        }\n    }\n\n    VBOX_RELEASE(progress);\n\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n    VBOX_UTF16_FREE(env);\n    VBOX_UTF16_FREE(sessionType);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainUndefine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2043-2046",
    "snippet": "static int vboxDomainUndefine(virDomainPtr dom)\n{\n    return vboxDomainUndefineFlags(dom, 0);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxDomainUndefineFlags",
          "args": [
            "dom",
            "0"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainUndefineFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "2008-2041",
          "snippet": "static int vboxDomainUndefineFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIID.vboxIIDInitialize(&iid);\n    /* No managed save, so we explicitly reject\n     * VIR_DOMAIN_UNDEFINE_MANAGED_SAVE.  No snapshot metadata for\n     * VBox, so we can trivially ignore that flag.  */\n    virCheckFlags(VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA, -1);\n    vboxIIDFromUUID(&iid, dom->uuid);\n    rc = gVBoxAPI.unregisterMachine(data, &iid, &machine);\n\n    DEBUGIID(\"UUID of machine being undefined\", &iid);\n\n    if (NS_SUCCEEDED(rc)) {\n        gVBoxAPI.deleteConfig(machine);\n        ret = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not delete the domain, rc=%08x\"), (unsigned)rc);\n    }\n\n    vboxIIDUnalloc(&iid);\n    VBOX_RELEASE(machine);\n\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainUndefineFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIID.vboxIIDInitialize(&iid);\n    /* No managed save, so we explicitly reject\n     * VIR_DOMAIN_UNDEFINE_MANAGED_SAVE.  No snapshot metadata for\n     * VBox, so we can trivially ignore that flag.  */\n    virCheckFlags(VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA, -1);\n    vboxIIDFromUUID(&iid, dom->uuid);\n    rc = gVBoxAPI.unregisterMachine(data, &iid, &machine);\n\n    DEBUGIID(\"UUID of machine being undefined\", &iid);\n\n    if (NS_SUCCEEDED(rc)) {\n        gVBoxAPI.deleteConfig(machine);\n        ret = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not delete the domain, rc=%08x\"), (unsigned)rc);\n    }\n\n    vboxIIDUnalloc(&iid);\n    VBOX_RELEASE(machine);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxDomainUndefine(virDomainPtr dom)\n{\n    return vboxDomainUndefineFlags(dom, 0);\n}"
  },
  {
    "function_name": "vboxDomainUndefineFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2008-2041",
    "snippet": "static int vboxDomainUndefineFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIID.vboxIIDInitialize(&iid);\n    /* No managed save, so we explicitly reject\n     * VIR_DOMAIN_UNDEFINE_MANAGED_SAVE.  No snapshot metadata for\n     * VBox, so we can trivially ignore that flag.  */\n    virCheckFlags(VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA, -1);\n    vboxIIDFromUUID(&iid, dom->uuid);\n    rc = gVBoxAPI.unregisterMachine(data, &iid, &machine);\n\n    DEBUGIID(\"UUID of machine being undefined\", &iid);\n\n    if (NS_SUCCEEDED(rc)) {\n        gVBoxAPI.deleteConfig(machine);\n        ret = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not delete the domain, rc=%08x\"), (unsigned)rc);\n    }\n\n    vboxIIDUnalloc(&iid);\n    VBOX_RELEASE(machine);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not delete the domain, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"could not delete the domain, rc=%08x\""
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.deleteConfig",
          "args": [
            "machine"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_SUCCEEDED",
          "args": [
            "rc"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUGIID",
          "args": [
            "\"UUID of machine being undefined\"",
            "&iid"
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.unregisterMachine",
          "args": [
            "data",
            "&iid",
            "&machine"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDFromUUID",
          "args": [
            "&iid",
            "dom->uuid"
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA",
            "-1"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIID.vboxIIDInitialize",
          "args": [
            "&iid"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxDomainUndefineFlags(virDomainPtr dom, unsigned int flags)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IMachine *machine = NULL;\n    vboxIID iid;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    gVBoxAPI.UIID.vboxIIDInitialize(&iid);\n    /* No managed save, so we explicitly reject\n     * VIR_DOMAIN_UNDEFINE_MANAGED_SAVE.  No snapshot metadata for\n     * VBox, so we can trivially ignore that flag.  */\n    virCheckFlags(VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA, -1);\n    vboxIIDFromUUID(&iid, dom->uuid);\n    rc = gVBoxAPI.unregisterMachine(data, &iid, &machine);\n\n    DEBUGIID(\"UUID of machine being undefined\", &iid);\n\n    if (NS_SUCCEEDED(rc)) {\n        gVBoxAPI.deleteConfig(machine);\n        ret = 0;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not delete the domain, rc=%08x\"), (unsigned)rc);\n    }\n\n    vboxIIDUnalloc(&iid);\n    VBOX_RELEASE(machine);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainDefineXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "2002-2006",
    "snippet": "static virDomainPtr\nvboxDomainDefineXML(virConnectPtr conn, const char *xml)\n{\n    return vboxDomainDefineXMLFlags(conn, xml, 0);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxDomainDefineXMLFlags",
          "args": [
            "conn",
            "xml",
            "0"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDomainDefineXMLFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "1835-2000",
          "snippet": "static virDomainPtr\nvboxDomainDefineXMLFlags(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    vboxDriverPtr data = conn->privateData;\n    IMachine *machine = NULL;\n    IBIOSSettings *bios = NULL;\n    vboxIID mchiid;\n    virDomainDefPtr def = NULL;\n    nsresult rc;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDomainPtr ret = NULL;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE;\n    bool machineReady = false;\n\n\n    virCheckFlags(VIR_DOMAIN_DEFINE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_DEFINE_VALIDATE)\n        parse_flags |= VIR_DOMAIN_DEF_PARSE_VALIDATE_SCHEMA;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!(def = virDomainDefParseString(xml, data->xmlopt,\n                                        NULL, parse_flags)))\n        return ret;\n\n    VBOX_IID_INITIALIZE(&mchiid);\n    virUUIDFormat(def->uuid, uuidstr);\n\n    rc = gVBoxAPI.UIVirtualBox.CreateMachine(data, def, &machine, uuidstr);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not define a domain, rc=%08x\"), (unsigned)rc);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIMachine.SetMemorySize(machine,\n                                          VIR_DIV_UP(def->mem.cur_balloon, 1024));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not set the memory size of the domain to: %llu Kb, \"\n                         \"rc=%08x\"),\n                       def->mem.cur_balloon, (unsigned)rc);\n    }\n\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"current vcpu count must equal maximum\"));\n    }\n    rc = gVBoxAPI.UIMachine.SetCPUCount(machine, virDomainDefGetVcpusMax(def));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not set the number of virtual CPUs to: %u, rc=%08x\"),\n                       virDomainDefGetVcpusMax(def), (unsigned)rc);\n    }\n\n    rc = gVBoxAPI.UIMachine.SetCPUProperty(machine, CPUPropertyType_PAE,\n                                           def->features[VIR_DOMAIN_FEATURE_PAE] ==\n                                           VIR_TRISTATE_SWITCH_ON);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not change PAE status to: %s, rc=%08x\"),\n                       (def->features[VIR_DOMAIN_FEATURE_PAE] == VIR_TRISTATE_SWITCH_ON)\n                       ? _(\"Enabled\") : _(\"Disabled\"), (unsigned)rc);\n    }\n\n    gVBoxAPI.UIMachine.GetBIOSSettings(machine, &bios);\n    if (bios) {\n        rc = gVBoxAPI.UIBIOSSettings.SetACPIEnabled(bios,\n                                                    def->features[VIR_DOMAIN_FEATURE_ACPI] ==\n                                                    VIR_TRISTATE_SWITCH_ON);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not change ACPI status to: %s, rc=%08x\"),\n                           (def->features[VIR_DOMAIN_FEATURE_ACPI] == VIR_TRISTATE_SWITCH_ON)\n                           ? _(\"Enabled\") : _(\"Disabled\"), (unsigned)rc);\n        }\n        rc = gVBoxAPI.UIBIOSSettings.SetIOAPICEnabled(bios,\n                                                      def->features[VIR_DOMAIN_FEATURE_APIC] ==\n                                                      VIR_TRISTATE_SWITCH_ON);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not change APIC status to: %s, rc=%08x\"),\n                           (def->features[VIR_DOMAIN_FEATURE_APIC] == VIR_TRISTATE_SWITCH_ON)\n                           ? _(\"Enabled\") : _(\"Disabled\"), (unsigned)rc);\n        }\n        VBOX_RELEASE(bios);\n    }\n\n    /* Register the machine before attaching other devices to it */\n    rc = gVBoxAPI.UIVirtualBox.RegisterMachine(data->vboxObj, machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not define a domain, rc=%08x\"), (unsigned)rc);\n        goto cleanup;\n    }\n\n    /* Get the uuid of the machine, currently it is immutable\n     * object so open a session to it and get it back, so that\n     * you can make changes to the machine setting\n     */\n    gVBoxAPI.UIMachine.GetId(machine, &mchiid);\n    gVBoxAPI.UISession.Open(data, &mchiid, machine);\n    gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n\n    vboxSetBootDeviceOrder(def, data, machine);\n    if (vboxAttachStorageControllers(def, data, machine) < 0)\n        goto cleanup;\n    if (vboxAttachDrives(def, data, machine) < 0)\n        goto cleanup;\n    vboxAttachSound(def, machine);\n    if (vboxAttachNetwork(def, data, machine) < 0)\n        goto cleanup;\n    vboxAttachSerial(def, data, machine);\n    vboxAttachParallel(def, data, machine);\n    vboxAttachVideo(def, machine);\n    vboxAttachDisplay(def, data, machine);\n    vboxAttachUSB(def, data, machine);\n    vboxAttachSharedFolder(def, data, machine);\n\n    machineReady = true;\n\n cleanup:\n    /* if machine wasn't even created, cleanup is trivial */\n    if (!machine) {\n        vboxIIDUnalloc(&mchiid);\n        virDomainDefFree(def);\n\n        return ret;\n    }\n\n    /* Save the machine settings made till now, even when jumped here on error,\n     * as otherwise unregister won't cleanup properly. For example, it won't\n     * close media that were partially attached. The VBOX SDK docs say that\n     * unregister implicitly calls saveSettings but evidently it's not so...\n     */\n    rc = gVBoxAPI.UIMachine.SaveSettings(machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to save VM settings, rc=%08x\"), rc);\n        machineReady = false;\n    }\n\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n    if (machineReady) {\n        ret = virGetDomain(conn, def->name, def->uuid, -1);\n    } else {\n        /* Unregister incompletely configured VM to not leave garbage behind */\n        rc = gVBoxAPI.unregisterMachine(data, &mchiid, &machine);\n\n        if (NS_SUCCEEDED(rc))\n            gVBoxAPI.deleteConfig(machine);\n        else\n            VIR_WARN(\"Could not cleanup partially created VM after failure, \"\n                     \"rc=%08x\", rc);\n    }\n\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&mchiid);\n    virDomainDefFree(def);\n\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virDomainPtr\nvboxDomainDefineXMLFlags(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    vboxDriverPtr data = conn->privateData;\n    IMachine *machine = NULL;\n    IBIOSSettings *bios = NULL;\n    vboxIID mchiid;\n    virDomainDefPtr def = NULL;\n    nsresult rc;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDomainPtr ret = NULL;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE;\n    bool machineReady = false;\n\n\n    virCheckFlags(VIR_DOMAIN_DEFINE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_DEFINE_VALIDATE)\n        parse_flags |= VIR_DOMAIN_DEF_PARSE_VALIDATE_SCHEMA;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!(def = virDomainDefParseString(xml, data->xmlopt,\n                                        NULL, parse_flags)))\n        return ret;\n\n    VBOX_IID_INITIALIZE(&mchiid);\n    virUUIDFormat(def->uuid, uuidstr);\n\n    rc = gVBoxAPI.UIVirtualBox.CreateMachine(data, def, &machine, uuidstr);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not define a domain, rc=%08x\"), (unsigned)rc);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIMachine.SetMemorySize(machine,\n                                          VIR_DIV_UP(def->mem.cur_balloon, 1024));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not set the memory size of the domain to: %llu Kb, \"\n                         \"rc=%08x\"),\n                       def->mem.cur_balloon, (unsigned)rc);\n    }\n\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"current vcpu count must equal maximum\"));\n    }\n    rc = gVBoxAPI.UIMachine.SetCPUCount(machine, virDomainDefGetVcpusMax(def));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not set the number of virtual CPUs to: %u, rc=%08x\"),\n                       virDomainDefGetVcpusMax(def), (unsigned)rc);\n    }\n\n    rc = gVBoxAPI.UIMachine.SetCPUProperty(machine, CPUPropertyType_PAE,\n                                           def->features[VIR_DOMAIN_FEATURE_PAE] ==\n                                           VIR_TRISTATE_SWITCH_ON);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not change PAE status to: %s, rc=%08x\"),\n                       (def->features[VIR_DOMAIN_FEATURE_PAE] == VIR_TRISTATE_SWITCH_ON)\n                       ? _(\"Enabled\") : _(\"Disabled\"), (unsigned)rc);\n    }\n\n    gVBoxAPI.UIMachine.GetBIOSSettings(machine, &bios);\n    if (bios) {\n        rc = gVBoxAPI.UIBIOSSettings.SetACPIEnabled(bios,\n                                                    def->features[VIR_DOMAIN_FEATURE_ACPI] ==\n                                                    VIR_TRISTATE_SWITCH_ON);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not change ACPI status to: %s, rc=%08x\"),\n                           (def->features[VIR_DOMAIN_FEATURE_ACPI] == VIR_TRISTATE_SWITCH_ON)\n                           ? _(\"Enabled\") : _(\"Disabled\"), (unsigned)rc);\n        }\n        rc = gVBoxAPI.UIBIOSSettings.SetIOAPICEnabled(bios,\n                                                      def->features[VIR_DOMAIN_FEATURE_APIC] ==\n                                                      VIR_TRISTATE_SWITCH_ON);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not change APIC status to: %s, rc=%08x\"),\n                           (def->features[VIR_DOMAIN_FEATURE_APIC] == VIR_TRISTATE_SWITCH_ON)\n                           ? _(\"Enabled\") : _(\"Disabled\"), (unsigned)rc);\n        }\n        VBOX_RELEASE(bios);\n    }\n\n    /* Register the machine before attaching other devices to it */\n    rc = gVBoxAPI.UIVirtualBox.RegisterMachine(data->vboxObj, machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not define a domain, rc=%08x\"), (unsigned)rc);\n        goto cleanup;\n    }\n\n    /* Get the uuid of the machine, currently it is immutable\n     * object so open a session to it and get it back, so that\n     * you can make changes to the machine setting\n     */\n    gVBoxAPI.UIMachine.GetId(machine, &mchiid);\n    gVBoxAPI.UISession.Open(data, &mchiid, machine);\n    gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n\n    vboxSetBootDeviceOrder(def, data, machine);\n    if (vboxAttachStorageControllers(def, data, machine) < 0)\n        goto cleanup;\n    if (vboxAttachDrives(def, data, machine) < 0)\n        goto cleanup;\n    vboxAttachSound(def, machine);\n    if (vboxAttachNetwork(def, data, machine) < 0)\n        goto cleanup;\n    vboxAttachSerial(def, data, machine);\n    vboxAttachParallel(def, data, machine);\n    vboxAttachVideo(def, machine);\n    vboxAttachDisplay(def, data, machine);\n    vboxAttachUSB(def, data, machine);\n    vboxAttachSharedFolder(def, data, machine);\n\n    machineReady = true;\n\n cleanup:\n    /* if machine wasn't even created, cleanup is trivial */\n    if (!machine) {\n        vboxIIDUnalloc(&mchiid);\n        virDomainDefFree(def);\n\n        return ret;\n    }\n\n    /* Save the machine settings made till now, even when jumped here on error,\n     * as otherwise unregister won't cleanup properly. For example, it won't\n     * close media that were partially attached. The VBOX SDK docs say that\n     * unregister implicitly calls saveSettings but evidently it's not so...\n     */\n    rc = gVBoxAPI.UIMachine.SaveSettings(machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to save VM settings, rc=%08x\"), rc);\n        machineReady = false;\n    }\n\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n    if (machineReady) {\n        ret = virGetDomain(conn, def->name, def->uuid, -1);\n    } else {\n        /* Unregister incompletely configured VM to not leave garbage behind */\n        rc = gVBoxAPI.unregisterMachine(data, &mchiid, &machine);\n\n        if (NS_SUCCEEDED(rc))\n            gVBoxAPI.deleteConfig(machine);\n        else\n            VIR_WARN(\"Could not cleanup partially created VM after failure, \"\n                     \"rc=%08x\", rc);\n    }\n\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&mchiid);\n    virDomainDefFree(def);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virDomainPtr\nvboxDomainDefineXML(virConnectPtr conn, const char *xml)\n{\n    return vboxDomainDefineXMLFlags(conn, xml, 0);\n}"
  },
  {
    "function_name": "vboxDomainDefineXMLFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "1835-2000",
    "snippet": "static virDomainPtr\nvboxDomainDefineXMLFlags(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    vboxDriverPtr data = conn->privateData;\n    IMachine *machine = NULL;\n    IBIOSSettings *bios = NULL;\n    vboxIID mchiid;\n    virDomainDefPtr def = NULL;\n    nsresult rc;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDomainPtr ret = NULL;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE;\n    bool machineReady = false;\n\n\n    virCheckFlags(VIR_DOMAIN_DEFINE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_DEFINE_VALIDATE)\n        parse_flags |= VIR_DOMAIN_DEF_PARSE_VALIDATE_SCHEMA;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!(def = virDomainDefParseString(xml, data->xmlopt,\n                                        NULL, parse_flags)))\n        return ret;\n\n    VBOX_IID_INITIALIZE(&mchiid);\n    virUUIDFormat(def->uuid, uuidstr);\n\n    rc = gVBoxAPI.UIVirtualBox.CreateMachine(data, def, &machine, uuidstr);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not define a domain, rc=%08x\"), (unsigned)rc);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIMachine.SetMemorySize(machine,\n                                          VIR_DIV_UP(def->mem.cur_balloon, 1024));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not set the memory size of the domain to: %llu Kb, \"\n                         \"rc=%08x\"),\n                       def->mem.cur_balloon, (unsigned)rc);\n    }\n\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"current vcpu count must equal maximum\"));\n    }\n    rc = gVBoxAPI.UIMachine.SetCPUCount(machine, virDomainDefGetVcpusMax(def));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not set the number of virtual CPUs to: %u, rc=%08x\"),\n                       virDomainDefGetVcpusMax(def), (unsigned)rc);\n    }\n\n    rc = gVBoxAPI.UIMachine.SetCPUProperty(machine, CPUPropertyType_PAE,\n                                           def->features[VIR_DOMAIN_FEATURE_PAE] ==\n                                           VIR_TRISTATE_SWITCH_ON);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not change PAE status to: %s, rc=%08x\"),\n                       (def->features[VIR_DOMAIN_FEATURE_PAE] == VIR_TRISTATE_SWITCH_ON)\n                       ? _(\"Enabled\") : _(\"Disabled\"), (unsigned)rc);\n    }\n\n    gVBoxAPI.UIMachine.GetBIOSSettings(machine, &bios);\n    if (bios) {\n        rc = gVBoxAPI.UIBIOSSettings.SetACPIEnabled(bios,\n                                                    def->features[VIR_DOMAIN_FEATURE_ACPI] ==\n                                                    VIR_TRISTATE_SWITCH_ON);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not change ACPI status to: %s, rc=%08x\"),\n                           (def->features[VIR_DOMAIN_FEATURE_ACPI] == VIR_TRISTATE_SWITCH_ON)\n                           ? _(\"Enabled\") : _(\"Disabled\"), (unsigned)rc);\n        }\n        rc = gVBoxAPI.UIBIOSSettings.SetIOAPICEnabled(bios,\n                                                      def->features[VIR_DOMAIN_FEATURE_APIC] ==\n                                                      VIR_TRISTATE_SWITCH_ON);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not change APIC status to: %s, rc=%08x\"),\n                           (def->features[VIR_DOMAIN_FEATURE_APIC] == VIR_TRISTATE_SWITCH_ON)\n                           ? _(\"Enabled\") : _(\"Disabled\"), (unsigned)rc);\n        }\n        VBOX_RELEASE(bios);\n    }\n\n    /* Register the machine before attaching other devices to it */\n    rc = gVBoxAPI.UIVirtualBox.RegisterMachine(data->vboxObj, machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not define a domain, rc=%08x\"), (unsigned)rc);\n        goto cleanup;\n    }\n\n    /* Get the uuid of the machine, currently it is immutable\n     * object so open a session to it and get it back, so that\n     * you can make changes to the machine setting\n     */\n    gVBoxAPI.UIMachine.GetId(machine, &mchiid);\n    gVBoxAPI.UISession.Open(data, &mchiid, machine);\n    gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n\n    vboxSetBootDeviceOrder(def, data, machine);\n    if (vboxAttachStorageControllers(def, data, machine) < 0)\n        goto cleanup;\n    if (vboxAttachDrives(def, data, machine) < 0)\n        goto cleanup;\n    vboxAttachSound(def, machine);\n    if (vboxAttachNetwork(def, data, machine) < 0)\n        goto cleanup;\n    vboxAttachSerial(def, data, machine);\n    vboxAttachParallel(def, data, machine);\n    vboxAttachVideo(def, machine);\n    vboxAttachDisplay(def, data, machine);\n    vboxAttachUSB(def, data, machine);\n    vboxAttachSharedFolder(def, data, machine);\n\n    machineReady = true;\n\n cleanup:\n    /* if machine wasn't even created, cleanup is trivial */\n    if (!machine) {\n        vboxIIDUnalloc(&mchiid);\n        virDomainDefFree(def);\n\n        return ret;\n    }\n\n    /* Save the machine settings made till now, even when jumped here on error,\n     * as otherwise unregister won't cleanup properly. For example, it won't\n     * close media that were partially attached. The VBOX SDK docs say that\n     * unregister implicitly calls saveSettings but evidently it's not so...\n     */\n    rc = gVBoxAPI.UIMachine.SaveSettings(machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to save VM settings, rc=%08x\"), rc);\n        machineReady = false;\n    }\n\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n    if (machineReady) {\n        ret = virGetDomain(conn, def->name, def->uuid, -1);\n    } else {\n        /* Unregister incompletely configured VM to not leave garbage behind */\n        rc = gVBoxAPI.unregisterMachine(data, &mchiid, &machine);\n\n        if (NS_SUCCEEDED(rc))\n            gVBoxAPI.deleteConfig(machine);\n        else\n            VIR_WARN(\"Could not cleanup partially created VM after failure, \"\n                     \"rc=%08x\", rc);\n    }\n\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&mchiid);\n    virDomainDefFree(def);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 1997
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&mchiid"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Could not cleanup partially created VM after failure, \"\n                     \"rc=%08x\"",
            "rc"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.deleteConfig",
          "args": [
            "machine"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_SUCCEEDED",
          "args": [
            "rc"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.unregisterMachine",
          "args": [
            "data",
            "&mchiid",
            "&machine"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "def->name",
            "def->uuid",
            "-1"
          ],
          "line": 1983
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to save VM settings, rc=%08x\")",
            "rc"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to save VM settings, rc=%08x\""
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SaveSettings",
          "args": [
            "machine"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&mchiid"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxAttachSharedFolder",
          "args": [
            "def",
            "data",
            "machine"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "vboxAttachSharedFolder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "1808-1833",
          "snippet": "static void\nvboxAttachSharedFolder(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    size_t i;\n    PRUnichar *nameUtf16;\n    PRUnichar *hostPathUtf16;\n    PRBool writable;\n\n    if (def->nfss == 0)\n        return;\n\n    for (i = 0; i < def->nfss; i++) {\n        if (def->fss[i]->type != VIR_DOMAIN_FS_TYPE_MOUNT)\n            continue;\n\n        VBOX_UTF8_TO_UTF16(def->fss[i]->dst, &nameUtf16);\n        VBOX_UTF8_TO_UTF16(def->fss[i]->src->path, &hostPathUtf16);\n        writable = !def->fss[i]->readonly;\n\n        gVBoxAPI.UIMachine.CreateSharedFolder(machine, nameUtf16, hostPathUtf16,\n                                              writable, PR_FALSE);\n\n        VBOX_UTF16_FREE(nameUtf16);\n        VBOX_UTF16_FREE(hostPathUtf16);\n    }\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxAttachSharedFolder(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    size_t i;\n    PRUnichar *nameUtf16;\n    PRUnichar *hostPathUtf16;\n    PRBool writable;\n\n    if (def->nfss == 0)\n        return;\n\n    for (i = 0; i < def->nfss; i++) {\n        if (def->fss[i]->type != VIR_DOMAIN_FS_TYPE_MOUNT)\n            continue;\n\n        VBOX_UTF8_TO_UTF16(def->fss[i]->dst, &nameUtf16);\n        VBOX_UTF8_TO_UTF16(def->fss[i]->src->path, &hostPathUtf16);\n        writable = !def->fss[i]->readonly;\n\n        gVBoxAPI.UIMachine.CreateSharedFolder(machine, nameUtf16, hostPathUtf16,\n                                              writable, PR_FALSE);\n\n        VBOX_UTF16_FREE(nameUtf16);\n        VBOX_UTF16_FREE(hostPathUtf16);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxAttachUSB",
          "args": [
            "def",
            "data",
            "machine"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "vboxAttachUSB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "1705-1806",
          "snippet": "static void\nvboxAttachUSB(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    IUSBCommon *USBCommon = NULL;\n    size_t i = 0;\n    bool isUSB = false;\n    nsresult rc;\n\n    if (def->nhostdevs == 0)\n        return;\n\n    /* Loop through the devices first and see if you\n     * have a USB Device, only if you have one then\n     * start the USB controller else just proceed as\n     * usual\n     */\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n\n        if (def->hostdevs[i]->source.subsys.type !=\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (!def->hostdevs[i]->source.subsys.u.usb.vendor &&\n            !def->hostdevs[i]->source.subsys.u.usb.product)\n            continue;\n\n        VIR_DEBUG(\"USB Device detected, VendorId:0x%x, ProductId:0x%x\",\n                  def->hostdevs[i]->source.subsys.u.usb.vendor,\n                  def->hostdevs[i]->source.subsys.u.usb.product);\n        isUSB = true;\n        break;\n    }\n\n    if (!isUSB)\n        return;\n\n    /* First Start the USB Controller and then loop\n     * to attach USB Devices to it\n     */\n    rc = gVBoxAPI.UIMachine.GetUSBCommon(machine, &USBCommon);\n    if (NS_FAILED(rc) || !USBCommon)\n        return;\n    gVBoxAPI.UIUSBCommon.Enable(USBCommon);\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        char *filtername = NULL;\n        PRUnichar *filternameUtf16 = NULL;\n        IUSBDeviceFilter *filter = NULL;\n        PRUnichar *vendorIdUtf16 = NULL;\n        char vendorId[40] = {0};\n        PRUnichar *productIdUtf16 = NULL;\n        char productId[40] = {0};\n\n        if (def->hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n\n        if (def->hostdevs[i]->source.subsys.type !=\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        /* Zero pad for nice alignment when fewer than 9999\n         * devices.\n         */\n        filtername = g_strdup_printf(\"filter%04zu\", i);\n        VBOX_UTF8_TO_UTF16(filtername, &filternameUtf16);\n        VIR_FREE(filtername);\n        gVBoxAPI.UIUSBCommon.CreateDeviceFilter(USBCommon,\n                                                filternameUtf16,\n                                                &filter);\n        VBOX_UTF16_FREE(filternameUtf16);\n\n        if (!filter)\n            continue;\n\n        if (!def->hostdevs[i]->source.subsys.u.usb.vendor &&\n            !def->hostdevs[i]->source.subsys.u.usb.product)\n            continue;\n\n        if (def->hostdevs[i]->source.subsys.u.usb.vendor) {\n            g_snprintf(vendorId, sizeof(vendorId), \"%x\",\n                       def->hostdevs[i]->source.subsys.u.usb.vendor);\n            VBOX_UTF8_TO_UTF16(vendorId, &vendorIdUtf16);\n            gVBoxAPI.UIUSBDeviceFilter.SetVendorId(filter, vendorIdUtf16);\n            VBOX_UTF16_FREE(vendorIdUtf16);\n        }\n        if (def->hostdevs[i]->source.subsys.u.usb.product) {\n            g_snprintf(productId, sizeof(productId), \"%x\",\n                       def->hostdevs[i]->source.subsys.u.usb.product);\n            VBOX_UTF8_TO_UTF16(productId, &productIdUtf16);\n            gVBoxAPI.UIUSBDeviceFilter.SetProductId(filter,\n                                                    productIdUtf16);\n            VBOX_UTF16_FREE(productIdUtf16);\n        }\n        gVBoxAPI.UIUSBDeviceFilter.SetActive(filter, 1);\n        gVBoxAPI.UIUSBCommon.InsertDeviceFilter(USBCommon, i, filter);\n        VBOX_RELEASE(filter);\n    }\n\n    VBOX_RELEASE(USBCommon);\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxAttachUSB(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    IUSBCommon *USBCommon = NULL;\n    size_t i = 0;\n    bool isUSB = false;\n    nsresult rc;\n\n    if (def->nhostdevs == 0)\n        return;\n\n    /* Loop through the devices first and see if you\n     * have a USB Device, only if you have one then\n     * start the USB controller else just proceed as\n     * usual\n     */\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n\n        if (def->hostdevs[i]->source.subsys.type !=\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (!def->hostdevs[i]->source.subsys.u.usb.vendor &&\n            !def->hostdevs[i]->source.subsys.u.usb.product)\n            continue;\n\n        VIR_DEBUG(\"USB Device detected, VendorId:0x%x, ProductId:0x%x\",\n                  def->hostdevs[i]->source.subsys.u.usb.vendor,\n                  def->hostdevs[i]->source.subsys.u.usb.product);\n        isUSB = true;\n        break;\n    }\n\n    if (!isUSB)\n        return;\n\n    /* First Start the USB Controller and then loop\n     * to attach USB Devices to it\n     */\n    rc = gVBoxAPI.UIMachine.GetUSBCommon(machine, &USBCommon);\n    if (NS_FAILED(rc) || !USBCommon)\n        return;\n    gVBoxAPI.UIUSBCommon.Enable(USBCommon);\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        char *filtername = NULL;\n        PRUnichar *filternameUtf16 = NULL;\n        IUSBDeviceFilter *filter = NULL;\n        PRUnichar *vendorIdUtf16 = NULL;\n        char vendorId[40] = {0};\n        PRUnichar *productIdUtf16 = NULL;\n        char productId[40] = {0};\n\n        if (def->hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n\n        if (def->hostdevs[i]->source.subsys.type !=\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        /* Zero pad for nice alignment when fewer than 9999\n         * devices.\n         */\n        filtername = g_strdup_printf(\"filter%04zu\", i);\n        VBOX_UTF8_TO_UTF16(filtername, &filternameUtf16);\n        VIR_FREE(filtername);\n        gVBoxAPI.UIUSBCommon.CreateDeviceFilter(USBCommon,\n                                                filternameUtf16,\n                                                &filter);\n        VBOX_UTF16_FREE(filternameUtf16);\n\n        if (!filter)\n            continue;\n\n        if (!def->hostdevs[i]->source.subsys.u.usb.vendor &&\n            !def->hostdevs[i]->source.subsys.u.usb.product)\n            continue;\n\n        if (def->hostdevs[i]->source.subsys.u.usb.vendor) {\n            g_snprintf(vendorId, sizeof(vendorId), \"%x\",\n                       def->hostdevs[i]->source.subsys.u.usb.vendor);\n            VBOX_UTF8_TO_UTF16(vendorId, &vendorIdUtf16);\n            gVBoxAPI.UIUSBDeviceFilter.SetVendorId(filter, vendorIdUtf16);\n            VBOX_UTF16_FREE(vendorIdUtf16);\n        }\n        if (def->hostdevs[i]->source.subsys.u.usb.product) {\n            g_snprintf(productId, sizeof(productId), \"%x\",\n                       def->hostdevs[i]->source.subsys.u.usb.product);\n            VBOX_UTF8_TO_UTF16(productId, &productIdUtf16);\n            gVBoxAPI.UIUSBDeviceFilter.SetProductId(filter,\n                                                    productIdUtf16);\n            VBOX_UTF16_FREE(productIdUtf16);\n        }\n        gVBoxAPI.UIUSBDeviceFilter.SetActive(filter, 1);\n        gVBoxAPI.UIUSBCommon.InsertDeviceFilter(USBCommon, i, filter);\n        VBOX_RELEASE(filter);\n    }\n\n    VBOX_RELEASE(USBCommon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxAttachDisplay",
          "args": [
            "def",
            "data",
            "machine"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "vboxAttachDisplay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "1568-1703",
          "snippet": "static void\nvboxAttachDisplay(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    int vrdpPresent = 0;\n    int sdlPresent = 0;\n    int guiPresent = 0;\n    char *guiDisplay = NULL;\n    char *sdlDisplay = NULL;\n    size_t i = 0;\n    virDomainGraphicsListenDefPtr glisten;\n\n    for (i = 0; i < def->ngraphics; i++) {\n        IVRDEServer *VRDEServer = NULL;\n\n        if ((def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_RDP) &&\n            (vrdpPresent == 0)) {\n\n            vrdpPresent = 1;\n            gVBoxAPI.UIMachine.GetVRDEServer(machine, &VRDEServer);\n            if (VRDEServer) {\n                gVBoxAPI.UIVRDEServer.SetEnabled(VRDEServer, PR_TRUE);\n                VIR_DEBUG(\"VRDP Support turned ON.\");\n\n                gVBoxAPI.UIVRDEServer.SetPorts(data, VRDEServer, def->graphics[i]);\n\n                if (def->graphics[i]->data.rdp.replaceUser) {\n                    gVBoxAPI.UIVRDEServer.SetReuseSingleConnection(VRDEServer,\n                                                                   PR_TRUE);\n                    VIR_DEBUG(\"VRDP set to reuse single connection\");\n                }\n\n                if (def->graphics[i]->data.rdp.multiUser) {\n                    gVBoxAPI.UIVRDEServer.SetAllowMultiConnection(VRDEServer,\n                                                                  PR_TRUE);\n                    VIR_DEBUG(\"VRDP set to allow multiple connection\");\n                }\n\n                if ((glisten = virDomainGraphicsGetListen(def->graphics[i], 0)) &&\n                    glisten->address) {\n                    PRUnichar *netAddressUtf16 = NULL;\n\n                    VBOX_UTF8_TO_UTF16(glisten->address, &netAddressUtf16);\n                    gVBoxAPI.UIVRDEServer.SetNetAddress(data, VRDEServer,\n                                                        netAddressUtf16);\n                    VIR_DEBUG(\"VRDP listen address is set to: %s\",\n                              glisten->address);\n\n                    VBOX_UTF16_FREE(netAddressUtf16);\n                }\n\n                VBOX_RELEASE(VRDEServer);\n            }\n        }\n\n        if ((def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP) &&\n            (guiPresent == 0)) {\n            guiPresent = 1;\n            guiDisplay = g_strdup(def->graphics[i]->data.desktop.display);\n        }\n\n        if ((def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL) &&\n            (sdlPresent == 0)) {\n            sdlPresent = 1;\n            sdlDisplay = g_strdup(def->graphics[i]->data.sdl.display);\n        }\n    }\n\n    if ((vrdpPresent == 1) && (guiPresent == 0) && (sdlPresent == 0)) {\n        /* store extradata key that frontend is set to vrdp */\n        PRUnichar *keyTypeUtf16 = NULL;\n        PRUnichar *valueTypeUtf16 = NULL;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n        VBOX_UTF8_TO_UTF16(\"vrdp\", &valueTypeUtf16);\n\n        gVBoxAPI.UIMachine.SetExtraData(machine, keyTypeUtf16, valueTypeUtf16);\n\n        VBOX_UTF16_FREE(keyTypeUtf16);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n    } else if ((guiPresent == 0) && (sdlPresent == 1)) {\n        /* store extradata key that frontend is set to sdl */\n        PRUnichar *keyTypeUtf16 = NULL;\n        PRUnichar *valueTypeUtf16 = NULL;\n        PRUnichar *keyDislpayUtf16 = NULL;\n        PRUnichar *valueDisplayUtf16 = NULL;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n        VBOX_UTF8_TO_UTF16(\"sdl\", &valueTypeUtf16);\n\n        gVBoxAPI.UIMachine.SetExtraData(machine, keyTypeUtf16, valueTypeUtf16);\n\n        VBOX_UTF16_FREE(keyTypeUtf16);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n        if (sdlDisplay) {\n            VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyDislpayUtf16);\n            VBOX_UTF8_TO_UTF16(sdlDisplay, &valueDisplayUtf16);\n\n            gVBoxAPI.UIMachine.SetExtraData(machine, keyDislpayUtf16,\n                                            valueDisplayUtf16);\n\n            VBOX_UTF16_FREE(keyDislpayUtf16);\n            VBOX_UTF16_FREE(valueDisplayUtf16);\n        }\n\n    } else {\n        /* if all are set then default is gui, with vrdp turned on */\n        PRUnichar *keyTypeUtf16 = NULL;\n        PRUnichar *valueTypeUtf16 = NULL;\n        PRUnichar *keyDislpayUtf16 = NULL;\n        PRUnichar *valueDisplayUtf16 = NULL;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n        VBOX_UTF8_TO_UTF16(\"gui\", &valueTypeUtf16);\n\n        gVBoxAPI.UIMachine.SetExtraData(machine, keyTypeUtf16, valueTypeUtf16);\n\n        VBOX_UTF16_FREE(keyTypeUtf16);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n        if (guiDisplay) {\n            VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyDislpayUtf16);\n            VBOX_UTF8_TO_UTF16(guiDisplay, &valueDisplayUtf16);\n\n            gVBoxAPI.UIMachine.SetExtraData(machine, keyDislpayUtf16,\n                                            valueDisplayUtf16);\n\n            VBOX_UTF16_FREE(keyDislpayUtf16);\n            VBOX_UTF16_FREE(valueDisplayUtf16);\n        }\n    }\n\n    VIR_FREE(guiDisplay);\n    VIR_FREE(sdlDisplay);\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxAttachDisplay(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    int vrdpPresent = 0;\n    int sdlPresent = 0;\n    int guiPresent = 0;\n    char *guiDisplay = NULL;\n    char *sdlDisplay = NULL;\n    size_t i = 0;\n    virDomainGraphicsListenDefPtr glisten;\n\n    for (i = 0; i < def->ngraphics; i++) {\n        IVRDEServer *VRDEServer = NULL;\n\n        if ((def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_RDP) &&\n            (vrdpPresent == 0)) {\n\n            vrdpPresent = 1;\n            gVBoxAPI.UIMachine.GetVRDEServer(machine, &VRDEServer);\n            if (VRDEServer) {\n                gVBoxAPI.UIVRDEServer.SetEnabled(VRDEServer, PR_TRUE);\n                VIR_DEBUG(\"VRDP Support turned ON.\");\n\n                gVBoxAPI.UIVRDEServer.SetPorts(data, VRDEServer, def->graphics[i]);\n\n                if (def->graphics[i]->data.rdp.replaceUser) {\n                    gVBoxAPI.UIVRDEServer.SetReuseSingleConnection(VRDEServer,\n                                                                   PR_TRUE);\n                    VIR_DEBUG(\"VRDP set to reuse single connection\");\n                }\n\n                if (def->graphics[i]->data.rdp.multiUser) {\n                    gVBoxAPI.UIVRDEServer.SetAllowMultiConnection(VRDEServer,\n                                                                  PR_TRUE);\n                    VIR_DEBUG(\"VRDP set to allow multiple connection\");\n                }\n\n                if ((glisten = virDomainGraphicsGetListen(def->graphics[i], 0)) &&\n                    glisten->address) {\n                    PRUnichar *netAddressUtf16 = NULL;\n\n                    VBOX_UTF8_TO_UTF16(glisten->address, &netAddressUtf16);\n                    gVBoxAPI.UIVRDEServer.SetNetAddress(data, VRDEServer,\n                                                        netAddressUtf16);\n                    VIR_DEBUG(\"VRDP listen address is set to: %s\",\n                              glisten->address);\n\n                    VBOX_UTF16_FREE(netAddressUtf16);\n                }\n\n                VBOX_RELEASE(VRDEServer);\n            }\n        }\n\n        if ((def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP) &&\n            (guiPresent == 0)) {\n            guiPresent = 1;\n            guiDisplay = g_strdup(def->graphics[i]->data.desktop.display);\n        }\n\n        if ((def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL) &&\n            (sdlPresent == 0)) {\n            sdlPresent = 1;\n            sdlDisplay = g_strdup(def->graphics[i]->data.sdl.display);\n        }\n    }\n\n    if ((vrdpPresent == 1) && (guiPresent == 0) && (sdlPresent == 0)) {\n        /* store extradata key that frontend is set to vrdp */\n        PRUnichar *keyTypeUtf16 = NULL;\n        PRUnichar *valueTypeUtf16 = NULL;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n        VBOX_UTF8_TO_UTF16(\"vrdp\", &valueTypeUtf16);\n\n        gVBoxAPI.UIMachine.SetExtraData(machine, keyTypeUtf16, valueTypeUtf16);\n\n        VBOX_UTF16_FREE(keyTypeUtf16);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n    } else if ((guiPresent == 0) && (sdlPresent == 1)) {\n        /* store extradata key that frontend is set to sdl */\n        PRUnichar *keyTypeUtf16 = NULL;\n        PRUnichar *valueTypeUtf16 = NULL;\n        PRUnichar *keyDislpayUtf16 = NULL;\n        PRUnichar *valueDisplayUtf16 = NULL;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n        VBOX_UTF8_TO_UTF16(\"sdl\", &valueTypeUtf16);\n\n        gVBoxAPI.UIMachine.SetExtraData(machine, keyTypeUtf16, valueTypeUtf16);\n\n        VBOX_UTF16_FREE(keyTypeUtf16);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n        if (sdlDisplay) {\n            VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyDislpayUtf16);\n            VBOX_UTF8_TO_UTF16(sdlDisplay, &valueDisplayUtf16);\n\n            gVBoxAPI.UIMachine.SetExtraData(machine, keyDislpayUtf16,\n                                            valueDisplayUtf16);\n\n            VBOX_UTF16_FREE(keyDislpayUtf16);\n            VBOX_UTF16_FREE(valueDisplayUtf16);\n        }\n\n    } else {\n        /* if all are set then default is gui, with vrdp turned on */\n        PRUnichar *keyTypeUtf16 = NULL;\n        PRUnichar *valueTypeUtf16 = NULL;\n        PRUnichar *keyDislpayUtf16 = NULL;\n        PRUnichar *valueDisplayUtf16 = NULL;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n        VBOX_UTF8_TO_UTF16(\"gui\", &valueTypeUtf16);\n\n        gVBoxAPI.UIMachine.SetExtraData(machine, keyTypeUtf16, valueTypeUtf16);\n\n        VBOX_UTF16_FREE(keyTypeUtf16);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n        if (guiDisplay) {\n            VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyDislpayUtf16);\n            VBOX_UTF8_TO_UTF16(guiDisplay, &valueDisplayUtf16);\n\n            gVBoxAPI.UIMachine.SetExtraData(machine, keyDislpayUtf16,\n                                            valueDisplayUtf16);\n\n            VBOX_UTF16_FREE(keyDislpayUtf16);\n            VBOX_UTF16_FREE(valueDisplayUtf16);\n        }\n    }\n\n    VIR_FREE(guiDisplay);\n    VIR_FREE(sdlDisplay);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxAttachVideo",
          "args": [
            "def",
            "machine"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "vboxAttachVideo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "1544-1566",
          "snippet": "static void\nvboxAttachVideo(virDomainDefPtr def, IMachine *machine)\n{\n    if ((def->nvideos == 1) &&\n        (def->videos[0]->type == VIR_DOMAIN_VIDEO_TYPE_VBOX)) {\n        gVBoxAPI.UIMachine.SetVRAMSize(machine,\n                                       VIR_DIV_UP(def->videos[0]->vram, 1024));\n        gVBoxAPI.UIMachine.SetMonitorCount(machine, def->videos[0]->heads);\n        if (def->videos[0]->accel) {\n            if (def->videos[0]->accel->accel3d) {\n                gVBoxAPI.UIMachine.SetAccelerate3DEnabled(machine,\n                    def->videos[0]->accel->accel3d == VIR_TRISTATE_BOOL_YES);\n            }\n            if (def->videos[0]->accel->accel2d) {\n                gVBoxAPI.UIMachine.SetAccelerate2DVideoEnabled(machine,\n                    def->videos[0]->accel->accel2d == VIR_TRISTATE_BOOL_YES);\n            }\n        } else {\n            gVBoxAPI.UIMachine.SetAccelerate3DEnabled(machine, 0);\n            gVBoxAPI.UIMachine.SetAccelerate2DVideoEnabled(machine, 0);\n        }\n    }\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxAttachVideo(virDomainDefPtr def, IMachine *machine)\n{\n    if ((def->nvideos == 1) &&\n        (def->videos[0]->type == VIR_DOMAIN_VIDEO_TYPE_VBOX)) {\n        gVBoxAPI.UIMachine.SetVRAMSize(machine,\n                                       VIR_DIV_UP(def->videos[0]->vram, 1024));\n        gVBoxAPI.UIMachine.SetMonitorCount(machine, def->videos[0]->heads);\n        if (def->videos[0]->accel) {\n            if (def->videos[0]->accel->accel3d) {\n                gVBoxAPI.UIMachine.SetAccelerate3DEnabled(machine,\n                    def->videos[0]->accel->accel3d == VIR_TRISTATE_BOOL_YES);\n            }\n            if (def->videos[0]->accel->accel2d) {\n                gVBoxAPI.UIMachine.SetAccelerate2DVideoEnabled(machine,\n                    def->videos[0]->accel->accel2d == VIR_TRISTATE_BOOL_YES);\n            }\n        } else {\n            gVBoxAPI.UIMachine.SetAccelerate3DEnabled(machine, 0);\n            gVBoxAPI.UIMachine.SetAccelerate2DVideoEnabled(machine, 0);\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxAttachParallel",
          "args": [
            "def",
            "data",
            "machine"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "vboxAttachParallel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "1481-1542",
          "snippet": "static void\nvboxAttachParallel(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 parallelPortCount = 0;\n    size_t i = 0;\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetParallelPortCount(systemProperties,\n                                                         &parallelPortCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    VIR_DEBUG(\"Number of Parallel Ports to be connected: %zu\", def->nparallels);\n    VIR_DEBUG(\"Number of Parallel Ports available: %d\", parallelPortCount);\n    for (i = 0; (i < def->nparallels) && (i < parallelPortCount); i++) {\n        IParallelPort *parallelPort = NULL;\n        PRUnichar *pathUtf16 = NULL;\n\n        VIR_DEBUG(\"ParallelPort(%zu): Type: %d\", i, def->parallels[i]->source->type);\n        VIR_DEBUG(\"ParallelPort(%zu): target.port: %d\", i,\n              def->parallels[i]->target.port);\n\n        gVBoxAPI.UIMachine.GetParallelPort(machine, i, &parallelPort);\n        if (!parallelPort)\n            continue;\n\n        VBOX_UTF8_TO_UTF16(def->parallels[i]->source->data.file.path, &pathUtf16);\n\n        /* For now hard code the parallel ports to\n         * LPT1 (Base Addr: 0x378 (decimal: 888), IRQ: 7)\n         * LPT2 (Base Addr: 0x278 (decimal: 632), IRQ: 5)\n         * TODO: make this more flexible\n         */\n        if ((def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV) ||\n            (def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY) ||\n            (def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE) ||\n            (def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE)) {\n            gVBoxAPI.UIParallelPort.SetPath(parallelPort, pathUtf16);\n            if (i == 0) {\n                gVBoxAPI.UIParallelPort.SetIRQ(parallelPort, 7);\n                gVBoxAPI.UIParallelPort.SetIOBase(parallelPort, 888);\n                VIR_DEBUG(\" parallePort-%zu irq: %d, iobase 0x%x, path: %s\",\n                      i, 7, 888, def->parallels[i]->source->data.file.path);\n            } else if (i == 1) {\n                gVBoxAPI.UIParallelPort.SetIRQ(parallelPort, 5);\n                gVBoxAPI.UIParallelPort.SetIOBase(parallelPort, 632);\n                VIR_DEBUG(\" parallePort-%zu irq: %d, iobase 0x%x, path: %s\",\n                      i, 5, 632, def->parallels[i]->source->data.file.path);\n            }\n        }\n\n        /* like serial port, parallel port can't be enabled unless\n         * correct IRQ and IOBase values are specified.\n         */\n        gVBoxAPI.UIParallelPort.SetEnabled(parallelPort, 1);\n\n        VBOX_RELEASE(parallelPort);\n        VBOX_UTF16_FREE(pathUtf16);\n    }\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxAttachParallel(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 parallelPortCount = 0;\n    size_t i = 0;\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetParallelPortCount(systemProperties,\n                                                         &parallelPortCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    VIR_DEBUG(\"Number of Parallel Ports to be connected: %zu\", def->nparallels);\n    VIR_DEBUG(\"Number of Parallel Ports available: %d\", parallelPortCount);\n    for (i = 0; (i < def->nparallels) && (i < parallelPortCount); i++) {\n        IParallelPort *parallelPort = NULL;\n        PRUnichar *pathUtf16 = NULL;\n\n        VIR_DEBUG(\"ParallelPort(%zu): Type: %d\", i, def->parallels[i]->source->type);\n        VIR_DEBUG(\"ParallelPort(%zu): target.port: %d\", i,\n              def->parallels[i]->target.port);\n\n        gVBoxAPI.UIMachine.GetParallelPort(machine, i, &parallelPort);\n        if (!parallelPort)\n            continue;\n\n        VBOX_UTF8_TO_UTF16(def->parallels[i]->source->data.file.path, &pathUtf16);\n\n        /* For now hard code the parallel ports to\n         * LPT1 (Base Addr: 0x378 (decimal: 888), IRQ: 7)\n         * LPT2 (Base Addr: 0x278 (decimal: 632), IRQ: 5)\n         * TODO: make this more flexible\n         */\n        if ((def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV) ||\n            (def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY) ||\n            (def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE) ||\n            (def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE)) {\n            gVBoxAPI.UIParallelPort.SetPath(parallelPort, pathUtf16);\n            if (i == 0) {\n                gVBoxAPI.UIParallelPort.SetIRQ(parallelPort, 7);\n                gVBoxAPI.UIParallelPort.SetIOBase(parallelPort, 888);\n                VIR_DEBUG(\" parallePort-%zu irq: %d, iobase 0x%x, path: %s\",\n                      i, 7, 888, def->parallels[i]->source->data.file.path);\n            } else if (i == 1) {\n                gVBoxAPI.UIParallelPort.SetIRQ(parallelPort, 5);\n                gVBoxAPI.UIParallelPort.SetIOBase(parallelPort, 632);\n                VIR_DEBUG(\" parallePort-%zu irq: %d, iobase 0x%x, path: %s\",\n                      i, 5, 632, def->parallels[i]->source->data.file.path);\n            }\n        }\n\n        /* like serial port, parallel port can't be enabled unless\n         * correct IRQ and IOBase values are specified.\n         */\n        gVBoxAPI.UIParallelPort.SetEnabled(parallelPort, 1);\n\n        VBOX_RELEASE(parallelPort);\n        VBOX_UTF16_FREE(pathUtf16);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxAttachSerial",
          "args": [
            "def",
            "data",
            "machine"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "vboxAttachSerial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "1405-1479",
          "snippet": "static void\nvboxAttachSerial(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 serialPortCount = 0;\n    size_t i = 0;\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetSerialPortCount(systemProperties,\n                                                       &serialPortCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    VIR_DEBUG(\"Number of Serial Ports to be connected: %zu\", def->nserials);\n    VIR_DEBUG(\"Number of Serial Ports available: %d\", serialPortCount);\n\n    for (i = 0; (i < def->nserials) && (i < serialPortCount); i++) {\n        ISerialPort *serialPort = NULL;\n        PRUnichar *pathUtf16 = NULL;\n\n        VIR_DEBUG(\"SerialPort(%zu): Type: %d\", i, def->serials[i]->source->type);\n        VIR_DEBUG(\"SerialPort(%zu): target.port: %d\", i,\n              def->serials[i]->target.port);\n\n        gVBoxAPI.UIMachine.GetSerialPort(machine, i, &serialPort);\n        if (!serialPort)\n            continue;\n\n        gVBoxAPI.UISerialPort.SetEnabled(serialPort, 1);\n\n        if (def->serials[i]->source->data.file.path) {\n            VBOX_UTF8_TO_UTF16(def->serials[i]->source->data.file.path,\n                               &pathUtf16);\n            gVBoxAPI.UISerialPort.SetPath(serialPort, pathUtf16);\n        }\n\n        /* For now hard code the serial ports to COM1 and COM2,\n         * COM1 (Base Addr: 0x3F8 (decimal: 1016), IRQ: 4)\n         * COM2 (Base Addr: 0x2F8 (decimal:  760), IRQ: 3)\n         * TODO: make this more flexible\n         */\n        /* TODO: to improve the libvirt XMl handling so\n         * that def->serials[i]->target.port shows real port\n         * and not always start at 0\n         */\n        if (def->serials[i]->target.port == 0) {\n            gVBoxAPI.UISerialPort.SetIRQ(serialPort, 4);\n            gVBoxAPI.UISerialPort.SetIOBase(serialPort, 1016);\n            VIR_DEBUG(\" serialPort-%zu irq: %d, iobase 0x%x, path: %s\",\n                  i, 4, 1016, def->serials[i]->source->data.file.path);\n        } else if (def->serials[i]->target.port == 1) {\n            gVBoxAPI.UISerialPort.SetIRQ(serialPort, 3);\n            gVBoxAPI.UISerialPort.SetIOBase(serialPort, 760);\n            VIR_DEBUG(\" serialPort-%zu irq: %d, iobase 0x%x, path: %s\",\n                  i, 3, 760, def->serials[i]->source->data.file.path);\n        }\n\n        if (def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV) {\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort, PortMode_HostDevice);\n        } else if (def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) {\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort, PortMode_HostPipe);\n        } else if (gVBoxAPI.APIVersion >= 2002051 &&\n                   def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE) {\n            /* PortMode RawFile is used for vbox 3.0 or later */\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort, PortMode_RawFile);\n        } else {\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort,\n                                              PortMode_Disconnected);\n        }\n\n        VBOX_RELEASE(serialPort);\n        VBOX_UTF16_FREE(pathUtf16);\n    }\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxAttachSerial(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 serialPortCount = 0;\n    size_t i = 0;\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetSerialPortCount(systemProperties,\n                                                       &serialPortCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    VIR_DEBUG(\"Number of Serial Ports to be connected: %zu\", def->nserials);\n    VIR_DEBUG(\"Number of Serial Ports available: %d\", serialPortCount);\n\n    for (i = 0; (i < def->nserials) && (i < serialPortCount); i++) {\n        ISerialPort *serialPort = NULL;\n        PRUnichar *pathUtf16 = NULL;\n\n        VIR_DEBUG(\"SerialPort(%zu): Type: %d\", i, def->serials[i]->source->type);\n        VIR_DEBUG(\"SerialPort(%zu): target.port: %d\", i,\n              def->serials[i]->target.port);\n\n        gVBoxAPI.UIMachine.GetSerialPort(machine, i, &serialPort);\n        if (!serialPort)\n            continue;\n\n        gVBoxAPI.UISerialPort.SetEnabled(serialPort, 1);\n\n        if (def->serials[i]->source->data.file.path) {\n            VBOX_UTF8_TO_UTF16(def->serials[i]->source->data.file.path,\n                               &pathUtf16);\n            gVBoxAPI.UISerialPort.SetPath(serialPort, pathUtf16);\n        }\n\n        /* For now hard code the serial ports to COM1 and COM2,\n         * COM1 (Base Addr: 0x3F8 (decimal: 1016), IRQ: 4)\n         * COM2 (Base Addr: 0x2F8 (decimal:  760), IRQ: 3)\n         * TODO: make this more flexible\n         */\n        /* TODO: to improve the libvirt XMl handling so\n         * that def->serials[i]->target.port shows real port\n         * and not always start at 0\n         */\n        if (def->serials[i]->target.port == 0) {\n            gVBoxAPI.UISerialPort.SetIRQ(serialPort, 4);\n            gVBoxAPI.UISerialPort.SetIOBase(serialPort, 1016);\n            VIR_DEBUG(\" serialPort-%zu irq: %d, iobase 0x%x, path: %s\",\n                  i, 4, 1016, def->serials[i]->source->data.file.path);\n        } else if (def->serials[i]->target.port == 1) {\n            gVBoxAPI.UISerialPort.SetIRQ(serialPort, 3);\n            gVBoxAPI.UISerialPort.SetIOBase(serialPort, 760);\n            VIR_DEBUG(\" serialPort-%zu irq: %d, iobase 0x%x, path: %s\",\n                  i, 3, 760, def->serials[i]->source->data.file.path);\n        }\n\n        if (def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV) {\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort, PortMode_HostDevice);\n        } else if (def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) {\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort, PortMode_HostPipe);\n        } else if (gVBoxAPI.APIVersion >= 2002051 &&\n                   def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE) {\n            /* PortMode RawFile is used for vbox 3.0 or later */\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort, PortMode_RawFile);\n        } else {\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort,\n                                              PortMode_Disconnected);\n        }\n\n        VBOX_RELEASE(serialPort);\n        VBOX_UTF16_FREE(pathUtf16);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxAttachNetwork",
          "args": [
            "def",
            "data",
            "machine"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "vboxAttachNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "1259-1403",
          "snippet": "static int\nvboxAttachNetwork(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 chipsetType = ChipsetType_Null;\n    PRUint32 networkAdapterCount = 0;\n    size_t i = 0;\n\n    if (gVBoxAPI.chipsetType)\n        gVBoxAPI.UIMachine.GetChipsetType(machine, &chipsetType);\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetMaxNetworkAdapters(systemProperties, chipsetType,\n                                                          &networkAdapterCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    VIR_DEBUG(\"Number of Network Cards to be connected: %zu\", def->nnets);\n    VIR_DEBUG(\"Number of Network Cards available: %d\", networkAdapterCount);\n\n    for (i = 0; (i < def->nnets) && (i < networkAdapterCount); i++) {\n        INetworkAdapter *adapter = NULL;\n        PRUint32 adapterType = NetworkAdapterType_Null;\n        char macaddr[VIR_MAC_STRING_BUFLEN] = {0};\n        char macaddrvbox[VIR_MAC_STRING_BUFLEN - 5] = {0};\n        PRUnichar *MACAddress = NULL;\n\n        virMacAddrFormat(&def->nets[i]->mac, macaddr);\n        g_snprintf(macaddrvbox, VIR_MAC_STRING_BUFLEN - 5,\n                   \"%02X%02X%02X%02X%02X%02X\",\n                   def->nets[i]->mac.addr[0],\n                   def->nets[i]->mac.addr[1],\n                   def->nets[i]->mac.addr[2],\n                   def->nets[i]->mac.addr[3],\n                   def->nets[i]->mac.addr[4],\n                   def->nets[i]->mac.addr[5]);\n        macaddrvbox[VIR_MAC_STRING_BUFLEN - 6] = '\\0';\n\n        VIR_DEBUG(\"NIC(%zu): Type:   %d\", i, def->nets[i]->type);\n        VIR_DEBUG(\"NIC(%zu): Model:  %s\", i, virDomainNetModelTypeToString(def->nets[i]->model));\n        VIR_DEBUG(\"NIC(%zu): Mac:    %s\", i, macaddr);\n        VIR_DEBUG(\"NIC(%zu): ifname: %s\", i, def->nets[i]->ifname);\n        if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            VIR_DEBUG(\"NIC(%zu): name:    %s\", i, def->nets[i]->data.network.name);\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_INTERNAL) {\n            VIR_DEBUG(\"NIC(%zu): name:   %s\", i, def->nets[i]->data.internal.name);\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_USER) {\n            VIR_DEBUG(\"NIC(%zu): NAT.\", i);\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n            VIR_DEBUG(\"NIC(%zu): brname: %s\", i, def->nets[i]->data.bridge.brname);\n            VIR_DEBUG(\"NIC(%zu): script: %s\", i, def->nets[i]->script);\n            if (def->nets[i]->guestIP.nips == 1) {\n                char *ipStr = virSocketAddrFormat(&def->nets[i]->guestIP.ips[0]->address);\n                VIR_DEBUG(\"NIC(%zu): ipaddr: %s\", i, ipStr);\n                VIR_FREE(ipStr);\n            } else if (def->nets[i]->guestIP.nips > 1) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Driver does not support setting multiple IP addresses\"));\n                return -1;\n            }\n        }\n\n        gVBoxAPI.UIMachine.GetNetworkAdapter(machine, i, &adapter);\n        if (!adapter)\n            continue;\n\n        gVBoxAPI.UINetworkAdapter.SetEnabled(adapter, 1);\n\n        if (def->nets[i]->model) {\n            if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_AM79C970A) {\n                adapterType = NetworkAdapterType_Am79C970A;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_AM79C973) {\n                adapterType = NetworkAdapterType_Am79C973;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_82540EM) {\n                adapterType = NetworkAdapterType_I82540EM;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_82545EM) {\n                adapterType = NetworkAdapterType_I82545EM;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_82543GC) {\n                adapterType = NetworkAdapterType_I82543GC;\n            } else if (gVBoxAPI.APIVersion >= 3000051 &&\n                       def->nets[i]->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n                /* Only vbox 3.1 and later support NetworkAdapterType_Virto */\n                adapterType = NetworkAdapterType_Virtio;\n            }\n        } else {\n            adapterType = NetworkAdapterType_Am79C973;\n        }\n\n        gVBoxAPI.UINetworkAdapter.SetAdapterType(adapter, adapterType);\n\n        if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n            PRUnichar *hostInterface = NULL;\n            /* Bridged Network */\n\n            gVBoxAPI.UINetworkAdapter.AttachToBridgedInterface(adapter);\n\n            if (def->nets[i]->data.bridge.brname) {\n                VBOX_UTF8_TO_UTF16(def->nets[i]->data.bridge.brname,\n                                   &hostInterface);\n                gVBoxAPI.UINetworkAdapter.SetBridgedInterface(adapter, hostInterface);\n                VBOX_UTF16_FREE(hostInterface);\n            }\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_INTERNAL) {\n            PRUnichar *internalNetwork = NULL;\n            /* Internal Network */\n\n            gVBoxAPI.UINetworkAdapter.AttachToInternalNetwork(adapter);\n\n            if (def->nets[i]->data.internal.name) {\n                VBOX_UTF8_TO_UTF16(def->nets[i]->data.internal.name,\n                                   &internalNetwork);\n                gVBoxAPI.UINetworkAdapter.SetInternalNetwork(adapter, internalNetwork);\n                VBOX_UTF16_FREE(internalNetwork);\n            }\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            PRUnichar *hostInterface = NULL;\n            /* Host Only Networking (currently only vboxnet0 available\n             * on *nix and mac, on windows you can create and configure\n             * as many as you want)\n             */\n            gVBoxAPI.UINetworkAdapter.AttachToHostOnlyInterface(adapter);\n\n            if (def->nets[i]->data.network.name) {\n                VBOX_UTF8_TO_UTF16(def->nets[i]->data.network.name,\n                                   &hostInterface);\n                gVBoxAPI.UINetworkAdapter.SetHostOnlyInterface(adapter, hostInterface);\n                VBOX_UTF16_FREE(hostInterface);\n            }\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_USER) {\n            /* NAT */\n            gVBoxAPI.UINetworkAdapter.AttachToNAT(adapter);\n        } else {\n            /* else always default to NAT if we don't understand\n             * what option is been passed to us\n             */\n            gVBoxAPI.UINetworkAdapter.AttachToNAT(adapter);\n        }\n\n        VBOX_UTF8_TO_UTF16(macaddrvbox, &MACAddress);\n        gVBoxAPI.UINetworkAdapter.SetMACAddress(adapter, MACAddress);\n        VBOX_UTF16_FREE(MACAddress);\n    }\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxAttachNetwork(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 chipsetType = ChipsetType_Null;\n    PRUint32 networkAdapterCount = 0;\n    size_t i = 0;\n\n    if (gVBoxAPI.chipsetType)\n        gVBoxAPI.UIMachine.GetChipsetType(machine, &chipsetType);\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetMaxNetworkAdapters(systemProperties, chipsetType,\n                                                          &networkAdapterCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    VIR_DEBUG(\"Number of Network Cards to be connected: %zu\", def->nnets);\n    VIR_DEBUG(\"Number of Network Cards available: %d\", networkAdapterCount);\n\n    for (i = 0; (i < def->nnets) && (i < networkAdapterCount); i++) {\n        INetworkAdapter *adapter = NULL;\n        PRUint32 adapterType = NetworkAdapterType_Null;\n        char macaddr[VIR_MAC_STRING_BUFLEN] = {0};\n        char macaddrvbox[VIR_MAC_STRING_BUFLEN - 5] = {0};\n        PRUnichar *MACAddress = NULL;\n\n        virMacAddrFormat(&def->nets[i]->mac, macaddr);\n        g_snprintf(macaddrvbox, VIR_MAC_STRING_BUFLEN - 5,\n                   \"%02X%02X%02X%02X%02X%02X\",\n                   def->nets[i]->mac.addr[0],\n                   def->nets[i]->mac.addr[1],\n                   def->nets[i]->mac.addr[2],\n                   def->nets[i]->mac.addr[3],\n                   def->nets[i]->mac.addr[4],\n                   def->nets[i]->mac.addr[5]);\n        macaddrvbox[VIR_MAC_STRING_BUFLEN - 6] = '\\0';\n\n        VIR_DEBUG(\"NIC(%zu): Type:   %d\", i, def->nets[i]->type);\n        VIR_DEBUG(\"NIC(%zu): Model:  %s\", i, virDomainNetModelTypeToString(def->nets[i]->model));\n        VIR_DEBUG(\"NIC(%zu): Mac:    %s\", i, macaddr);\n        VIR_DEBUG(\"NIC(%zu): ifname: %s\", i, def->nets[i]->ifname);\n        if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            VIR_DEBUG(\"NIC(%zu): name:    %s\", i, def->nets[i]->data.network.name);\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_INTERNAL) {\n            VIR_DEBUG(\"NIC(%zu): name:   %s\", i, def->nets[i]->data.internal.name);\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_USER) {\n            VIR_DEBUG(\"NIC(%zu): NAT.\", i);\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n            VIR_DEBUG(\"NIC(%zu): brname: %s\", i, def->nets[i]->data.bridge.brname);\n            VIR_DEBUG(\"NIC(%zu): script: %s\", i, def->nets[i]->script);\n            if (def->nets[i]->guestIP.nips == 1) {\n                char *ipStr = virSocketAddrFormat(&def->nets[i]->guestIP.ips[0]->address);\n                VIR_DEBUG(\"NIC(%zu): ipaddr: %s\", i, ipStr);\n                VIR_FREE(ipStr);\n            } else if (def->nets[i]->guestIP.nips > 1) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Driver does not support setting multiple IP addresses\"));\n                return -1;\n            }\n        }\n\n        gVBoxAPI.UIMachine.GetNetworkAdapter(machine, i, &adapter);\n        if (!adapter)\n            continue;\n\n        gVBoxAPI.UINetworkAdapter.SetEnabled(adapter, 1);\n\n        if (def->nets[i]->model) {\n            if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_AM79C970A) {\n                adapterType = NetworkAdapterType_Am79C970A;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_AM79C973) {\n                adapterType = NetworkAdapterType_Am79C973;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_82540EM) {\n                adapterType = NetworkAdapterType_I82540EM;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_82545EM) {\n                adapterType = NetworkAdapterType_I82545EM;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_82543GC) {\n                adapterType = NetworkAdapterType_I82543GC;\n            } else if (gVBoxAPI.APIVersion >= 3000051 &&\n                       def->nets[i]->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n                /* Only vbox 3.1 and later support NetworkAdapterType_Virto */\n                adapterType = NetworkAdapterType_Virtio;\n            }\n        } else {\n            adapterType = NetworkAdapterType_Am79C973;\n        }\n\n        gVBoxAPI.UINetworkAdapter.SetAdapterType(adapter, adapterType);\n\n        if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n            PRUnichar *hostInterface = NULL;\n            /* Bridged Network */\n\n            gVBoxAPI.UINetworkAdapter.AttachToBridgedInterface(adapter);\n\n            if (def->nets[i]->data.bridge.brname) {\n                VBOX_UTF8_TO_UTF16(def->nets[i]->data.bridge.brname,\n                                   &hostInterface);\n                gVBoxAPI.UINetworkAdapter.SetBridgedInterface(adapter, hostInterface);\n                VBOX_UTF16_FREE(hostInterface);\n            }\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_INTERNAL) {\n            PRUnichar *internalNetwork = NULL;\n            /* Internal Network */\n\n            gVBoxAPI.UINetworkAdapter.AttachToInternalNetwork(adapter);\n\n            if (def->nets[i]->data.internal.name) {\n                VBOX_UTF8_TO_UTF16(def->nets[i]->data.internal.name,\n                                   &internalNetwork);\n                gVBoxAPI.UINetworkAdapter.SetInternalNetwork(adapter, internalNetwork);\n                VBOX_UTF16_FREE(internalNetwork);\n            }\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            PRUnichar *hostInterface = NULL;\n            /* Host Only Networking (currently only vboxnet0 available\n             * on *nix and mac, on windows you can create and configure\n             * as many as you want)\n             */\n            gVBoxAPI.UINetworkAdapter.AttachToHostOnlyInterface(adapter);\n\n            if (def->nets[i]->data.network.name) {\n                VBOX_UTF8_TO_UTF16(def->nets[i]->data.network.name,\n                                   &hostInterface);\n                gVBoxAPI.UINetworkAdapter.SetHostOnlyInterface(adapter, hostInterface);\n                VBOX_UTF16_FREE(hostInterface);\n            }\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_USER) {\n            /* NAT */\n            gVBoxAPI.UINetworkAdapter.AttachToNAT(adapter);\n        } else {\n            /* else always default to NAT if we don't understand\n             * what option is been passed to us\n             */\n            gVBoxAPI.UINetworkAdapter.AttachToNAT(adapter);\n        }\n\n        VBOX_UTF8_TO_UTF16(macaddrvbox, &MACAddress);\n        gVBoxAPI.UINetworkAdapter.SetMACAddress(adapter, MACAddress);\n        VBOX_UTF16_FREE(MACAddress);\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxAttachSound",
          "args": [
            "def",
            "machine"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "vboxAttachSound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "1227-1257",
          "snippet": "static void\nvboxAttachSound(virDomainDefPtr def, IMachine *machine)\n{\n    nsresult rc;\n    IAudioAdapter *audioAdapter = NULL;\n\n    /* Check if def->nsounds is one as VirtualBox currently supports\n     * only one sound card\n     */\n    if (def->nsounds != 1)\n        return;\n\n    gVBoxAPI.UIMachine.GetAudioAdapter(machine, &audioAdapter);\n    if (!audioAdapter)\n        return;\n\n    rc = gVBoxAPI.UIAudioAdapter.SetEnabled(audioAdapter, 1);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    if (def->sounds[0]->model == VIR_DOMAIN_SOUND_MODEL_SB16) {\n        gVBoxAPI.UIAudioAdapter.SetAudioController(audioAdapter,\n                                                   AudioControllerType_SB16);\n    } else if (def->sounds[0]->model == VIR_DOMAIN_SOUND_MODEL_AC97) {\n        gVBoxAPI.UIAudioAdapter.SetAudioController(audioAdapter,\n                                                   AudioControllerType_AC97);\n    }\n\n cleanup:\n    VBOX_RELEASE(audioAdapter);\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxAttachSound(virDomainDefPtr def, IMachine *machine)\n{\n    nsresult rc;\n    IAudioAdapter *audioAdapter = NULL;\n\n    /* Check if def->nsounds is one as VirtualBox currently supports\n     * only one sound card\n     */\n    if (def->nsounds != 1)\n        return;\n\n    gVBoxAPI.UIMachine.GetAudioAdapter(machine, &audioAdapter);\n    if (!audioAdapter)\n        return;\n\n    rc = gVBoxAPI.UIAudioAdapter.SetEnabled(audioAdapter, 1);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    if (def->sounds[0]->model == VIR_DOMAIN_SOUND_MODEL_SB16) {\n        gVBoxAPI.UIAudioAdapter.SetAudioController(audioAdapter,\n                                                   AudioControllerType_SB16);\n    } else if (def->sounds[0]->model == VIR_DOMAIN_SOUND_MODEL_AC97) {\n        gVBoxAPI.UIAudioAdapter.SetAudioController(audioAdapter,\n                                                   AudioControllerType_AC97);\n    }\n\n cleanup:\n    VBOX_RELEASE(audioAdapter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxAttachDrives",
          "args": [
            "def",
            "data",
            "machine"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "vboxAttachDrives",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "1026-1225",
          "snippet": "static int\nvboxAttachDrives(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    size_t i;\n    int type, ret = 0;\n    const char *src = NULL;\n    nsresult rc = 0;\n    virDomainDiskDefPtr disk = NULL;\n    virDomainControllerDefPtr cont;\n    PRUnichar *storageCtlName = NULL;\n    char *controllerName = NULL;\n    IMedium *medium = NULL;\n    PRUnichar *mediumFileUtf16 = NULL;\n    PRUint32 devicePort, deviceSlot, deviceType, accessMode;\n    vboxIID mediumUUID;\n\n    VBOX_IID_INITIALIZE(&mediumUUID);\n\n    for (i = 0; i < def->ndisks; i++) {\n        disk = def->disks[i];\n        src = virDomainDiskGetSource(disk);\n        type = virDomainDiskGetType(disk);\n        deviceType = DeviceType_Null;\n        accessMode = AccessMode_ReadOnly;\n        devicePort = disk->info.addr.drive.unit;\n        deviceSlot = disk->info.addr.drive.bus;\n\n        if (type != VIR_STORAGE_TYPE_FILE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported storage type %s, the only supported \"\n                             \"type is %s\"),\n                           virStorageTypeToString(type),\n                           virStorageTypeToString(VIR_STORAGE_TYPE_FILE));\n            ret = -1;\n            goto cleanup;\n        }\n\n        switch ((virDomainDiskDevice) disk->device) {\n        case VIR_DOMAIN_DISK_DEVICE_DISK:\n            if (!src) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Missing disk source file path\"));\n                ret = -1;\n                goto cleanup;\n            }\n\n            deviceType = DeviceType_HardDisk;\n            accessMode = AccessMode_ReadWrite;\n\n            break;\n\n        case VIR_DOMAIN_DISK_DEVICE_CDROM:\n            deviceType = DeviceType_DVD;\n            accessMode = AccessMode_ReadOnly;\n\n            break;\n        case VIR_DOMAIN_DISK_DEVICE_FLOPPY:\n            deviceType = DeviceType_Floppy;\n            accessMode = AccessMode_ReadWrite;\n\n            break;\n        case VIR_DOMAIN_DISK_DEVICE_LUN:\n        case VIR_DOMAIN_DISK_DEVICE_LAST:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"The vbox driver does not support %s disk device\"),\n                           virDomainDiskDeviceTypeToString(disk->device));\n            ret = -1;\n            goto cleanup;\n        }\n\n        switch ((virDomainDiskBus) disk->bus) {\n        case VIR_DOMAIN_DISK_BUS_IDE:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_IDE_NAME, &storageCtlName);\n            devicePort = def->disks[i]->info.addr.drive.bus;\n            deviceSlot = def->disks[i]->info.addr.drive.unit;\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_SATA:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SATA_NAME, &storageCtlName);\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_SCSI:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SCSI_NAME, &storageCtlName);\n\n            cont = virDomainDeviceFindSCSIController(def, &disk->info.addr.drive);\n            if (cont && cont->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068) {\n                VBOX_UTF16_FREE(storageCtlName);\n                VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SAS_NAME, &storageCtlName);\n            }\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_FDC:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_FLOPPY_NAME, &storageCtlName);\n            devicePort = 0;\n            deviceSlot = disk->info.addr.drive.unit;\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_VIRTIO:\n        case VIR_DOMAIN_DISK_BUS_XEN:\n        case VIR_DOMAIN_DISK_BUS_USB:\n        case VIR_DOMAIN_DISK_BUS_UML:\n        case VIR_DOMAIN_DISK_BUS_SD:\n        case VIR_DOMAIN_DISK_BUS_LAST:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"The vbox driver does not support %s bus type\"),\n                           virDomainDiskBusTypeToString(disk->bus));\n            ret = -1;\n            goto cleanup;\n        }\n\n        /* If disk source is specified, lookup IMedium - removable drives don't\n         * have either.\n         */\n        if (src) {\n            VBOX_UTF8_TO_UTF16(src, &mediumFileUtf16);\n            VIR_DEBUG(\"Looking up medium %s, type: %d, mode: %d\", src,\n                      deviceType, accessMode);\n\n            rc = gVBoxAPI.UIVirtualBox.FindHardDisk(data->vboxObj, mediumFileUtf16,\n                                                    deviceType, accessMode, &medium);\n\n            /* The following is not needed for vbox 4.2+ but older versions have\n             * distinct find and open operations where the former looks in vbox\n             * media registry while the latter at storage location. In 4.2+, the\n             * OpenMedium call takes care of both cases internally\n             */\n            if (!medium) {\n                rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                      mediumFileUtf16,\n                                                      deviceType, accessMode,\n                                                      &medium);\n            }\n\n            if (!medium) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to open the following disk/dvd/floppy \"\n                                 \"to the machine: %s, rc=%08x\"), src, rc);\n                ret = -1;\n                goto cleanup;\n            }\n\n            rc = gVBoxAPI.UIMedium.GetId(medium, &mediumUUID);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Can't get the UUID of the file to be attached \"\n                                 \"as harddisk/dvd/floppy: %s, rc=%08x\"),\n                               src, rc);\n                ret = -1;\n                goto cleanup;\n            }\n        }\n\n        if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n            if (disk->src->readonly) {\n                gVBoxAPI.UIMedium.SetType(medium, MediumType_Immutable);\n                VIR_DEBUG(\"Setting hard disk to immutable\");\n            } else if (!disk->src->readonly) {\n                gVBoxAPI.UIMedium.SetType(medium, MediumType_Normal);\n                VIR_DEBUG(\"Setting hard disk type to normal\");\n            }\n        }\n\n        VBOX_UTF16_TO_UTF8(storageCtlName, &controllerName);\n        VIR_DEBUG(\"Attaching disk(%zu), controller: %s, port: %d, slot: %d, \"\n                  \"type: %d, medium: %s\", i, controllerName, devicePort,\n                    deviceSlot, deviceType, medium == NULL ? \"empty\" : src);\n        VBOX_UTF8_FREE(controllerName);\n\n        /* Attach the harddisk/dvd/Floppy to the storage controller,\n         * medium == NULL is ok here\n         */\n        rc = gVBoxAPI.UIMachine.AttachDevice(machine,\n                                             storageCtlName,\n                                             devicePort,\n                                             deviceSlot,\n                                             deviceType,\n                                             medium);\n\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not attach the file as \"\n                             \"harddisk/dvd/floppy: %s, rc=%08x\"), src, rc);\n            ret = -1;\n            goto cleanup;\n        } else {\n            DEBUGIID(\"Attached HDD/DVD/Floppy with UUID\", &mediumUUID);\n        }\n\n cleanup:\n        VBOX_MEDIUM_RELEASE(medium);\n        vboxIIDUnalloc(&mediumUUID);\n        VBOX_UTF16_FREE(mediumFileUtf16);\n        VBOX_UTF16_FREE(storageCtlName);\n\n        if (ret < 0)\n            break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxAttachDrives(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    size_t i;\n    int type, ret = 0;\n    const char *src = NULL;\n    nsresult rc = 0;\n    virDomainDiskDefPtr disk = NULL;\n    virDomainControllerDefPtr cont;\n    PRUnichar *storageCtlName = NULL;\n    char *controllerName = NULL;\n    IMedium *medium = NULL;\n    PRUnichar *mediumFileUtf16 = NULL;\n    PRUint32 devicePort, deviceSlot, deviceType, accessMode;\n    vboxIID mediumUUID;\n\n    VBOX_IID_INITIALIZE(&mediumUUID);\n\n    for (i = 0; i < def->ndisks; i++) {\n        disk = def->disks[i];\n        src = virDomainDiskGetSource(disk);\n        type = virDomainDiskGetType(disk);\n        deviceType = DeviceType_Null;\n        accessMode = AccessMode_ReadOnly;\n        devicePort = disk->info.addr.drive.unit;\n        deviceSlot = disk->info.addr.drive.bus;\n\n        if (type != VIR_STORAGE_TYPE_FILE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported storage type %s, the only supported \"\n                             \"type is %s\"),\n                           virStorageTypeToString(type),\n                           virStorageTypeToString(VIR_STORAGE_TYPE_FILE));\n            ret = -1;\n            goto cleanup;\n        }\n\n        switch ((virDomainDiskDevice) disk->device) {\n        case VIR_DOMAIN_DISK_DEVICE_DISK:\n            if (!src) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Missing disk source file path\"));\n                ret = -1;\n                goto cleanup;\n            }\n\n            deviceType = DeviceType_HardDisk;\n            accessMode = AccessMode_ReadWrite;\n\n            break;\n\n        case VIR_DOMAIN_DISK_DEVICE_CDROM:\n            deviceType = DeviceType_DVD;\n            accessMode = AccessMode_ReadOnly;\n\n            break;\n        case VIR_DOMAIN_DISK_DEVICE_FLOPPY:\n            deviceType = DeviceType_Floppy;\n            accessMode = AccessMode_ReadWrite;\n\n            break;\n        case VIR_DOMAIN_DISK_DEVICE_LUN:\n        case VIR_DOMAIN_DISK_DEVICE_LAST:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"The vbox driver does not support %s disk device\"),\n                           virDomainDiskDeviceTypeToString(disk->device));\n            ret = -1;\n            goto cleanup;\n        }\n\n        switch ((virDomainDiskBus) disk->bus) {\n        case VIR_DOMAIN_DISK_BUS_IDE:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_IDE_NAME, &storageCtlName);\n            devicePort = def->disks[i]->info.addr.drive.bus;\n            deviceSlot = def->disks[i]->info.addr.drive.unit;\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_SATA:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SATA_NAME, &storageCtlName);\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_SCSI:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SCSI_NAME, &storageCtlName);\n\n            cont = virDomainDeviceFindSCSIController(def, &disk->info.addr.drive);\n            if (cont && cont->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068) {\n                VBOX_UTF16_FREE(storageCtlName);\n                VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SAS_NAME, &storageCtlName);\n            }\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_FDC:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_FLOPPY_NAME, &storageCtlName);\n            devicePort = 0;\n            deviceSlot = disk->info.addr.drive.unit;\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_VIRTIO:\n        case VIR_DOMAIN_DISK_BUS_XEN:\n        case VIR_DOMAIN_DISK_BUS_USB:\n        case VIR_DOMAIN_DISK_BUS_UML:\n        case VIR_DOMAIN_DISK_BUS_SD:\n        case VIR_DOMAIN_DISK_BUS_LAST:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"The vbox driver does not support %s bus type\"),\n                           virDomainDiskBusTypeToString(disk->bus));\n            ret = -1;\n            goto cleanup;\n        }\n\n        /* If disk source is specified, lookup IMedium - removable drives don't\n         * have either.\n         */\n        if (src) {\n            VBOX_UTF8_TO_UTF16(src, &mediumFileUtf16);\n            VIR_DEBUG(\"Looking up medium %s, type: %d, mode: %d\", src,\n                      deviceType, accessMode);\n\n            rc = gVBoxAPI.UIVirtualBox.FindHardDisk(data->vboxObj, mediumFileUtf16,\n                                                    deviceType, accessMode, &medium);\n\n            /* The following is not needed for vbox 4.2+ but older versions have\n             * distinct find and open operations where the former looks in vbox\n             * media registry while the latter at storage location. In 4.2+, the\n             * OpenMedium call takes care of both cases internally\n             */\n            if (!medium) {\n                rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                      mediumFileUtf16,\n                                                      deviceType, accessMode,\n                                                      &medium);\n            }\n\n            if (!medium) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to open the following disk/dvd/floppy \"\n                                 \"to the machine: %s, rc=%08x\"), src, rc);\n                ret = -1;\n                goto cleanup;\n            }\n\n            rc = gVBoxAPI.UIMedium.GetId(medium, &mediumUUID);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Can't get the UUID of the file to be attached \"\n                                 \"as harddisk/dvd/floppy: %s, rc=%08x\"),\n                               src, rc);\n                ret = -1;\n                goto cleanup;\n            }\n        }\n\n        if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n            if (disk->src->readonly) {\n                gVBoxAPI.UIMedium.SetType(medium, MediumType_Immutable);\n                VIR_DEBUG(\"Setting hard disk to immutable\");\n            } else if (!disk->src->readonly) {\n                gVBoxAPI.UIMedium.SetType(medium, MediumType_Normal);\n                VIR_DEBUG(\"Setting hard disk type to normal\");\n            }\n        }\n\n        VBOX_UTF16_TO_UTF8(storageCtlName, &controllerName);\n        VIR_DEBUG(\"Attaching disk(%zu), controller: %s, port: %d, slot: %d, \"\n                  \"type: %d, medium: %s\", i, controllerName, devicePort,\n                    deviceSlot, deviceType, medium == NULL ? \"empty\" : src);\n        VBOX_UTF8_FREE(controllerName);\n\n        /* Attach the harddisk/dvd/Floppy to the storage controller,\n         * medium == NULL is ok here\n         */\n        rc = gVBoxAPI.UIMachine.AttachDevice(machine,\n                                             storageCtlName,\n                                             devicePort,\n                                             deviceSlot,\n                                             deviceType,\n                                             medium);\n\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not attach the file as \"\n                             \"harddisk/dvd/floppy: %s, rc=%08x\"), src, rc);\n            ret = -1;\n            goto cleanup;\n        } else {\n            DEBUGIID(\"Attached HDD/DVD/Floppy with UUID\", &mediumUUID);\n        }\n\n cleanup:\n        VBOX_MEDIUM_RELEASE(medium);\n        vboxIIDUnalloc(&mediumUUID);\n        VBOX_UTF16_FREE(mediumFileUtf16);\n        VBOX_UTF16_FREE(storageCtlName);\n\n        if (ret < 0)\n            break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxAttachStorageControllers",
          "args": [
            "def",
            "data",
            "machine"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "vboxAttachStorageControllers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "484-496",
          "snippet": "static int\nvboxAttachStorageControllers(virDomainDefPtr def,\n                             vboxDriverPtr data,\n                             IMachine *machine)\n{\n    size_t i;\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (vboxSetStorageController(def->controllers[i], data, machine) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvboxAttachStorageControllers(virDomainDefPtr def,\n                             vboxDriverPtr data,\n                             IMachine *machine)\n{\n    size_t i;\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (vboxSetStorageController(def->controllers[i], data, machine) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxSetBootDeviceOrder",
          "args": [
            "def",
            "data",
            "machine"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "vboxSetBootDeviceOrder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "969-1024",
          "snippet": "static void\nvboxSetBootDeviceOrder(virDomainDefPtr def, vboxDriverPtr data,\n                       IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 maxBootPosition = 0;\n    size_t i = 0;\n\n    VIR_DEBUG(\"def->os.type             %s\", virDomainOSTypeToString(def->os.type));\n    VIR_DEBUG(\"def->os.arch             %s\", virArchToString(def->os.arch));\n    VIR_DEBUG(\"def->os.machine          %s\", def->os.machine);\n    VIR_DEBUG(\"def->os.nBootDevs        %zu\", def->os.nBootDevs);\n    VIR_DEBUG(\"def->os.bootDevs[0]      %d\", def->os.bootDevs[0]);\n    VIR_DEBUG(\"def->os.bootDevs[1]      %d\", def->os.bootDevs[1]);\n    VIR_DEBUG(\"def->os.bootDevs[2]      %d\", def->os.bootDevs[2]);\n    VIR_DEBUG(\"def->os.bootDevs[3]      %d\", def->os.bootDevs[3]);\n    VIR_DEBUG(\"def->os.init             %s\", def->os.init);\n    VIR_DEBUG(\"def->os.kernel           %s\", def->os.kernel);\n    VIR_DEBUG(\"def->os.initrd           %s\", def->os.initrd);\n    VIR_DEBUG(\"def->os.cmdline          %s\", def->os.cmdline);\n    VIR_DEBUG(\"def->os.root             %s\", def->os.root);\n    if (def->os.loader) {\n        VIR_DEBUG(\"def->os.loader->path     %s\", def->os.loader->path);\n        VIR_DEBUG(\"def->os.loader->readonly %d\", def->os.loader->readonly);\n        VIR_DEBUG(\"def->os.loader->type     %d\", def->os.loader->type);\n        VIR_DEBUG(\"def->os.loader->nvram    %s\", def->os.loader->nvram);\n    }\n    VIR_DEBUG(\"def->os.bootloader       %s\", def->os.bootloader);\n    VIR_DEBUG(\"def->os.bootloaderArgs   %s\", def->os.bootloaderArgs);\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetMaxBootPosition(systemProperties,\n                                                       &maxBootPosition);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    /* Clear the defaults first */\n    for (i = 0; i < maxBootPosition; i++)\n        gVBoxAPI.UIMachine.SetBootOrder(machine, i+1, DeviceType_Null);\n\n    for (i = 0; (i < def->os.nBootDevs) && (i < maxBootPosition); i++) {\n        PRUint32 device = DeviceType_Null;\n\n        if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_FLOPPY) {\n            device = DeviceType_Floppy;\n        } else if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_CDROM) {\n            device = DeviceType_DVD;\n        } else if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_DISK) {\n            device = DeviceType_HardDisk;\n        } else if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_NET) {\n            device = DeviceType_Network;\n        }\n        gVBoxAPI.UIMachine.SetBootOrder(machine, i+1, device);\n    }\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxSetBootDeviceOrder(virDomainDefPtr def, vboxDriverPtr data,\n                       IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 maxBootPosition = 0;\n    size_t i = 0;\n\n    VIR_DEBUG(\"def->os.type             %s\", virDomainOSTypeToString(def->os.type));\n    VIR_DEBUG(\"def->os.arch             %s\", virArchToString(def->os.arch));\n    VIR_DEBUG(\"def->os.machine          %s\", def->os.machine);\n    VIR_DEBUG(\"def->os.nBootDevs        %zu\", def->os.nBootDevs);\n    VIR_DEBUG(\"def->os.bootDevs[0]      %d\", def->os.bootDevs[0]);\n    VIR_DEBUG(\"def->os.bootDevs[1]      %d\", def->os.bootDevs[1]);\n    VIR_DEBUG(\"def->os.bootDevs[2]      %d\", def->os.bootDevs[2]);\n    VIR_DEBUG(\"def->os.bootDevs[3]      %d\", def->os.bootDevs[3]);\n    VIR_DEBUG(\"def->os.init             %s\", def->os.init);\n    VIR_DEBUG(\"def->os.kernel           %s\", def->os.kernel);\n    VIR_DEBUG(\"def->os.initrd           %s\", def->os.initrd);\n    VIR_DEBUG(\"def->os.cmdline          %s\", def->os.cmdline);\n    VIR_DEBUG(\"def->os.root             %s\", def->os.root);\n    if (def->os.loader) {\n        VIR_DEBUG(\"def->os.loader->path     %s\", def->os.loader->path);\n        VIR_DEBUG(\"def->os.loader->readonly %d\", def->os.loader->readonly);\n        VIR_DEBUG(\"def->os.loader->type     %d\", def->os.loader->type);\n        VIR_DEBUG(\"def->os.loader->nvram    %s\", def->os.loader->nvram);\n    }\n    VIR_DEBUG(\"def->os.bootloader       %s\", def->os.bootloader);\n    VIR_DEBUG(\"def->os.bootloaderArgs   %s\", def->os.bootloaderArgs);\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetMaxBootPosition(systemProperties,\n                                                       &maxBootPosition);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    /* Clear the defaults first */\n    for (i = 0; i < maxBootPosition; i++)\n        gVBoxAPI.UIMachine.SetBootOrder(machine, i+1, DeviceType_Null);\n\n    for (i = 0; (i < def->os.nBootDevs) && (i < maxBootPosition); i++) {\n        PRUint32 device = DeviceType_Null;\n\n        if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_FLOPPY) {\n            device = DeviceType_Floppy;\n        } else if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_CDROM) {\n            device = DeviceType_DVD;\n        } else if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_DISK) {\n            device = DeviceType_HardDisk;\n        } else if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_NET) {\n            device = DeviceType_Network;\n        }\n        gVBoxAPI.UIMachine.SetBootOrder(machine, i+1, device);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetMachine",
          "args": [
            "data->vboxSession",
            "&machine"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Open",
          "args": [
            "data",
            "&mchiid",
            "machine"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetId",
          "args": [
            "machine",
            "&mchiid"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not define a domain, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.RegisterMachine",
          "args": [
            "data->vboxObj",
            "machine"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "bios"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not change APIC status to: %s, rc=%08x\")",
            "(def->features[VIR_DOMAIN_FEATURE_APIC] == VIR_TRISTATE_SWITCH_ON)\n                           ? _(\"Enabled\") : _(\"Disabled\")",
            "(unsigned)rc"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIBIOSSettings.SetIOAPICEnabled",
          "args": [
            "bios",
            "def->features[VIR_DOMAIN_FEATURE_APIC] ==\n                                                      VIR_TRISTATE_SWITCH_ON"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not change ACPI status to: %s, rc=%08x\")",
            "(def->features[VIR_DOMAIN_FEATURE_ACPI] == VIR_TRISTATE_SWITCH_ON)\n                           ? _(\"Enabled\") : _(\"Disabled\")",
            "(unsigned)rc"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIBIOSSettings.SetACPIEnabled",
          "args": [
            "bios",
            "def->features[VIR_DOMAIN_FEATURE_ACPI] ==\n                                                    VIR_TRISTATE_SWITCH_ON"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetBIOSSettings",
          "args": [
            "machine",
            "&bios"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not change PAE status to: %s, rc=%08x\")",
            "(def->features[VIR_DOMAIN_FEATURE_PAE] == VIR_TRISTATE_SWITCH_ON)\n                       ? _(\"Enabled\") : _(\"Disabled\")",
            "(unsigned)rc"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetCPUProperty",
          "args": [
            "machine",
            "CPUPropertyType_PAE",
            "def->features[VIR_DOMAIN_FEATURE_PAE] ==\n                                           VIR_TRISTATE_SWITCH_ON"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not set the number of virtual CPUs to: %u, rc=%08x\")",
            "virDomainDefGetVcpusMax(def)",
            "(unsigned)rc"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetVcpusMax",
          "args": [
            "def"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetVcpusMax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1882-1886",
          "snippet": "unsigned int\nvirDomainDefGetVcpusMax(const virDomainDef *def)\n{\n    return def->maxvcpus;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int\nvirDomainDefGetVcpusMax(const virDomainDef *def)\n{\n    return def->maxvcpus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetCPUCount",
          "args": [
            "machine",
            "virDomainDefGetVcpusMax(def)"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"current vcpu count must equal maximum\")"
          ],
          "line": 1883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefHasVcpusOffline",
          "args": [
            "def"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefHasVcpusOffline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1868-1879",
          "snippet": "bool\nvirDomainDefHasVcpusOffline(const virDomainDef *def)\n{\n    size_t i;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (!def->vcpus[i]->online)\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainDefHasVcpusOffline(const virDomainDef *def)\n{\n    size_t i;\n\n    for (i = 0; i < def->maxvcpus; i++) {\n        if (!def->vcpus[i]->online)\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not set the memory size of the domain to: %llu Kb, \"\n                         \"rc=%08x\")",
            "def->mem.cur_balloon",
            "(unsigned)rc"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetMemorySize",
          "args": [
            "machine",
            "VIR_DIV_UP(def->mem.cur_balloon, 1024)"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "def->mem.cur_balloon",
            "1024"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"could not define a domain, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.CreateMachine",
          "args": [
            "data",
            "def",
            "&machine",
            "uuidstr"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "def->uuid",
            "uuidstr"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&mchiid"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefParseString",
          "args": [
            "xml",
            "data->xmlopt",
            "NULL",
            "parse_flags"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "22134-22141",
          "snippet": "virDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_DEFINE_VALIDATE",
            "NULL"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virDomainPtr\nvboxDomainDefineXMLFlags(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    vboxDriverPtr data = conn->privateData;\n    IMachine *machine = NULL;\n    IBIOSSettings *bios = NULL;\n    vboxIID mchiid;\n    virDomainDefPtr def = NULL;\n    nsresult rc;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDomainPtr ret = NULL;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE;\n    bool machineReady = false;\n\n\n    virCheckFlags(VIR_DOMAIN_DEFINE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_DEFINE_VALIDATE)\n        parse_flags |= VIR_DOMAIN_DEF_PARSE_VALIDATE_SCHEMA;\n\n    if (!data->vboxObj)\n        return ret;\n\n    if (!(def = virDomainDefParseString(xml, data->xmlopt,\n                                        NULL, parse_flags)))\n        return ret;\n\n    VBOX_IID_INITIALIZE(&mchiid);\n    virUUIDFormat(def->uuid, uuidstr);\n\n    rc = gVBoxAPI.UIVirtualBox.CreateMachine(data, def, &machine, uuidstr);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not define a domain, rc=%08x\"), (unsigned)rc);\n        goto cleanup;\n    }\n\n    rc = gVBoxAPI.UIMachine.SetMemorySize(machine,\n                                          VIR_DIV_UP(def->mem.cur_balloon, 1024));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not set the memory size of the domain to: %llu Kb, \"\n                         \"rc=%08x\"),\n                       def->mem.cur_balloon, (unsigned)rc);\n    }\n\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"current vcpu count must equal maximum\"));\n    }\n    rc = gVBoxAPI.UIMachine.SetCPUCount(machine, virDomainDefGetVcpusMax(def));\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not set the number of virtual CPUs to: %u, rc=%08x\"),\n                       virDomainDefGetVcpusMax(def), (unsigned)rc);\n    }\n\n    rc = gVBoxAPI.UIMachine.SetCPUProperty(machine, CPUPropertyType_PAE,\n                                           def->features[VIR_DOMAIN_FEATURE_PAE] ==\n                                           VIR_TRISTATE_SWITCH_ON);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not change PAE status to: %s, rc=%08x\"),\n                       (def->features[VIR_DOMAIN_FEATURE_PAE] == VIR_TRISTATE_SWITCH_ON)\n                       ? _(\"Enabled\") : _(\"Disabled\"), (unsigned)rc);\n    }\n\n    gVBoxAPI.UIMachine.GetBIOSSettings(machine, &bios);\n    if (bios) {\n        rc = gVBoxAPI.UIBIOSSettings.SetACPIEnabled(bios,\n                                                    def->features[VIR_DOMAIN_FEATURE_ACPI] ==\n                                                    VIR_TRISTATE_SWITCH_ON);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not change ACPI status to: %s, rc=%08x\"),\n                           (def->features[VIR_DOMAIN_FEATURE_ACPI] == VIR_TRISTATE_SWITCH_ON)\n                           ? _(\"Enabled\") : _(\"Disabled\"), (unsigned)rc);\n        }\n        rc = gVBoxAPI.UIBIOSSettings.SetIOAPICEnabled(bios,\n                                                      def->features[VIR_DOMAIN_FEATURE_APIC] ==\n                                                      VIR_TRISTATE_SWITCH_ON);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"could not change APIC status to: %s, rc=%08x\"),\n                           (def->features[VIR_DOMAIN_FEATURE_APIC] == VIR_TRISTATE_SWITCH_ON)\n                           ? _(\"Enabled\") : _(\"Disabled\"), (unsigned)rc);\n        }\n        VBOX_RELEASE(bios);\n    }\n\n    /* Register the machine before attaching other devices to it */\n    rc = gVBoxAPI.UIVirtualBox.RegisterMachine(data->vboxObj, machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"could not define a domain, rc=%08x\"), (unsigned)rc);\n        goto cleanup;\n    }\n\n    /* Get the uuid of the machine, currently it is immutable\n     * object so open a session to it and get it back, so that\n     * you can make changes to the machine setting\n     */\n    gVBoxAPI.UIMachine.GetId(machine, &mchiid);\n    gVBoxAPI.UISession.Open(data, &mchiid, machine);\n    gVBoxAPI.UISession.GetMachine(data->vboxSession, &machine);\n\n    vboxSetBootDeviceOrder(def, data, machine);\n    if (vboxAttachStorageControllers(def, data, machine) < 0)\n        goto cleanup;\n    if (vboxAttachDrives(def, data, machine) < 0)\n        goto cleanup;\n    vboxAttachSound(def, machine);\n    if (vboxAttachNetwork(def, data, machine) < 0)\n        goto cleanup;\n    vboxAttachSerial(def, data, machine);\n    vboxAttachParallel(def, data, machine);\n    vboxAttachVideo(def, machine);\n    vboxAttachDisplay(def, data, machine);\n    vboxAttachUSB(def, data, machine);\n    vboxAttachSharedFolder(def, data, machine);\n\n    machineReady = true;\n\n cleanup:\n    /* if machine wasn't even created, cleanup is trivial */\n    if (!machine) {\n        vboxIIDUnalloc(&mchiid);\n        virDomainDefFree(def);\n\n        return ret;\n    }\n\n    /* Save the machine settings made till now, even when jumped here on error,\n     * as otherwise unregister won't cleanup properly. For example, it won't\n     * close media that were partially attached. The VBOX SDK docs say that\n     * unregister implicitly calls saveSettings but evidently it's not so...\n     */\n    rc = gVBoxAPI.UIMachine.SaveSettings(machine);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to save VM settings, rc=%08x\"), rc);\n        machineReady = false;\n    }\n\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n    if (machineReady) {\n        ret = virGetDomain(conn, def->name, def->uuid, -1);\n    } else {\n        /* Unregister incompletely configured VM to not leave garbage behind */\n        rc = gVBoxAPI.unregisterMachine(data, &mchiid, &machine);\n\n        if (NS_SUCCEEDED(rc))\n            gVBoxAPI.deleteConfig(machine);\n        else\n            VIR_WARN(\"Could not cleanup partially created VM after failure, \"\n                     \"rc=%08x\", rc);\n    }\n\n    VBOX_RELEASE(machine);\n    vboxIIDUnalloc(&mchiid);\n    virDomainDefFree(def);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxAttachSharedFolder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "1808-1833",
    "snippet": "static void\nvboxAttachSharedFolder(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    size_t i;\n    PRUnichar *nameUtf16;\n    PRUnichar *hostPathUtf16;\n    PRBool writable;\n\n    if (def->nfss == 0)\n        return;\n\n    for (i = 0; i < def->nfss; i++) {\n        if (def->fss[i]->type != VIR_DOMAIN_FS_TYPE_MOUNT)\n            continue;\n\n        VBOX_UTF8_TO_UTF16(def->fss[i]->dst, &nameUtf16);\n        VBOX_UTF8_TO_UTF16(def->fss[i]->src->path, &hostPathUtf16);\n        writable = !def->fss[i]->readonly;\n\n        gVBoxAPI.UIMachine.CreateSharedFolder(machine, nameUtf16, hostPathUtf16,\n                                              writable, PR_FALSE);\n\n        VBOX_UTF16_FREE(nameUtf16);\n        VBOX_UTF16_FREE(hostPathUtf16);\n    }\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "hostPathUtf16"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "nameUtf16"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.CreateSharedFolder",
          "args": [
            "machine",
            "nameUtf16",
            "hostPathUtf16",
            "writable",
            "PR_FALSE"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "def->fss[i]->src->path",
            "&hostPathUtf16"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "def->fss[i]->dst",
            "&nameUtf16"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxAttachSharedFolder(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    size_t i;\n    PRUnichar *nameUtf16;\n    PRUnichar *hostPathUtf16;\n    PRBool writable;\n\n    if (def->nfss == 0)\n        return;\n\n    for (i = 0; i < def->nfss; i++) {\n        if (def->fss[i]->type != VIR_DOMAIN_FS_TYPE_MOUNT)\n            continue;\n\n        VBOX_UTF8_TO_UTF16(def->fss[i]->dst, &nameUtf16);\n        VBOX_UTF8_TO_UTF16(def->fss[i]->src->path, &hostPathUtf16);\n        writable = !def->fss[i]->readonly;\n\n        gVBoxAPI.UIMachine.CreateSharedFolder(machine, nameUtf16, hostPathUtf16,\n                                              writable, PR_FALSE);\n\n        VBOX_UTF16_FREE(nameUtf16);\n        VBOX_UTF16_FREE(hostPathUtf16);\n    }\n}"
  },
  {
    "function_name": "vboxAttachUSB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "1705-1806",
    "snippet": "static void\nvboxAttachUSB(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    IUSBCommon *USBCommon = NULL;\n    size_t i = 0;\n    bool isUSB = false;\n    nsresult rc;\n\n    if (def->nhostdevs == 0)\n        return;\n\n    /* Loop through the devices first and see if you\n     * have a USB Device, only if you have one then\n     * start the USB controller else just proceed as\n     * usual\n     */\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n\n        if (def->hostdevs[i]->source.subsys.type !=\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (!def->hostdevs[i]->source.subsys.u.usb.vendor &&\n            !def->hostdevs[i]->source.subsys.u.usb.product)\n            continue;\n\n        VIR_DEBUG(\"USB Device detected, VendorId:0x%x, ProductId:0x%x\",\n                  def->hostdevs[i]->source.subsys.u.usb.vendor,\n                  def->hostdevs[i]->source.subsys.u.usb.product);\n        isUSB = true;\n        break;\n    }\n\n    if (!isUSB)\n        return;\n\n    /* First Start the USB Controller and then loop\n     * to attach USB Devices to it\n     */\n    rc = gVBoxAPI.UIMachine.GetUSBCommon(machine, &USBCommon);\n    if (NS_FAILED(rc) || !USBCommon)\n        return;\n    gVBoxAPI.UIUSBCommon.Enable(USBCommon);\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        char *filtername = NULL;\n        PRUnichar *filternameUtf16 = NULL;\n        IUSBDeviceFilter *filter = NULL;\n        PRUnichar *vendorIdUtf16 = NULL;\n        char vendorId[40] = {0};\n        PRUnichar *productIdUtf16 = NULL;\n        char productId[40] = {0};\n\n        if (def->hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n\n        if (def->hostdevs[i]->source.subsys.type !=\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        /* Zero pad for nice alignment when fewer than 9999\n         * devices.\n         */\n        filtername = g_strdup_printf(\"filter%04zu\", i);\n        VBOX_UTF8_TO_UTF16(filtername, &filternameUtf16);\n        VIR_FREE(filtername);\n        gVBoxAPI.UIUSBCommon.CreateDeviceFilter(USBCommon,\n                                                filternameUtf16,\n                                                &filter);\n        VBOX_UTF16_FREE(filternameUtf16);\n\n        if (!filter)\n            continue;\n\n        if (!def->hostdevs[i]->source.subsys.u.usb.vendor &&\n            !def->hostdevs[i]->source.subsys.u.usb.product)\n            continue;\n\n        if (def->hostdevs[i]->source.subsys.u.usb.vendor) {\n            g_snprintf(vendorId, sizeof(vendorId), \"%x\",\n                       def->hostdevs[i]->source.subsys.u.usb.vendor);\n            VBOX_UTF8_TO_UTF16(vendorId, &vendorIdUtf16);\n            gVBoxAPI.UIUSBDeviceFilter.SetVendorId(filter, vendorIdUtf16);\n            VBOX_UTF16_FREE(vendorIdUtf16);\n        }\n        if (def->hostdevs[i]->source.subsys.u.usb.product) {\n            g_snprintf(productId, sizeof(productId), \"%x\",\n                       def->hostdevs[i]->source.subsys.u.usb.product);\n            VBOX_UTF8_TO_UTF16(productId, &productIdUtf16);\n            gVBoxAPI.UIUSBDeviceFilter.SetProductId(filter,\n                                                    productIdUtf16);\n            VBOX_UTF16_FREE(productIdUtf16);\n        }\n        gVBoxAPI.UIUSBDeviceFilter.SetActive(filter, 1);\n        gVBoxAPI.UIUSBCommon.InsertDeviceFilter(USBCommon, i, filter);\n        VBOX_RELEASE(filter);\n    }\n\n    VBOX_RELEASE(USBCommon);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "USBCommon"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "filter"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIUSBCommon.InsertDeviceFilter",
          "args": [
            "USBCommon",
            "i",
            "filter"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIUSBDeviceFilter.SetActive",
          "args": [
            "filter",
            "1"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "productIdUtf16"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIUSBDeviceFilter.SetProductId",
          "args": [
            "filter",
            "productIdUtf16"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "productId",
            "&productIdUtf16"
          ],
          "line": 1795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "productId",
            "sizeof(productId)",
            "\"%x\"",
            "def->hostdevs[i]->source.subsys.u.usb.product"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "vendorIdUtf16"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIUSBDeviceFilter.SetVendorId",
          "args": [
            "filter",
            "vendorIdUtf16"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "vendorId",
            "&vendorIdUtf16"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "vendorId",
            "sizeof(vendorId)",
            "\"%x\"",
            "def->hostdevs[i]->source.subsys.u.usb.vendor"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "filternameUtf16"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIUSBCommon.CreateDeviceFilter",
          "args": [
            "USBCommon",
            "filternameUtf16",
            "&filter"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "filtername"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "filtername",
            "&filternameUtf16"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"filter%04zu\"",
            "i"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIUSBCommon.Enable",
          "args": [
            "USBCommon"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetUSBCommon",
          "args": [
            "machine",
            "&USBCommon"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"USB Device detected, VendorId:0x%x, ProductId:0x%x\"",
            "def->hostdevs[i]->source.subsys.u.usb.vendor",
            "def->hostdevs[i]->source.subsys.u.usb.product"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxAttachUSB(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    IUSBCommon *USBCommon = NULL;\n    size_t i = 0;\n    bool isUSB = false;\n    nsresult rc;\n\n    if (def->nhostdevs == 0)\n        return;\n\n    /* Loop through the devices first and see if you\n     * have a USB Device, only if you have one then\n     * start the USB controller else just proceed as\n     * usual\n     */\n    for (i = 0; i < def->nhostdevs; i++) {\n        if (def->hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n\n        if (def->hostdevs[i]->source.subsys.type !=\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (!def->hostdevs[i]->source.subsys.u.usb.vendor &&\n            !def->hostdevs[i]->source.subsys.u.usb.product)\n            continue;\n\n        VIR_DEBUG(\"USB Device detected, VendorId:0x%x, ProductId:0x%x\",\n                  def->hostdevs[i]->source.subsys.u.usb.vendor,\n                  def->hostdevs[i]->source.subsys.u.usb.product);\n        isUSB = true;\n        break;\n    }\n\n    if (!isUSB)\n        return;\n\n    /* First Start the USB Controller and then loop\n     * to attach USB Devices to it\n     */\n    rc = gVBoxAPI.UIMachine.GetUSBCommon(machine, &USBCommon);\n    if (NS_FAILED(rc) || !USBCommon)\n        return;\n    gVBoxAPI.UIUSBCommon.Enable(USBCommon);\n\n    for (i = 0; i < def->nhostdevs; i++) {\n        char *filtername = NULL;\n        PRUnichar *filternameUtf16 = NULL;\n        IUSBDeviceFilter *filter = NULL;\n        PRUnichar *vendorIdUtf16 = NULL;\n        char vendorId[40] = {0};\n        PRUnichar *productIdUtf16 = NULL;\n        char productId[40] = {0};\n\n        if (def->hostdevs[i]->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n\n        if (def->hostdevs[i]->source.subsys.type !=\n            VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        /* Zero pad for nice alignment when fewer than 9999\n         * devices.\n         */\n        filtername = g_strdup_printf(\"filter%04zu\", i);\n        VBOX_UTF8_TO_UTF16(filtername, &filternameUtf16);\n        VIR_FREE(filtername);\n        gVBoxAPI.UIUSBCommon.CreateDeviceFilter(USBCommon,\n                                                filternameUtf16,\n                                                &filter);\n        VBOX_UTF16_FREE(filternameUtf16);\n\n        if (!filter)\n            continue;\n\n        if (!def->hostdevs[i]->source.subsys.u.usb.vendor &&\n            !def->hostdevs[i]->source.subsys.u.usb.product)\n            continue;\n\n        if (def->hostdevs[i]->source.subsys.u.usb.vendor) {\n            g_snprintf(vendorId, sizeof(vendorId), \"%x\",\n                       def->hostdevs[i]->source.subsys.u.usb.vendor);\n            VBOX_UTF8_TO_UTF16(vendorId, &vendorIdUtf16);\n            gVBoxAPI.UIUSBDeviceFilter.SetVendorId(filter, vendorIdUtf16);\n            VBOX_UTF16_FREE(vendorIdUtf16);\n        }\n        if (def->hostdevs[i]->source.subsys.u.usb.product) {\n            g_snprintf(productId, sizeof(productId), \"%x\",\n                       def->hostdevs[i]->source.subsys.u.usb.product);\n            VBOX_UTF8_TO_UTF16(productId, &productIdUtf16);\n            gVBoxAPI.UIUSBDeviceFilter.SetProductId(filter,\n                                                    productIdUtf16);\n            VBOX_UTF16_FREE(productIdUtf16);\n        }\n        gVBoxAPI.UIUSBDeviceFilter.SetActive(filter, 1);\n        gVBoxAPI.UIUSBCommon.InsertDeviceFilter(USBCommon, i, filter);\n        VBOX_RELEASE(filter);\n    }\n\n    VBOX_RELEASE(USBCommon);\n}"
  },
  {
    "function_name": "vboxAttachDisplay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "1568-1703",
    "snippet": "static void\nvboxAttachDisplay(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    int vrdpPresent = 0;\n    int sdlPresent = 0;\n    int guiPresent = 0;\n    char *guiDisplay = NULL;\n    char *sdlDisplay = NULL;\n    size_t i = 0;\n    virDomainGraphicsListenDefPtr glisten;\n\n    for (i = 0; i < def->ngraphics; i++) {\n        IVRDEServer *VRDEServer = NULL;\n\n        if ((def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_RDP) &&\n            (vrdpPresent == 0)) {\n\n            vrdpPresent = 1;\n            gVBoxAPI.UIMachine.GetVRDEServer(machine, &VRDEServer);\n            if (VRDEServer) {\n                gVBoxAPI.UIVRDEServer.SetEnabled(VRDEServer, PR_TRUE);\n                VIR_DEBUG(\"VRDP Support turned ON.\");\n\n                gVBoxAPI.UIVRDEServer.SetPorts(data, VRDEServer, def->graphics[i]);\n\n                if (def->graphics[i]->data.rdp.replaceUser) {\n                    gVBoxAPI.UIVRDEServer.SetReuseSingleConnection(VRDEServer,\n                                                                   PR_TRUE);\n                    VIR_DEBUG(\"VRDP set to reuse single connection\");\n                }\n\n                if (def->graphics[i]->data.rdp.multiUser) {\n                    gVBoxAPI.UIVRDEServer.SetAllowMultiConnection(VRDEServer,\n                                                                  PR_TRUE);\n                    VIR_DEBUG(\"VRDP set to allow multiple connection\");\n                }\n\n                if ((glisten = virDomainGraphicsGetListen(def->graphics[i], 0)) &&\n                    glisten->address) {\n                    PRUnichar *netAddressUtf16 = NULL;\n\n                    VBOX_UTF8_TO_UTF16(glisten->address, &netAddressUtf16);\n                    gVBoxAPI.UIVRDEServer.SetNetAddress(data, VRDEServer,\n                                                        netAddressUtf16);\n                    VIR_DEBUG(\"VRDP listen address is set to: %s\",\n                              glisten->address);\n\n                    VBOX_UTF16_FREE(netAddressUtf16);\n                }\n\n                VBOX_RELEASE(VRDEServer);\n            }\n        }\n\n        if ((def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP) &&\n            (guiPresent == 0)) {\n            guiPresent = 1;\n            guiDisplay = g_strdup(def->graphics[i]->data.desktop.display);\n        }\n\n        if ((def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL) &&\n            (sdlPresent == 0)) {\n            sdlPresent = 1;\n            sdlDisplay = g_strdup(def->graphics[i]->data.sdl.display);\n        }\n    }\n\n    if ((vrdpPresent == 1) && (guiPresent == 0) && (sdlPresent == 0)) {\n        /* store extradata key that frontend is set to vrdp */\n        PRUnichar *keyTypeUtf16 = NULL;\n        PRUnichar *valueTypeUtf16 = NULL;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n        VBOX_UTF8_TO_UTF16(\"vrdp\", &valueTypeUtf16);\n\n        gVBoxAPI.UIMachine.SetExtraData(machine, keyTypeUtf16, valueTypeUtf16);\n\n        VBOX_UTF16_FREE(keyTypeUtf16);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n    } else if ((guiPresent == 0) && (sdlPresent == 1)) {\n        /* store extradata key that frontend is set to sdl */\n        PRUnichar *keyTypeUtf16 = NULL;\n        PRUnichar *valueTypeUtf16 = NULL;\n        PRUnichar *keyDislpayUtf16 = NULL;\n        PRUnichar *valueDisplayUtf16 = NULL;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n        VBOX_UTF8_TO_UTF16(\"sdl\", &valueTypeUtf16);\n\n        gVBoxAPI.UIMachine.SetExtraData(machine, keyTypeUtf16, valueTypeUtf16);\n\n        VBOX_UTF16_FREE(keyTypeUtf16);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n        if (sdlDisplay) {\n            VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyDislpayUtf16);\n            VBOX_UTF8_TO_UTF16(sdlDisplay, &valueDisplayUtf16);\n\n            gVBoxAPI.UIMachine.SetExtraData(machine, keyDislpayUtf16,\n                                            valueDisplayUtf16);\n\n            VBOX_UTF16_FREE(keyDislpayUtf16);\n            VBOX_UTF16_FREE(valueDisplayUtf16);\n        }\n\n    } else {\n        /* if all are set then default is gui, with vrdp turned on */\n        PRUnichar *keyTypeUtf16 = NULL;\n        PRUnichar *valueTypeUtf16 = NULL;\n        PRUnichar *keyDislpayUtf16 = NULL;\n        PRUnichar *valueDisplayUtf16 = NULL;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n        VBOX_UTF8_TO_UTF16(\"gui\", &valueTypeUtf16);\n\n        gVBoxAPI.UIMachine.SetExtraData(machine, keyTypeUtf16, valueTypeUtf16);\n\n        VBOX_UTF16_FREE(keyTypeUtf16);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n        if (guiDisplay) {\n            VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyDislpayUtf16);\n            VBOX_UTF8_TO_UTF16(guiDisplay, &valueDisplayUtf16);\n\n            gVBoxAPI.UIMachine.SetExtraData(machine, keyDislpayUtf16,\n                                            valueDisplayUtf16);\n\n            VBOX_UTF16_FREE(keyDislpayUtf16);\n            VBOX_UTF16_FREE(valueDisplayUtf16);\n        }\n    }\n\n    VIR_FREE(guiDisplay);\n    VIR_FREE(sdlDisplay);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sdlDisplay"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "guiDisplay"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "valueDisplayUtf16"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "keyDislpayUtf16"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetExtraData",
          "args": [
            "machine",
            "keyDislpayUtf16",
            "valueDisplayUtf16"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "guiDisplay",
            "&valueDisplayUtf16"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"FRONTEND/Display\"",
            "&keyDislpayUtf16"
          ],
          "line": 1690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "valueTypeUtf16"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "keyTypeUtf16"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetExtraData",
          "args": [
            "machine",
            "keyTypeUtf16",
            "valueTypeUtf16"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"gui\"",
            "&valueTypeUtf16"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"FRONTEND/Type\"",
            "&keyTypeUtf16"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "valueDisplayUtf16"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "keyDislpayUtf16"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetExtraData",
          "args": [
            "machine",
            "keyDislpayUtf16",
            "valueDisplayUtf16"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "sdlDisplay",
            "&valueDisplayUtf16"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"FRONTEND/Display\"",
            "&keyDislpayUtf16"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "valueTypeUtf16"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "keyTypeUtf16"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetExtraData",
          "args": [
            "machine",
            "keyTypeUtf16",
            "valueTypeUtf16"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"sdl\"",
            "&valueTypeUtf16"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"FRONTEND/Type\"",
            "&keyTypeUtf16"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "valueTypeUtf16"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "keyTypeUtf16"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetExtraData",
          "args": [
            "machine",
            "keyTypeUtf16",
            "valueTypeUtf16"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"vrdp\"",
            "&valueTypeUtf16"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "\"FRONTEND/Type\"",
            "&keyTypeUtf16"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "def->graphics[i]->data.sdl.display"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "VRDEServer"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "netAddressUtf16"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"VRDP listen address is set to: %s\"",
            "glisten->address"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVRDEServer.SetNetAddress",
          "args": [
            "data",
            "VRDEServer",
            "netAddressUtf16"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "glisten->address",
            "&netAddressUtf16"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsGetListen",
          "args": [
            "def->graphics[i]",
            "0"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainGraphicsGetListen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30357-30364",
          "snippet": "virDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainGraphicsListenDefPtr\nvirDomainGraphicsGetListen(virDomainGraphicsDefPtr def, size_t i)\n{\n    if (!def->listens || (def->nListens <= i))\n        return NULL;\n\n    return &def->listens[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"VRDP set to allow multiple connection\""
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVRDEServer.SetAllowMultiConnection",
          "args": [
            "VRDEServer",
            "PR_TRUE"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"VRDP set to reuse single connection\""
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVRDEServer.SetReuseSingleConnection",
          "args": [
            "VRDEServer",
            "PR_TRUE"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVRDEServer.SetPorts",
          "args": [
            "data",
            "VRDEServer",
            "def->graphics[i]"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"VRDP Support turned ON.\""
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVRDEServer.SetEnabled",
          "args": [
            "VRDEServer",
            "PR_TRUE"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetVRDEServer",
          "args": [
            "machine",
            "&VRDEServer"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxAttachDisplay(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    int vrdpPresent = 0;\n    int sdlPresent = 0;\n    int guiPresent = 0;\n    char *guiDisplay = NULL;\n    char *sdlDisplay = NULL;\n    size_t i = 0;\n    virDomainGraphicsListenDefPtr glisten;\n\n    for (i = 0; i < def->ngraphics; i++) {\n        IVRDEServer *VRDEServer = NULL;\n\n        if ((def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_RDP) &&\n            (vrdpPresent == 0)) {\n\n            vrdpPresent = 1;\n            gVBoxAPI.UIMachine.GetVRDEServer(machine, &VRDEServer);\n            if (VRDEServer) {\n                gVBoxAPI.UIVRDEServer.SetEnabled(VRDEServer, PR_TRUE);\n                VIR_DEBUG(\"VRDP Support turned ON.\");\n\n                gVBoxAPI.UIVRDEServer.SetPorts(data, VRDEServer, def->graphics[i]);\n\n                if (def->graphics[i]->data.rdp.replaceUser) {\n                    gVBoxAPI.UIVRDEServer.SetReuseSingleConnection(VRDEServer,\n                                                                   PR_TRUE);\n                    VIR_DEBUG(\"VRDP set to reuse single connection\");\n                }\n\n                if (def->graphics[i]->data.rdp.multiUser) {\n                    gVBoxAPI.UIVRDEServer.SetAllowMultiConnection(VRDEServer,\n                                                                  PR_TRUE);\n                    VIR_DEBUG(\"VRDP set to allow multiple connection\");\n                }\n\n                if ((glisten = virDomainGraphicsGetListen(def->graphics[i], 0)) &&\n                    glisten->address) {\n                    PRUnichar *netAddressUtf16 = NULL;\n\n                    VBOX_UTF8_TO_UTF16(glisten->address, &netAddressUtf16);\n                    gVBoxAPI.UIVRDEServer.SetNetAddress(data, VRDEServer,\n                                                        netAddressUtf16);\n                    VIR_DEBUG(\"VRDP listen address is set to: %s\",\n                              glisten->address);\n\n                    VBOX_UTF16_FREE(netAddressUtf16);\n                }\n\n                VBOX_RELEASE(VRDEServer);\n            }\n        }\n\n        if ((def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP) &&\n            (guiPresent == 0)) {\n            guiPresent = 1;\n            guiDisplay = g_strdup(def->graphics[i]->data.desktop.display);\n        }\n\n        if ((def->graphics[i]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL) &&\n            (sdlPresent == 0)) {\n            sdlPresent = 1;\n            sdlDisplay = g_strdup(def->graphics[i]->data.sdl.display);\n        }\n    }\n\n    if ((vrdpPresent == 1) && (guiPresent == 0) && (sdlPresent == 0)) {\n        /* store extradata key that frontend is set to vrdp */\n        PRUnichar *keyTypeUtf16 = NULL;\n        PRUnichar *valueTypeUtf16 = NULL;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n        VBOX_UTF8_TO_UTF16(\"vrdp\", &valueTypeUtf16);\n\n        gVBoxAPI.UIMachine.SetExtraData(machine, keyTypeUtf16, valueTypeUtf16);\n\n        VBOX_UTF16_FREE(keyTypeUtf16);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n    } else if ((guiPresent == 0) && (sdlPresent == 1)) {\n        /* store extradata key that frontend is set to sdl */\n        PRUnichar *keyTypeUtf16 = NULL;\n        PRUnichar *valueTypeUtf16 = NULL;\n        PRUnichar *keyDislpayUtf16 = NULL;\n        PRUnichar *valueDisplayUtf16 = NULL;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n        VBOX_UTF8_TO_UTF16(\"sdl\", &valueTypeUtf16);\n\n        gVBoxAPI.UIMachine.SetExtraData(machine, keyTypeUtf16, valueTypeUtf16);\n\n        VBOX_UTF16_FREE(keyTypeUtf16);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n        if (sdlDisplay) {\n            VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyDislpayUtf16);\n            VBOX_UTF8_TO_UTF16(sdlDisplay, &valueDisplayUtf16);\n\n            gVBoxAPI.UIMachine.SetExtraData(machine, keyDislpayUtf16,\n                                            valueDisplayUtf16);\n\n            VBOX_UTF16_FREE(keyDislpayUtf16);\n            VBOX_UTF16_FREE(valueDisplayUtf16);\n        }\n\n    } else {\n        /* if all are set then default is gui, with vrdp turned on */\n        PRUnichar *keyTypeUtf16 = NULL;\n        PRUnichar *valueTypeUtf16 = NULL;\n        PRUnichar *keyDislpayUtf16 = NULL;\n        PRUnichar *valueDisplayUtf16 = NULL;\n\n        VBOX_UTF8_TO_UTF16(\"FRONTEND/Type\", &keyTypeUtf16);\n        VBOX_UTF8_TO_UTF16(\"gui\", &valueTypeUtf16);\n\n        gVBoxAPI.UIMachine.SetExtraData(machine, keyTypeUtf16, valueTypeUtf16);\n\n        VBOX_UTF16_FREE(keyTypeUtf16);\n        VBOX_UTF16_FREE(valueTypeUtf16);\n\n        if (guiDisplay) {\n            VBOX_UTF8_TO_UTF16(\"FRONTEND/Display\", &keyDislpayUtf16);\n            VBOX_UTF8_TO_UTF16(guiDisplay, &valueDisplayUtf16);\n\n            gVBoxAPI.UIMachine.SetExtraData(machine, keyDislpayUtf16,\n                                            valueDisplayUtf16);\n\n            VBOX_UTF16_FREE(keyDislpayUtf16);\n            VBOX_UTF16_FREE(valueDisplayUtf16);\n        }\n    }\n\n    VIR_FREE(guiDisplay);\n    VIR_FREE(sdlDisplay);\n}"
  },
  {
    "function_name": "vboxAttachVideo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "1544-1566",
    "snippet": "static void\nvboxAttachVideo(virDomainDefPtr def, IMachine *machine)\n{\n    if ((def->nvideos == 1) &&\n        (def->videos[0]->type == VIR_DOMAIN_VIDEO_TYPE_VBOX)) {\n        gVBoxAPI.UIMachine.SetVRAMSize(machine,\n                                       VIR_DIV_UP(def->videos[0]->vram, 1024));\n        gVBoxAPI.UIMachine.SetMonitorCount(machine, def->videos[0]->heads);\n        if (def->videos[0]->accel) {\n            if (def->videos[0]->accel->accel3d) {\n                gVBoxAPI.UIMachine.SetAccelerate3DEnabled(machine,\n                    def->videos[0]->accel->accel3d == VIR_TRISTATE_BOOL_YES);\n            }\n            if (def->videos[0]->accel->accel2d) {\n                gVBoxAPI.UIMachine.SetAccelerate2DVideoEnabled(machine,\n                    def->videos[0]->accel->accel2d == VIR_TRISTATE_BOOL_YES);\n            }\n        } else {\n            gVBoxAPI.UIMachine.SetAccelerate3DEnabled(machine, 0);\n            gVBoxAPI.UIMachine.SetAccelerate2DVideoEnabled(machine, 0);\n        }\n    }\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetAccelerate2DVideoEnabled",
          "args": [
            "machine",
            "0"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetAccelerate3DEnabled",
          "args": [
            "machine",
            "0"
          ],
          "line": 1562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetAccelerate2DVideoEnabled",
          "args": [
            "machine",
            "def->videos[0]->accel->accel2d == VIR_TRISTATE_BOOL_YES"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetAccelerate3DEnabled",
          "args": [
            "machine",
            "def->videos[0]->accel->accel3d == VIR_TRISTATE_BOOL_YES"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetMonitorCount",
          "args": [
            "machine",
            "def->videos[0]->heads"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetVRAMSize",
          "args": [
            "machine",
            "VIR_DIV_UP(def->videos[0]->vram, 1024)"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "def->videos[0]->vram",
            "1024"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxAttachVideo(virDomainDefPtr def, IMachine *machine)\n{\n    if ((def->nvideos == 1) &&\n        (def->videos[0]->type == VIR_DOMAIN_VIDEO_TYPE_VBOX)) {\n        gVBoxAPI.UIMachine.SetVRAMSize(machine,\n                                       VIR_DIV_UP(def->videos[0]->vram, 1024));\n        gVBoxAPI.UIMachine.SetMonitorCount(machine, def->videos[0]->heads);\n        if (def->videos[0]->accel) {\n            if (def->videos[0]->accel->accel3d) {\n                gVBoxAPI.UIMachine.SetAccelerate3DEnabled(machine,\n                    def->videos[0]->accel->accel3d == VIR_TRISTATE_BOOL_YES);\n            }\n            if (def->videos[0]->accel->accel2d) {\n                gVBoxAPI.UIMachine.SetAccelerate2DVideoEnabled(machine,\n                    def->videos[0]->accel->accel2d == VIR_TRISTATE_BOOL_YES);\n            }\n        } else {\n            gVBoxAPI.UIMachine.SetAccelerate3DEnabled(machine, 0);\n            gVBoxAPI.UIMachine.SetAccelerate2DVideoEnabled(machine, 0);\n        }\n    }\n}"
  },
  {
    "function_name": "vboxAttachParallel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "1481-1542",
    "snippet": "static void\nvboxAttachParallel(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 parallelPortCount = 0;\n    size_t i = 0;\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetParallelPortCount(systemProperties,\n                                                         &parallelPortCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    VIR_DEBUG(\"Number of Parallel Ports to be connected: %zu\", def->nparallels);\n    VIR_DEBUG(\"Number of Parallel Ports available: %d\", parallelPortCount);\n    for (i = 0; (i < def->nparallels) && (i < parallelPortCount); i++) {\n        IParallelPort *parallelPort = NULL;\n        PRUnichar *pathUtf16 = NULL;\n\n        VIR_DEBUG(\"ParallelPort(%zu): Type: %d\", i, def->parallels[i]->source->type);\n        VIR_DEBUG(\"ParallelPort(%zu): target.port: %d\", i,\n              def->parallels[i]->target.port);\n\n        gVBoxAPI.UIMachine.GetParallelPort(machine, i, &parallelPort);\n        if (!parallelPort)\n            continue;\n\n        VBOX_UTF8_TO_UTF16(def->parallels[i]->source->data.file.path, &pathUtf16);\n\n        /* For now hard code the parallel ports to\n         * LPT1 (Base Addr: 0x378 (decimal: 888), IRQ: 7)\n         * LPT2 (Base Addr: 0x278 (decimal: 632), IRQ: 5)\n         * TODO: make this more flexible\n         */\n        if ((def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV) ||\n            (def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY) ||\n            (def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE) ||\n            (def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE)) {\n            gVBoxAPI.UIParallelPort.SetPath(parallelPort, pathUtf16);\n            if (i == 0) {\n                gVBoxAPI.UIParallelPort.SetIRQ(parallelPort, 7);\n                gVBoxAPI.UIParallelPort.SetIOBase(parallelPort, 888);\n                VIR_DEBUG(\" parallePort-%zu irq: %d, iobase 0x%x, path: %s\",\n                      i, 7, 888, def->parallels[i]->source->data.file.path);\n            } else if (i == 1) {\n                gVBoxAPI.UIParallelPort.SetIRQ(parallelPort, 5);\n                gVBoxAPI.UIParallelPort.SetIOBase(parallelPort, 632);\n                VIR_DEBUG(\" parallePort-%zu irq: %d, iobase 0x%x, path: %s\",\n                      i, 5, 632, def->parallels[i]->source->data.file.path);\n            }\n        }\n\n        /* like serial port, parallel port can't be enabled unless\n         * correct IRQ and IOBase values are specified.\n         */\n        gVBoxAPI.UIParallelPort.SetEnabled(parallelPort, 1);\n\n        VBOX_RELEASE(parallelPort);\n        VBOX_UTF16_FREE(pathUtf16);\n    }\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "pathUtf16"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "parallelPort"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIParallelPort.SetEnabled",
          "args": [
            "parallelPort",
            "1"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\" parallePort-%zu irq: %d, iobase 0x%x, path: %s\"",
            "i",
            "5",
            "632",
            "def->parallels[i]->source->data.file.path"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIParallelPort.SetIOBase",
          "args": [
            "parallelPort",
            "632"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIParallelPort.SetIRQ",
          "args": [
            "parallelPort",
            "5"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\" parallePort-%zu irq: %d, iobase 0x%x, path: %s\"",
            "i",
            "7",
            "888",
            "def->parallels[i]->source->data.file.path"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIParallelPort.SetIOBase",
          "args": [
            "parallelPort",
            "888"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIParallelPort.SetIRQ",
          "args": [
            "parallelPort",
            "7"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIParallelPort.SetPath",
          "args": [
            "parallelPort",
            "pathUtf16"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "def->parallels[i]->source->data.file.path",
            "&pathUtf16"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetParallelPort",
          "args": [
            "machine",
            "i",
            "&parallelPort"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"ParallelPort(%zu): target.port: %d\"",
            "i",
            "def->parallels[i]->target.port"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"ParallelPort(%zu): Type: %d\"",
            "i",
            "def->parallels[i]->source->type"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Number of Parallel Ports available: %d\"",
            "parallelPortCount"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Number of Parallel Ports to be connected: %zu\"",
            "def->nparallels"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "systemProperties"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISystemProperties.GetParallelPortCount",
          "args": [
            "systemProperties",
            "&parallelPortCount"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetSystemProperties",
          "args": [
            "data->vboxObj",
            "&systemProperties"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxAttachParallel(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 parallelPortCount = 0;\n    size_t i = 0;\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetParallelPortCount(systemProperties,\n                                                         &parallelPortCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    VIR_DEBUG(\"Number of Parallel Ports to be connected: %zu\", def->nparallels);\n    VIR_DEBUG(\"Number of Parallel Ports available: %d\", parallelPortCount);\n    for (i = 0; (i < def->nparallels) && (i < parallelPortCount); i++) {\n        IParallelPort *parallelPort = NULL;\n        PRUnichar *pathUtf16 = NULL;\n\n        VIR_DEBUG(\"ParallelPort(%zu): Type: %d\", i, def->parallels[i]->source->type);\n        VIR_DEBUG(\"ParallelPort(%zu): target.port: %d\", i,\n              def->parallels[i]->target.port);\n\n        gVBoxAPI.UIMachine.GetParallelPort(machine, i, &parallelPort);\n        if (!parallelPort)\n            continue;\n\n        VBOX_UTF8_TO_UTF16(def->parallels[i]->source->data.file.path, &pathUtf16);\n\n        /* For now hard code the parallel ports to\n         * LPT1 (Base Addr: 0x378 (decimal: 888), IRQ: 7)\n         * LPT2 (Base Addr: 0x278 (decimal: 632), IRQ: 5)\n         * TODO: make this more flexible\n         */\n        if ((def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV) ||\n            (def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY) ||\n            (def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE) ||\n            (def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE)) {\n            gVBoxAPI.UIParallelPort.SetPath(parallelPort, pathUtf16);\n            if (i == 0) {\n                gVBoxAPI.UIParallelPort.SetIRQ(parallelPort, 7);\n                gVBoxAPI.UIParallelPort.SetIOBase(parallelPort, 888);\n                VIR_DEBUG(\" parallePort-%zu irq: %d, iobase 0x%x, path: %s\",\n                      i, 7, 888, def->parallels[i]->source->data.file.path);\n            } else if (i == 1) {\n                gVBoxAPI.UIParallelPort.SetIRQ(parallelPort, 5);\n                gVBoxAPI.UIParallelPort.SetIOBase(parallelPort, 632);\n                VIR_DEBUG(\" parallePort-%zu irq: %d, iobase 0x%x, path: %s\",\n                      i, 5, 632, def->parallels[i]->source->data.file.path);\n            }\n        }\n\n        /* like serial port, parallel port can't be enabled unless\n         * correct IRQ and IOBase values are specified.\n         */\n        gVBoxAPI.UIParallelPort.SetEnabled(parallelPort, 1);\n\n        VBOX_RELEASE(parallelPort);\n        VBOX_UTF16_FREE(pathUtf16);\n    }\n}"
  },
  {
    "function_name": "vboxAttachSerial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "1405-1479",
    "snippet": "static void\nvboxAttachSerial(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 serialPortCount = 0;\n    size_t i = 0;\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetSerialPortCount(systemProperties,\n                                                       &serialPortCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    VIR_DEBUG(\"Number of Serial Ports to be connected: %zu\", def->nserials);\n    VIR_DEBUG(\"Number of Serial Ports available: %d\", serialPortCount);\n\n    for (i = 0; (i < def->nserials) && (i < serialPortCount); i++) {\n        ISerialPort *serialPort = NULL;\n        PRUnichar *pathUtf16 = NULL;\n\n        VIR_DEBUG(\"SerialPort(%zu): Type: %d\", i, def->serials[i]->source->type);\n        VIR_DEBUG(\"SerialPort(%zu): target.port: %d\", i,\n              def->serials[i]->target.port);\n\n        gVBoxAPI.UIMachine.GetSerialPort(machine, i, &serialPort);\n        if (!serialPort)\n            continue;\n\n        gVBoxAPI.UISerialPort.SetEnabled(serialPort, 1);\n\n        if (def->serials[i]->source->data.file.path) {\n            VBOX_UTF8_TO_UTF16(def->serials[i]->source->data.file.path,\n                               &pathUtf16);\n            gVBoxAPI.UISerialPort.SetPath(serialPort, pathUtf16);\n        }\n\n        /* For now hard code the serial ports to COM1 and COM2,\n         * COM1 (Base Addr: 0x3F8 (decimal: 1016), IRQ: 4)\n         * COM2 (Base Addr: 0x2F8 (decimal:  760), IRQ: 3)\n         * TODO: make this more flexible\n         */\n        /* TODO: to improve the libvirt XMl handling so\n         * that def->serials[i]->target.port shows real port\n         * and not always start at 0\n         */\n        if (def->serials[i]->target.port == 0) {\n            gVBoxAPI.UISerialPort.SetIRQ(serialPort, 4);\n            gVBoxAPI.UISerialPort.SetIOBase(serialPort, 1016);\n            VIR_DEBUG(\" serialPort-%zu irq: %d, iobase 0x%x, path: %s\",\n                  i, 4, 1016, def->serials[i]->source->data.file.path);\n        } else if (def->serials[i]->target.port == 1) {\n            gVBoxAPI.UISerialPort.SetIRQ(serialPort, 3);\n            gVBoxAPI.UISerialPort.SetIOBase(serialPort, 760);\n            VIR_DEBUG(\" serialPort-%zu irq: %d, iobase 0x%x, path: %s\",\n                  i, 3, 760, def->serials[i]->source->data.file.path);\n        }\n\n        if (def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV) {\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort, PortMode_HostDevice);\n        } else if (def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) {\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort, PortMode_HostPipe);\n        } else if (gVBoxAPI.APIVersion >= 2002051 &&\n                   def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE) {\n            /* PortMode RawFile is used for vbox 3.0 or later */\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort, PortMode_RawFile);\n        } else {\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort,\n                                              PortMode_Disconnected);\n        }\n\n        VBOX_RELEASE(serialPort);\n        VBOX_UTF16_FREE(pathUtf16);\n    }\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "pathUtf16"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "serialPort"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.SetHostMode",
          "args": [
            "serialPort",
            "PortMode_Disconnected"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.SetHostMode",
          "args": [
            "serialPort",
            "PortMode_RawFile"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.SetHostMode",
          "args": [
            "serialPort",
            "PortMode_HostPipe"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.SetHostMode",
          "args": [
            "serialPort",
            "PortMode_HostDevice"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\" serialPort-%zu irq: %d, iobase 0x%x, path: %s\"",
            "i",
            "3",
            "760",
            "def->serials[i]->source->data.file.path"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.SetIOBase",
          "args": [
            "serialPort",
            "760"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.SetIRQ",
          "args": [
            "serialPort",
            "3"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\" serialPort-%zu irq: %d, iobase 0x%x, path: %s\"",
            "i",
            "4",
            "1016",
            "def->serials[i]->source->data.file.path"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.SetIOBase",
          "args": [
            "serialPort",
            "1016"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.SetIRQ",
          "args": [
            "serialPort",
            "4"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.SetPath",
          "args": [
            "serialPort",
            "pathUtf16"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "def->serials[i]->source->data.file.path",
            "&pathUtf16"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISerialPort.SetEnabled",
          "args": [
            "serialPort",
            "1"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetSerialPort",
          "args": [
            "machine",
            "i",
            "&serialPort"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"SerialPort(%zu): target.port: %d\"",
            "i",
            "def->serials[i]->target.port"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"SerialPort(%zu): Type: %d\"",
            "i",
            "def->serials[i]->source->type"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Number of Serial Ports available: %d\"",
            "serialPortCount"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Number of Serial Ports to be connected: %zu\"",
            "def->nserials"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "systemProperties"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISystemProperties.GetSerialPortCount",
          "args": [
            "systemProperties",
            "&serialPortCount"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetSystemProperties",
          "args": [
            "data->vboxObj",
            "&systemProperties"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxAttachSerial(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 serialPortCount = 0;\n    size_t i = 0;\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetSerialPortCount(systemProperties,\n                                                       &serialPortCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    VIR_DEBUG(\"Number of Serial Ports to be connected: %zu\", def->nserials);\n    VIR_DEBUG(\"Number of Serial Ports available: %d\", serialPortCount);\n\n    for (i = 0; (i < def->nserials) && (i < serialPortCount); i++) {\n        ISerialPort *serialPort = NULL;\n        PRUnichar *pathUtf16 = NULL;\n\n        VIR_DEBUG(\"SerialPort(%zu): Type: %d\", i, def->serials[i]->source->type);\n        VIR_DEBUG(\"SerialPort(%zu): target.port: %d\", i,\n              def->serials[i]->target.port);\n\n        gVBoxAPI.UIMachine.GetSerialPort(machine, i, &serialPort);\n        if (!serialPort)\n            continue;\n\n        gVBoxAPI.UISerialPort.SetEnabled(serialPort, 1);\n\n        if (def->serials[i]->source->data.file.path) {\n            VBOX_UTF8_TO_UTF16(def->serials[i]->source->data.file.path,\n                               &pathUtf16);\n            gVBoxAPI.UISerialPort.SetPath(serialPort, pathUtf16);\n        }\n\n        /* For now hard code the serial ports to COM1 and COM2,\n         * COM1 (Base Addr: 0x3F8 (decimal: 1016), IRQ: 4)\n         * COM2 (Base Addr: 0x2F8 (decimal:  760), IRQ: 3)\n         * TODO: make this more flexible\n         */\n        /* TODO: to improve the libvirt XMl handling so\n         * that def->serials[i]->target.port shows real port\n         * and not always start at 0\n         */\n        if (def->serials[i]->target.port == 0) {\n            gVBoxAPI.UISerialPort.SetIRQ(serialPort, 4);\n            gVBoxAPI.UISerialPort.SetIOBase(serialPort, 1016);\n            VIR_DEBUG(\" serialPort-%zu irq: %d, iobase 0x%x, path: %s\",\n                  i, 4, 1016, def->serials[i]->source->data.file.path);\n        } else if (def->serials[i]->target.port == 1) {\n            gVBoxAPI.UISerialPort.SetIRQ(serialPort, 3);\n            gVBoxAPI.UISerialPort.SetIOBase(serialPort, 760);\n            VIR_DEBUG(\" serialPort-%zu irq: %d, iobase 0x%x, path: %s\",\n                  i, 3, 760, def->serials[i]->source->data.file.path);\n        }\n\n        if (def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV) {\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort, PortMode_HostDevice);\n        } else if (def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) {\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort, PortMode_HostPipe);\n        } else if (gVBoxAPI.APIVersion >= 2002051 &&\n                   def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE) {\n            /* PortMode RawFile is used for vbox 3.0 or later */\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort, PortMode_RawFile);\n        } else {\n            gVBoxAPI.UISerialPort.SetHostMode(serialPort,\n                                              PortMode_Disconnected);\n        }\n\n        VBOX_RELEASE(serialPort);\n        VBOX_UTF16_FREE(pathUtf16);\n    }\n}"
  },
  {
    "function_name": "vboxAttachNetwork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "1259-1403",
    "snippet": "static int\nvboxAttachNetwork(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 chipsetType = ChipsetType_Null;\n    PRUint32 networkAdapterCount = 0;\n    size_t i = 0;\n\n    if (gVBoxAPI.chipsetType)\n        gVBoxAPI.UIMachine.GetChipsetType(machine, &chipsetType);\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetMaxNetworkAdapters(systemProperties, chipsetType,\n                                                          &networkAdapterCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    VIR_DEBUG(\"Number of Network Cards to be connected: %zu\", def->nnets);\n    VIR_DEBUG(\"Number of Network Cards available: %d\", networkAdapterCount);\n\n    for (i = 0; (i < def->nnets) && (i < networkAdapterCount); i++) {\n        INetworkAdapter *adapter = NULL;\n        PRUint32 adapterType = NetworkAdapterType_Null;\n        char macaddr[VIR_MAC_STRING_BUFLEN] = {0};\n        char macaddrvbox[VIR_MAC_STRING_BUFLEN - 5] = {0};\n        PRUnichar *MACAddress = NULL;\n\n        virMacAddrFormat(&def->nets[i]->mac, macaddr);\n        g_snprintf(macaddrvbox, VIR_MAC_STRING_BUFLEN - 5,\n                   \"%02X%02X%02X%02X%02X%02X\",\n                   def->nets[i]->mac.addr[0],\n                   def->nets[i]->mac.addr[1],\n                   def->nets[i]->mac.addr[2],\n                   def->nets[i]->mac.addr[3],\n                   def->nets[i]->mac.addr[4],\n                   def->nets[i]->mac.addr[5]);\n        macaddrvbox[VIR_MAC_STRING_BUFLEN - 6] = '\\0';\n\n        VIR_DEBUG(\"NIC(%zu): Type:   %d\", i, def->nets[i]->type);\n        VIR_DEBUG(\"NIC(%zu): Model:  %s\", i, virDomainNetModelTypeToString(def->nets[i]->model));\n        VIR_DEBUG(\"NIC(%zu): Mac:    %s\", i, macaddr);\n        VIR_DEBUG(\"NIC(%zu): ifname: %s\", i, def->nets[i]->ifname);\n        if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            VIR_DEBUG(\"NIC(%zu): name:    %s\", i, def->nets[i]->data.network.name);\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_INTERNAL) {\n            VIR_DEBUG(\"NIC(%zu): name:   %s\", i, def->nets[i]->data.internal.name);\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_USER) {\n            VIR_DEBUG(\"NIC(%zu): NAT.\", i);\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n            VIR_DEBUG(\"NIC(%zu): brname: %s\", i, def->nets[i]->data.bridge.brname);\n            VIR_DEBUG(\"NIC(%zu): script: %s\", i, def->nets[i]->script);\n            if (def->nets[i]->guestIP.nips == 1) {\n                char *ipStr = virSocketAddrFormat(&def->nets[i]->guestIP.ips[0]->address);\n                VIR_DEBUG(\"NIC(%zu): ipaddr: %s\", i, ipStr);\n                VIR_FREE(ipStr);\n            } else if (def->nets[i]->guestIP.nips > 1) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Driver does not support setting multiple IP addresses\"));\n                return -1;\n            }\n        }\n\n        gVBoxAPI.UIMachine.GetNetworkAdapter(machine, i, &adapter);\n        if (!adapter)\n            continue;\n\n        gVBoxAPI.UINetworkAdapter.SetEnabled(adapter, 1);\n\n        if (def->nets[i]->model) {\n            if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_AM79C970A) {\n                adapterType = NetworkAdapterType_Am79C970A;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_AM79C973) {\n                adapterType = NetworkAdapterType_Am79C973;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_82540EM) {\n                adapterType = NetworkAdapterType_I82540EM;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_82545EM) {\n                adapterType = NetworkAdapterType_I82545EM;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_82543GC) {\n                adapterType = NetworkAdapterType_I82543GC;\n            } else if (gVBoxAPI.APIVersion >= 3000051 &&\n                       def->nets[i]->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n                /* Only vbox 3.1 and later support NetworkAdapterType_Virto */\n                adapterType = NetworkAdapterType_Virtio;\n            }\n        } else {\n            adapterType = NetworkAdapterType_Am79C973;\n        }\n\n        gVBoxAPI.UINetworkAdapter.SetAdapterType(adapter, adapterType);\n\n        if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n            PRUnichar *hostInterface = NULL;\n            /* Bridged Network */\n\n            gVBoxAPI.UINetworkAdapter.AttachToBridgedInterface(adapter);\n\n            if (def->nets[i]->data.bridge.brname) {\n                VBOX_UTF8_TO_UTF16(def->nets[i]->data.bridge.brname,\n                                   &hostInterface);\n                gVBoxAPI.UINetworkAdapter.SetBridgedInterface(adapter, hostInterface);\n                VBOX_UTF16_FREE(hostInterface);\n            }\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_INTERNAL) {\n            PRUnichar *internalNetwork = NULL;\n            /* Internal Network */\n\n            gVBoxAPI.UINetworkAdapter.AttachToInternalNetwork(adapter);\n\n            if (def->nets[i]->data.internal.name) {\n                VBOX_UTF8_TO_UTF16(def->nets[i]->data.internal.name,\n                                   &internalNetwork);\n                gVBoxAPI.UINetworkAdapter.SetInternalNetwork(adapter, internalNetwork);\n                VBOX_UTF16_FREE(internalNetwork);\n            }\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            PRUnichar *hostInterface = NULL;\n            /* Host Only Networking (currently only vboxnet0 available\n             * on *nix and mac, on windows you can create and configure\n             * as many as you want)\n             */\n            gVBoxAPI.UINetworkAdapter.AttachToHostOnlyInterface(adapter);\n\n            if (def->nets[i]->data.network.name) {\n                VBOX_UTF8_TO_UTF16(def->nets[i]->data.network.name,\n                                   &hostInterface);\n                gVBoxAPI.UINetworkAdapter.SetHostOnlyInterface(adapter, hostInterface);\n                VBOX_UTF16_FREE(hostInterface);\n            }\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_USER) {\n            /* NAT */\n            gVBoxAPI.UINetworkAdapter.AttachToNAT(adapter);\n        } else {\n            /* else always default to NAT if we don't understand\n             * what option is been passed to us\n             */\n            gVBoxAPI.UINetworkAdapter.AttachToNAT(adapter);\n        }\n\n        VBOX_UTF8_TO_UTF16(macaddrvbox, &MACAddress);\n        gVBoxAPI.UINetworkAdapter.SetMACAddress(adapter, MACAddress);\n        VBOX_UTF16_FREE(MACAddress);\n    }\n    return 0;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "MACAddress"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.SetMACAddress",
          "args": [
            "adapter",
            "MACAddress"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "macaddrvbox",
            "&MACAddress"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.AttachToNAT",
          "args": [
            "adapter"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.AttachToNAT",
          "args": [
            "adapter"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "hostInterface"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.SetHostOnlyInterface",
          "args": [
            "adapter",
            "hostInterface"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "def->nets[i]->data.network.name",
            "&hostInterface"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.AttachToHostOnlyInterface",
          "args": [
            "adapter"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "internalNetwork"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.SetInternalNetwork",
          "args": [
            "adapter",
            "internalNetwork"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "def->nets[i]->data.internal.name",
            "&internalNetwork"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.AttachToInternalNetwork",
          "args": [
            "adapter"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "hostInterface"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.SetBridgedInterface",
          "args": [
            "adapter",
            "hostInterface"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "def->nets[i]->data.bridge.brname",
            "&hostInterface"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.AttachToBridgedInterface",
          "args": [
            "adapter"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.SetAdapterType",
          "args": [
            "adapter",
            "adapterType"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UINetworkAdapter.SetEnabled",
          "args": [
            "adapter",
            "1"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetNetworkAdapter",
          "args": [
            "machine",
            "i",
            "&adapter"
          ],
          "line": 1322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Driver does not support setting multiple IP addresses\")"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Driver does not support setting multiple IP addresses\""
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "ipStr"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"NIC(%zu): ipaddr: %s\"",
            "i",
            "ipStr"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "&def->nets[i]->guestIP.ips[0]->address"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"NIC(%zu): script: %s\"",
            "i",
            "def->nets[i]->script"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"NIC(%zu): brname: %s\"",
            "i",
            "def->nets[i]->data.bridge.brname"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"NIC(%zu): NAT.\"",
            "i"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"NIC(%zu): name:   %s\"",
            "i",
            "def->nets[i]->data.internal.name"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"NIC(%zu): name:    %s\"",
            "i",
            "def->nets[i]->data.network.name"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"NIC(%zu): ifname: %s\"",
            "i",
            "def->nets[i]->ifname"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"NIC(%zu): Mac:    %s\"",
            "i",
            "macaddr"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"NIC(%zu): Model:  %s\"",
            "i",
            "virDomainNetModelTypeToString(def->nets[i]->model)"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainNetModelTypeToString",
          "args": [
            "def->nets[i]->model"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"NIC(%zu): Type:   %d\"",
            "i",
            "def->nets[i]->type"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "macaddrvbox",
            "VIR_MAC_STRING_BUFLEN - 5",
            "\"%02X%02X%02X%02X%02X%02X\"",
            "def->nets[i]->mac.addr[0]",
            "def->nets[i]->mac.addr[1]",
            "def->nets[i]->mac.addr[2]",
            "def->nets[i]->mac.addr[3]",
            "def->nets[i]->mac.addr[4]",
            "def->nets[i]->mac.addr[5]"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "&def->nets[i]->mac",
            "macaddr"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Number of Network Cards available: %d\"",
            "networkAdapterCount"
          ],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Number of Network Cards to be connected: %zu\"",
            "def->nnets"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "systemProperties"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISystemProperties.GetMaxNetworkAdapters",
          "args": [
            "systemProperties",
            "chipsetType",
            "&networkAdapterCount"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetSystemProperties",
          "args": [
            "data->vboxObj",
            "&systemProperties"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetChipsetType",
          "args": [
            "machine",
            "&chipsetType"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxAttachNetwork(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 chipsetType = ChipsetType_Null;\n    PRUint32 networkAdapterCount = 0;\n    size_t i = 0;\n\n    if (gVBoxAPI.chipsetType)\n        gVBoxAPI.UIMachine.GetChipsetType(machine, &chipsetType);\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetMaxNetworkAdapters(systemProperties, chipsetType,\n                                                          &networkAdapterCount);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    VIR_DEBUG(\"Number of Network Cards to be connected: %zu\", def->nnets);\n    VIR_DEBUG(\"Number of Network Cards available: %d\", networkAdapterCount);\n\n    for (i = 0; (i < def->nnets) && (i < networkAdapterCount); i++) {\n        INetworkAdapter *adapter = NULL;\n        PRUint32 adapterType = NetworkAdapterType_Null;\n        char macaddr[VIR_MAC_STRING_BUFLEN] = {0};\n        char macaddrvbox[VIR_MAC_STRING_BUFLEN - 5] = {0};\n        PRUnichar *MACAddress = NULL;\n\n        virMacAddrFormat(&def->nets[i]->mac, macaddr);\n        g_snprintf(macaddrvbox, VIR_MAC_STRING_BUFLEN - 5,\n                   \"%02X%02X%02X%02X%02X%02X\",\n                   def->nets[i]->mac.addr[0],\n                   def->nets[i]->mac.addr[1],\n                   def->nets[i]->mac.addr[2],\n                   def->nets[i]->mac.addr[3],\n                   def->nets[i]->mac.addr[4],\n                   def->nets[i]->mac.addr[5]);\n        macaddrvbox[VIR_MAC_STRING_BUFLEN - 6] = '\\0';\n\n        VIR_DEBUG(\"NIC(%zu): Type:   %d\", i, def->nets[i]->type);\n        VIR_DEBUG(\"NIC(%zu): Model:  %s\", i, virDomainNetModelTypeToString(def->nets[i]->model));\n        VIR_DEBUG(\"NIC(%zu): Mac:    %s\", i, macaddr);\n        VIR_DEBUG(\"NIC(%zu): ifname: %s\", i, def->nets[i]->ifname);\n        if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            VIR_DEBUG(\"NIC(%zu): name:    %s\", i, def->nets[i]->data.network.name);\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_INTERNAL) {\n            VIR_DEBUG(\"NIC(%zu): name:   %s\", i, def->nets[i]->data.internal.name);\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_USER) {\n            VIR_DEBUG(\"NIC(%zu): NAT.\", i);\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n            VIR_DEBUG(\"NIC(%zu): brname: %s\", i, def->nets[i]->data.bridge.brname);\n            VIR_DEBUG(\"NIC(%zu): script: %s\", i, def->nets[i]->script);\n            if (def->nets[i]->guestIP.nips == 1) {\n                char *ipStr = virSocketAddrFormat(&def->nets[i]->guestIP.ips[0]->address);\n                VIR_DEBUG(\"NIC(%zu): ipaddr: %s\", i, ipStr);\n                VIR_FREE(ipStr);\n            } else if (def->nets[i]->guestIP.nips > 1) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Driver does not support setting multiple IP addresses\"));\n                return -1;\n            }\n        }\n\n        gVBoxAPI.UIMachine.GetNetworkAdapter(machine, i, &adapter);\n        if (!adapter)\n            continue;\n\n        gVBoxAPI.UINetworkAdapter.SetEnabled(adapter, 1);\n\n        if (def->nets[i]->model) {\n            if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_AM79C970A) {\n                adapterType = NetworkAdapterType_Am79C970A;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_AM79C973) {\n                adapterType = NetworkAdapterType_Am79C973;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_82540EM) {\n                adapterType = NetworkAdapterType_I82540EM;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_82545EM) {\n                adapterType = NetworkAdapterType_I82545EM;\n            } else if (def->nets[i]->model == VIR_DOMAIN_NET_MODEL_82543GC) {\n                adapterType = NetworkAdapterType_I82543GC;\n            } else if (gVBoxAPI.APIVersion >= 3000051 &&\n                       def->nets[i]->model == VIR_DOMAIN_NET_MODEL_VIRTIO) {\n                /* Only vbox 3.1 and later support NetworkAdapterType_Virto */\n                adapterType = NetworkAdapterType_Virtio;\n            }\n        } else {\n            adapterType = NetworkAdapterType_Am79C973;\n        }\n\n        gVBoxAPI.UINetworkAdapter.SetAdapterType(adapter, adapterType);\n\n        if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_BRIDGE) {\n            PRUnichar *hostInterface = NULL;\n            /* Bridged Network */\n\n            gVBoxAPI.UINetworkAdapter.AttachToBridgedInterface(adapter);\n\n            if (def->nets[i]->data.bridge.brname) {\n                VBOX_UTF8_TO_UTF16(def->nets[i]->data.bridge.brname,\n                                   &hostInterface);\n                gVBoxAPI.UINetworkAdapter.SetBridgedInterface(adapter, hostInterface);\n                VBOX_UTF16_FREE(hostInterface);\n            }\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_INTERNAL) {\n            PRUnichar *internalNetwork = NULL;\n            /* Internal Network */\n\n            gVBoxAPI.UINetworkAdapter.AttachToInternalNetwork(adapter);\n\n            if (def->nets[i]->data.internal.name) {\n                VBOX_UTF8_TO_UTF16(def->nets[i]->data.internal.name,\n                                   &internalNetwork);\n                gVBoxAPI.UINetworkAdapter.SetInternalNetwork(adapter, internalNetwork);\n                VBOX_UTF16_FREE(internalNetwork);\n            }\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            PRUnichar *hostInterface = NULL;\n            /* Host Only Networking (currently only vboxnet0 available\n             * on *nix and mac, on windows you can create and configure\n             * as many as you want)\n             */\n            gVBoxAPI.UINetworkAdapter.AttachToHostOnlyInterface(adapter);\n\n            if (def->nets[i]->data.network.name) {\n                VBOX_UTF8_TO_UTF16(def->nets[i]->data.network.name,\n                                   &hostInterface);\n                gVBoxAPI.UINetworkAdapter.SetHostOnlyInterface(adapter, hostInterface);\n                VBOX_UTF16_FREE(hostInterface);\n            }\n        } else if (def->nets[i]->type == VIR_DOMAIN_NET_TYPE_USER) {\n            /* NAT */\n            gVBoxAPI.UINetworkAdapter.AttachToNAT(adapter);\n        } else {\n            /* else always default to NAT if we don't understand\n             * what option is been passed to us\n             */\n            gVBoxAPI.UINetworkAdapter.AttachToNAT(adapter);\n        }\n\n        VBOX_UTF8_TO_UTF16(macaddrvbox, &MACAddress);\n        gVBoxAPI.UINetworkAdapter.SetMACAddress(adapter, MACAddress);\n        VBOX_UTF16_FREE(MACAddress);\n    }\n    return 0;\n}"
  },
  {
    "function_name": "vboxAttachSound",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "1227-1257",
    "snippet": "static void\nvboxAttachSound(virDomainDefPtr def, IMachine *machine)\n{\n    nsresult rc;\n    IAudioAdapter *audioAdapter = NULL;\n\n    /* Check if def->nsounds is one as VirtualBox currently supports\n     * only one sound card\n     */\n    if (def->nsounds != 1)\n        return;\n\n    gVBoxAPI.UIMachine.GetAudioAdapter(machine, &audioAdapter);\n    if (!audioAdapter)\n        return;\n\n    rc = gVBoxAPI.UIAudioAdapter.SetEnabled(audioAdapter, 1);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    if (def->sounds[0]->model == VIR_DOMAIN_SOUND_MODEL_SB16) {\n        gVBoxAPI.UIAudioAdapter.SetAudioController(audioAdapter,\n                                                   AudioControllerType_SB16);\n    } else if (def->sounds[0]->model == VIR_DOMAIN_SOUND_MODEL_AC97) {\n        gVBoxAPI.UIAudioAdapter.SetAudioController(audioAdapter,\n                                                   AudioControllerType_AC97);\n    }\n\n cleanup:\n    VBOX_RELEASE(audioAdapter);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "audioAdapter"
          ],
          "line": 1256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIAudioAdapter.SetAudioController",
          "args": [
            "audioAdapter",
            "AudioControllerType_AC97"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIAudioAdapter.SetAudioController",
          "args": [
            "audioAdapter",
            "AudioControllerType_SB16"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIAudioAdapter.SetEnabled",
          "args": [
            "audioAdapter",
            "1"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAudioAdapter",
          "args": [
            "machine",
            "&audioAdapter"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxAttachSound(virDomainDefPtr def, IMachine *machine)\n{\n    nsresult rc;\n    IAudioAdapter *audioAdapter = NULL;\n\n    /* Check if def->nsounds is one as VirtualBox currently supports\n     * only one sound card\n     */\n    if (def->nsounds != 1)\n        return;\n\n    gVBoxAPI.UIMachine.GetAudioAdapter(machine, &audioAdapter);\n    if (!audioAdapter)\n        return;\n\n    rc = gVBoxAPI.UIAudioAdapter.SetEnabled(audioAdapter, 1);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    if (def->sounds[0]->model == VIR_DOMAIN_SOUND_MODEL_SB16) {\n        gVBoxAPI.UIAudioAdapter.SetAudioController(audioAdapter,\n                                                   AudioControllerType_SB16);\n    } else if (def->sounds[0]->model == VIR_DOMAIN_SOUND_MODEL_AC97) {\n        gVBoxAPI.UIAudioAdapter.SetAudioController(audioAdapter,\n                                                   AudioControllerType_AC97);\n    }\n\n cleanup:\n    VBOX_RELEASE(audioAdapter);\n}"
  },
  {
    "function_name": "vboxAttachDrives",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "1026-1225",
    "snippet": "static int\nvboxAttachDrives(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    size_t i;\n    int type, ret = 0;\n    const char *src = NULL;\n    nsresult rc = 0;\n    virDomainDiskDefPtr disk = NULL;\n    virDomainControllerDefPtr cont;\n    PRUnichar *storageCtlName = NULL;\n    char *controllerName = NULL;\n    IMedium *medium = NULL;\n    PRUnichar *mediumFileUtf16 = NULL;\n    PRUint32 devicePort, deviceSlot, deviceType, accessMode;\n    vboxIID mediumUUID;\n\n    VBOX_IID_INITIALIZE(&mediumUUID);\n\n    for (i = 0; i < def->ndisks; i++) {\n        disk = def->disks[i];\n        src = virDomainDiskGetSource(disk);\n        type = virDomainDiskGetType(disk);\n        deviceType = DeviceType_Null;\n        accessMode = AccessMode_ReadOnly;\n        devicePort = disk->info.addr.drive.unit;\n        deviceSlot = disk->info.addr.drive.bus;\n\n        if (type != VIR_STORAGE_TYPE_FILE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported storage type %s, the only supported \"\n                             \"type is %s\"),\n                           virStorageTypeToString(type),\n                           virStorageTypeToString(VIR_STORAGE_TYPE_FILE));\n            ret = -1;\n            goto cleanup;\n        }\n\n        switch ((virDomainDiskDevice) disk->device) {\n        case VIR_DOMAIN_DISK_DEVICE_DISK:\n            if (!src) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Missing disk source file path\"));\n                ret = -1;\n                goto cleanup;\n            }\n\n            deviceType = DeviceType_HardDisk;\n            accessMode = AccessMode_ReadWrite;\n\n            break;\n\n        case VIR_DOMAIN_DISK_DEVICE_CDROM:\n            deviceType = DeviceType_DVD;\n            accessMode = AccessMode_ReadOnly;\n\n            break;\n        case VIR_DOMAIN_DISK_DEVICE_FLOPPY:\n            deviceType = DeviceType_Floppy;\n            accessMode = AccessMode_ReadWrite;\n\n            break;\n        case VIR_DOMAIN_DISK_DEVICE_LUN:\n        case VIR_DOMAIN_DISK_DEVICE_LAST:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"The vbox driver does not support %s disk device\"),\n                           virDomainDiskDeviceTypeToString(disk->device));\n            ret = -1;\n            goto cleanup;\n        }\n\n        switch ((virDomainDiskBus) disk->bus) {\n        case VIR_DOMAIN_DISK_BUS_IDE:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_IDE_NAME, &storageCtlName);\n            devicePort = def->disks[i]->info.addr.drive.bus;\n            deviceSlot = def->disks[i]->info.addr.drive.unit;\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_SATA:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SATA_NAME, &storageCtlName);\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_SCSI:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SCSI_NAME, &storageCtlName);\n\n            cont = virDomainDeviceFindSCSIController(def, &disk->info.addr.drive);\n            if (cont && cont->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068) {\n                VBOX_UTF16_FREE(storageCtlName);\n                VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SAS_NAME, &storageCtlName);\n            }\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_FDC:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_FLOPPY_NAME, &storageCtlName);\n            devicePort = 0;\n            deviceSlot = disk->info.addr.drive.unit;\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_VIRTIO:\n        case VIR_DOMAIN_DISK_BUS_XEN:\n        case VIR_DOMAIN_DISK_BUS_USB:\n        case VIR_DOMAIN_DISK_BUS_UML:\n        case VIR_DOMAIN_DISK_BUS_SD:\n        case VIR_DOMAIN_DISK_BUS_LAST:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"The vbox driver does not support %s bus type\"),\n                           virDomainDiskBusTypeToString(disk->bus));\n            ret = -1;\n            goto cleanup;\n        }\n\n        /* If disk source is specified, lookup IMedium - removable drives don't\n         * have either.\n         */\n        if (src) {\n            VBOX_UTF8_TO_UTF16(src, &mediumFileUtf16);\n            VIR_DEBUG(\"Looking up medium %s, type: %d, mode: %d\", src,\n                      deviceType, accessMode);\n\n            rc = gVBoxAPI.UIVirtualBox.FindHardDisk(data->vboxObj, mediumFileUtf16,\n                                                    deviceType, accessMode, &medium);\n\n            /* The following is not needed for vbox 4.2+ but older versions have\n             * distinct find and open operations where the former looks in vbox\n             * media registry while the latter at storage location. In 4.2+, the\n             * OpenMedium call takes care of both cases internally\n             */\n            if (!medium) {\n                rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                      mediumFileUtf16,\n                                                      deviceType, accessMode,\n                                                      &medium);\n            }\n\n            if (!medium) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to open the following disk/dvd/floppy \"\n                                 \"to the machine: %s, rc=%08x\"), src, rc);\n                ret = -1;\n                goto cleanup;\n            }\n\n            rc = gVBoxAPI.UIMedium.GetId(medium, &mediumUUID);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Can't get the UUID of the file to be attached \"\n                                 \"as harddisk/dvd/floppy: %s, rc=%08x\"),\n                               src, rc);\n                ret = -1;\n                goto cleanup;\n            }\n        }\n\n        if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n            if (disk->src->readonly) {\n                gVBoxAPI.UIMedium.SetType(medium, MediumType_Immutable);\n                VIR_DEBUG(\"Setting hard disk to immutable\");\n            } else if (!disk->src->readonly) {\n                gVBoxAPI.UIMedium.SetType(medium, MediumType_Normal);\n                VIR_DEBUG(\"Setting hard disk type to normal\");\n            }\n        }\n\n        VBOX_UTF16_TO_UTF8(storageCtlName, &controllerName);\n        VIR_DEBUG(\"Attaching disk(%zu), controller: %s, port: %d, slot: %d, \"\n                  \"type: %d, medium: %s\", i, controllerName, devicePort,\n                    deviceSlot, deviceType, medium == NULL ? \"empty\" : src);\n        VBOX_UTF8_FREE(controllerName);\n\n        /* Attach the harddisk/dvd/Floppy to the storage controller,\n         * medium == NULL is ok here\n         */\n        rc = gVBoxAPI.UIMachine.AttachDevice(machine,\n                                             storageCtlName,\n                                             devicePort,\n                                             deviceSlot,\n                                             deviceType,\n                                             medium);\n\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not attach the file as \"\n                             \"harddisk/dvd/floppy: %s, rc=%08x\"), src, rc);\n            ret = -1;\n            goto cleanup;\n        } else {\n            DEBUGIID(\"Attached HDD/DVD/Floppy with UUID\", &mediumUUID);\n        }\n\n cleanup:\n        VBOX_MEDIUM_RELEASE(medium);\n        vboxIIDUnalloc(&mediumUUID);\n        VBOX_UTF16_FREE(mediumFileUtf16);\n        VBOX_UTF16_FREE(storageCtlName);\n\n        if (ret < 0)\n            break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "storageCtlName"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "mediumFileUtf16"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&mediumUUID"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_MEDIUM_RELEASE",
          "args": [
            "medium"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUGIID",
          "args": [
            "\"Attached HDD/DVD/Floppy with UUID\"",
            "&mediumUUID"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not attach the file as \"\n                             \"harddisk/dvd/floppy: %s, rc=%08x\")",
            "src",
            "rc"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not attach the file as \"\n                             \"harddisk/dvd/floppy: %s, rc=%08x\""
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.AttachDevice",
          "args": [
            "machine",
            "storageCtlName",
            "devicePort",
            "deviceSlot",
            "deviceType",
            "medium"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "controllerName"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Attaching disk(%zu), controller: %s, port: %d, slot: %d, \"\n                  \"type: %d, medium: %s\"",
            "i",
            "controllerName",
            "devicePort",
            "deviceSlot",
            "deviceType",
            "medium == NULL ? \"empty\" : src"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "storageCtlName",
            "&controllerName"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting hard disk type to normal\""
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.SetType",
          "args": [
            "medium",
            "MediumType_Normal"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting hard disk to immutable\""
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.SetType",
          "args": [
            "medium",
            "MediumType_Immutable"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Can't get the UUID of the file to be attached \"\n                                 \"as harddisk/dvd/floppy: %s, rc=%08x\")",
            "src",
            "rc"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMedium.GetId",
          "args": [
            "medium",
            "&mediumUUID"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to open the following disk/dvd/floppy \"\n                                 \"to the machine: %s, rc=%08x\")",
            "src",
            "rc"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.OpenMedium",
          "args": [
            "data->vboxObj",
            "mediumFileUtf16",
            "deviceType",
            "accessMode",
            "&medium"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.FindHardDisk",
          "args": [
            "data->vboxObj",
            "mediumFileUtf16",
            "deviceType",
            "accessMode",
            "&medium"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Looking up medium %s, type: %d, mode: %d\"",
            "src",
            "deviceType",
            "accessMode"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "src",
            "&mediumFileUtf16"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"The vbox driver does not support %s bus type\")",
            "virDomainDiskBusTypeToString(disk->bus)"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskBusTypeToString",
          "args": [
            "disk->bus"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "VBOX_CONTROLLER_FLOPPY_NAME",
            "&storageCtlName"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "VBOX_CONTROLLER_SAS_NAME",
            "&storageCtlName"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "storageCtlName"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDeviceFindSCSIController",
          "args": [
            "def",
            "&disk->info.addr.drive"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeviceFindSCSIController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "8816-8829",
          "snippet": "virDomainControllerDefPtr\nvirDomainDeviceFindSCSIController(const virDomainDef *def,\n                                  const virDomainDeviceDriveAddress *addr)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI &&\n            def->controllers[i]->idx == addr->controller)\n            return def->controllers[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainControllerDefPtr\nvirDomainDeviceFindSCSIController(const virDomainDef *def,\n                                  const virDomainDeviceDriveAddress *addr)\n{\n    size_t i;\n\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (def->controllers[i]->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI &&\n            def->controllers[i]->idx == addr->controller)\n            return def->controllers[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "VBOX_CONTROLLER_SCSI_NAME",
            "&storageCtlName"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "VBOX_CONTROLLER_SATA_NAME",
            "&storageCtlName"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "VBOX_CONTROLLER_IDE_NAME",
            "&storageCtlName"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"The vbox driver does not support %s disk device\")",
            "virDomainDiskDeviceTypeToString(disk->device)"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskDeviceTypeToString",
          "args": [
            "disk->device"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Missing disk source file path\")"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unsupported storage type %s, the only supported \"\n                             \"type is %s\")",
            "virStorageTypeToString(type)",
            "virStorageTypeToString(VIR_STORAGE_TYPE_FILE)"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageTypeToString",
          "args": [
            "VIR_STORAGE_TYPE_FILE"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageTypeToString",
          "args": [
            "type"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetType",
          "args": [
            "disk"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2141-2145",
          "snippet": "int\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "disk"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&mediumUUID"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxAttachDrives(virDomainDefPtr def, vboxDriverPtr data, IMachine *machine)\n{\n    size_t i;\n    int type, ret = 0;\n    const char *src = NULL;\n    nsresult rc = 0;\n    virDomainDiskDefPtr disk = NULL;\n    virDomainControllerDefPtr cont;\n    PRUnichar *storageCtlName = NULL;\n    char *controllerName = NULL;\n    IMedium *medium = NULL;\n    PRUnichar *mediumFileUtf16 = NULL;\n    PRUint32 devicePort, deviceSlot, deviceType, accessMode;\n    vboxIID mediumUUID;\n\n    VBOX_IID_INITIALIZE(&mediumUUID);\n\n    for (i = 0; i < def->ndisks; i++) {\n        disk = def->disks[i];\n        src = virDomainDiskGetSource(disk);\n        type = virDomainDiskGetType(disk);\n        deviceType = DeviceType_Null;\n        accessMode = AccessMode_ReadOnly;\n        devicePort = disk->info.addr.drive.unit;\n        deviceSlot = disk->info.addr.drive.bus;\n\n        if (type != VIR_STORAGE_TYPE_FILE) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported storage type %s, the only supported \"\n                             \"type is %s\"),\n                           virStorageTypeToString(type),\n                           virStorageTypeToString(VIR_STORAGE_TYPE_FILE));\n            ret = -1;\n            goto cleanup;\n        }\n\n        switch ((virDomainDiskDevice) disk->device) {\n        case VIR_DOMAIN_DISK_DEVICE_DISK:\n            if (!src) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Missing disk source file path\"));\n                ret = -1;\n                goto cleanup;\n            }\n\n            deviceType = DeviceType_HardDisk;\n            accessMode = AccessMode_ReadWrite;\n\n            break;\n\n        case VIR_DOMAIN_DISK_DEVICE_CDROM:\n            deviceType = DeviceType_DVD;\n            accessMode = AccessMode_ReadOnly;\n\n            break;\n        case VIR_DOMAIN_DISK_DEVICE_FLOPPY:\n            deviceType = DeviceType_Floppy;\n            accessMode = AccessMode_ReadWrite;\n\n            break;\n        case VIR_DOMAIN_DISK_DEVICE_LUN:\n        case VIR_DOMAIN_DISK_DEVICE_LAST:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"The vbox driver does not support %s disk device\"),\n                           virDomainDiskDeviceTypeToString(disk->device));\n            ret = -1;\n            goto cleanup;\n        }\n\n        switch ((virDomainDiskBus) disk->bus) {\n        case VIR_DOMAIN_DISK_BUS_IDE:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_IDE_NAME, &storageCtlName);\n            devicePort = def->disks[i]->info.addr.drive.bus;\n            deviceSlot = def->disks[i]->info.addr.drive.unit;\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_SATA:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SATA_NAME, &storageCtlName);\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_SCSI:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SCSI_NAME, &storageCtlName);\n\n            cont = virDomainDeviceFindSCSIController(def, &disk->info.addr.drive);\n            if (cont && cont->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068) {\n                VBOX_UTF16_FREE(storageCtlName);\n                VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SAS_NAME, &storageCtlName);\n            }\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_FDC:\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_FLOPPY_NAME, &storageCtlName);\n            devicePort = 0;\n            deviceSlot = disk->info.addr.drive.unit;\n\n            break;\n        case VIR_DOMAIN_DISK_BUS_VIRTIO:\n        case VIR_DOMAIN_DISK_BUS_XEN:\n        case VIR_DOMAIN_DISK_BUS_USB:\n        case VIR_DOMAIN_DISK_BUS_UML:\n        case VIR_DOMAIN_DISK_BUS_SD:\n        case VIR_DOMAIN_DISK_BUS_LAST:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"The vbox driver does not support %s bus type\"),\n                           virDomainDiskBusTypeToString(disk->bus));\n            ret = -1;\n            goto cleanup;\n        }\n\n        /* If disk source is specified, lookup IMedium - removable drives don't\n         * have either.\n         */\n        if (src) {\n            VBOX_UTF8_TO_UTF16(src, &mediumFileUtf16);\n            VIR_DEBUG(\"Looking up medium %s, type: %d, mode: %d\", src,\n                      deviceType, accessMode);\n\n            rc = gVBoxAPI.UIVirtualBox.FindHardDisk(data->vboxObj, mediumFileUtf16,\n                                                    deviceType, accessMode, &medium);\n\n            /* The following is not needed for vbox 4.2+ but older versions have\n             * distinct find and open operations where the former looks in vbox\n             * media registry while the latter at storage location. In 4.2+, the\n             * OpenMedium call takes care of both cases internally\n             */\n            if (!medium) {\n                rc = gVBoxAPI.UIVirtualBox.OpenMedium(data->vboxObj,\n                                                      mediumFileUtf16,\n                                                      deviceType, accessMode,\n                                                      &medium);\n            }\n\n            if (!medium) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to open the following disk/dvd/floppy \"\n                                 \"to the machine: %s, rc=%08x\"), src, rc);\n                ret = -1;\n                goto cleanup;\n            }\n\n            rc = gVBoxAPI.UIMedium.GetId(medium, &mediumUUID);\n            if (NS_FAILED(rc)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Can't get the UUID of the file to be attached \"\n                                 \"as harddisk/dvd/floppy: %s, rc=%08x\"),\n                               src, rc);\n                ret = -1;\n                goto cleanup;\n            }\n        }\n\n        if (disk->device == VIR_DOMAIN_DISK_DEVICE_DISK) {\n            if (disk->src->readonly) {\n                gVBoxAPI.UIMedium.SetType(medium, MediumType_Immutable);\n                VIR_DEBUG(\"Setting hard disk to immutable\");\n            } else if (!disk->src->readonly) {\n                gVBoxAPI.UIMedium.SetType(medium, MediumType_Normal);\n                VIR_DEBUG(\"Setting hard disk type to normal\");\n            }\n        }\n\n        VBOX_UTF16_TO_UTF8(storageCtlName, &controllerName);\n        VIR_DEBUG(\"Attaching disk(%zu), controller: %s, port: %d, slot: %d, \"\n                  \"type: %d, medium: %s\", i, controllerName, devicePort,\n                    deviceSlot, deviceType, medium == NULL ? \"empty\" : src);\n        VBOX_UTF8_FREE(controllerName);\n\n        /* Attach the harddisk/dvd/Floppy to the storage controller,\n         * medium == NULL is ok here\n         */\n        rc = gVBoxAPI.UIMachine.AttachDevice(machine,\n                                             storageCtlName,\n                                             devicePort,\n                                             deviceSlot,\n                                             deviceType,\n                                             medium);\n\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not attach the file as \"\n                             \"harddisk/dvd/floppy: %s, rc=%08x\"), src, rc);\n            ret = -1;\n            goto cleanup;\n        } else {\n            DEBUGIID(\"Attached HDD/DVD/Floppy with UUID\", &mediumUUID);\n        }\n\n cleanup:\n        VBOX_MEDIUM_RELEASE(medium);\n        vboxIIDUnalloc(&mediumUUID);\n        VBOX_UTF16_FREE(mediumFileUtf16);\n        VBOX_UTF16_FREE(storageCtlName);\n\n        if (ret < 0)\n            break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxSetBootDeviceOrder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "969-1024",
    "snippet": "static void\nvboxSetBootDeviceOrder(virDomainDefPtr def, vboxDriverPtr data,\n                       IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 maxBootPosition = 0;\n    size_t i = 0;\n\n    VIR_DEBUG(\"def->os.type             %s\", virDomainOSTypeToString(def->os.type));\n    VIR_DEBUG(\"def->os.arch             %s\", virArchToString(def->os.arch));\n    VIR_DEBUG(\"def->os.machine          %s\", def->os.machine);\n    VIR_DEBUG(\"def->os.nBootDevs        %zu\", def->os.nBootDevs);\n    VIR_DEBUG(\"def->os.bootDevs[0]      %d\", def->os.bootDevs[0]);\n    VIR_DEBUG(\"def->os.bootDevs[1]      %d\", def->os.bootDevs[1]);\n    VIR_DEBUG(\"def->os.bootDevs[2]      %d\", def->os.bootDevs[2]);\n    VIR_DEBUG(\"def->os.bootDevs[3]      %d\", def->os.bootDevs[3]);\n    VIR_DEBUG(\"def->os.init             %s\", def->os.init);\n    VIR_DEBUG(\"def->os.kernel           %s\", def->os.kernel);\n    VIR_DEBUG(\"def->os.initrd           %s\", def->os.initrd);\n    VIR_DEBUG(\"def->os.cmdline          %s\", def->os.cmdline);\n    VIR_DEBUG(\"def->os.root             %s\", def->os.root);\n    if (def->os.loader) {\n        VIR_DEBUG(\"def->os.loader->path     %s\", def->os.loader->path);\n        VIR_DEBUG(\"def->os.loader->readonly %d\", def->os.loader->readonly);\n        VIR_DEBUG(\"def->os.loader->type     %d\", def->os.loader->type);\n        VIR_DEBUG(\"def->os.loader->nvram    %s\", def->os.loader->nvram);\n    }\n    VIR_DEBUG(\"def->os.bootloader       %s\", def->os.bootloader);\n    VIR_DEBUG(\"def->os.bootloaderArgs   %s\", def->os.bootloaderArgs);\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetMaxBootPosition(systemProperties,\n                                                       &maxBootPosition);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    /* Clear the defaults first */\n    for (i = 0; i < maxBootPosition; i++)\n        gVBoxAPI.UIMachine.SetBootOrder(machine, i+1, DeviceType_Null);\n\n    for (i = 0; (i < def->os.nBootDevs) && (i < maxBootPosition); i++) {\n        PRUint32 device = DeviceType_Null;\n\n        if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_FLOPPY) {\n            device = DeviceType_Floppy;\n        } else if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_CDROM) {\n            device = DeviceType_DVD;\n        } else if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_DISK) {\n            device = DeviceType_HardDisk;\n        } else if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_NET) {\n            device = DeviceType_Network;\n        }\n        gVBoxAPI.UIMachine.SetBootOrder(machine, i+1, device);\n    }\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetBootOrder",
          "args": [
            "machine",
            "i+1",
            "device"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.SetBootOrder",
          "args": [
            "machine",
            "i+1",
            "DeviceType_Null"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "systemProperties"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISystemProperties.GetMaxBootPosition",
          "args": [
            "systemProperties",
            "&maxBootPosition"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetSystemProperties",
          "args": [
            "data->vboxObj",
            "&systemProperties"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.bootloaderArgs   %s\"",
            "def->os.bootloaderArgs"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.bootloader       %s\"",
            "def->os.bootloader"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.loader->nvram    %s\"",
            "def->os.loader->nvram"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.loader->type     %d\"",
            "def->os.loader->type"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.loader->readonly %d\"",
            "def->os.loader->readonly"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.loader->path     %s\"",
            "def->os.loader->path"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.root             %s\"",
            "def->os.root"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.cmdline          %s\"",
            "def->os.cmdline"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.initrd           %s\"",
            "def->os.initrd"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.kernel           %s\"",
            "def->os.kernel"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.init             %s\"",
            "def->os.init"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.bootDevs[3]      %d\"",
            "def->os.bootDevs[3]"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.bootDevs[2]      %d\"",
            "def->os.bootDevs[2]"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.bootDevs[1]      %d\"",
            "def->os.bootDevs[1]"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.bootDevs[0]      %d\"",
            "def->os.bootDevs[0]"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.nBootDevs        %zu\"",
            "def->os.nBootDevs"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.machine          %s\"",
            "def->os.machine"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.arch             %s\"",
            "virArchToString(def->os.arch)"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "def->os.arch"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"def->os.type             %s\"",
            "virDomainOSTypeToString(def->os.type)"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainOSTypeToString",
          "args": [
            "def->os.type"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic void\nvboxSetBootDeviceOrder(virDomainDefPtr def, vboxDriverPtr data,\n                       IMachine *machine)\n{\n    ISystemProperties *systemProperties = NULL;\n    PRUint32 maxBootPosition = 0;\n    size_t i = 0;\n\n    VIR_DEBUG(\"def->os.type             %s\", virDomainOSTypeToString(def->os.type));\n    VIR_DEBUG(\"def->os.arch             %s\", virArchToString(def->os.arch));\n    VIR_DEBUG(\"def->os.machine          %s\", def->os.machine);\n    VIR_DEBUG(\"def->os.nBootDevs        %zu\", def->os.nBootDevs);\n    VIR_DEBUG(\"def->os.bootDevs[0]      %d\", def->os.bootDevs[0]);\n    VIR_DEBUG(\"def->os.bootDevs[1]      %d\", def->os.bootDevs[1]);\n    VIR_DEBUG(\"def->os.bootDevs[2]      %d\", def->os.bootDevs[2]);\n    VIR_DEBUG(\"def->os.bootDevs[3]      %d\", def->os.bootDevs[3]);\n    VIR_DEBUG(\"def->os.init             %s\", def->os.init);\n    VIR_DEBUG(\"def->os.kernel           %s\", def->os.kernel);\n    VIR_DEBUG(\"def->os.initrd           %s\", def->os.initrd);\n    VIR_DEBUG(\"def->os.cmdline          %s\", def->os.cmdline);\n    VIR_DEBUG(\"def->os.root             %s\", def->os.root);\n    if (def->os.loader) {\n        VIR_DEBUG(\"def->os.loader->path     %s\", def->os.loader->path);\n        VIR_DEBUG(\"def->os.loader->readonly %d\", def->os.loader->readonly);\n        VIR_DEBUG(\"def->os.loader->type     %d\", def->os.loader->type);\n        VIR_DEBUG(\"def->os.loader->nvram    %s\", def->os.loader->nvram);\n    }\n    VIR_DEBUG(\"def->os.bootloader       %s\", def->os.bootloader);\n    VIR_DEBUG(\"def->os.bootloaderArgs   %s\", def->os.bootloaderArgs);\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (systemProperties) {\n        gVBoxAPI.UISystemProperties.GetMaxBootPosition(systemProperties,\n                                                       &maxBootPosition);\n        VBOX_RELEASE(systemProperties);\n    }\n\n    /* Clear the defaults first */\n    for (i = 0; i < maxBootPosition; i++)\n        gVBoxAPI.UIMachine.SetBootOrder(machine, i+1, DeviceType_Null);\n\n    for (i = 0; (i < def->os.nBootDevs) && (i < maxBootPosition); i++) {\n        PRUint32 device = DeviceType_Null;\n\n        if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_FLOPPY) {\n            device = DeviceType_Floppy;\n        } else if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_CDROM) {\n            device = DeviceType_DVD;\n        } else if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_DISK) {\n            device = DeviceType_HardDisk;\n        } else if (def->os.bootDevs[i] == VIR_DOMAIN_BOOT_NET) {\n            device = DeviceType_Network;\n        }\n        gVBoxAPI.UIMachine.SetBootOrder(machine, i+1, device);\n    }\n}"
  },
  {
    "function_name": "vboxDomainLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "901-967",
    "snippet": "static virDomainPtr\nvboxDomainLookupByName(virConnectPtr conn, const char *name)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    vboxIID iid;\n    char *machineNameUtf8 = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    size_t i;\n    bool matched = false;\n    nsresult rc;\n    virDomainPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return NULL;\n    }\n\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n        PRBool isAccessible = PR_FALSE;\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (!isAccessible)\n            continue;\n\n        gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n        VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineNameUtf8);\n\n        if (STREQ(name, machineNameUtf8)) {\n            PRUint32 state;\n            int id = -1;\n\n            matched = true;\n\n            gVBoxAPI.UIMachine.GetId(machine, &iid);\n            vboxIIDToUUID(&iid, uuid);\n            vboxIIDUnalloc(&iid);\n\n            gVBoxAPI.UIMachine.GetState(machine, &state);\n\n            if (gVBoxAPI.machineStateChecker.Online(state))\n                id = i + 1;\n\n            ret = virGetDomain(conn, machineNameUtf8, uuid, id);\n        }\n\n        VBOX_UTF8_FREE(machineNameUtf8);\n        VBOX_COM_UNALLOC_MEM(machineNameUtf16);\n        if (matched)\n            break;\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&machines"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_COM_UNALLOC_MEM",
          "args": [
            "machineNameUtf16"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "machineNameUtf8"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "machineNameUtf8",
            "uuid",
            "id"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Online",
          "args": [
            "state"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDToUUID",
          "args": [
            "&iid",
            "uuid"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetId",
          "args": [
            "machine",
            "&iid"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "name",
            "machineNameUtf8"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "machineNameUtf16",
            "&machineNameUtf8"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetName",
          "args": [
            "machine",
            "&machineNameUtf16"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get list of machines, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not get list of machines, rc=%08x\""
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&machines",
            "data->vboxObj",
            "ARRAY_GET_MACHINES"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virDomainPtr\nvboxDomainLookupByName(virConnectPtr conn, const char *name)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    vboxIID iid;\n    char *machineNameUtf8 = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    size_t i;\n    bool matched = false;\n    nsresult rc;\n    virDomainPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return NULL;\n    }\n\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n        PRBool isAccessible = PR_FALSE;\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (!isAccessible)\n            continue;\n\n        gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n        VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineNameUtf8);\n\n        if (STREQ(name, machineNameUtf8)) {\n            PRUint32 state;\n            int id = -1;\n\n            matched = true;\n\n            gVBoxAPI.UIMachine.GetId(machine, &iid);\n            vboxIIDToUUID(&iid, uuid);\n            vboxIIDUnalloc(&iid);\n\n            gVBoxAPI.UIMachine.GetState(machine, &state);\n\n            if (gVBoxAPI.machineStateChecker.Online(state))\n                id = i + 1;\n\n            ret = virGetDomain(conn, machineNameUtf8, uuid, id);\n        }\n\n        VBOX_UTF8_FREE(machineNameUtf8);\n        VBOX_COM_UNALLOC_MEM(machineNameUtf16);\n        if (matched)\n            break;\n    }\n\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainLookupByUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "829-899",
    "snippet": "virDomainPtr vboxDomainLookupByUUID(virConnectPtr conn,\n                                    const unsigned char *uuid)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    vboxIID iid;\n    char *machineNameUtf8 = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    unsigned char iid_as_uuid[VIR_UUID_BUFLEN];\n    size_t i;\n    bool matched = false;\n    nsresult rc;\n    virDomainPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return NULL;\n    }\n\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n        PRBool isAccessible = PR_FALSE;\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (!isAccessible)\n            continue;\n\n        rc = gVBoxAPI.UIMachine.GetId(machine, &iid);\n        if (NS_FAILED(rc))\n            continue;\n        vboxIIDToUUID(&iid, iid_as_uuid);\n        vboxIIDUnalloc(&iid);\n\n        if (memcmp(uuid, iid_as_uuid, VIR_UUID_BUFLEN) == 0) {\n            PRUint32 state;\n            int id = -1;\n\n\n            matched = true;\n\n            gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n            VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineNameUtf8);\n\n            gVBoxAPI.UIMachine.GetState(machine, &state);\n\n            if (gVBoxAPI.machineStateChecker.Online(state))\n                id = i + 1;\n\n            ret = virGetDomain(conn, machineNameUtf8, iid_as_uuid, id);\n         }\n\n         if (matched)\n             break;\n    }\n\n    /* Do the cleanup and take care you dont leak any memory */\n    VBOX_UTF8_FREE(machineNameUtf8);\n    VBOX_COM_UNALLOC_MEM(machineNameUtf16);\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&machines"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_COM_UNALLOC_MEM",
          "args": [
            "machineNameUtf16"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "machineNameUtf8"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "machineNameUtf8",
            "iid_as_uuid",
            "id"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Online",
          "args": [
            "state"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "machineNameUtf16",
            "&machineNameUtf8"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetName",
          "args": [
            "machine",
            "&machineNameUtf16"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "uuid",
            "iid_as_uuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDToUUID",
          "args": [
            "&iid",
            "iid_as_uuid"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetId",
          "args": [
            "machine",
            "&iid"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get list of machines, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not get list of machines, rc=%08x\""
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&machines",
            "data->vboxObj",
            "ARRAY_GET_MACHINES"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nvirDomainPtr vboxDomainLookupByUUID(virConnectPtr conn,\n                                    const unsigned char *uuid)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    vboxIID iid;\n    char *machineNameUtf8 = NULL;\n    PRUnichar *machineNameUtf16 = NULL;\n    unsigned char iid_as_uuid[VIR_UUID_BUFLEN];\n    size_t i;\n    bool matched = false;\n    nsresult rc;\n    virDomainPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return NULL;\n    }\n\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n        PRBool isAccessible = PR_FALSE;\n\n        if (!machine)\n            continue;\n\n        gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n        if (!isAccessible)\n            continue;\n\n        rc = gVBoxAPI.UIMachine.GetId(machine, &iid);\n        if (NS_FAILED(rc))\n            continue;\n        vboxIIDToUUID(&iid, iid_as_uuid);\n        vboxIIDUnalloc(&iid);\n\n        if (memcmp(uuid, iid_as_uuid, VIR_UUID_BUFLEN) == 0) {\n            PRUint32 state;\n            int id = -1;\n\n\n            matched = true;\n\n            gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n            VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineNameUtf8);\n\n            gVBoxAPI.UIMachine.GetState(machine, &state);\n\n            if (gVBoxAPI.machineStateChecker.Online(state))\n                id = i + 1;\n\n            ret = virGetDomain(conn, machineNameUtf8, iid_as_uuid, id);\n         }\n\n         if (matched)\n             break;\n    }\n\n    /* Do the cleanup and take care you dont leak any memory */\n    VBOX_UTF8_FREE(machineNameUtf8);\n    VBOX_COM_UNALLOC_MEM(machineNameUtf16);\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxDomainLookupByID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "754-827",
    "snippet": "static virDomainPtr vboxDomainLookupByID(virConnectPtr conn, int id)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    IMachine *machine;\n    PRBool isAccessible = PR_FALSE;\n    PRUnichar *machineNameUtf16 = NULL;\n    char *machineNameUtf8 = NULL;\n    vboxIID iid;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    PRUint32 state;\n    nsresult rc;\n    virDomainPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    /* Internal vbox IDs start from 0, the public libvirt ID\n     * starts from 1, so refuse id == 0, and adjust the rest */\n    if (id == 0) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching id %d\"), id);\n        return NULL;\n    }\n    id = id - 1;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return NULL;\n    }\n\n    if (id >= machines.count)\n        goto cleanup;\n\n    machine = machines.items[id];\n\n    if (!machine)\n        goto cleanup;\n\n    isAccessible = PR_FALSE;\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n    if (!gVBoxAPI.machineStateChecker.Online(state))\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n    VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineNameUtf8);\n\n    gVBoxAPI.UIMachine.GetId(machine, &iid);\n    vboxIIDToUUID(&iid, uuid);\n    vboxIIDUnalloc(&iid);\n\n    /* get a new domain pointer from virGetDomain, if it fails\n     * then no need to assign the id, else assign the id, cause\n     * it is -1 by default. rest is taken care by virGetDomain\n     * itself, so need not worry.\n     */\n\n    ret = virGetDomain(conn, machineNameUtf8, uuid, id + 1);\n\n    /* Cleanup all the XPCOM allocated stuff here */\n    VBOX_UTF8_FREE(machineNameUtf8);\n    VBOX_UTF16_FREE(machineNameUtf16);\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&machines"
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "machineNameUtf16"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "machineNameUtf8"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "machineNameUtf8",
            "uuid",
            "id + 1"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDToUUID",
          "args": [
            "&iid",
            "uuid"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetId",
          "args": [
            "machine",
            "&iid"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "machineNameUtf16",
            "&machineNameUtf8"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetName",
          "args": [
            "machine",
            "&machineNameUtf16"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Online",
          "args": [
            "state"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get list of machines, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not get list of machines, rc=%08x\""
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&machines",
            "data->vboxObj",
            "ARRAY_GET_MACHINES"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"no domain with matching id %d\")",
            "id"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "&iid"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic virDomainPtr vboxDomainLookupByID(virConnectPtr conn, int id)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    IMachine *machine;\n    PRBool isAccessible = PR_FALSE;\n    PRUnichar *machineNameUtf16 = NULL;\n    char *machineNameUtf8 = NULL;\n    vboxIID iid;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    PRUint32 state;\n    nsresult rc;\n    virDomainPtr ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    VBOX_IID_INITIALIZE(&iid);\n    /* Internal vbox IDs start from 0, the public libvirt ID\n     * starts from 1, so refuse id == 0, and adjust the rest */\n    if (id == 0) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"no domain with matching id %d\"), id);\n        return NULL;\n    }\n    id = id - 1;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of machines, rc=%08x\"), (unsigned)rc);\n        return NULL;\n    }\n\n    if (id >= machines.count)\n        goto cleanup;\n\n    machine = machines.items[id];\n\n    if (!machine)\n        goto cleanup;\n\n    isAccessible = PR_FALSE;\n    gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n    if (!isAccessible)\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetState(machine, &state);\n    if (!gVBoxAPI.machineStateChecker.Online(state))\n        goto cleanup;\n\n    gVBoxAPI.UIMachine.GetName(machine, &machineNameUtf16);\n    VBOX_UTF16_TO_UTF8(machineNameUtf16, &machineNameUtf8);\n\n    gVBoxAPI.UIMachine.GetId(machine, &iid);\n    vboxIIDToUUID(&iid, uuid);\n    vboxIIDUnalloc(&iid);\n\n    /* get a new domain pointer from virGetDomain, if it fails\n     * then no need to assign the id, else assign the id, cause\n     * it is -1 by default. rest is taken care by virGetDomain\n     * itself, so need not worry.\n     */\n\n    ret = virGetDomain(conn, machineNameUtf8, uuid, id + 1);\n\n    /* Cleanup all the XPCOM allocated stuff here */\n    VBOX_UTF8_FREE(machineNameUtf8);\n    VBOX_UTF16_FREE(machineNameUtf16);\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n    return ret;\n}"
  },
  {
    "function_name": "vboxConnectNumOfDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "715-752",
    "snippet": "static int vboxConnectNumOfDomains(virConnectPtr conn)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    PRUint32 state;\n    nsresult rc;\n    size_t i;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get number of Domains, rc=%08x\"), (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n\n        if (machine) {\n            PRBool isAccessible = PR_FALSE;\n            gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n            if (isAccessible) {\n                gVBoxAPI.UIMachine.GetState(machine, &state);\n                if (gVBoxAPI.machineStateChecker.Online(state))\n                    ret++;\n            }\n        }\n    }\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&machines"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Online",
          "args": [
            "state"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get number of Domains, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not get number of Domains, rc=%08x\""
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&machines",
            "data->vboxObj",
            "ARRAY_GET_MACHINES"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxConnectNumOfDomains(virConnectPtr conn)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    PRUint32 state;\n    nsresult rc;\n    size_t i;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get number of Domains, rc=%08x\"), (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n    for (i = 0; i < machines.count; ++i) {\n        IMachine *machine = machines.items[i];\n\n        if (machine) {\n            PRBool isAccessible = PR_FALSE;\n            gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n            if (isAccessible) {\n                gVBoxAPI.UIMachine.GetState(machine, &state);\n                if (gVBoxAPI.machineStateChecker.Online(state))\n                    ret++;\n            }\n        }\n    }\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n    return ret;\n}"
  },
  {
    "function_name": "vboxConnectListDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "673-713",
    "snippet": "static int vboxConnectListDomains(virConnectPtr conn, int *ids, int nids)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    PRUint32 state;\n    nsresult rc;\n    size_t i, j;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of Domains, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n    for (i = 0, j = 0; (i < machines.count) && (j < nids); ++i) {\n        IMachine *machine = machines.items[i];\n\n        if (machine) {\n            PRBool isAccessible = PR_FALSE;\n            gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n            if (isAccessible) {\n                gVBoxAPI.UIMachine.GetState(machine, &state);\n                if (gVBoxAPI.machineStateChecker.Online(state)) {\n                    ret++;\n                    ids[j++] = i + 1;\n                }\n            }\n        }\n    }\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayRelease",
          "args": [
            "&machines"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "316-336",
          "snippet": "void\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static PCVBOXXPCOM pVBoxFuncs_v2_2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nstatic PCVBOXXPCOM pVBoxFuncs_v2_2;\n\nvoid\nvboxArrayRelease(vboxArray *array)\n{\n    size_t i;\n    nsISupports *supports;\n\n    if (array->items == NULL)\n        return;\n\n    for (i = 0; i < array->count; ++i) {\n        supports = array->items[i];\n\n        if (supports != NULL)\n            supports->vtbl->Release(supports);\n    }\n\n    pVBoxFuncs_v2_2->pfnComUnallocMem(array->items);\n\n    array->items = NULL;\n    array->count = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.machineStateChecker.Online",
          "args": [
            "state"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetState",
          "args": [
            "machine",
            "&state"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.GetAccessible",
          "args": [
            "machine",
            "&isAccessible"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not get list of Domains, rc=%08x\")",
            "(unsigned)rc"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not get list of Domains, rc=%08x\""
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UArray.vboxArrayGet",
          "args": [
            "&machines",
            "data->vboxObj",
            "ARRAY_GET_MACHINES"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "vboxArrayGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_XPCOMCGlue.c",
          "lines": "269-279",
          "snippet": "nsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include \"vbox_XPCOMCGlue.h\"",
            "#include <dlfcn.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include \"vbox_XPCOMCGlue.h\"\n#include <dlfcn.h>\n#include <config.h>\n\nnsresult\nvboxArrayGet(vboxArray *array, void *self, void *getter)\n{\n    nsresult nsrc;\n    void **items = NULL;\n    PRUint32 count = 0;\n\n    nsrc = ((ArrayGetter)getter)(self, &count, &items);\n\n    return vboxArrayGetHelper(array, nsrc, items, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int vboxConnectListDomains(virConnectPtr conn, int *ids, int nids)\n{\n    vboxDriverPtr data = conn->privateData;\n    vboxArray machines = VBOX_ARRAY_INITIALIZER;\n    PRUint32 state;\n    nsresult rc;\n    size_t i, j;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    rc = gVBoxAPI.UArray.vboxArrayGet(&machines, data->vboxObj, ARRAY_GET_MACHINES);\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not get list of Domains, rc=%08x\"),\n                       (unsigned)rc);\n        goto cleanup;\n    }\n\n    ret = 0;\n    for (i = 0, j = 0; (i < machines.count) && (j < nids); ++i) {\n        IMachine *machine = machines.items[i];\n\n        if (machine) {\n            PRBool isAccessible = PR_FALSE;\n            gVBoxAPI.UIMachine.GetAccessible(machine, &isAccessible);\n            if (isAccessible) {\n                gVBoxAPI.UIMachine.GetState(machine, &state);\n                if (gVBoxAPI.machineStateChecker.Online(state)) {\n                    ret++;\n                    ids[j++] = i + 1;\n                }\n            }\n        }\n    }\n\n cleanup:\n    gVBoxAPI.UArray.vboxArrayRelease(&machines);\n    return ret;\n}"
  },
  {
    "function_name": "vboxConnectGetCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "658-671",
    "snippet": "static char *vboxConnectGetCapabilities(virConnectPtr conn)\n{\n    vboxDriverPtr data = conn->privateData;\n    char *ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virObjectLock(data);\n    ret = virCapabilitiesFormatXML(data->caps);\n    virObjectUnlock(data);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "data"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFormatXML",
          "args": [
            "data->caps"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFormatXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1335-1358",
          "snippet": "char *\nvirCapabilitiesFormatXML(virCapsPtr caps)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAddLit(&buf, \"<capabilities>\\n\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    if (virCapabilitiesFormatHostXML(&caps->host, &buf) < 0)\n        goto error;\n\n    virCapabilitiesFormatGuestXML(caps->guests, caps->nguests, &buf);\n\n    virCapabilitiesFormatStoragePoolXML(caps->pools, caps->npools, &buf);\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</capabilities>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirCapabilitiesFormatXML(virCapsPtr caps)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAddLit(&buf, \"<capabilities>\\n\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    if (virCapabilitiesFormatHostXML(&caps->host, &buf) < 0)\n        goto error;\n\n    virCapabilitiesFormatGuestXML(caps->guests, caps->nguests, &buf);\n\n    virCapabilitiesFormatStoragePoolXML(caps->pools, caps->npools, &buf);\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</capabilities>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "data"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic char *vboxConnectGetCapabilities(virConnectPtr conn)\n{\n    vboxDriverPtr data = conn->privateData;\n    char *ret = NULL;\n\n    if (!data->vboxObj)\n        return ret;\n\n    virObjectLock(data);\n    ret = virCapabilitiesFormatXML(data->caps);\n    virObjectUnlock(data);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxConnectGetMaxVcpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "630-656",
    "snippet": "static int\nvboxConnectGetMaxVcpus(virConnectPtr conn, const char *type G_GNUC_UNUSED)\n{\n    vboxDriverPtr data = conn->privateData;\n    PRUint32 maxCPUCount = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    /* VirtualBox Supports only hvm and thus the type passed to it\n     * has no meaning, setting it to G_GNUC_UNUSED\n     */\n    ISystemProperties *systemProperties = NULL;\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (!systemProperties)\n        goto cleanup;\n    gVBoxAPI.UISystemProperties.GetMaxGuestCPUCount(systemProperties, &maxCPUCount);\n\n    if (maxCPUCount > 0)\n        ret = maxCPUCount;\n\n cleanup:\n    VBOX_RELEASE(systemProperties);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "systemProperties"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISystemProperties.GetMaxGuestCPUCount",
          "args": [
            "systemProperties",
            "&maxCPUCount"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetSystemProperties",
          "args": [
            "data->vboxObj",
            "&systemProperties"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxConnectGetMaxVcpus(virConnectPtr conn, const char *type G_GNUC_UNUSED)\n{\n    vboxDriverPtr data = conn->privateData;\n    PRUint32 maxCPUCount = 0;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    /* VirtualBox Supports only hvm and thus the type passed to it\n     * has no meaning, setting it to G_GNUC_UNUSED\n     */\n    ISystemProperties *systemProperties = NULL;\n\n    gVBoxAPI.UIVirtualBox.GetSystemProperties(data->vboxObj, &systemProperties);\n    if (!systemProperties)\n        goto cleanup;\n    gVBoxAPI.UISystemProperties.GetMaxGuestCPUCount(systemProperties, &maxCPUCount);\n\n    if (maxCPUCount > 0)\n        ret = maxCPUCount;\n\n cleanup:\n    VBOX_RELEASE(systemProperties);\n    return ret;\n}"
  },
  {
    "function_name": "vboxConnectIsAlive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "625-628",
    "snippet": "static int vboxConnectIsAlive(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 1;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxConnectIsAlive(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return 1;\n}"
  },
  {
    "function_name": "vboxConnectIsEncrypted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "619-623",
    "snippet": "static int vboxConnectIsEncrypted(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* No encryption is needed, or used on the local transport */\n    return 0;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxConnectIsEncrypted(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* No encryption is needed, or used on the local transport */\n    return 0;\n}"
  },
  {
    "function_name": "vboxConnectIsSecure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "613-617",
    "snippet": "static int vboxConnectIsSecure(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* Driver is using local, non-network based transport */\n    return 1;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxConnectIsSecure(virConnectPtr conn G_GNUC_UNUSED)\n{\n    /* Driver is using local, non-network based transport */\n    return 1;\n}"
  },
  {
    "function_name": "vboxConnectGetHostname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "608-611",
    "snippet": "static char *vboxConnectGetHostname(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return virGetHostname();\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virGetHostname",
          "args": [],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "virGetHostnameQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "560-564",
          "snippet": "char *\nvirGetHostnameQuiet(void)\n{\n    return virGetHostnameImpl(true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirGetHostnameQuiet(void)\n{\n    return virGetHostnameImpl(true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic char *vboxConnectGetHostname(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return virGetHostname();\n}"
  },
  {
    "function_name": "vboxConnectGetVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "596-606",
    "snippet": "static int vboxConnectGetVersion(virConnectPtr conn, unsigned long *version)\n{\n    vboxDriverPtr data = conn->privateData;\n    VIR_DEBUG(\"%s: in vboxGetVersion\", conn->driver->name);\n\n    virObjectLock(data);\n    *version = data->version;\n    virObjectUnlock(data);\n\n    return 0;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "data"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "data"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s: in vboxGetVersion\"",
            "conn->driver->name"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxConnectGetVersion(virConnectPtr conn, unsigned long *version)\n{\n    vboxDriverPtr data = conn->privateData;\n    VIR_DEBUG(\"%s: in vboxGetVersion\", conn->driver->name);\n\n    virObjectLock(data);\n    *version = data->version;\n    virObjectUnlock(data);\n\n    return 0;\n}"
  },
  {
    "function_name": "vboxDomainSave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "541-594",
    "snippet": "static int\nvboxDomainSave(virDomainPtr dom, const char *path G_GNUC_UNUSED)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IConsole *console = NULL;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    IProgress *progress = NULL;\n    resultCodeUnion resultCode;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    /* VirtualBox currently doesn't support saving to a file\n     * at a location other then the machine folder and thus\n     * setting path to G_GNUC_UNUSED for now, will change\n     * this behaviour once get the VirtualBox API in right\n     * shape to do this\n     */\n\n    /* Open a Session for the machine */\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n    if (NS_FAILED(rc) || !console)\n        goto freeSession;\n\n    rc = gVBoxAPI.UIConsole.SaveState(console, &progress);\n    if (!progress)\n        goto freeSession;\n\n    gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n    gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n    if (RC_SUCCEEDED(resultCode))\n        ret = 0;\n\n freeSession:\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    DEBUGIID(\"UUID of machine being saved:\", &iid);\n    VBOX_RELEASE(machine);\n    VBOX_RELEASE(console);\n    VBOX_RELEASE(progress);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxIIDUnalloc",
          "args": [
            "&iid"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "progress"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "console"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "machine"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEBUGIID",
          "args": [
            "\"UUID of machine being saved:\"",
            "&iid"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.Close",
          "args": [
            "data->vboxSession"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RC_SUCCEEDED",
          "args": [
            "resultCode"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.GetResultCode",
          "args": [
            "progress",
            "&resultCode"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIProgress.WaitForCompletion",
          "args": [
            "progress",
            "-1"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIConsole.SaveState",
          "args": [
            "console",
            "&progress"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.GetConsole",
          "args": [
            "data->vboxSession",
            "&console"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UISession.OpenExisting",
          "args": [
            "data",
            "&iid",
            "machine"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openSessionForMachine",
          "args": [
            "data",
            "dom->uuid",
            "&iid",
            "&machine"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "openSessionForMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "271-285",
          "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxDomainSave(virDomainPtr dom, const char *path G_GNUC_UNUSED)\n{\n    vboxDriverPtr data = dom->conn->privateData;\n    IConsole *console = NULL;\n    vboxIID iid;\n    IMachine *machine = NULL;\n    IProgress *progress = NULL;\n    resultCodeUnion resultCode;\n    nsresult rc;\n    int ret = -1;\n\n    if (!data->vboxObj)\n        return ret;\n\n    /* VirtualBox currently doesn't support saving to a file\n     * at a location other then the machine folder and thus\n     * setting path to G_GNUC_UNUSED for now, will change\n     * this behaviour once get the VirtualBox API in right\n     * shape to do this\n     */\n\n    /* Open a Session for the machine */\n    if (openSessionForMachine(data, dom->uuid, &iid, &machine) < 0)\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.OpenExisting(data, &iid, machine);\n    if (NS_FAILED(rc))\n        goto cleanup;\n\n    rc = gVBoxAPI.UISession.GetConsole(data->vboxSession, &console);\n    if (NS_FAILED(rc) || !console)\n        goto freeSession;\n\n    rc = gVBoxAPI.UIConsole.SaveState(console, &progress);\n    if (!progress)\n        goto freeSession;\n\n    gVBoxAPI.UIProgress.WaitForCompletion(progress, -1);\n    gVBoxAPI.UIProgress.GetResultCode(progress, &resultCode);\n    if (RC_SUCCEEDED(resultCode))\n        ret = 0;\n\n freeSession:\n    gVBoxAPI.UISession.Close(data->vboxSession);\n\n cleanup:\n    DEBUGIID(\"UUID of machine being saved:\", &iid);\n    VBOX_RELEASE(machine);\n    VBOX_RELEASE(console);\n    VBOX_RELEASE(progress);\n    vboxIIDUnalloc(&iid);\n    return ret;\n}"
  },
  {
    "function_name": "vboxConnectClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "531-539",
    "snippet": "static int vboxConnectClose(virConnectPtr conn)\n{\n    VIR_DEBUG(\"%s: in vboxClose\", conn->driver->name);\n\n    virObjectUnref(conn->privateData);\n    vboxDestroyDriverConnection();\n\n    return 0;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxDestroyDriverConnection",
          "args": [],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDestroyDriverConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "252-269",
          "snippet": "static void\nvboxDestroyDriverConnection(void)\n{\n    virMutexLock(&vbox_driver_lock);\n\n    if (!vbox_driver)\n        goto cleanup;\n\n    vbox_driver->connectionCount--;\n\n    vboxSdkUninitialize();\n\n    if (!virObjectUnref(vbox_driver))\n        vbox_driver = NULL;\n\n cleanup:\n    virMutexUnlock(&vbox_driver_lock);\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virMutex vbox_driver_lock = VIR_MUTEX_INITIALIZER;",
            "static vboxDriverPtr vbox_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virMutex vbox_driver_lock = VIR_MUTEX_INITIALIZER;\nstatic vboxDriverPtr vbox_driver;\n\nstatic void\nvboxDestroyDriverConnection(void)\n{\n    virMutexLock(&vbox_driver_lock);\n\n    if (!vbox_driver)\n        goto cleanup;\n\n    vbox_driver->connectionCount--;\n\n    vboxSdkUninitialize();\n\n    if (!virObjectUnref(vbox_driver))\n        vbox_driver = NULL;\n\n cleanup:\n    virMutexUnlock(&vbox_driver_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "conn->privateData"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s: in vboxClose\"",
            "conn->driver->name"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int vboxConnectClose(virConnectPtr conn)\n{\n    VIR_DEBUG(\"%s: in vboxClose\", conn->driver->name);\n\n    virObjectUnref(conn->privateData);\n    vboxDestroyDriverConnection();\n\n    return 0;\n}"
  },
  {
    "function_name": "vboxConnectOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "507-529",
    "snippet": "static virDrvOpenStatus\nvboxConnectOpen(virConnectPtr conn,\n                virConnectAuthPtr auth G_GNUC_UNUSED,\n                virConfPtr conf G_GNUC_UNUSED,\n                unsigned int flags)\n{\n    vboxDriverPtr driver = NULL;\n    uid_t uid = geteuid();\n\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    if (!virConnectValidateURIPath(conn->uri->path, \"vbox\", uid == 0))\n        return VIR_DRV_OPEN_ERROR;\n\n    if (!(driver = vboxGetDriverConnection()))\n        return VIR_DRV_OPEN_ERROR;\n\n    conn->privateData = virObjectRef(driver);\n\n    VIR_DEBUG(\"in vboxOpen\");\n\n    return VIR_DRV_OPEN_SUCCESS;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"in vboxOpen\""
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "driver"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxGetDriverConnection",
          "args": [],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "vboxGetDriverConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "217-250",
          "snippet": "static vboxDriverPtr\nvboxGetDriverConnection(void)\n{\n    virMutexLock(&vbox_driver_lock);\n\n    if (vbox_driver) {\n        virObjectRef(vbox_driver);\n    } else {\n        vbox_driver = vboxDriverObjNew();\n\n        if (!vbox_driver) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Failed to create vbox driver object.\"));\n            return NULL;\n        }\n    }\n\n    if (vboxSdkInitialize() < 0 || vboxExtractVersion() < 0) {\n        gVBoxAPI.UPFN.Uninitialize(vbox_driver);\n        /* make sure to clear the pointer when last reference was released */\n        if (!virObjectUnref(vbox_driver))\n            vbox_driver = NULL;\n\n        virMutexUnlock(&vbox_driver_lock);\n\n        return NULL;\n    }\n\n    vbox_driver->connectionCount++;\n\n    virMutexUnlock(&vbox_driver_lock);\n\n    return vbox_driver;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;",
            "static virMutex vbox_driver_lock = VIR_MUTEX_INITIALIZER;",
            "static vboxDriverPtr vbox_driver;",
            "static vboxDriverPtr vboxDriverObjNew(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\nstatic virMutex vbox_driver_lock = VIR_MUTEX_INITIALIZER;\nstatic vboxDriverPtr vbox_driver;\nstatic vboxDriverPtr vboxDriverObjNew(void);\n\nstatic vboxDriverPtr\nvboxGetDriverConnection(void)\n{\n    virMutexLock(&vbox_driver_lock);\n\n    if (vbox_driver) {\n        virObjectRef(vbox_driver);\n    } else {\n        vbox_driver = vboxDriverObjNew();\n\n        if (!vbox_driver) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Failed to create vbox driver object.\"));\n            return NULL;\n        }\n    }\n\n    if (vboxSdkInitialize() < 0 || vboxExtractVersion() < 0) {\n        gVBoxAPI.UPFN.Uninitialize(vbox_driver);\n        /* make sure to clear the pointer when last reference was released */\n        if (!virObjectUnref(vbox_driver))\n            vbox_driver = NULL;\n\n        virMutexUnlock(&vbox_driver_lock);\n\n        return NULL;\n    }\n\n    vbox_driver->connectionCount++;\n\n    virMutexUnlock(&vbox_driver_lock);\n\n    return vbox_driver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectValidateURIPath",
          "args": [
            "conn->uri->path",
            "\"vbox\"",
            "uid == 0"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectValidateURIPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "260-296",
          "snippet": "bool\nvirConnectValidateURIPath(const char *uriPath,\n                          const char *entityName,\n                          bool privileged)\n{\n    if (privileged) {\n        /* TODO: qemu and vbox drivers allow '/session'\n         * connections as root. This is not ideal, but changing\n         * these drivers to refuse privileged '/session'\n         * connections, like everyone else is already doing, can\n         * break existing applications. Until we decide what to do,\n         * for now we can handle them as exception in this validate\n         * function.\n         */\n        bool compatSessionRoot = (STREQ(entityName, \"qemu\") ||\n                                  STREQ(entityName, \"vbox\")) &&\n                                  STREQ(uriPath, \"/session\");\n\n        if (STRNEQ(uriPath, \"/system\") && !compatSessionRoot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///system\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    } else {\n        if (STRNEQ(uriPath, \"/session\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///session\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirConnectValidateURIPath(const char *uriPath,\n                          const char *entityName,\n                          bool privileged)\n{\n    if (privileged) {\n        /* TODO: qemu and vbox drivers allow '/session'\n         * connections as root. This is not ideal, but changing\n         * these drivers to refuse privileged '/session'\n         * connections, like everyone else is already doing, can\n         * break existing applications. Until we decide what to do,\n         * for now we can handle them as exception in this validate\n         * function.\n         */\n        bool compatSessionRoot = (STREQ(entityName, \"qemu\") ||\n                                  STREQ(entityName, \"vbox\")) &&\n                                  STREQ(uriPath, \"/session\");\n\n        if (STRNEQ(uriPath, \"/system\") && !compatSessionRoot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///system\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    } else {\n        if (STRNEQ(uriPath, \"/session\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unexpected %s URI path '%s', try \"\n                             \"%s:///session\"),\n                           entityName, uriPath, entityName);\n            return false;\n        }\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_CONNECT_RO",
            "VIR_DRV_OPEN_ERROR"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virDrvOpenStatus\nvboxConnectOpen(virConnectPtr conn,\n                virConnectAuthPtr auth G_GNUC_UNUSED,\n                virConfPtr conf G_GNUC_UNUSED,\n                unsigned int flags)\n{\n    vboxDriverPtr driver = NULL;\n    uid_t uid = geteuid();\n\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    if (!virConnectValidateURIPath(conn->uri->path, \"vbox\", uid == 0))\n        return VIR_DRV_OPEN_ERROR;\n\n    if (!(driver = vboxGetDriverConnection()))\n        return VIR_DRV_OPEN_ERROR;\n\n    conn->privateData = virObjectRef(driver);\n\n    VIR_DEBUG(\"in vboxOpen\");\n\n    return VIR_DRV_OPEN_SUCCESS;\n}"
  },
  {
    "function_name": "vboxConnectURIProbe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "499-504",
    "snippet": "static int\nvboxConnectURIProbe(char **uri)\n{\n    *uri = g_strdup(geteuid() ? \"vbox:///session\" : \"vbox:///system\");\n    return 1;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "geteuid() ? \"vbox:///session\" : \"vbox:///system\""
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvboxConnectURIProbe(char **uri)\n{\n    *uri = g_strdup(geteuid() ? \"vbox:///session\" : \"vbox:///system\");\n    return 1;\n}"
  },
  {
    "function_name": "vboxAttachStorageControllers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "484-496",
    "snippet": "static int\nvboxAttachStorageControllers(virDomainDefPtr def,\n                             vboxDriverPtr data,\n                             IMachine *machine)\n{\n    size_t i;\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (vboxSetStorageController(def->controllers[i], data, machine) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vboxSetStorageController",
          "args": [
            "def->controllers[i]",
            "data",
            "machine"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "vboxSetStorageController",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "338-481",
          "snippet": "static int\nvboxSetStorageController(virDomainControllerDefPtr controller,\n                         vboxDriverPtr data,\n                         IMachine *machine)\n{\n    PRUnichar *controllerName = NULL;\n    PRInt32 vboxModel = StorageControllerType_Null;\n    PRInt32 vboxBusType = StorageBus_Null;\n    IStorageController *vboxController = NULL;\n    nsresult rc = 0;\n    char *debugName = NULL;\n    int ret = -1;\n\n    /* libvirt controller type => vbox bus type */\n    switch ((virDomainControllerType) controller->type) {\n    case VIR_DOMAIN_CONTROLLER_TYPE_FDC:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_FLOPPY_NAME, &controllerName);\n        vboxBusType = StorageBus_Floppy;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_IDE:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_IDE_NAME, &controllerName);\n        vboxBusType = StorageBus_IDE;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_SCSI:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SCSI_NAME, &controllerName);\n        vboxBusType = StorageBus_SCSI;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SATA_NAME, &controllerName);\n        vboxBusType = StorageBus_SATA;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL:\n    case VIR_DOMAIN_CONTROLLER_TYPE_CCID:\n    case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n    case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n    case VIR_DOMAIN_CONTROLLER_TYPE_XENBUS:\n    case VIR_DOMAIN_CONTROLLER_TYPE_LAST:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"The vbox driver does not support %s controller type\"),\n                       virDomainControllerTypeToString(controller->type));\n        return -1;\n    }\n\n    /* libvirt scsi model => vbox scsi model */\n    if (controller->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI) {\n        switch ((virDomainControllerModelSCSI) controller->model) {\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AUTO:\n            vboxModel = StorageControllerType_LsiLogic;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC:\n            vboxModel = StorageControllerType_BusLogic;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068:\n            /* in vbox, lsisas has a dedicated SAS bus type with no model */\n            VBOX_UTF16_FREE(controllerName);\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SAS_NAME, &controllerName);\n            vboxBusType = StorageBus_SAS;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_TRANSITIONAL:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_NON_TRANSITIONAL:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1078:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"The vbox driver does not support %s SCSI \"\n                             \"controller model\"),\n                           virDomainControllerModelSCSITypeToString(controller->model));\n            goto cleanup;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DEFAULT:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LAST:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected SCSI controller model %d\"),\n                           controller->model);\n            goto cleanup;\n        }\n    /* libvirt ide model => vbox ide model */\n    } else if (controller->type == VIR_DOMAIN_CONTROLLER_TYPE_IDE) {\n        switch ((virDomainControllerModelIDE) controller->model) {\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX3:\n            vboxModel = StorageControllerType_PIIX3;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX4:\n            vboxModel = StorageControllerType_PIIX4;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_ICH6:\n            vboxModel = StorageControllerType_ICH6;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_LAST:\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_DEFAULT:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unexpected IDE controller model %d\"),\n                           controller->model);\n            goto cleanup;\n        }\n    }\n\n    VBOX_UTF16_TO_UTF8(controllerName, &debugName);\n    VIR_DEBUG(\"Adding VBOX storage controller (name: %s, busType: %d)\",\n               debugName, vboxBusType);\n\n    rc = gVBoxAPI.UIMachine.AddStorageController(machine, controllerName,\n                                                 vboxBusType, &vboxController);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to add storage controller \"\n                         \"(name: %s, busType: %d), rc=%08x\"),\n                       debugName, vboxBusType, rc);\n        goto cleanup;\n    }\n\n    /* only IDE or SCSI controller have model choices */\n    if (vboxModel != StorageControllerType_Null) {\n        rc = gVBoxAPI.UIStorageController.SetControllerType(vboxController,\n                                                            vboxModel);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                            _(\"Failed to change storage controller model, \"\n                              \"rc=%08x\"), rc);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_UTF16_FREE(controllerName);\n    VBOX_UTF8_FREE(debugName);\n    VBOX_RELEASE(vboxController);\n\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxSetStorageController(virDomainControllerDefPtr controller,\n                         vboxDriverPtr data,\n                         IMachine *machine)\n{\n    PRUnichar *controllerName = NULL;\n    PRInt32 vboxModel = StorageControllerType_Null;\n    PRInt32 vboxBusType = StorageBus_Null;\n    IStorageController *vboxController = NULL;\n    nsresult rc = 0;\n    char *debugName = NULL;\n    int ret = -1;\n\n    /* libvirt controller type => vbox bus type */\n    switch ((virDomainControllerType) controller->type) {\n    case VIR_DOMAIN_CONTROLLER_TYPE_FDC:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_FLOPPY_NAME, &controllerName);\n        vboxBusType = StorageBus_Floppy;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_IDE:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_IDE_NAME, &controllerName);\n        vboxBusType = StorageBus_IDE;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_SCSI:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SCSI_NAME, &controllerName);\n        vboxBusType = StorageBus_SCSI;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SATA_NAME, &controllerName);\n        vboxBusType = StorageBus_SATA;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL:\n    case VIR_DOMAIN_CONTROLLER_TYPE_CCID:\n    case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n    case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n    case VIR_DOMAIN_CONTROLLER_TYPE_XENBUS:\n    case VIR_DOMAIN_CONTROLLER_TYPE_LAST:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"The vbox driver does not support %s controller type\"),\n                       virDomainControllerTypeToString(controller->type));\n        return -1;\n    }\n\n    /* libvirt scsi model => vbox scsi model */\n    if (controller->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI) {\n        switch ((virDomainControllerModelSCSI) controller->model) {\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AUTO:\n            vboxModel = StorageControllerType_LsiLogic;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC:\n            vboxModel = StorageControllerType_BusLogic;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068:\n            /* in vbox, lsisas has a dedicated SAS bus type with no model */\n            VBOX_UTF16_FREE(controllerName);\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SAS_NAME, &controllerName);\n            vboxBusType = StorageBus_SAS;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_TRANSITIONAL:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_NON_TRANSITIONAL:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1078:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"The vbox driver does not support %s SCSI \"\n                             \"controller model\"),\n                           virDomainControllerModelSCSITypeToString(controller->model));\n            goto cleanup;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DEFAULT:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LAST:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected SCSI controller model %d\"),\n                           controller->model);\n            goto cleanup;\n        }\n    /* libvirt ide model => vbox ide model */\n    } else if (controller->type == VIR_DOMAIN_CONTROLLER_TYPE_IDE) {\n        switch ((virDomainControllerModelIDE) controller->model) {\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX3:\n            vboxModel = StorageControllerType_PIIX3;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX4:\n            vboxModel = StorageControllerType_PIIX4;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_ICH6:\n            vboxModel = StorageControllerType_ICH6;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_LAST:\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_DEFAULT:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unexpected IDE controller model %d\"),\n                           controller->model);\n            goto cleanup;\n        }\n    }\n\n    VBOX_UTF16_TO_UTF8(controllerName, &debugName);\n    VIR_DEBUG(\"Adding VBOX storage controller (name: %s, busType: %d)\",\n               debugName, vboxBusType);\n\n    rc = gVBoxAPI.UIMachine.AddStorageController(machine, controllerName,\n                                                 vboxBusType, &vboxController);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to add storage controller \"\n                         \"(name: %s, busType: %d), rc=%08x\"),\n                       debugName, vboxBusType, rc);\n        goto cleanup;\n    }\n\n    /* only IDE or SCSI controller have model choices */\n    if (vboxModel != StorageControllerType_Null) {\n        rc = gVBoxAPI.UIStorageController.SetControllerType(vboxController,\n                                                            vboxModel);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                            _(\"Failed to change storage controller model, \"\n                              \"rc=%08x\"), rc);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_UTF16_FREE(controllerName);\n    VBOX_UTF8_FREE(debugName);\n    VBOX_RELEASE(vboxController);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvboxAttachStorageControllers(virDomainDefPtr def,\n                             vboxDriverPtr data,\n                             IMachine *machine)\n{\n    size_t i;\n    for (i = 0; i < def->ncontrollers; i++) {\n        if (vboxSetStorageController(def->controllers[i], data, machine) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vboxSetStorageController",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "338-481",
    "snippet": "static int\nvboxSetStorageController(virDomainControllerDefPtr controller,\n                         vboxDriverPtr data,\n                         IMachine *machine)\n{\n    PRUnichar *controllerName = NULL;\n    PRInt32 vboxModel = StorageControllerType_Null;\n    PRInt32 vboxBusType = StorageBus_Null;\n    IStorageController *vboxController = NULL;\n    nsresult rc = 0;\n    char *debugName = NULL;\n    int ret = -1;\n\n    /* libvirt controller type => vbox bus type */\n    switch ((virDomainControllerType) controller->type) {\n    case VIR_DOMAIN_CONTROLLER_TYPE_FDC:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_FLOPPY_NAME, &controllerName);\n        vboxBusType = StorageBus_Floppy;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_IDE:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_IDE_NAME, &controllerName);\n        vboxBusType = StorageBus_IDE;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_SCSI:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SCSI_NAME, &controllerName);\n        vboxBusType = StorageBus_SCSI;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SATA_NAME, &controllerName);\n        vboxBusType = StorageBus_SATA;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL:\n    case VIR_DOMAIN_CONTROLLER_TYPE_CCID:\n    case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n    case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n    case VIR_DOMAIN_CONTROLLER_TYPE_XENBUS:\n    case VIR_DOMAIN_CONTROLLER_TYPE_LAST:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"The vbox driver does not support %s controller type\"),\n                       virDomainControllerTypeToString(controller->type));\n        return -1;\n    }\n\n    /* libvirt scsi model => vbox scsi model */\n    if (controller->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI) {\n        switch ((virDomainControllerModelSCSI) controller->model) {\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AUTO:\n            vboxModel = StorageControllerType_LsiLogic;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC:\n            vboxModel = StorageControllerType_BusLogic;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068:\n            /* in vbox, lsisas has a dedicated SAS bus type with no model */\n            VBOX_UTF16_FREE(controllerName);\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SAS_NAME, &controllerName);\n            vboxBusType = StorageBus_SAS;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_TRANSITIONAL:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_NON_TRANSITIONAL:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1078:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"The vbox driver does not support %s SCSI \"\n                             \"controller model\"),\n                           virDomainControllerModelSCSITypeToString(controller->model));\n            goto cleanup;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DEFAULT:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LAST:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected SCSI controller model %d\"),\n                           controller->model);\n            goto cleanup;\n        }\n    /* libvirt ide model => vbox ide model */\n    } else if (controller->type == VIR_DOMAIN_CONTROLLER_TYPE_IDE) {\n        switch ((virDomainControllerModelIDE) controller->model) {\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX3:\n            vboxModel = StorageControllerType_PIIX3;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX4:\n            vboxModel = StorageControllerType_PIIX4;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_ICH6:\n            vboxModel = StorageControllerType_ICH6;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_LAST:\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_DEFAULT:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unexpected IDE controller model %d\"),\n                           controller->model);\n            goto cleanup;\n        }\n    }\n\n    VBOX_UTF16_TO_UTF8(controllerName, &debugName);\n    VIR_DEBUG(\"Adding VBOX storage controller (name: %s, busType: %d)\",\n               debugName, vboxBusType);\n\n    rc = gVBoxAPI.UIMachine.AddStorageController(machine, controllerName,\n                                                 vboxBusType, &vboxController);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to add storage controller \"\n                         \"(name: %s, busType: %d), rc=%08x\"),\n                       debugName, vboxBusType, rc);\n        goto cleanup;\n    }\n\n    /* only IDE or SCSI controller have model choices */\n    if (vboxModel != StorageControllerType_Null) {\n        rc = gVBoxAPI.UIStorageController.SetControllerType(vboxController,\n                                                            vboxModel);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                            _(\"Failed to change storage controller model, \"\n                              \"rc=%08x\"), rc);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_UTF16_FREE(controllerName);\n    VBOX_UTF8_FREE(debugName);\n    VBOX_RELEASE(vboxController);\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VBOX_RELEASE",
          "args": [
            "vboxController"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_FREE",
          "args": [
            "debugName"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "controllerName"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to change storage controller model, \"\n                              \"rc=%08x\")",
            "rc"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to change storage controller model, \"\n                              \"rc=%08x\""
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIStorageController.SetControllerType",
          "args": [
            "vboxController",
            "vboxModel"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to add storage controller \"\n                         \"(name: %s, busType: %d), rc=%08x\")",
            "debugName",
            "vboxBusType",
            "rc"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIMachine.AddStorageController",
          "args": [
            "machine",
            "controllerName",
            "vboxBusType",
            "&vboxController"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Adding VBOX storage controller (name: %s, busType: %d)\"",
            "debugName",
            "vboxBusType"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_TO_UTF8",
          "args": [
            "controllerName",
            "&debugName"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Unexpected IDE controller model %d\")",
            "controller->model"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected SCSI controller model %d\")",
            "controller->model"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"The vbox driver does not support %s SCSI \"\n                             \"controller model\")",
            "virDomainControllerModelSCSITypeToString(controller->model)"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainControllerModelSCSITypeToString",
          "args": [
            "controller->model"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "VBOX_CONTROLLER_SAS_NAME",
            "&controllerName"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF16_FREE",
          "args": [
            "controllerName"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"The vbox driver does not support %s controller type\")",
            "virDomainControllerTypeToString(controller->type)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainControllerTypeToString",
          "args": [
            "controller->type"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "VBOX_CONTROLLER_SATA_NAME",
            "&controllerName"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "VBOX_CONTROLLER_SCSI_NAME",
            "&controllerName"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "VBOX_CONTROLLER_IDE_NAME",
            "&controllerName"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_UTF8_TO_UTF16",
          "args": [
            "VBOX_CONTROLLER_FLOPPY_NAME",
            "&controllerName"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int\nvboxSetStorageController(virDomainControllerDefPtr controller,\n                         vboxDriverPtr data,\n                         IMachine *machine)\n{\n    PRUnichar *controllerName = NULL;\n    PRInt32 vboxModel = StorageControllerType_Null;\n    PRInt32 vboxBusType = StorageBus_Null;\n    IStorageController *vboxController = NULL;\n    nsresult rc = 0;\n    char *debugName = NULL;\n    int ret = -1;\n\n    /* libvirt controller type => vbox bus type */\n    switch ((virDomainControllerType) controller->type) {\n    case VIR_DOMAIN_CONTROLLER_TYPE_FDC:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_FLOPPY_NAME, &controllerName);\n        vboxBusType = StorageBus_Floppy;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_IDE:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_IDE_NAME, &controllerName);\n        vboxBusType = StorageBus_IDE;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_SCSI:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SCSI_NAME, &controllerName);\n        vboxBusType = StorageBus_SCSI;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_SATA:\n        VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SATA_NAME, &controllerName);\n        vboxBusType = StorageBus_SATA;\n\n        break;\n    case VIR_DOMAIN_CONTROLLER_TYPE_VIRTIO_SERIAL:\n    case VIR_DOMAIN_CONTROLLER_TYPE_CCID:\n    case VIR_DOMAIN_CONTROLLER_TYPE_USB:\n    case VIR_DOMAIN_CONTROLLER_TYPE_PCI:\n    case VIR_DOMAIN_CONTROLLER_TYPE_XENBUS:\n    case VIR_DOMAIN_CONTROLLER_TYPE_LAST:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"The vbox driver does not support %s controller type\"),\n                       virDomainControllerTypeToString(controller->type));\n        return -1;\n    }\n\n    /* libvirt scsi model => vbox scsi model */\n    if (controller->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI) {\n        switch ((virDomainControllerModelSCSI) controller->model) {\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_AUTO:\n            vboxModel = StorageControllerType_LsiLogic;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC:\n            vboxModel = StorageControllerType_BusLogic;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068:\n            /* in vbox, lsisas has a dedicated SAS bus type with no model */\n            VBOX_UTF16_FREE(controllerName);\n            VBOX_UTF8_TO_UTF16(VBOX_CONTROLLER_SAS_NAME, &controllerName);\n            vboxBusType = StorageBus_SAS;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_IBMVSCSI:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_TRANSITIONAL:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_NON_TRANSITIONAL:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1078:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"The vbox driver does not support %s SCSI \"\n                             \"controller model\"),\n                           virDomainControllerModelSCSITypeToString(controller->model));\n            goto cleanup;\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_DEFAULT:\n        case VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LAST:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unexpected SCSI controller model %d\"),\n                           controller->model);\n            goto cleanup;\n        }\n    /* libvirt ide model => vbox ide model */\n    } else if (controller->type == VIR_DOMAIN_CONTROLLER_TYPE_IDE) {\n        switch ((virDomainControllerModelIDE) controller->model) {\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX3:\n            vboxModel = StorageControllerType_PIIX3;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_PIIX4:\n            vboxModel = StorageControllerType_PIIX4;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_ICH6:\n            vboxModel = StorageControllerType_ICH6;\n\n            break;\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_LAST:\n        case VIR_DOMAIN_CONTROLLER_MODEL_IDE_DEFAULT:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unexpected IDE controller model %d\"),\n                           controller->model);\n            goto cleanup;\n        }\n    }\n\n    VBOX_UTF16_TO_UTF8(controllerName, &debugName);\n    VIR_DEBUG(\"Adding VBOX storage controller (name: %s, busType: %d)\",\n               debugName, vboxBusType);\n\n    rc = gVBoxAPI.UIMachine.AddStorageController(machine, controllerName,\n                                                 vboxBusType, &vboxController);\n\n    if (NS_FAILED(rc)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to add storage controller \"\n                         \"(name: %s, busType: %d), rc=%08x\"),\n                       debugName, vboxBusType, rc);\n        goto cleanup;\n    }\n\n    /* only IDE or SCSI controller have model choices */\n    if (vboxModel != StorageControllerType_Null) {\n        rc = gVBoxAPI.UIStorageController.SetControllerType(vboxController,\n                                                            vboxModel);\n        if (NS_FAILED(rc)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                            _(\"Failed to change storage controller model, \"\n                              \"rc=%08x\"), rc);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    VBOX_UTF16_FREE(controllerName);\n    VBOX_UTF8_FREE(debugName);\n    VBOX_RELEASE(vboxController);\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxGenerateMediumName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "299-335",
    "snippet": "static char *\nvboxGenerateMediumName(PRUint32 storageBus,\n                       PRInt32 devicePort,\n                       PRInt32 deviceSlot,\n                       size_t sdCount)\n{\n    const char *prefix = NULL;\n    char *name = NULL;\n    int total = 0;\n\n    switch ((enum StorageBus) storageBus) {\n    case StorageBus_IDE:\n        prefix = \"hd\";\n        total = devicePort * 2 + deviceSlot;\n\n        break;\n    case StorageBus_SATA:\n    case StorageBus_SCSI:\n    case StorageBus_SAS:\n        prefix = \"sd\";\n        total = sdCount;\n\n        break;\n    case StorageBus_Floppy:\n        total = deviceSlot;\n        prefix = \"fd\";\n\n        break;\n    case StorageBus_Null:\n\n        return NULL;\n    }\n\n    name = virIndexToDiskName(total, prefix);\n\n    return name;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virIndexToDiskName",
          "args": [
            "total",
            "prefix"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "virIndexToDiskName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "436-463",
          "snippet": "char *virIndexToDiskName(int idx, const char *prefix)\n{\n    char *name = NULL;\n    size_t i;\n    int ctr;\n    int offset;\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Disk index %d is negative\"), idx);\n        return NULL;\n    }\n\n    for (i = 0, ctr = idx; ctr >= 0; ++i, ctr = ctr / 26 - 1) { }\n\n    offset = strlen(prefix);\n\n    if (VIR_ALLOC_N(name, offset + i + 1))\n        return NULL;\n\n    strcpy(name, prefix);\n    name[offset + i] = '\\0';\n\n    for (i = i - 1, ctr = idx; ctr >= 0; --i, ctr = ctr / 26 - 1)\n        name[offset + i] = 'a' + (ctr % 26);\n\n    return name;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virIndexToDiskName(int idx, const char *prefix)\n{\n    char *name = NULL;\n    size_t i;\n    int ctr;\n    int offset;\n\n    if (idx < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Disk index %d is negative\"), idx);\n        return NULL;\n    }\n\n    for (i = 0, ctr = idx; ctr >= 0; ++i, ctr = ctr / 26 - 1) { }\n\n    offset = strlen(prefix);\n\n    if (VIR_ALLOC_N(name, offset + i + 1))\n        return NULL;\n\n    strcpy(name, prefix);\n    name[offset + i] = '\\0';\n\n    for (i = i - 1, ctr = idx; ctr >= 0; --i, ctr = ctr / 26 - 1)\n        name[offset + i] = 'a' + (ctr % 26);\n\n    return name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic char *\nvboxGenerateMediumName(PRUint32 storageBus,\n                       PRInt32 devicePort,\n                       PRInt32 deviceSlot,\n                       size_t sdCount)\n{\n    const char *prefix = NULL;\n    char *name = NULL;\n    int total = 0;\n\n    switch ((enum StorageBus) storageBus) {\n    case StorageBus_IDE:\n        prefix = \"hd\";\n        total = devicePort * 2 + deviceSlot;\n\n        break;\n    case StorageBus_SATA:\n    case StorageBus_SCSI:\n    case StorageBus_SAS:\n        prefix = \"sd\";\n        total = sdCount;\n\n        break;\n    case StorageBus_Floppy:\n        total = deviceSlot;\n        prefix = \"fd\";\n\n        break;\n    case StorageBus_Null:\n\n        return NULL;\n    }\n\n    name = virIndexToDiskName(total, prefix);\n\n    return name;\n}"
  },
  {
    "function_name": "openSessionForMachine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "271-285",
    "snippet": "static int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "\"%s\"",
            "_(\"no domain with matching uuid\")"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no domain with matching uuid\""
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetMachine",
          "args": [
            "data->vboxObj",
            "iid",
            "machine"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxIIDFromUUID",
          "args": [
            "iid",
            "dom_uuid"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VBOX_IID_INITIALIZE",
          "args": [
            "iid"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\n\nstatic int openSessionForMachine(vboxDriverPtr data, const unsigned char *dom_uuid,\n                                 vboxIID *iid, IMachine **machine)\n{\n    VBOX_IID_INITIALIZE(iid);\n    vboxIIDFromUUID(iid, dom_uuid);\n\n    /* Get machine for the call to VBOX_SESSION_OPEN_EXISTING */\n    if (NS_FAILED(gVBoxAPI.UIVirtualBox.GetMachine(data->vboxObj, iid, machine))) {\n        virReportError(VIR_ERR_NO_DOMAIN, \"%s\",\n                       _(\"no domain with matching uuid\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vboxDestroyDriverConnection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "252-269",
    "snippet": "static void\nvboxDestroyDriverConnection(void)\n{\n    virMutexLock(&vbox_driver_lock);\n\n    if (!vbox_driver)\n        goto cleanup;\n\n    vbox_driver->connectionCount--;\n\n    vboxSdkUninitialize();\n\n    if (!virObjectUnref(vbox_driver))\n        vbox_driver = NULL;\n\n cleanup:\n    virMutexUnlock(&vbox_driver_lock);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virMutex vbox_driver_lock = VIR_MUTEX_INITIALIZER;",
      "static vboxDriverPtr vbox_driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&vbox_driver_lock"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "vbox_driver"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxSdkUninitialize",
          "args": [],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "vboxSdkUninitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "207-215",
          "snippet": "static void\nvboxSdkUninitialize(void)\n{\n    /* do not uninitialize, when there are still connection using it */\n    if (vbox_driver->connectionCount > 0)\n        return;\n\n    gVBoxAPI.UPFN.Uninitialize(vbox_driver);\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;",
            "static vboxDriverPtr vbox_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\nstatic vboxDriverPtr vbox_driver;\n\nstatic void\nvboxSdkUninitialize(void)\n{\n    /* do not uninitialize, when there are still connection using it */\n    if (vbox_driver->connectionCount > 0)\n        return;\n\n    gVBoxAPI.UPFN.Uninitialize(vbox_driver);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&vbox_driver_lock"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virMutex vbox_driver_lock = VIR_MUTEX_INITIALIZER;\nstatic vboxDriverPtr vbox_driver;\n\nstatic void\nvboxDestroyDriverConnection(void)\n{\n    virMutexLock(&vbox_driver_lock);\n\n    if (!vbox_driver)\n        goto cleanup;\n\n    vbox_driver->connectionCount--;\n\n    vboxSdkUninitialize();\n\n    if (!virObjectUnref(vbox_driver))\n        vbox_driver = NULL;\n\n cleanup:\n    virMutexUnlock(&vbox_driver_lock);\n}"
  },
  {
    "function_name": "vboxGetDriverConnection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "217-250",
    "snippet": "static vboxDriverPtr\nvboxGetDriverConnection(void)\n{\n    virMutexLock(&vbox_driver_lock);\n\n    if (vbox_driver) {\n        virObjectRef(vbox_driver);\n    } else {\n        vbox_driver = vboxDriverObjNew();\n\n        if (!vbox_driver) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Failed to create vbox driver object.\"));\n            return NULL;\n        }\n    }\n\n    if (vboxSdkInitialize() < 0 || vboxExtractVersion() < 0) {\n        gVBoxAPI.UPFN.Uninitialize(vbox_driver);\n        /* make sure to clear the pointer when last reference was released */\n        if (!virObjectUnref(vbox_driver))\n            vbox_driver = NULL;\n\n        virMutexUnlock(&vbox_driver_lock);\n\n        return NULL;\n    }\n\n    vbox_driver->connectionCount++;\n\n    virMutexUnlock(&vbox_driver_lock);\n\n    return vbox_driver;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;",
      "static virMutex vbox_driver_lock = VIR_MUTEX_INITIALIZER;",
      "static vboxDriverPtr vbox_driver;",
      "static vboxDriverPtr vboxDriverObjNew(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMutexUnlock",
          "args": [
            "&vbox_driver_lock"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "86-89",
          "snippet": "void virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexUnlock(virMutexPtr m)\n{\n    pthread_mutex_unlock(&m->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "vbox_driver"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UPFN.Uninitialize",
          "args": [
            "vbox_driver"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vboxExtractVersion",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "vboxExtractVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "149-180",
          "snippet": "static int\nvboxExtractVersion(void)\n{\n    int ret = -1;\n    PRUnichar *versionUtf16 = NULL;\n    char *vboxVersion = NULL;\n    nsresult rc;\n\n    if (vbox_driver->version > 0)\n        return 0;\n\n    rc = gVBoxAPI.UIVirtualBox.GetVersion(vbox_driver->vboxObj, &versionUtf16);\n    if (NS_FAILED(rc))\n        goto failed;\n\n    gVBoxAPI.UPFN.Utf16ToUtf8(vbox_driver->pFuncs, versionUtf16, &vboxVersion);\n\n    if (virParseVersionString(vboxVersion, &vbox_driver->version, false) >= 0)\n        ret = 0;\n\n    gVBoxAPI.UPFN.Utf8Free(vbox_driver->pFuncs, vboxVersion);\n    gVBoxAPI.UPFN.ComUnallocMem(vbox_driver->pFuncs, versionUtf16);\n    vboxVersion = NULL;\n    versionUtf16 = NULL;\n\n failed:\n    if (ret != 0)\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not extract VirtualBox version\"));\n\n    return ret;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;",
            "static vboxDriverPtr vbox_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\nstatic vboxDriverPtr vbox_driver;\n\nstatic int\nvboxExtractVersion(void)\n{\n    int ret = -1;\n    PRUnichar *versionUtf16 = NULL;\n    char *vboxVersion = NULL;\n    nsresult rc;\n\n    if (vbox_driver->version > 0)\n        return 0;\n\n    rc = gVBoxAPI.UIVirtualBox.GetVersion(vbox_driver->vboxObj, &versionUtf16);\n    if (NS_FAILED(rc))\n        goto failed;\n\n    gVBoxAPI.UPFN.Utf16ToUtf8(vbox_driver->pFuncs, versionUtf16, &vboxVersion);\n\n    if (virParseVersionString(vboxVersion, &vbox_driver->version, false) >= 0)\n        ret = 0;\n\n    gVBoxAPI.UPFN.Utf8Free(vbox_driver->pFuncs, vboxVersion);\n    gVBoxAPI.UPFN.ComUnallocMem(vbox_driver->pFuncs, versionUtf16);\n    vboxVersion = NULL;\n    versionUtf16 = NULL;\n\n failed:\n    if (ret != 0)\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not extract VirtualBox version\"));\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxSdkInitialize",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "vboxSdkInitialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "182-205",
          "snippet": "static int\nvboxSdkInitialize(void)\n{\n    /* vbox API was already initialized by first connection */\n    if (vbox_driver->connectionCount > 0)\n        return 0;\n\n    if (gVBoxAPI.UPFN.Initialize(vbox_driver) != 0)\n        return -1;\n\n    if (vbox_driver->vboxObj == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"IVirtualBox object is null\"));\n        return -1;\n    }\n\n    if (vbox_driver->vboxSession == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ISession object is null\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static vboxUniformedAPI gVBoxAPI;",
            "static vboxDriverPtr vbox_driver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\nstatic vboxDriverPtr vbox_driver;\n\nstatic int\nvboxSdkInitialize(void)\n{\n    /* vbox API was already initialized by first connection */\n    if (vbox_driver->connectionCount > 0)\n        return 0;\n\n    if (gVBoxAPI.UPFN.Initialize(vbox_driver) != 0)\n        return -1;\n\n    if (vbox_driver->vboxObj == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"IVirtualBox object is null\"));\n        return -1;\n    }\n\n    if (vbox_driver->vboxSession == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ISession object is null\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to create vbox driver object.\")"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to create vbox driver object.\""
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDriverObjNew",
          "args": [],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "vboxDriverObjNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "126-147",
          "snippet": "static vboxDriverPtr\nvboxDriverObjNew(void)\n{\n    vboxDriverPtr driver;\n\n    if (vboxDriverInitialize() < 0)\n        return NULL;\n\n    if (!(driver = virObjectLockableNew(vboxDriverClass)))\n        return NULL;\n\n    if (!(driver->caps = vboxCapsInit()) ||\n        !(driver->xmlopt = virDomainXMLOptionNew(&vboxDomainDefParserConfig,\n                                                 NULL, NULL, NULL, NULL)))\n        goto cleanup;\n\n    return driver;\n\n cleanup:\n    virObjectUnref(driver);\n    return NULL;\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr vboxDriverClass;",
            "static vboxDriverPtr vboxDriverObjNew(void);",
            "static virDomainDefParserConfig vboxDomainDefParserConfig = {\n    .macPrefix = { 0x08, 0x00, 0x27 },\n    .features = VIR_DOMAIN_DEF_FEATURE_NAME_SLASH,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr vboxDriverClass;\nstatic vboxDriverPtr vboxDriverObjNew(void);\nstatic virDomainDefParserConfig vboxDomainDefParserConfig = {\n    .macPrefix = { 0x08, 0x00, 0x27 },\n    .features = VIR_DOMAIN_DEF_FEATURE_NAME_SLASH,\n};\n\nstatic vboxDriverPtr\nvboxDriverObjNew(void)\n{\n    vboxDriverPtr driver;\n\n    if (vboxDriverInitialize() < 0)\n        return NULL;\n\n    if (!(driver = virObjectLockableNew(vboxDriverClass)))\n        return NULL;\n\n    if (!(driver->caps = vboxCapsInit()) ||\n        !(driver->xmlopt = virDomainXMLOptionNew(&vboxDomainDefParserConfig,\n                                                 NULL, NULL, NULL, NULL)))\n        goto cleanup;\n\n    return driver;\n\n cleanup:\n    virObjectUnref(driver);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "vbox_driver"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMutexLock",
          "args": [
            "&vbox_driver_lock"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "virMutexLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "81-84",
          "snippet": "void virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virMutexLock(virMutexPtr m)\n{\n    pthread_mutex_lock(&m->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\nstatic virMutex vbox_driver_lock = VIR_MUTEX_INITIALIZER;\nstatic vboxDriverPtr vbox_driver;\nstatic vboxDriverPtr vboxDriverObjNew(void);\n\nstatic vboxDriverPtr\nvboxGetDriverConnection(void)\n{\n    virMutexLock(&vbox_driver_lock);\n\n    if (vbox_driver) {\n        virObjectRef(vbox_driver);\n    } else {\n        vbox_driver = vboxDriverObjNew();\n\n        if (!vbox_driver) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Failed to create vbox driver object.\"));\n            return NULL;\n        }\n    }\n\n    if (vboxSdkInitialize() < 0 || vboxExtractVersion() < 0) {\n        gVBoxAPI.UPFN.Uninitialize(vbox_driver);\n        /* make sure to clear the pointer when last reference was released */\n        if (!virObjectUnref(vbox_driver))\n            vbox_driver = NULL;\n\n        virMutexUnlock(&vbox_driver_lock);\n\n        return NULL;\n    }\n\n    vbox_driver->connectionCount++;\n\n    virMutexUnlock(&vbox_driver_lock);\n\n    return vbox_driver;\n}"
  },
  {
    "function_name": "vboxSdkUninitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "207-215",
    "snippet": "static void\nvboxSdkUninitialize(void)\n{\n    /* do not uninitialize, when there are still connection using it */\n    if (vbox_driver->connectionCount > 0)\n        return;\n\n    gVBoxAPI.UPFN.Uninitialize(vbox_driver);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;",
      "static vboxDriverPtr vbox_driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gVBoxAPI.UPFN.Uninitialize",
          "args": [
            "vbox_driver"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\nstatic vboxDriverPtr vbox_driver;\n\nstatic void\nvboxSdkUninitialize(void)\n{\n    /* do not uninitialize, when there are still connection using it */\n    if (vbox_driver->connectionCount > 0)\n        return;\n\n    gVBoxAPI.UPFN.Uninitialize(vbox_driver);\n}"
  },
  {
    "function_name": "vboxSdkInitialize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "182-205",
    "snippet": "static int\nvboxSdkInitialize(void)\n{\n    /* vbox API was already initialized by first connection */\n    if (vbox_driver->connectionCount > 0)\n        return 0;\n\n    if (gVBoxAPI.UPFN.Initialize(vbox_driver) != 0)\n        return -1;\n\n    if (vbox_driver->vboxObj == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"IVirtualBox object is null\"));\n        return -1;\n    }\n\n    if (vbox_driver->vboxSession == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ISession object is null\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;",
      "static vboxDriverPtr vbox_driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"ISession object is null\")"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"ISession object is null\""
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"IVirtualBox object is null\")"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UPFN.Initialize",
          "args": [
            "vbox_driver"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\nstatic vboxDriverPtr vbox_driver;\n\nstatic int\nvboxSdkInitialize(void)\n{\n    /* vbox API was already initialized by first connection */\n    if (vbox_driver->connectionCount > 0)\n        return 0;\n\n    if (gVBoxAPI.UPFN.Initialize(vbox_driver) != 0)\n        return -1;\n\n    if (vbox_driver->vboxObj == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"IVirtualBox object is null\"));\n        return -1;\n    }\n\n    if (vbox_driver->vboxSession == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ISession object is null\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "vboxExtractVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "149-180",
    "snippet": "static int\nvboxExtractVersion(void)\n{\n    int ret = -1;\n    PRUnichar *versionUtf16 = NULL;\n    char *vboxVersion = NULL;\n    nsresult rc;\n\n    if (vbox_driver->version > 0)\n        return 0;\n\n    rc = gVBoxAPI.UIVirtualBox.GetVersion(vbox_driver->vboxObj, &versionUtf16);\n    if (NS_FAILED(rc))\n        goto failed;\n\n    gVBoxAPI.UPFN.Utf16ToUtf8(vbox_driver->pFuncs, versionUtf16, &vboxVersion);\n\n    if (virParseVersionString(vboxVersion, &vbox_driver->version, false) >= 0)\n        ret = 0;\n\n    gVBoxAPI.UPFN.Utf8Free(vbox_driver->pFuncs, vboxVersion);\n    gVBoxAPI.UPFN.ComUnallocMem(vbox_driver->pFuncs, versionUtf16);\n    vboxVersion = NULL;\n    versionUtf16 = NULL;\n\n failed:\n    if (ret != 0)\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not extract VirtualBox version\"));\n\n    return ret;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static vboxUniformedAPI gVBoxAPI;",
      "static vboxDriverPtr vbox_driver;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not extract VirtualBox version\")"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not extract VirtualBox version\""
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "_machineStatePoweredOff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_tmpl.c",
          "lines": "2114-2117",
          "snippet": "static bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}",
          "includes": [
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_glue.h\"",
            "# include \"vbox_CAPI_v5_2.h\"",
            "# include \"vbox_CAPI_v5_1.h\"",
            "# include \"vbox_CAPI_v5_0.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_uniformed_api.h\"\n#include \"vbox_glue.h\"\n# include \"vbox_CAPI_v5_2.h\"\n# include \"vbox_CAPI_v5_1.h\"\n# include \"vbox_CAPI_v5_0.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"domain_event.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic bool _machineStatePoweredOff(PRUint32 state)\n{\n    return state == MachineState_PoweredOff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UPFN.ComUnallocMem",
          "args": [
            "vbox_driver->pFuncs",
            "versionUtf16"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UPFN.Utf8Free",
          "args": [
            "vbox_driver->pFuncs",
            "vboxVersion"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virParseVersionString",
          "args": [
            "vboxVersion",
            "&vbox_driver->version",
            "false"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "virParseVersionString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "254-282",
          "snippet": "int\nvirParseVersionString(const char *str, unsigned long *version,\n                      bool allowMissing)\n{\n    unsigned int major, minor = 0, micro = 0;\n    char *tmp;\n\n    if (virStrToLong_ui(str, &tmp, 10, &major) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &minor) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &micro) < 0)\n        return -1;\n\n    if (major > UINT_MAX / 1000000 || minor > 999 || micro > 999)\n        return -1;\n\n    *version = 1000000 * major + 1000 * minor + micro;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirParseVersionString(const char *str, unsigned long *version,\n                      bool allowMissing)\n{\n    unsigned int major, minor = 0, micro = 0;\n    char *tmp;\n\n    if (virStrToLong_ui(str, &tmp, 10, &major) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &minor) < 0)\n        return -1;\n\n    if (!allowMissing && *tmp != '.')\n        return -1;\n\n    if ((*tmp == '.') && virStrToLong_ui(tmp + 1, &tmp, 10, &micro) < 0)\n        return -1;\n\n    if (major > UINT_MAX / 1000000 || minor > 999 || micro > 999)\n        return -1;\n\n    *version = 1000000 * major + 1000 * minor + micro;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UPFN.Utf16ToUtf8",
          "args": [
            "vbox_driver->pFuncs",
            "versionUtf16",
            "&vboxVersion"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NS_FAILED",
          "args": [
            "rc"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gVBoxAPI.UIVirtualBox.GetVersion",
          "args": [
            "vbox_driver->vboxObj",
            "&versionUtf16"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic vboxUniformedAPI gVBoxAPI;\nstatic vboxDriverPtr vbox_driver;\n\nstatic int\nvboxExtractVersion(void)\n{\n    int ret = -1;\n    PRUnichar *versionUtf16 = NULL;\n    char *vboxVersion = NULL;\n    nsresult rc;\n\n    if (vbox_driver->version > 0)\n        return 0;\n\n    rc = gVBoxAPI.UIVirtualBox.GetVersion(vbox_driver->vboxObj, &versionUtf16);\n    if (NS_FAILED(rc))\n        goto failed;\n\n    gVBoxAPI.UPFN.Utf16ToUtf8(vbox_driver->pFuncs, versionUtf16, &vboxVersion);\n\n    if (virParseVersionString(vboxVersion, &vbox_driver->version, false) >= 0)\n        ret = 0;\n\n    gVBoxAPI.UPFN.Utf8Free(vbox_driver->pFuncs, vboxVersion);\n    gVBoxAPI.UPFN.ComUnallocMem(vbox_driver->pFuncs, versionUtf16);\n    vboxVersion = NULL;\n    versionUtf16 = NULL;\n\n failed:\n    if (ret != 0)\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not extract VirtualBox version\"));\n\n    return ret;\n}"
  },
  {
    "function_name": "vboxDriverObjNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "126-147",
    "snippet": "static vboxDriverPtr\nvboxDriverObjNew(void)\n{\n    vboxDriverPtr driver;\n\n    if (vboxDriverInitialize() < 0)\n        return NULL;\n\n    if (!(driver = virObjectLockableNew(vboxDriverClass)))\n        return NULL;\n\n    if (!(driver->caps = vboxCapsInit()) ||\n        !(driver->xmlopt = virDomainXMLOptionNew(&vboxDomainDefParserConfig,\n                                                 NULL, NULL, NULL, NULL)))\n        goto cleanup;\n\n    return driver;\n\n cleanup:\n    virObjectUnref(driver);\n    return NULL;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr vboxDriverClass;",
      "static vboxDriverPtr vboxDriverObjNew(void);",
      "static virDomainDefParserConfig vboxDomainDefParserConfig = {\n    .macPrefix = { 0x08, 0x00, 0x27 },\n    .features = VIR_DOMAIN_DEF_FEATURE_NAME_SLASH,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "driver"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainXMLOptionNew",
          "args": [
            "&vboxDomainDefParserConfig",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainXMLOptionNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "1415-1458",
          "snippet": "virDomainXMLOptionPtr\nvirDomainXMLOptionNew(virDomainDefParserConfigPtr config,\n                      virDomainXMLPrivateDataCallbacksPtr priv,\n                      virXMLNamespacePtr xmlns,\n                      virDomainABIStabilityPtr abi,\n                      virSaveCookieCallbacksPtr saveCookie)\n{\n    virDomainXMLOptionPtr xmlopt;\n\n    if (virDomainObjInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virDomainXMLOptionClass)))\n        return NULL;\n\n    if (priv)\n        xmlopt->privateData = *priv;\n\n    if (config)\n        xmlopt->config = *config;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    if (abi)\n        xmlopt->abi = *abi;\n\n    if (saveCookie)\n        xmlopt->saveCookie = *saveCookie;\n\n    /* Technically this forbids to use one of Xerox's MAC address prefixes in\n     * our hypervisor drivers. This shouldn't ever be a problem.\n     *\n     * Use the KVM prefix as default as it's in the privately administered\n     * range */\n    if (xmlopt->config.macPrefix[0] == 0 &&\n        xmlopt->config.macPrefix[1] == 0 &&\n        xmlopt->config.macPrefix[2] == 0) {\n        xmlopt->config.macPrefix[0] = 0x52;\n        xmlopt->config.macPrefix[1] = 0x54;\n    }\n\n    return xmlopt;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virDomainXMLOptionClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virClassPtr virDomainXMLOptionClass;\n\nvirDomainXMLOptionPtr\nvirDomainXMLOptionNew(virDomainDefParserConfigPtr config,\n                      virDomainXMLPrivateDataCallbacksPtr priv,\n                      virXMLNamespacePtr xmlns,\n                      virDomainABIStabilityPtr abi,\n                      virSaveCookieCallbacksPtr saveCookie)\n{\n    virDomainXMLOptionPtr xmlopt;\n\n    if (virDomainObjInitialize() < 0)\n        return NULL;\n\n    if (!(xmlopt = virObjectNew(virDomainXMLOptionClass)))\n        return NULL;\n\n    if (priv)\n        xmlopt->privateData = *priv;\n\n    if (config)\n        xmlopt->config = *config;\n\n    if (xmlns)\n        xmlopt->ns = *xmlns;\n\n    if (abi)\n        xmlopt->abi = *abi;\n\n    if (saveCookie)\n        xmlopt->saveCookie = *saveCookie;\n\n    /* Technically this forbids to use one of Xerox's MAC address prefixes in\n     * our hypervisor drivers. This shouldn't ever be a problem.\n     *\n     * Use the KVM prefix as default as it's in the privately administered\n     * range */\n    if (xmlopt->config.macPrefix[0] == 0 &&\n        xmlopt->config.macPrefix[1] == 0 &&\n        xmlopt->config.macPrefix[2] == 0) {\n        xmlopt->config.macPrefix[0] = 0x52;\n        xmlopt->config.macPrefix[1] = 0x54;\n    }\n\n    return xmlopt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxCapsInit",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "vboxCapsInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
          "lines": "70-104",
          "snippet": "static virCapsPtr\nvboxCapsInit(void)\n{\n    g_autoptr(virCaps) caps = NULL;\n    virCapsGuestPtr guest = NULL;\n\n    if ((caps = virCapabilitiesNew(virArchFromHost(),\n                                   false, false)) == NULL)\n        return NULL;\n\n    if (!(caps->host.numa = virCapabilitiesHostNUMANewHost()))\n        return NULL;\n\n    if (virCapabilitiesInitCaches(caps) < 0)\n        return NULL;\n\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_HVM,\n                                         caps->host.arch,\n                                         NULL,\n                                         NULL,\n                                         0,\n                                         NULL)) == NULL)\n        return NULL;\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_VBOX,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL)\n        return NULL;\n\n    return g_steal_pointer(&caps);\n}",
          "includes": [
            "#include \"vbox_get_driver.h\"",
            "#include \"vbox_uniformed_api.h\"",
            "#include \"vbox_common.h\"",
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virfdstream.h\"",
            "#include \"vbox_snapshot_conf.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virkeycode.h\"",
            "#include \"virtime.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virhostmem.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_event.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virCapsPtr\nvboxCapsInit(void)\n{\n    g_autoptr(virCaps) caps = NULL;\n    virCapsGuestPtr guest = NULL;\n\n    if ((caps = virCapabilitiesNew(virArchFromHost(),\n                                   false, false)) == NULL)\n        return NULL;\n\n    if (!(caps->host.numa = virCapabilitiesHostNUMANewHost()))\n        return NULL;\n\n    if (virCapabilitiesInitCaches(caps) < 0)\n        return NULL;\n\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_HVM,\n                                         caps->host.arch,\n                                         NULL,\n                                         NULL,\n                                         0,\n                                         NULL)) == NULL)\n        return NULL;\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_VBOX,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL)\n        return NULL;\n\n    return g_steal_pointer(&caps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "vboxDriverClass"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vboxDriverInitialize",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr vboxDriverClass;\nstatic vboxDriverPtr vboxDriverObjNew(void);\nstatic virDomainDefParserConfig vboxDomainDefParserConfig = {\n    .macPrefix = { 0x08, 0x00, 0x27 },\n    .features = VIR_DOMAIN_DEF_FEATURE_NAME_SLASH,\n};\n\nstatic vboxDriverPtr\nvboxDriverObjNew(void)\n{\n    vboxDriverPtr driver;\n\n    if (vboxDriverInitialize() < 0)\n        return NULL;\n\n    if (!(driver = virObjectLockableNew(vboxDriverClass)))\n        return NULL;\n\n    if (!(driver->caps = vboxCapsInit()) ||\n        !(driver->xmlopt = virDomainXMLOptionNew(&vboxDomainDefParserConfig,\n                                                 NULL, NULL, NULL, NULL)))\n        goto cleanup;\n\n    return driver;\n\n cleanup:\n    virObjectUnref(driver);\n    return NULL;\n}"
  },
  {
    "function_name": "vboxDriverOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "115-122",
    "snippet": "static int\nvboxDriverOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(vboxDriver, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "vboxDriver",
            "virClassForObjectLockable()"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int\nvboxDriverOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(vboxDriver, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "vboxDriverDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "106-113",
    "snippet": "static void\nvboxDriverDispose(void *obj)\n{\n    vboxDriverPtr driver = obj;\n\n    virObjectUnref(driver->caps);\n    virObjectUnref(driver->xmlopt);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "driver->xmlopt"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic void\nvboxDriverDispose(void *obj)\n{\n    vboxDriverPtr driver = obj;\n\n    virObjectUnref(driver->caps);\n    virObjectUnref(driver->xmlopt);\n}"
  },
  {
    "function_name": "vboxCapsInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vbox/vbox_common.c",
    "lines": "70-104",
    "snippet": "static virCapsPtr\nvboxCapsInit(void)\n{\n    g_autoptr(virCaps) caps = NULL;\n    virCapsGuestPtr guest = NULL;\n\n    if ((caps = virCapabilitiesNew(virArchFromHost(),\n                                   false, false)) == NULL)\n        return NULL;\n\n    if (!(caps->host.numa = virCapabilitiesHostNUMANewHost()))\n        return NULL;\n\n    if (virCapabilitiesInitCaches(caps) < 0)\n        return NULL;\n\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_HVM,\n                                         caps->host.arch,\n                                         NULL,\n                                         NULL,\n                                         0,\n                                         NULL)) == NULL)\n        return NULL;\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_VBOX,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL)\n        return NULL;\n\n    return g_steal_pointer(&caps);\n}",
    "includes": [
      "#include \"vbox_get_driver.h\"",
      "#include \"vbox_uniformed_api.h\"",
      "#include \"vbox_common.h\"",
      "#include \"configmake.h\"",
      "#include \"virutil.h\"",
      "#include \"virfdstream.h\"",
      "#include \"vbox_snapshot_conf.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virkeycode.h\"",
      "#include \"virtime.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"virhostmem.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_event.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"datatypes.h\"",
      "#include \"internal.h\"",
      "#include <fcntl.h>",
      "#include <unistd.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&caps"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuestDomain",
          "args": [
            "guest",
            "VIR_DOMAIN_VIRT_VBOX",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuestDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "485-518",
          "snippet": "virCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuest",
          "args": [
            "caps",
            "VIR_DOMAIN_OSTYPE_HVM",
            "caps->host.arch",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "434-470",
          "snippet": "virCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesInitCaches",
          "args": [
            "caps"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesInitCaches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1857-2002",
          "snippet": "int\nvirCapabilitiesInitCaches(virCapsPtr caps)\n{\n    size_t i = 0;\n    virBitmapPtr cpus = NULL;\n    ssize_t pos = -1;\n    DIR *dirp = NULL;\n    int ret = -1;\n    char *path = NULL;\n    char *type = NULL;\n    struct dirent *ent = NULL;\n    virCapsHostCacheBankPtr bank = NULL;\n    const virResctrlMonitorType montype = VIR_RESCTRL_MONITOR_TYPE_CACHE;\n    const char *prefix = virResctrlMonitorPrefixTypeToString(montype);\n\n    /* Minimum level to expose in capabilities.  Can be lowered or removed (with\n     * the appropriate code below), but should not be increased, because we'd\n     * lose information. */\n    const int cache_min_level = 3;\n\n    if (virCapabilitiesInitResctrl(caps) < 0)\n        return -1;\n\n    /* offline CPUs don't provide cache info */\n    if (virFileReadValueBitmap(&cpus, \"%s/cpu/online\", SYSFS_SYSTEM_PATH) < 0)\n        return -1;\n\n    while ((pos = virBitmapNextSetBit(cpus, pos)) >= 0) {\n        int rv = -1;\n\n        VIR_FREE(path);\n        path = g_strdup_printf(\"%s/cpu/cpu%zd/cache/\", SYSFS_SYSTEM_PATH, pos);\n\n        VIR_DIR_CLOSE(dirp);\n\n        rv = virDirOpenIfExists(&dirp, path);\n        if (rv < 0)\n            goto cleanup;\n\n        if (!dirp)\n            continue;\n\n        while ((rv = virDirRead(dirp, &ent, path)) > 0) {\n            int kernel_type;\n            unsigned int level;\n\n            if (!STRPREFIX(ent->d_name, \"index\"))\n                continue;\n\n            if (virFileReadValueUint(&level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (level < cache_min_level)\n                continue;\n\n            if (VIR_ALLOC(bank) < 0)\n                goto cleanup;\n\n            bank->level = level;\n\n            if (virFileReadValueUint(&bank->id,\n                                     \"%s/cpu/cpu%zd/cache/%s/id\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueUint(&bank->level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueString(&type,\n                                       \"%s/cpu/cpu%zd/cache/%s/type\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueScaledInt(&bank->size,\n                                          \"%s/cpu/cpu%zd/cache/%s/size\",\n                                          SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueBitmap(&bank->cpus,\n                                       \"%s/cpu/cpu%zd/cache/%s/shared_cpu_list\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            kernel_type = virCacheKernelTypeFromString(type);\n            if (kernel_type < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown cache type '%s'\"), type);\n                goto cleanup;\n            }\n\n            bank->type = kernel_type;\n            VIR_FREE(type);\n\n            for (i = 0; i < caps->host.cache.nbanks; i++) {\n                if (virCapsHostCacheBankEquals(bank, caps->host.cache.banks[i]))\n                    break;\n            }\n            if (i == caps->host.cache.nbanks) {\n                /* If it is a new cache, then update its resctrl information. */\n                if (virResctrlInfoGetCache(caps->host.resctrl,\n                                           bank->level,\n                                           bank->size,\n                                           &bank->ncontrols,\n                                           &bank->controls) < 0)\n                    goto cleanup;\n\n                if (VIR_APPEND_ELEMENT(caps->host.cache.banks,\n                                       caps->host.cache.nbanks,\n                                       bank) < 0) {\n                    goto cleanup;\n                }\n            }\n\n            virCapsHostCacheBankFree(bank);\n            bank = NULL;\n        }\n        if (rv < 0)\n            goto cleanup;\n    }\n\n    /* Sort the array in order for the tests to be predictable.  This way we can\n     * still traverse the directory instead of guessing names (in case there is\n     * 'index1' and 'index3' but no 'index2'). */\n    qsort(caps->host.cache.banks, caps->host.cache.nbanks,\n          sizeof(*caps->host.cache.banks), virCapsHostCacheBankSorter);\n\n    if (virCapabilitiesInitResctrlMemory(caps) < 0)\n        goto cleanup;\n\n    if (virResctrlInfoGetMonitorPrefix(caps->host.resctrl, prefix,\n                                       &caps->host.cache.monitor) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    VIR_FREE(path);\n    VIR_DIR_CLOSE(dirp);\n    virCapsHostCacheBankFree(bank);\n    virBitmapFree(cpus);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SYSTEM_PATH \"/sys/devices/system\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\n#define SYSFS_SYSTEM_PATH \"/sys/devices/system\"\n\nint\nvirCapabilitiesInitCaches(virCapsPtr caps)\n{\n    size_t i = 0;\n    virBitmapPtr cpus = NULL;\n    ssize_t pos = -1;\n    DIR *dirp = NULL;\n    int ret = -1;\n    char *path = NULL;\n    char *type = NULL;\n    struct dirent *ent = NULL;\n    virCapsHostCacheBankPtr bank = NULL;\n    const virResctrlMonitorType montype = VIR_RESCTRL_MONITOR_TYPE_CACHE;\n    const char *prefix = virResctrlMonitorPrefixTypeToString(montype);\n\n    /* Minimum level to expose in capabilities.  Can be lowered or removed (with\n     * the appropriate code below), but should not be increased, because we'd\n     * lose information. */\n    const int cache_min_level = 3;\n\n    if (virCapabilitiesInitResctrl(caps) < 0)\n        return -1;\n\n    /* offline CPUs don't provide cache info */\n    if (virFileReadValueBitmap(&cpus, \"%s/cpu/online\", SYSFS_SYSTEM_PATH) < 0)\n        return -1;\n\n    while ((pos = virBitmapNextSetBit(cpus, pos)) >= 0) {\n        int rv = -1;\n\n        VIR_FREE(path);\n        path = g_strdup_printf(\"%s/cpu/cpu%zd/cache/\", SYSFS_SYSTEM_PATH, pos);\n\n        VIR_DIR_CLOSE(dirp);\n\n        rv = virDirOpenIfExists(&dirp, path);\n        if (rv < 0)\n            goto cleanup;\n\n        if (!dirp)\n            continue;\n\n        while ((rv = virDirRead(dirp, &ent, path)) > 0) {\n            int kernel_type;\n            unsigned int level;\n\n            if (!STRPREFIX(ent->d_name, \"index\"))\n                continue;\n\n            if (virFileReadValueUint(&level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (level < cache_min_level)\n                continue;\n\n            if (VIR_ALLOC(bank) < 0)\n                goto cleanup;\n\n            bank->level = level;\n\n            if (virFileReadValueUint(&bank->id,\n                                     \"%s/cpu/cpu%zd/cache/%s/id\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueUint(&bank->level,\n                                     \"%s/cpu/cpu%zd/cache/%s/level\",\n                                     SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueString(&type,\n                                       \"%s/cpu/cpu%zd/cache/%s/type\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueScaledInt(&bank->size,\n                                          \"%s/cpu/cpu%zd/cache/%s/size\",\n                                          SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            if (virFileReadValueBitmap(&bank->cpus,\n                                       \"%s/cpu/cpu%zd/cache/%s/shared_cpu_list\",\n                                       SYSFS_SYSTEM_PATH, pos, ent->d_name) < 0)\n                goto cleanup;\n\n            kernel_type = virCacheKernelTypeFromString(type);\n            if (kernel_type < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unknown cache type '%s'\"), type);\n                goto cleanup;\n            }\n\n            bank->type = kernel_type;\n            VIR_FREE(type);\n\n            for (i = 0; i < caps->host.cache.nbanks; i++) {\n                if (virCapsHostCacheBankEquals(bank, caps->host.cache.banks[i]))\n                    break;\n            }\n            if (i == caps->host.cache.nbanks) {\n                /* If it is a new cache, then update its resctrl information. */\n                if (virResctrlInfoGetCache(caps->host.resctrl,\n                                           bank->level,\n                                           bank->size,\n                                           &bank->ncontrols,\n                                           &bank->controls) < 0)\n                    goto cleanup;\n\n                if (VIR_APPEND_ELEMENT(caps->host.cache.banks,\n                                       caps->host.cache.nbanks,\n                                       bank) < 0) {\n                    goto cleanup;\n                }\n            }\n\n            virCapsHostCacheBankFree(bank);\n            bank = NULL;\n        }\n        if (rv < 0)\n            goto cleanup;\n    }\n\n    /* Sort the array in order for the tests to be predictable.  This way we can\n     * still traverse the directory instead of guessing names (in case there is\n     * 'index1' and 'index3' but no 'index2'). */\n    qsort(caps->host.cache.banks, caps->host.cache.nbanks,\n          sizeof(*caps->host.cache.banks), virCapsHostCacheBankSorter);\n\n    if (virCapabilitiesInitResctrlMemory(caps) < 0)\n        goto cleanup;\n\n    if (virResctrlInfoGetMonitorPrefix(caps->host.resctrl, prefix,\n                                       &caps->host.cache.monitor) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(type);\n    VIR_FREE(path);\n    VIR_DIR_CLOSE(dirp);\n    virCapsHostCacheBankFree(bank);\n    virBitmapFree(cpus);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMANewHost",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMANewHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1714-1734",
          "snippet": "virCapsHostNUMAPtr\nvirCapabilitiesHostNUMANewHost(void)\n{\n    virCapsHostNUMAPtr caps = virCapabilitiesHostNUMANew();\n\n    if (virNumaIsAvailable()) {\n        if (virCapabilitiesHostNUMAInitReal(caps) == 0)\n            return caps;\n\n        virCapabilitiesHostNUMAUnref(caps);\n        caps = virCapabilitiesHostNUMANew();\n        VIR_WARN(\"Failed to query host NUMA topology, faking single NUMA node\");\n    }\n\n    if (virCapabilitiesHostNUMAInitFake(caps) < 0) {\n        virCapabilitiesHostNUMAUnref(caps);\n        return NULL;\n    }\n\n    return caps;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsHostNUMAPtr\nvirCapabilitiesHostNUMANewHost(void)\n{\n    virCapsHostNUMAPtr caps = virCapabilitiesHostNUMANew();\n\n    if (virNumaIsAvailable()) {\n        if (virCapabilitiesHostNUMAInitReal(caps) == 0)\n            return caps;\n\n        virCapabilitiesHostNUMAUnref(caps);\n        caps = virCapabilitiesHostNUMANew();\n        VIR_WARN(\"Failed to query host NUMA topology, faking single NUMA node\");\n    }\n\n    if (virCapabilitiesHostNUMAInitFake(caps) < 0) {\n        virCapabilitiesHostNUMAUnref(caps);\n        return NULL;\n    }\n\n    return caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesNew",
          "args": [
            "virArchFromHost()",
            "false",
            "false"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "78-96",
          "snippet": "virCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virCapsClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virCapsClass;\n\nvirCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virArchFromHost",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "206-235",
          "snippet": "virArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nvirArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vbox_get_driver.h\"\n#include \"vbox_uniformed_api.h\"\n#include \"vbox_common.h\"\n#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virfdstream.h\"\n#include \"vbox_snapshot_conf.h\"\n#include \"snapshot_conf.h\"\n#include \"virkeycode.h\"\n#include \"virtime.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"virhostmem.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_event.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic virCapsPtr\nvboxCapsInit(void)\n{\n    g_autoptr(virCaps) caps = NULL;\n    virCapsGuestPtr guest = NULL;\n\n    if ((caps = virCapabilitiesNew(virArchFromHost(),\n                                   false, false)) == NULL)\n        return NULL;\n\n    if (!(caps->host.numa = virCapabilitiesHostNUMANewHost()))\n        return NULL;\n\n    if (virCapabilitiesInitCaches(caps) < 0)\n        return NULL;\n\n    if ((guest = virCapabilitiesAddGuest(caps,\n                                         VIR_DOMAIN_OSTYPE_HVM,\n                                         caps->host.arch,\n                                         NULL,\n                                         NULL,\n                                         0,\n                                         NULL)) == NULL)\n        return NULL;\n\n    if (virCapabilitiesAddGuestDomain(guest,\n                                      VIR_DOMAIN_VIRT_VBOX,\n                                      NULL,\n                                      NULL,\n                                      0,\n                                      NULL) == NULL)\n        return NULL;\n\n    return g_steal_pointer(&caps);\n}"
  }
]